#pragma once

#include <stdint.h>

////
//
//    STM32H7x3
//
//       schema-version : 1.1
//       vendor         : 
//       series         : 
//       device-version : 1.8
//       address-unit   : 8 bits
//       device-width   : 32
//       device-size    : 32
//
////

namespace stm32h7x3
{

template<int N> class reserved_t { private: uint32_t m_pad[N]; };

template<uint8_t POS, uint32_t MASK>
struct bit_field_t
{
    template <uint32_t X>
    static constexpr uint32_t value()
    {
        static_assert((X & ~MASK) == 0, "field value too large");
        return X << POS;
    }
};

////
//
//    COMP1
//
////

struct comp1_t
{
    volatile uint32_t    SR;                   // [Read-only] Comparator status register
    volatile uint32_t    ICFR;                 // [Write-only] Comparator interrupt clear flag register
    volatile uint32_t    OR;                   // [Read-write] Comparator option register
    volatile uint32_t    CFGR1;                // [Read-write] Comparator configuration register 1
    volatile uint32_t    CFGR2;                // [Read-write] Comparator configuration register 2

    static constexpr uint32_t SR_C1VAL = 0x1;          // COMP channel 1 output status bit
    static constexpr uint32_t SR_C2VAL = 0x2;          // COMP channel 2 output status bit
    static constexpr uint32_t SR_C1IF = 0x10000;       // COMP channel 1 Interrupt Flag
    static constexpr uint32_t SR_C2IF = 0x20000;       // COMP channel 2 Interrupt Flag
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint32_t ICFR_CC1IF = 0x10000;      // Clear COMP channel 1 Interrupt Flag
    static constexpr uint32_t ICFR_CC2IF = 0x20000;      // Clear COMP channel 2 Interrupt Flag
    static const uint32_t ICFR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OR_AFOP =                // Selection of source for alternate function of output ports (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OR_OR =                  // Option Register (21 bits)
        bit_field_t<11, 0x1fffff>::value<X>();
    static const uint32_t OR_RESET_VALUE = 0x0;

    static constexpr uint32_t CFGR1_EN = 0x1;             // COMP channel 1 enable bit
    static constexpr uint32_t CFGR1_BRGEN = 0x2;          // Scaler bridge enable
    static constexpr uint32_t CFGR1_SCALEN = 0x4;         // Voltage scaler enable bit
    static constexpr uint32_t CFGR1_POLARITY = 0x8;       // COMP channel 1 polarity selection bit
    static constexpr uint32_t CFGR1_ITEN = 0x40;          // COMP channel 1 interrupt enable
    template<uint32_t X>
    static constexpr uint32_t CFGR1_HYST =                // COMP channel 1 hysteresis selection bits (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR1_PWRMODE =             // Power Mode of the COMP channel 1 (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR1_INMSEL =              // COMP channel 1 inverting input selection field (3 bits)
        bit_field_t<16, 0x7>::value<X>();
    static constexpr uint32_t CFGR1_INPSEL = 0x100000;    // COMP channel 1 non-inverting input selection bit
    template<uint32_t X>
    static constexpr uint32_t CFGR1_BLANKING =            // COMP channel 1 blanking source selection bits (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    static constexpr uint32_t CFGR1_LOCK = 0x80000000;    // Lock bit
    static const uint32_t CFGR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CFGR2_EN = 0x1;             // COMP channel 1 enable bit
    static constexpr uint32_t CFGR2_BRGEN = 0x2;          // Scaler bridge enable
    static constexpr uint32_t CFGR2_SCALEN = 0x4;         // Voltage scaler enable bit
    static constexpr uint32_t CFGR2_POLARITY = 0x8;       // COMP channel 1 polarity selection bit
    static constexpr uint32_t CFGR2_WINMODE = 0x10;       // Window comparator mode selection bit
    static constexpr uint32_t CFGR2_ITEN = 0x40;          // COMP channel 1 interrupt enable
    template<uint32_t X>
    static constexpr uint32_t CFGR2_HYST =                // COMP channel 1 hysteresis selection bits (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR2_PWRMODE =             // Power Mode of the COMP channel 1 (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR2_INMSEL =              // COMP channel 1 inverting input selection field (3 bits)
        bit_field_t<16, 0x7>::value<X>();
    static constexpr uint32_t CFGR2_INPSEL = 0x100000;    // COMP channel 1 non-inverting input selection bit
    template<uint32_t X>
    static constexpr uint32_t CFGR2_BLANKING =            // COMP channel 1 blanking source selection bits (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    static constexpr uint32_t CFGR2_LOCK = 0x80000000;    // Lock bit
    static const uint32_t CFGR2_RESET_VALUE = 0x0;

    static constexpr uint8_t COMP = 137; // COMP1 and COMP2
};

static comp1_t& COMP1 = *reinterpret_cast<comp1_t*>(0x58003800);

#define HAVE_PERIPHERAL_COMP1


////
//
//    CRS
//
////

struct crs_t
{
    volatile uint32_t    CR;                   // CRS control register
    volatile uint32_t    CFGR;                 // [Read-write] This register can be written only when the frequency error counter is disabled (CEN bit is cleared in CRS_CR). When the counter is enabled, this register is write-protected.
    volatile uint32_t    ISR;                  // [Read-only] CRS interrupt and status register
    volatile uint32_t    ICR;                  // [Read-write] CRS interrupt flag clear register

    static constexpr uint32_t CR_SYNCOKIE = 0x1;       // SYNC event OK interrupt enable, Read-write
    static constexpr uint32_t CR_SYNCWARNIE = 0x2;     // SYNC warning interrupt enable, Read-write
    static constexpr uint32_t CR_ERRIE = 0x4;          // Synchronization or trimming error interrupt enable, Read-write
    static constexpr uint32_t CR_ESYNCIE = 0x8;        // Expected SYNC interrupt enable, Read-write
    static constexpr uint32_t CR_CEN = 0x20;           // Frequency error counter enable This bit enables the oscillator clock for the frequency error counter. When this bit is set, the CRS_CFGR register is write-protected and cannot be modified., Read-write
    static constexpr uint32_t CR_AUTOTRIMEN = 0x40;    // Automatic trimming enable This bit enables the automatic hardware adjustment of TRIM bits according to the measured frequency error between two SYNC events. If this bit is set, the TRIM bits are read-only. The TRIM value can be adjusted by hardware by one or two steps at a time, depending on the measured frequency error value. Refer to Section7.3.4: Frequency error evaluation and automatic trimming for more details., Read-write
    static constexpr uint32_t CR_SWSYNC = 0x80;        // Generate software SYNC event This bit is set by software in order to generate a software SYNC event. It is automatically cleared by hardware., Read-only
    template<uint32_t X>
    static constexpr uint32_t CR_TRIM =                // HSI48 oscillator smooth trimming These bits provide a user-programmable trimming value to the HSI48 oscillator. They can be programmed to adjust to variations in voltage and temperature that influence the frequency of the HSI48. The default value is 32, which corresponds to the middle of the trimming interval. The trimming step is around 67 kHz between two consecutive TRIM steps. A higher TRIM value corresponds to a higher output frequency. When the AUTOTRIMEN bit is set, this field is controlled by hardware and is read-only. (6 bits), Read-write
        bit_field_t<8, 0x3f>::value<X>();
    static const uint32_t CR_RESET_VALUE = 0x2000;

    template<uint32_t X>
    static constexpr uint32_t CFGR_RELOAD =              // Counter reload value RELOAD is the value to be loaded in the frequency error counter with each SYNC event. Refer to Section7.3.3: Frequency error measurement for more details about counter behavior. (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_FELIM =               // Frequency error limit FELIM contains the value to be used to evaluate the captured frequency error value latched in the FECAP[15:0] bits of the CRS_ISR register. Refer to Section7.3.4: Frequency error evaluation and automatic trimming for more details about FECAP evaluation. (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_SYNCDIV =             // SYNC divider These bits are set and cleared by software to control the division factor of the SYNC signal. (3 bits)
        bit_field_t<24, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_SYNCSRC =             // SYNC signal source selection These bits are set and cleared by software to select the SYNC signal source. Note: When using USB LPM (Link Power Management) and the device is in Sleep mode, the periodic USB SOF will not be generated by the host. No SYNC signal will therefore be provided to the CRS to calibrate the HSI48 on the run. To guarantee the required clock precision after waking up from Sleep mode, the LSE or reference clock on the GPIOs should be used as SYNC signal. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    static constexpr uint32_t CFGR_SYNCPOL = 0x80000000; // SYNC polarity selection This bit is set and cleared by software to select the input polarity for the SYNC signal source.
    static const uint32_t CFGR_RESET_VALUE = 0x2022bb7f;

    static constexpr uint32_t ISR_SYNCOKF = 0x1;        // SYNC event OK flag This flag is set by hardware when the measured frequency error is smaller than FELIM * 3. This means that either no adjustment of the TRIM value is needed or that an adjustment by one trimming step is enough to compensate the frequency error. An interrupt is generated if the SYNCOKIE bit is set in the CRS_CR register. It is cleared by software by setting the SYNCOKC bit in the CRS_ICR register.
    static constexpr uint32_t ISR_SYNCWARNF = 0x2;      // SYNC warning flag This flag is set by hardware when the measured frequency error is greater than or equal to FELIM * 3, but smaller than FELIM * 128. This means that to compensate the frequency error, the TRIM value must be adjusted by two steps or more. An interrupt is generated if the SYNCWARNIE bit is set in the CRS_CR register. It is cleared by software by setting the SYNCWARNC bit in the CRS_ICR register.
    static constexpr uint32_t ISR_ERRF = 0x4;           // Error flag This flag is set by hardware in case of any synchronization or trimming error. It is the logical OR of the TRIMOVF, SYNCMISS and SYNCERR bits. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software in reaction to setting the ERRC bit in the CRS_ICR register, which clears the TRIMOVF, SYNCMISS and SYNCERR bits.
    static constexpr uint32_t ISR_ESYNCF = 0x8;         // Expected SYNC flag This flag is set by hardware when the frequency error counter reached a zero value. An interrupt is generated if the ESYNCIE bit is set in the CRS_CR register. It is cleared by software by setting the ESYNCC bit in the CRS_ICR register.
    static constexpr uint32_t ISR_SYNCERR = 0x100;      // SYNC error This flag is set by hardware when the SYNC pulse arrives before the ESYNC event and the measured frequency error is greater than or equal to FELIM * 128. This means that the frequency error is too big (internal frequency too low) to be compensated by adjusting the TRIM value, and that some other action should be taken. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register.
    static constexpr uint32_t ISR_SYNCMISS = 0x200;     // SYNC missed This flag is set by hardware when the frequency error counter reached value FELIM * 128 and no SYNC was detected, meaning either that a SYNC pulse was missed or that the frequency error is too big (internal frequency too high) to be compensated by adjusting the TRIM value, and that some other action should be taken. At this point, the frequency error counter is stopped (waiting for a next SYNC) and an interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register.
    static constexpr uint32_t ISR_TRIMOVF = 0x400;      // Trimming overflow or underflow This flag is set by hardware when the automatic trimming tries to over- or under-flow the TRIM value. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register.
    static constexpr uint32_t ISR_FEDIR = 0x8000;       // Frequency error direction FEDIR is the counting direction of the frequency error counter latched in the time of the last SYNC event. It shows whether the actual frequency is below or above the target.
    template<uint32_t X>
    static constexpr uint32_t ISR_FECAP =               // Frequency error capture FECAP is the frequency error counter value latched in the time of the last SYNC event. Refer to Section7.3.4: Frequency error evaluation and automatic trimming for more details about FECAP usage. (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t ISR_RESET_VALUE = 0x0;

    static constexpr uint32_t ICR_SYNCOKC = 0x1;        // SYNC event OK clear flag Writing 1 to this bit clears the SYNCOKF flag in the CRS_ISR register.
    static constexpr uint32_t ICR_SYNCWARNC = 0x2;      // SYNC warning clear flag Writing 1 to this bit clears the SYNCWARNF flag in the CRS_ISR register.
    static constexpr uint32_t ICR_ERRC = 0x4;           // Error clear flag Writing 1 to this bit clears TRIMOVF, SYNCMISS and SYNCERR bits and consequently also the ERRF flag in the CRS_ISR register.
    static constexpr uint32_t ICR_ESYNCC = 0x8;         // Expected SYNC clear flag Writing 1 to this bit clears the ESYNCF flag in the CRS_ISR register.
    static const uint32_t ICR_RESET_VALUE = 0x0;

    static constexpr uint8_t CRS = 144; // Clock Recovery System globa
};

static crs_t& CRS = *reinterpret_cast<crs_t*>(0x40008400);

#define HAVE_PERIPHERAL_CRS


////
//
//    DAC
//
////

struct dac_t
{
    volatile uint32_t    CR;                   // [Read-write] DAC control register
    volatile uint32_t    SWTRGR;               // [Write-only] DAC software trigger register
    volatile uint32_t    DHR12R1;              // [Read-write] DAC channel1 12-bit right-aligned data holding register
    volatile uint32_t    DHR12L1;              // [Read-write] DAC channel1 12-bit left aligned data holding register
    volatile uint32_t    DHR8R1;               // [Read-write] DAC channel1 8-bit right aligned data holding register
    volatile uint32_t    DHR12R2;              // [Read-write] DAC channel2 12-bit right aligned data holding register
    volatile uint32_t    DHR12L2;              // [Read-write] DAC channel2 12-bit left aligned data holding register
    volatile uint32_t    DHR8R2;               // [Read-write] DAC channel2 8-bit right-aligned data holding register
    volatile uint32_t    DHR12RD;              // [Read-write] Dual DAC 12-bit right-aligned data holding register
    volatile uint32_t    DHR12LD;              // [Read-write] DUAL DAC 12-bit left aligned data holding register
    volatile uint32_t    DHR8RD;               // [Read-write] DUAL DAC 8-bit right aligned data holding register
    volatile uint32_t    DOR1;                 // [Read-only] DAC channel1 data output register
    volatile uint32_t    DOR2;                 // [Read-only] DAC channel2 data output register
    volatile uint32_t    SR;                   // DAC status register
    volatile uint32_t    CCR;                  // [Read-write] DAC calibration control register
    volatile uint32_t    MCR;                  // [Read-write] DAC mode control register
    volatile uint32_t    SHSR1;                // [Read-write] DAC Sample and Hold sample time register 1
    volatile uint32_t    SHSR2;                // [Read-write] DAC Sample and Hold sample time register 2
    volatile uint32_t    SHHR;                 // [Read-write] DAC Sample and Hold hold time register
    volatile uint32_t    SHRR;                 // [Read-write] DAC Sample and Hold refresh time register

    static constexpr uint32_t CR_EN1 = 0x1;            // DAC channel1 enable This bit is set and cleared by software to enable/disable DAC channel1.
    static constexpr uint32_t CR_TEN1 = 0x2;           // DAC channel1 trigger enable
    template<uint32_t X>
    static constexpr uint32_t CR_TSEL1 =               // DAC channel1 trigger selection These bits select the external event used to trigger DAC channel1. Note: Only used if bit TEN1 = 1 (DAC channel1 trigger enabled). (3 bits)
        bit_field_t<2, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR_WAVE1 =               // DAC channel1 noise/triangle wave generation enable These bits are set and cleared by software. Note: Only used if bit TEN1 = 1 (DAC channel1 trigger enabled). (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR_MAMP1 =               // DAC channel1 mask/amplitude selector These bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. = 1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095 (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    static constexpr uint32_t CR_DMAEN1 = 0x1000;      // DAC channel1 DMA enable This bit is set and cleared by software.
    static constexpr uint32_t CR_DMAUDRIE1 = 0x2000;   // DAC channel1 DMA Underrun Interrupt enable This bit is set and cleared by software.
    static constexpr uint32_t CR_CEN1 = 0x4000;        // DAC Channel 1 calibration enable This bit is set and cleared by software to enable/disable DAC channel 1 calibration, it can be written only if bit EN1=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored.
    static constexpr uint32_t CR_EN2 = 0x10000;        // DAC channel2 enable This bit is set and cleared by software to enable/disable DAC channel2.
    static constexpr uint32_t CR_TEN2 = 0x20000;       // DAC channel2 trigger enable
    template<uint32_t X>
    static constexpr uint32_t CR_TSEL2 =               // DAC channel2 trigger selection These bits select the external event used to trigger DAC channel2 Note: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled). (3 bits)
        bit_field_t<18, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR_WAVE2 =               // DAC channel2 noise/triangle wave generation enable These bits are set/reset by software. 1x: Triangle wave generation enabled Note: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled) (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR_MAMP2 =               // DAC channel2 mask/amplitude selector These bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. = 1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095 (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    static constexpr uint32_t CR_DMAEN2 = 0x10000000;  // DAC channel2 DMA enable This bit is set and cleared by software.
    static constexpr uint32_t CR_DMAUDRIE2 = 0x20000000;// DAC channel2 DMA underrun interrupt enable This bit is set and cleared by software.
    static constexpr uint32_t CR_CEN2 = 0x40000000;    // DAC Channel 2 calibration enable This bit is set and cleared by software to enable/disable DAC channel 2 calibration, it can be written only if bit EN2=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored.
    static const uint32_t CR_RESET_VALUE = 0x0;

    static constexpr uint32_t SWTRGR_SWTRIG1 = 0x1;        // DAC channel1 software trigger This bit is set by software to trigger the DAC in software trigger mode. Note: This bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR1 register value has been loaded into the DAC_DOR1 register.
    static constexpr uint32_t SWTRGR_SWTRIG2 = 0x2;        // DAC channel2 software trigger This bit is set by software to trigger the DAC in software trigger mode. Note: This bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR2 register value has been loaded into the DAC_DOR2 register.
    static const uint32_t SWTRGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DHR12R1_DACC1DHR =            // DAC channel1 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel1. (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t DHR12R1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DHR12L1_DACC1DHR =            // DAC channel1 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel1. (12 bits)
        bit_field_t<4, 0xfff>::value<X>();
    static const uint32_t DHR12L1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DHR8R1_DACC1DHR =            // DAC channel1 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel1. (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t DHR8R1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DHR12R2_DACC2DHR =            // DAC channel2 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel2. (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t DHR12R2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DHR12L2_DACC2DHR =            // DAC channel2 12-bit left-aligned data These bits are written by software which specify 12-bit data for DAC channel2. (12 bits)
        bit_field_t<4, 0xfff>::value<X>();
    static const uint32_t DHR12L2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DHR8R2_DACC2DHR =            // DAC channel2 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel2. (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t DHR8R2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DHR12RD_DACC1DHR =            // DAC channel1 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel1. (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DHR12RD_DACC2DHR =            // DAC channel2 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel2. (12 bits)
        bit_field_t<16, 0xfff>::value<X>();
    static const uint32_t DHR12RD_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DHR12LD_DACC1DHR =            // DAC channel1 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel1. (12 bits)
        bit_field_t<4, 0xfff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DHR12LD_DACC2DHR =            // DAC channel2 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel2. (12 bits)
        bit_field_t<20, 0xfff>::value<X>();
    static const uint32_t DHR12LD_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DHR8RD_DACC1DHR =            // DAC channel1 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel1. (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DHR8RD_DACC2DHR =            // DAC channel2 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel2. (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static const uint32_t DHR8RD_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOR1_DACC1DOR =            // DAC channel1 data output These bits are read-only, they contain data output for DAC channel1. (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t DOR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOR2_DACC2DOR =            // DAC channel2 data output These bits are read-only, they contain data output for DAC channel2. (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t DOR2_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_DMAUDR1 = 0x2000;     // DAC channel1 DMA underrun flag This bit is set by hardware and cleared by software (by writing it to 1)., Read-write
    static constexpr uint32_t SR_CAL_FLAG1 = 0x4000;   // DAC Channel 1 calibration offset status This bit is set and cleared by hardware, Read-only
    static constexpr uint32_t SR_BWST1 = 0x8000;       // DAC Channel 1 busy writing sample time flag This bit is systematically set just after Sample &amp; Hold mode enable and is set each time the software writes the register DAC_SHSR1, It is cleared by hardware when the write operation of DAC_SHSR1 is complete. (It takes about 3LSI periods of synchronization)., Read-only
    static constexpr uint32_t SR_DMAUDR2 = 0x20000000; // DAC channel2 DMA underrun flag This bit is set by hardware and cleared by software (by writing it to 1)., Read-write
    static constexpr uint32_t SR_CAL_FLAG2 = 0x40000000;// DAC Channel 2 calibration offset status This bit is set and cleared by hardware, Read-only
    static constexpr uint32_t SR_BWST2 = 0x80000000;   // DAC Channel 2 busy writing sample time flag This bit is systematically set just after Sample &amp; Hold mode enable and is set each time the software writes the register DAC_SHSR2, It is cleared by hardware when the write operation of DAC_SHSR2 is complete. (It takes about 3 LSI periods of synchronization)., Read-only
    static const uint32_t SR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR_OTRIM1 =              // DAC Channel 1 offset trimming value (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR_OTRIM2 =              // DAC Channel 2 offset trimming value (5 bits)
        bit_field_t<16, 0x1f>::value<X>();
    static const uint32_t CCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t MCR_MODE1 =               // DAC Channel 1 mode These bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN1=0 and bit CEN1 =0 in the DAC_CR register). If EN1=1 or CEN1 =1 the write operation is ignored. They can be set and cleared by software to select the DAC Channel 1 mode: DAC Channel 1 in normal Mode DAC Channel 1 in sample &amp;amp; hold mode (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MCR_MODE2 =               // DAC Channel 2 mode These bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN2=0 and bit CEN2 =0 in the DAC_CR register). If EN2=1 or CEN2 =1 the write operation is ignored. They can be set and cleared by software to select the DAC Channel 2 mode: DAC Channel 2 in normal Mode DAC Channel 2 in sample &amp;amp; hold mode (3 bits)
        bit_field_t<16, 0x7>::value<X>();
    static const uint32_t MCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SHSR1_TSAMPLE1 =            // DAC Channel 1 sample Time (only valid in sample &amp;amp; hold mode) These bits can be written when the DAC channel1 is disabled or also during normal operation. in the latter case, the write can be done only when BWSTx of DAC_SR register is low, If BWSTx=1, the write operation is ignored. (10 bits)
        bit_field_t<0, 0x3ff>::value<X>();
    static const uint32_t SHSR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SHSR2_TSAMPLE2 =            // DAC Channel 2 sample Time (only valid in sample &amp;amp; hold mode) These bits can be written when the DAC channel2 is disabled or also during normal operation. in the latter case, the write can be done only when BWSTx of DAC_SR register is low, if BWSTx=1, the write operation is ignored. (10 bits)
        bit_field_t<0, 0x3ff>::value<X>();
    static const uint32_t SHSR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SHHR_THOLD1 =              // DAC Channel 1 hold Time (only valid in sample &amp;amp; hold mode) Hold time= (THOLD[9:0]) x T LSI (10 bits)
        bit_field_t<0, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SHHR_THOLD2 =              // DAC Channel 2 hold time (only valid in sample &amp;amp; hold mode). Hold time= (THOLD[9:0]) x T LSI (10 bits)
        bit_field_t<16, 0x3ff>::value<X>();
    static const uint32_t SHHR_RESET_VALUE = 0x10001;

    template<uint32_t X>
    static constexpr uint32_t SHRR_TREFRESH1 =           // DAC Channel 1 refresh Time (only valid in sample &amp;amp; hold mode) Refresh time= (TREFRESH[7:0]) x T LSI (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SHRR_TREFRESH2 =           // DAC Channel 2 refresh Time (only valid in sample &amp;amp; hold mode) Refresh time= (TREFRESH[7:0]) x T LSI (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static const uint32_t SHRR_RESET_VALUE = 0x10001;
};

static dac_t& DAC = *reinterpret_cast<dac_t*>(0x40007400);

#define HAVE_PERIPHERAL_DAC


////
//
//    BDMA
//
////

struct bdma_t
{
    volatile uint32_t    ISR;                  // [Read-only] DMA interrupt status register
    volatile uint32_t    IFCR;                 // [Write-only] DMA interrupt flag clear register
    volatile uint32_t    CCR1;                 // [Read-write] DMA channel x configuration register
    volatile uint32_t    CNDTR1;               // [Read-write] DMA channel x number of data register
    volatile uint32_t    CPAR1;                // [Read-write] This register must not be written when the channel is enabled.
    volatile uint32_t    CMAR1;                // [Read-write] This register must not be written when the channel is enabled.
    reserved_t<1>        _0;
    volatile uint32_t    CCR2;                 // [Read-write] DMA channel x configuration register
    volatile uint32_t    CNDTR2;               // [Read-write] DMA channel x number of data register
    volatile uint32_t    CPAR2;                // [Read-write] This register must not be written when the channel is enabled.
    volatile uint32_t    CMAR2;                // [Read-write] This register must not be written when the channel is enabled.
    reserved_t<1>        _1;
    volatile uint32_t    CCR3;                 // [Read-write] DMA channel x configuration register
    volatile uint32_t    CNDTR3;               // [Read-write] DMA channel x number of data register
    volatile uint32_t    CPAR3;                // [Read-write] This register must not be written when the channel is enabled.
    volatile uint32_t    CMAR3;                // [Read-write] This register must not be written when the channel is enabled.
    reserved_t<1>        _2;
    volatile uint32_t    CCR4;                 // [Read-write] DMA channel x configuration register
    volatile uint32_t    CNDTR4;               // [Read-write] DMA channel x number of data register
    volatile uint32_t    CPAR4;                // [Read-write] This register must not be written when the channel is enabled.
    volatile uint32_t    CMAR4;                // [Read-write] This register must not be written when the channel is enabled.
    reserved_t<1>        _3;
    volatile uint32_t    CCR5;                 // [Read-write] DMA channel x configuration register
    volatile uint32_t    CNDTR5;               // [Read-write] DMA channel x number of data register
    volatile uint32_t    CPAR5;                // [Read-write] This register must not be written when the channel is enabled.
    volatile uint32_t    CMAR5;                // [Read-write] This register must not be written when the channel is enabled.
    reserved_t<1>        _4;
    volatile uint32_t    CCR6;                 // [Read-write] DMA channel x configuration register
    volatile uint32_t    CNDTR6;               // [Read-write] DMA channel x number of data register
    volatile uint32_t    CPAR6;                // [Read-write] This register must not be written when the channel is enabled.
    volatile uint32_t    CMAR6;                // [Read-write] This register must not be written when the channel is enabled.
    reserved_t<1>        _5;
    volatile uint32_t    CCR7;                 // [Read-write] DMA channel x configuration register
    volatile uint32_t    CNDTR7;               // [Read-write] DMA channel x number of data register
    volatile uint32_t    CPAR7;                // [Read-write] This register must not be written when the channel is enabled.
    volatile uint32_t    CMAR7;                // [Read-write] This register must not be written when the channel is enabled.
    reserved_t<1>        _6;
    volatile uint32_t    CCR8;                 // [Read-write] DMA channel x configuration register
    volatile uint32_t    CNDTR8;               // [Read-write] DMA channel x number of data register
    volatile uint32_t    CPAR8;                // [Read-write] This register must not be written when the channel is enabled.
    volatile uint32_t    CMAR8;                // [Read-write] This register must not be written when the channel is enabled.

    static constexpr uint32_t ISR_GIF1 = 0x1;           // Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    static constexpr uint32_t ISR_TCIF1 = 0x2;          // Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    static constexpr uint32_t ISR_HTIF1 = 0x4;          // Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    static constexpr uint32_t ISR_TEIF1 = 0x8;          // Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    static constexpr uint32_t ISR_GIF2 = 0x10;          // Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    static constexpr uint32_t ISR_TCIF2 = 0x20;         // Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    static constexpr uint32_t ISR_HTIF2 = 0x40;         // Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    static constexpr uint32_t ISR_TEIF2 = 0x80;         // Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    static constexpr uint32_t ISR_GIF3 = 0x100;         // Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    static constexpr uint32_t ISR_TCIF3 = 0x200;        // Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    static constexpr uint32_t ISR_HTIF3 = 0x400;        // Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    static constexpr uint32_t ISR_TEIF3 = 0x800;        // Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    static constexpr uint32_t ISR_GIF4 = 0x1000;        // Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    static constexpr uint32_t ISR_TCIF4 = 0x2000;       // Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    static constexpr uint32_t ISR_HTIF4 = 0x4000;       // Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    static constexpr uint32_t ISR_TEIF4 = 0x8000;       // Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    static constexpr uint32_t ISR_GIF5 = 0x10000;       // Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    static constexpr uint32_t ISR_TCIF5 = 0x20000;      // Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    static constexpr uint32_t ISR_HTIF5 = 0x40000;      // Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    static constexpr uint32_t ISR_TEIF5 = 0x80000;      // Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    static constexpr uint32_t ISR_GIF6 = 0x100000;      // Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    static constexpr uint32_t ISR_TCIF6 = 0x200000;     // Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    static constexpr uint32_t ISR_HTIF6 = 0x400000;     // Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    static constexpr uint32_t ISR_TEIF6 = 0x800000;     // Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    static constexpr uint32_t ISR_GIF7 = 0x1000000;     // Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    static constexpr uint32_t ISR_TCIF7 = 0x2000000;    // Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    static constexpr uint32_t ISR_HTIF7 = 0x4000000;    // Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    static constexpr uint32_t ISR_TEIF7 = 0x8000000;    // Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    static constexpr uint32_t ISR_GIF8 = 0x10000000;    // Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    static constexpr uint32_t ISR_TCIF8 = 0x20000000;   // Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    static constexpr uint32_t ISR_HTIF8 = 0x40000000;   // Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    static constexpr uint32_t ISR_TEIF8 = 0x80000000;   // Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    static const uint32_t ISR_RESET_VALUE = 0x0;

    static constexpr uint32_t IFCR_CGIF1 = 0x1;          // Channel x global interrupt clear This bit is set and cleared by software.
    static constexpr uint32_t IFCR_CTCIF1 = 0x2;         // Channel x transfer complete clear This bit is set and cleared by software.
    static constexpr uint32_t IFCR_CHTIF1 = 0x4;         // Channel x half transfer clear This bit is set and cleared by software.
    static constexpr uint32_t IFCR_CTEIF1 = 0x8;         // Channel x transfer error clear This bit is set and cleared by software.
    static constexpr uint32_t IFCR_CGIF2 = 0x10;         // Channel x global interrupt clear This bit is set and cleared by software.
    static constexpr uint32_t IFCR_CTCIF2 = 0x20;        // Channel x transfer complete clear This bit is set and cleared by software.
    static constexpr uint32_t IFCR_CHTIF2 = 0x40;        // Channel x half transfer clear This bit is set and cleared by software.
    static constexpr uint32_t IFCR_CTEIF2 = 0x80;        // Channel x transfer error clear This bit is set and cleared by software.
    static constexpr uint32_t IFCR_CGIF3 = 0x100;        // Channel x global interrupt clear This bit is set and cleared by software.
    static constexpr uint32_t IFCR_CTCIF3 = 0x200;       // Channel x transfer complete clear This bit is set and cleared by software.
    static constexpr uint32_t IFCR_CHTIF3 = 0x400;       // Channel x half transfer clear This bit is set and cleared by software.
    static constexpr uint32_t IFCR_CTEIF3 = 0x800;       // Channel x transfer error clear This bit is set and cleared by software.
    static constexpr uint32_t IFCR_CGIF4 = 0x1000;       // Channel x global interrupt clear This bit is set and cleared by software.
    static constexpr uint32_t IFCR_CTCIF4 = 0x2000;      // Channel x transfer complete clear This bit is set and cleared by software.
    static constexpr uint32_t IFCR_CHTIF4 = 0x4000;      // Channel x half transfer clear This bit is set and cleared by software.
    static constexpr uint32_t IFCR_CTEIF4 = 0x8000;      // Channel x transfer error clear This bit is set and cleared by software.
    static constexpr uint32_t IFCR_CGIF5 = 0x10000;      // Channel x global interrupt clear This bit is set and cleared by software.
    static constexpr uint32_t IFCR_CTCIF5 = 0x20000;     // Channel x transfer complete clear This bit is set and cleared by software.
    static constexpr uint32_t IFCR_CHTIF5 = 0x40000;     // Channel x half transfer clear This bit is set and cleared by software.
    static constexpr uint32_t IFCR_CTEIF5 = 0x80000;     // Channel x transfer error clear This bit is set and cleared by software.
    static constexpr uint32_t IFCR_CGIF6 = 0x100000;     // Channel x global interrupt clear This bit is set and cleared by software.
    static constexpr uint32_t IFCR_CTCIF6 = 0x200000;    // Channel x transfer complete clear This bit is set and cleared by software.
    static constexpr uint32_t IFCR_CHTIF6 = 0x400000;    // Channel x half transfer clear This bit is set and cleared by software.
    static constexpr uint32_t IFCR_CTEIF6 = 0x800000;    // Channel x transfer error clear This bit is set and cleared by software.
    static constexpr uint32_t IFCR_CGIF7 = 0x1000000;    // Channel x global interrupt clear This bit is set and cleared by software.
    static constexpr uint32_t IFCR_CTCIF7 = 0x2000000;   // Channel x transfer complete clear This bit is set and cleared by software.
    static constexpr uint32_t IFCR_CHTIF7 = 0x4000000;   // Channel x half transfer clear This bit is set and cleared by software.
    static constexpr uint32_t IFCR_CTEIF7 = 0x8000000;   // Channel x transfer error clear This bit is set and cleared by software.
    static constexpr uint32_t IFCR_CGIF8 = 0x10000000;   // Channel x global interrupt clear This bit is set and cleared by software.
    static constexpr uint32_t IFCR_CTCIF8 = 0x20000000;  // Channel x transfer complete clear This bit is set and cleared by software.
    static constexpr uint32_t IFCR_CHTIF8 = 0x40000000;  // Channel x half transfer clear This bit is set and cleared by software.
    static constexpr uint32_t IFCR_CTEIF8 = 0x80000000;  // Channel x transfer error clear This bit is set and cleared by software.
    static const uint32_t IFCR_RESET_VALUE = 0x0;

    static constexpr uint32_t CCR1_EN = 0x1;             // Channel enable This bit is set and cleared by software.
    static constexpr uint32_t CCR1_TCIE = 0x2;           // Transfer complete interrupt enable This bit is set and cleared by software.
    static constexpr uint32_t CCR1_HTIE = 0x4;           // Half transfer interrupt enable This bit is set and cleared by software.
    static constexpr uint32_t CCR1_TEIE = 0x8;           // Transfer error interrupt enable This bit is set and cleared by software.
    static constexpr uint32_t CCR1_DIR = 0x10;           // Data transfer direction This bit is set and cleared by software.
    static constexpr uint32_t CCR1_CIRC = 0x20;          // Circular mode This bit is set and cleared by software.
    static constexpr uint32_t CCR1_PINC = 0x40;          // Peripheral increment mode This bit is set and cleared by software.
    static constexpr uint32_t CCR1_MINC = 0x80;          // Memory increment mode This bit is set and cleared by software.
    template<uint32_t X>
    static constexpr uint32_t CCR1_PSIZE =               // Peripheral size These bits are set and cleared by software. (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR1_MSIZE =               // Memory size These bits are set and cleared by software. (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR1_PL =                  // Channel priority level These bits are set and cleared by software. (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    static constexpr uint32_t CCR1_MEM2MEM = 0x4000;     // Memory to memory mode This bit is set and cleared by software.
    static const uint32_t CCR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CNDTR1_NDT =                 // Number of data to transfer Number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not. (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CNDTR1_RESET_VALUE = 0x0;


    static const uint32_t CPAR1_RESET_VALUE = 0x0;


    static const uint32_t CMAR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CCR2_EN = 0x1;             // Channel enable This bit is set and cleared by software.
    static constexpr uint32_t CCR2_TCIE = 0x2;           // Transfer complete interrupt enable This bit is set and cleared by software.
    static constexpr uint32_t CCR2_HTIE = 0x4;           // Half transfer interrupt enable This bit is set and cleared by software.
    static constexpr uint32_t CCR2_TEIE = 0x8;           // Transfer error interrupt enable This bit is set and cleared by software.
    static constexpr uint32_t CCR2_DIR = 0x10;           // Data transfer direction This bit is set and cleared by software.
    static constexpr uint32_t CCR2_CIRC = 0x20;          // Circular mode This bit is set and cleared by software.
    static constexpr uint32_t CCR2_PINC = 0x40;          // Peripheral increment mode This bit is set and cleared by software.
    static constexpr uint32_t CCR2_MINC = 0x80;          // Memory increment mode This bit is set and cleared by software.
    template<uint32_t X>
    static constexpr uint32_t CCR2_PSIZE =               // Peripheral size These bits are set and cleared by software. (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR2_MSIZE =               // Memory size These bits are set and cleared by software. (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR2_PL =                  // Channel priority level These bits are set and cleared by software. (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    static constexpr uint32_t CCR2_MEM2MEM = 0x4000;     // Memory to memory mode This bit is set and cleared by software.
    static const uint32_t CCR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CNDTR2_NDT =                 // Number of data to transfer Number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not. (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CNDTR2_RESET_VALUE = 0x0;


    static const uint32_t CPAR2_RESET_VALUE = 0x0;


    static const uint32_t CMAR2_RESET_VALUE = 0x0;

    static constexpr uint32_t CCR3_EN = 0x1;             // Channel enable This bit is set and cleared by software.
    static constexpr uint32_t CCR3_TCIE = 0x2;           // Transfer complete interrupt enable This bit is set and cleared by software.
    static constexpr uint32_t CCR3_HTIE = 0x4;           // Half transfer interrupt enable This bit is set and cleared by software.
    static constexpr uint32_t CCR3_TEIE = 0x8;           // Transfer error interrupt enable This bit is set and cleared by software.
    static constexpr uint32_t CCR3_DIR = 0x10;           // Data transfer direction This bit is set and cleared by software.
    static constexpr uint32_t CCR3_CIRC = 0x20;          // Circular mode This bit is set and cleared by software.
    static constexpr uint32_t CCR3_PINC = 0x40;          // Peripheral increment mode This bit is set and cleared by software.
    static constexpr uint32_t CCR3_MINC = 0x80;          // Memory increment mode This bit is set and cleared by software.
    template<uint32_t X>
    static constexpr uint32_t CCR3_PSIZE =               // Peripheral size These bits are set and cleared by software. (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR3_MSIZE =               // Memory size These bits are set and cleared by software. (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR3_PL =                  // Channel priority level These bits are set and cleared by software. (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    static constexpr uint32_t CCR3_MEM2MEM = 0x4000;     // Memory to memory mode This bit is set and cleared by software.
    static const uint32_t CCR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CNDTR3_NDT =                 // Number of data to transfer Number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not. (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CNDTR3_RESET_VALUE = 0x0;


    static const uint32_t CPAR3_RESET_VALUE = 0x0;


    static const uint32_t CMAR3_RESET_VALUE = 0x0;

    static constexpr uint32_t CCR4_EN = 0x1;             // Channel enable This bit is set and cleared by software.
    static constexpr uint32_t CCR4_TCIE = 0x2;           // Transfer complete interrupt enable This bit is set and cleared by software.
    static constexpr uint32_t CCR4_HTIE = 0x4;           // Half transfer interrupt enable This bit is set and cleared by software.
    static constexpr uint32_t CCR4_TEIE = 0x8;           // Transfer error interrupt enable This bit is set and cleared by software.
    static constexpr uint32_t CCR4_DIR = 0x10;           // Data transfer direction This bit is set and cleared by software.
    static constexpr uint32_t CCR4_CIRC = 0x20;          // Circular mode This bit is set and cleared by software.
    static constexpr uint32_t CCR4_PINC = 0x40;          // Peripheral increment mode This bit is set and cleared by software.
    static constexpr uint32_t CCR4_MINC = 0x80;          // Memory increment mode This bit is set and cleared by software.
    template<uint32_t X>
    static constexpr uint32_t CCR4_PSIZE =               // Peripheral size These bits are set and cleared by software. (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR4_MSIZE =               // Memory size These bits are set and cleared by software. (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR4_PL =                  // Channel priority level These bits are set and cleared by software. (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    static constexpr uint32_t CCR4_MEM2MEM = 0x4000;     // Memory to memory mode This bit is set and cleared by software.
    static const uint32_t CCR4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CNDTR4_NDT =                 // Number of data to transfer Number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not. (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CNDTR4_RESET_VALUE = 0x0;


    static const uint32_t CPAR4_RESET_VALUE = 0x0;


    static const uint32_t CMAR4_RESET_VALUE = 0x0;

    static constexpr uint32_t CCR5_EN = 0x1;             // Channel enable This bit is set and cleared by software.
    static constexpr uint32_t CCR5_TCIE = 0x2;           // Transfer complete interrupt enable This bit is set and cleared by software.
    static constexpr uint32_t CCR5_HTIE = 0x4;           // Half transfer interrupt enable This bit is set and cleared by software.
    static constexpr uint32_t CCR5_TEIE = 0x8;           // Transfer error interrupt enable This bit is set and cleared by software.
    static constexpr uint32_t CCR5_DIR = 0x10;           // Data transfer direction This bit is set and cleared by software.
    static constexpr uint32_t CCR5_CIRC = 0x20;          // Circular mode This bit is set and cleared by software.
    static constexpr uint32_t CCR5_PINC = 0x40;          // Peripheral increment mode This bit is set and cleared by software.
    static constexpr uint32_t CCR5_MINC = 0x80;          // Memory increment mode This bit is set and cleared by software.
    template<uint32_t X>
    static constexpr uint32_t CCR5_PSIZE =               // Peripheral size These bits are set and cleared by software. (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR5_MSIZE =               // Memory size These bits are set and cleared by software. (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR5_PL =                  // Channel priority level These bits are set and cleared by software. (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    static constexpr uint32_t CCR5_MEM2MEM = 0x4000;     // Memory to memory mode This bit is set and cleared by software.
    static const uint32_t CCR5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CNDTR5_NDT =                 // Number of data to transfer Number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not. (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CNDTR5_RESET_VALUE = 0x0;


    static const uint32_t CPAR5_RESET_VALUE = 0x0;


    static const uint32_t CMAR5_RESET_VALUE = 0x0;

    static constexpr uint32_t CCR6_EN = 0x1;             // Channel enable This bit is set and cleared by software.
    static constexpr uint32_t CCR6_TCIE = 0x2;           // Transfer complete interrupt enable This bit is set and cleared by software.
    static constexpr uint32_t CCR6_HTIE = 0x4;           // Half transfer interrupt enable This bit is set and cleared by software.
    static constexpr uint32_t CCR6_TEIE = 0x8;           // Transfer error interrupt enable This bit is set and cleared by software.
    static constexpr uint32_t CCR6_DIR = 0x10;           // Data transfer direction This bit is set and cleared by software.
    static constexpr uint32_t CCR6_CIRC = 0x20;          // Circular mode This bit is set and cleared by software.
    static constexpr uint32_t CCR6_PINC = 0x40;          // Peripheral increment mode This bit is set and cleared by software.
    static constexpr uint32_t CCR6_MINC = 0x80;          // Memory increment mode This bit is set and cleared by software.
    template<uint32_t X>
    static constexpr uint32_t CCR6_PSIZE =               // Peripheral size These bits are set and cleared by software. (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR6_MSIZE =               // Memory size These bits are set and cleared by software. (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR6_PL =                  // Channel priority level These bits are set and cleared by software. (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    static constexpr uint32_t CCR6_MEM2MEM = 0x4000;     // Memory to memory mode This bit is set and cleared by software.
    static const uint32_t CCR6_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CNDTR6_NDT =                 // Number of data to transfer Number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not. (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CNDTR6_RESET_VALUE = 0x0;


    static const uint32_t CPAR6_RESET_VALUE = 0x0;


    static const uint32_t CMAR6_RESET_VALUE = 0x0;

    static constexpr uint32_t CCR7_EN = 0x1;             // Channel enable This bit is set and cleared by software.
    static constexpr uint32_t CCR7_TCIE = 0x2;           // Transfer complete interrupt enable This bit is set and cleared by software.
    static constexpr uint32_t CCR7_HTIE = 0x4;           // Half transfer interrupt enable This bit is set and cleared by software.
    static constexpr uint32_t CCR7_TEIE = 0x8;           // Transfer error interrupt enable This bit is set and cleared by software.
    static constexpr uint32_t CCR7_DIR = 0x10;           // Data transfer direction This bit is set and cleared by software.
    static constexpr uint32_t CCR7_CIRC = 0x20;          // Circular mode This bit is set and cleared by software.
    static constexpr uint32_t CCR7_PINC = 0x40;          // Peripheral increment mode This bit is set and cleared by software.
    static constexpr uint32_t CCR7_MINC = 0x80;          // Memory increment mode This bit is set and cleared by software.
    template<uint32_t X>
    static constexpr uint32_t CCR7_PSIZE =               // Peripheral size These bits are set and cleared by software. (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR7_MSIZE =               // Memory size These bits are set and cleared by software. (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR7_PL =                  // Channel priority level These bits are set and cleared by software. (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    static constexpr uint32_t CCR7_MEM2MEM = 0x4000;     // Memory to memory mode This bit is set and cleared by software.
    static const uint32_t CCR7_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CNDTR7_NDT =                 // Number of data to transfer Number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not. (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CNDTR7_RESET_VALUE = 0x0;


    static const uint32_t CPAR7_RESET_VALUE = 0x0;


    static const uint32_t CMAR7_RESET_VALUE = 0x0;

    static constexpr uint32_t CCR8_EN = 0x1;             // Channel enable This bit is set and cleared by software.
    static constexpr uint32_t CCR8_TCIE = 0x2;           // Transfer complete interrupt enable This bit is set and cleared by software.
    static constexpr uint32_t CCR8_HTIE = 0x4;           // Half transfer interrupt enable This bit is set and cleared by software.
    static constexpr uint32_t CCR8_TEIE = 0x8;           // Transfer error interrupt enable This bit is set and cleared by software.
    static constexpr uint32_t CCR8_DIR = 0x10;           // Data transfer direction This bit is set and cleared by software.
    static constexpr uint32_t CCR8_CIRC = 0x20;          // Circular mode This bit is set and cleared by software.
    static constexpr uint32_t CCR8_PINC = 0x40;          // Peripheral increment mode This bit is set and cleared by software.
    static constexpr uint32_t CCR8_MINC = 0x80;          // Memory increment mode This bit is set and cleared by software.
    template<uint32_t X>
    static constexpr uint32_t CCR8_PSIZE =               // Peripheral size These bits are set and cleared by software. (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR8_MSIZE =               // Memory size These bits are set and cleared by software. (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR8_PL =                  // Channel priority level These bits are set and cleared by software. (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    static constexpr uint32_t CCR8_MEM2MEM = 0x4000;     // Memory to memory mode This bit is set and cleared by software.
    static const uint32_t CCR8_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CNDTR8_NDT =                 // Number of data to transfer Number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not. (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CNDTR8_RESET_VALUE = 0x0;


    static const uint32_t CPAR8_RESET_VALUE = 0x0;


    static const uint32_t CMAR8_RESET_VALUE = 0x0;

    static constexpr uint8_t BDMA_CH1 = 129; // BDMA channel 1 interrupt
    static constexpr uint8_t BDMA_CH2 = 130; // BDMA channel 2 interrupt
    static constexpr uint8_t BDMA_CH3 = 131; // BDMA channel 3 interrupt
    static constexpr uint8_t BDMA_CH4 = 132; // BDMA channel 4 interrupt
    static constexpr uint8_t BDMA_CH5 = 133; // BDMA channel 5 interrupt
    static constexpr uint8_t BDMA_CH6 = 134; // BDMA channel 6 interrupt
    static constexpr uint8_t BDMA_CH7 = 135; // BDMA channel 7 interrupt
    static constexpr uint8_t BDMA_CH8 = 136; // BDMA channel 8 interrupt
};

static bdma_t& BDMA = *reinterpret_cast<bdma_t*>(0x58025400);

#define HAVE_PERIPHERAL_BDMA


////
//
//    DMA2D
//
////

struct dma2d_t
{
    volatile uint32_t    CR;                   // [Read-write] DMA2D control register
    volatile uint32_t    ISR;                  // [Read-only] DMA2D Interrupt Status Register
    volatile uint32_t    IFCR;                 // [Read-write] DMA2D interrupt flag clear register
    volatile uint32_t    FGMAR;                // [Read-write] DMA2D foreground memory address register
    volatile uint32_t    FGOR;                 // [Read-write] DMA2D foreground offset register
    volatile uint32_t    BGMAR;                // [Read-write] DMA2D background memory address register
    volatile uint32_t    BGOR;                 // [Read-write] DMA2D background offset register
    volatile uint32_t    FGPFCCR;              // [Read-write] DMA2D foreground PFC control register
    volatile uint32_t    FGCOLR;               // [Read-write] DMA2D foreground color register
    volatile uint32_t    BGPFCCR;              // [Read-write] DMA2D background PFC control register
    volatile uint32_t    BGCOLR;               // [Read-write] DMA2D background color register
    volatile uint32_t    FGCMAR;               // [Read-write] DMA2D foreground CLUT memory address register
    volatile uint32_t    BGCMAR;               // [Read-write] DMA2D background CLUT memory address register
    volatile uint32_t    OPFCCR;               // [Read-write] DMA2D output PFC control register
    volatile uint32_t    OCOLR;                // [Read-write] DMA2D output color register
    volatile uint32_t    OMAR;                 // [Read-write] DMA2D output memory address register
    volatile uint32_t    OOR;                  // [Read-write] DMA2D output offset register
    volatile uint32_t    NLR;                  // [Read-write] DMA2D number of line register
    volatile uint32_t    LWR;                  // [Read-write] DMA2D line watermark register
    volatile uint32_t    AMTCR;                // [Read-write] DMA2D AXI master timer configuration register

    static constexpr uint32_t CR_START = 0x1;          // Start This bit can be used to launch the DMA2D according to the parameters loaded in the various configuration registers
    static constexpr uint32_t CR_SUSP = 0x2;           // Suspend This bit can be used to suspend the current transfer. This bit is set and reset by software. It is automatically reset by hardware when the START bit is reset.
    static constexpr uint32_t CR_ABORT = 0x4;          // Abort This bit can be used to abort the current transfer. This bit is set by software and is automatically reset by hardware when the START bit is reset.
    static constexpr uint32_t CR_TEIE = 0x100;         // Transfer error interrupt enable This bit is set and cleared by software.
    static constexpr uint32_t CR_TCIE = 0x200;         // Transfer complete interrupt enable This bit is set and cleared by software.
    static constexpr uint32_t CR_TWIE = 0x400;         // Transfer watermark interrupt enable This bit is set and cleared by software.
    static constexpr uint32_t CR_CAEIE = 0x800;        // CLUT access error interrupt enable This bit is set and cleared by software.
    static constexpr uint32_t CR_CTCIE = 0x1000;       // CLUT transfer complete interrupt enable This bit is set and cleared by software.
    static constexpr uint32_t CR_CEIE = 0x2000;        // Configuration Error Interrupt Enable This bit is set and cleared by software.
    template<uint32_t X>
    static constexpr uint32_t CR_MODE =                // DMA2D mode This bit is set and cleared by software. It cannot be modified while a transfer is ongoing. (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    static const uint32_t CR_RESET_VALUE = 0x0;

    static constexpr uint32_t ISR_TEIF = 0x1;           // Transfer error interrupt flag This bit is set when an error occurs during a DMA transfer (data transfer or automatic CLUT loading).
    static constexpr uint32_t ISR_TCIF = 0x2;           // Transfer complete interrupt flag This bit is set when a DMA2D transfer operation is complete (data transfer only).
    static constexpr uint32_t ISR_TWIF = 0x4;           // Transfer watermark interrupt flag This bit is set when the last pixel of the watermarked line has been transferred.
    static constexpr uint32_t ISR_CAEIF = 0x8;          // CLUT access error interrupt flag This bit is set when the CPU accesses the CLUT while the CLUT is being automatically copied from a system memory to the internal DMA2D.
    static constexpr uint32_t ISR_CTCIF = 0x10;         // CLUT transfer complete interrupt flag This bit is set when the CLUT copy from a system memory area to the internal DMA2D memory is complete.
    static constexpr uint32_t ISR_CEIF = 0x20;          // Configuration error interrupt flag This bit is set when the START bit of DMA2D_CR, DMA2DFGPFCCR or DMA2D_BGPFCCR is set and a wrong configuration has been programmed.
    static const uint32_t ISR_RESET_VALUE = 0x0;

    static constexpr uint32_t IFCR_CTEIF = 0x1;          // Clear Transfer error interrupt flag Programming this bit to 1 clears the TEIF flag in the DMA2D_ISR register
    static constexpr uint32_t IFCR_CTCIF = 0x2;          // Clear transfer complete interrupt flag Programming this bit to 1 clears the TCIF flag in the DMA2D_ISR register
    static constexpr uint32_t IFCR_CTWIF = 0x4;          // Clear transfer watermark interrupt flag Programming this bit to 1 clears the TWIF flag in the DMA2D_ISR register
    static constexpr uint32_t IFCR_CAECIF = 0x8;         // Clear CLUT access error interrupt flag Programming this bit to 1 clears the CAEIF flag in the DMA2D_ISR register
    static constexpr uint32_t IFCR_CCTCIF = 0x10;        // Clear CLUT transfer complete interrupt flag Programming this bit to 1 clears the CTCIF flag in the DMA2D_ISR register
    static constexpr uint32_t IFCR_CCEIF = 0x20;         // Clear configuration error interrupt flag Programming this bit to 1 clears the CEIF flag in the DMA2D_ISR register
    static const uint32_t IFCR_RESET_VALUE = 0x0;


    static const uint32_t FGMAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t FGOR_LO =                  // Line offset Line offset used for the foreground expressed in pixel. This value is used to generate the address. It is added at the end of each line to determine the starting address of the next line. These bits can only be written when data transfers are disabled. Once a data transfer has started, they become read-only. If the image format is 4-bit per pixel, the line offset must be even. (14 bits)
        bit_field_t<0, 0x3fff>::value<X>();
    static const uint32_t FGOR_RESET_VALUE = 0x0;


    static const uint32_t BGMAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BGOR_LO =                  // Line offset Line offset used for the background image (expressed in pixel). This value is used for the address generation. It is added at the end of each line to determine the starting address of the next line. These bits can only be written when data transfers are disabled. Once data transfer has started, they become read-only. If the image format is 4-bit per pixel, the line offset must be even. (14 bits)
        bit_field_t<0, 0x3fff>::value<X>();
    static const uint32_t BGOR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t FGPFCCR_CM =                  // Color mode These bits defines the color format of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, they are read-only. others: meaningless (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static constexpr uint32_t FGPFCCR_CCM = 0x10;           // CLUT color mode This bit defines the color format of the CLUT. It can only be written when the transfer is disabled. Once the CLUT transfer has started, this bit is read-only.
    static constexpr uint32_t FGPFCCR_START = 0x20;         // Start This bit can be set to start the automatic loading of the CLUT. It is automatically reset: ** at the end of the transfer ** when the transfer is aborted by the user application by setting the ABORT bit in DMA2D_CR ** when a transfer error occurs ** when the transfer has not started due to a configuration error or another transfer operation already ongoing (data transfer or automatic background CLUT transfer).
    template<uint32_t X>
    static constexpr uint32_t FGPFCCR_CS =                  // CLUT size These bits define the size of the CLUT used for the foreground image. Once the CLUT transfer has started, this field is read-only. The number of CLUT entries is equal to CS[7:0] + 1. (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FGPFCCR_AM =                  // Alpha mode These bits select the alpha channel value to be used for the foreground image. They can only be written data the transfer are disabled. Once the transfer has started, they become read-only. other configurations are meaningless (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FGPFCCR_CSS =                 // Chroma Sub-Sampling These bits define the chroma sub-sampling mode for YCbCr color mode. Once the transfer has started, these bits are read-only. others: meaningless (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t FGPFCCR_AI = 0x100000;        // Alpha Inverted This bit inverts the alpha value. Once the transfer has started, this bit is read-only.
    static constexpr uint32_t FGPFCCR_RBS = 0x200000;       // Red Blue Swap This bit allows to swap the R &amp;amp; B to support BGR or ABGR color formats. Once the transfer has started, this bit is read-only.
    template<uint32_t X>
    static constexpr uint32_t FGPFCCR_ALPHA =               // Alpha value These bits define a fixed alpha channel value which can replace the original alpha value or be multiplied by the original alpha value according to the alpha mode selected through the AM[1:0] bits. These bits can only be written when data transfers are disabled. Once a transfer has started, they become read-only. (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t FGPFCCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t FGCOLR_BLUE =                // Blue Value These bits defines the blue value for the A4 or A8 mode of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, They are read-only. (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FGCOLR_GREEN =               // Green Value These bits defines the green value for the A4 or A8 mode of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, They are read-only. (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FGCOLR_RED =                 // Red Value These bits defines the red value for the A4 or A8 mode of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, they are read-only. (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static const uint32_t FGCOLR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BGPFCCR_CM =                  // Color mode These bits define the color format of the foreground image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. others: meaningless (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static constexpr uint32_t BGPFCCR_CCM = 0x10;           // CLUT Color mode These bits define the color format of the CLUT. This register can only be written when the transfer is disabled. Once the CLUT transfer has started, this bit is read-only.
    static constexpr uint32_t BGPFCCR_START = 0x20;         // Start This bit is set to start the automatic loading of the CLUT. This bit is automatically reset: ** at the end of the transfer ** when the transfer is aborted by the user application by setting the ABORT bit in the DMA2D_CR ** when a transfer error occurs ** when the transfer has not started due to a configuration error or another transfer operation already on going (data transfer or automatic BackGround CLUT transfer).
    template<uint32_t X>
    static constexpr uint32_t BGPFCCR_CS =                  // CLUT size These bits define the size of the CLUT used for the BG. Once the CLUT transfer has started, this field is read-only. The number of CLUT entries is equal to CS[7:0] + 1. (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BGPFCCR_AM =                  // Alpha mode These bits define which alpha channel value to be used for the background image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. others: meaningless (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    static constexpr uint32_t BGPFCCR_AI = 0x100000;        // Alpha Inverted This bit inverts the alpha value. Once the transfer has started, this bit is read-only.
    static constexpr uint32_t BGPFCCR_RBS = 0x200000;       // Red Blue Swap This bit allows to swap the R &amp;amp; B to support BGR or ABGR color formats. Once the transfer has started, this bit is read-only.
    template<uint32_t X>
    static constexpr uint32_t BGPFCCR_ALPHA =               // Alpha value These bits define a fixed alpha channel value which can replace the original alpha value or be multiplied with the original alpha value according to the alpha mode selected with bits AM[1: 0]. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t BGPFCCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BGCOLR_BLUE =                // Blue Value These bits define the blue value for the A4 or A8 mode of the background. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BGCOLR_GREEN =               // Green Value These bits define the green value for the A4 or A8 mode of the background. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BGCOLR_RED =                 // Red Value These bits define the red value for the A4 or A8 mode of the background. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static const uint32_t BGCOLR_RESET_VALUE = 0x0;


    static const uint32_t FGCMAR_RESET_VALUE = 0x0;


    static const uint32_t BGCMAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OPFCCR_CM =                  // Color mode These bits define the color format of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. others: meaningless (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static constexpr uint32_t OPFCCR_AI = 0x100000;        // Alpha Inverted This bit inverts the alpha value. Once the transfer has started, this bit is read-only.
    static constexpr uint32_t OPFCCR_RBS = 0x200000;       // Red Blue Swap This bit allows to swap the R &amp;amp; B to support BGR or ABGR color formats. Once the transfer has started, this bit is read-only.
    static const uint32_t OPFCCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OCOLR_BLUE =                // Blue Value These bits define the blue value of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OCOLR_GREEN =               // Green Value These bits define the green value of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OCOLR_RED =                 // Red Value These bits define the red value of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OCOLR_ALPHA =               // Alpha Channel Value These bits define the alpha channel of the output color. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t OCOLR_RESET_VALUE = 0x0;


    static const uint32_t OMAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OOR_LO =                  // Line Offset Line offset used for the output (expressed in pixels). This value is used for the address generation. It is added at the end of each line to determine the starting address of the next line. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. (14 bits)
        bit_field_t<0, 0x3fff>::value<X>();
    static const uint32_t OOR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t NLR_NL =                  // Number of lines Number of lines of the area to be transferred. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t NLR_PL =                  // Pixel per lines Number of pixels per lines of the area to be transferred. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. If any of the input image format is 4-bit per pixel, pixel per lines must be even. (14 bits)
        bit_field_t<16, 0x3fff>::value<X>();
    static const uint32_t NLR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t LWR_LW =                  // Line watermark These bits allow to configure the line watermark for interrupt generation. An interrupt is raised when the last pixel of the watermarked line has been transferred. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t LWR_RESET_VALUE = 0x0;

    static constexpr uint32_t AMTCR_EN = 0x1;             // Enable Enables the dead time functionality.
    template<uint32_t X>
    static constexpr uint32_t AMTCR_DT =                  // Dead Time Dead time value in the AXI clock cycle inserted between two consecutive accesses on the AXI master port. These bits represent the minimum guaranteed number of cycles between two consecutive AXI accesses. (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static const uint32_t AMTCR_RESET_VALUE = 0x0;

    static constexpr uint8_t DMA2D = 90; // DMA2D global interrupt
};

static dma2d_t& DMA2D = *reinterpret_cast<dma2d_t*>(0x52001000);

#define HAVE_PERIPHERAL_DMA2D


////
//
//    DMAMUX
//
////

struct dmamux2_t
{
    volatile uint32_t    C0CR;                 // [Read-write] DMAMux - DMA request line multiplexer channel x control register
    volatile uint32_t    C1CR;                 // [Read-write] DMAMux - DMA request line multiplexer channel x control register
    volatile uint32_t    C2CR;                 // [Read-write] DMAMux - DMA request line multiplexer channel x control register
    volatile uint32_t    C3CR;                 // [Read-write] DMAMux - DMA request line multiplexer channel x control register
    volatile uint32_t    C4CR;                 // [Read-write] DMAMux - DMA request line multiplexer channel x control register
    volatile uint32_t    C5CR;                 // [Read-write] DMAMux - DMA request line multiplexer channel x control register
    volatile uint32_t    C6CR;                 // [Read-write] DMAMux - DMA request line multiplexer channel x control register
    volatile uint32_t    C7CR;                 // [Read-write] DMAMux - DMA request line multiplexer channel x control register
    reserved_t<24>       _0;
    volatile uint32_t    CSR;                  // [Read-only] DMAMUX request line multiplexer interrupt channel status register
    volatile uint32_t    CFR;                  // [Write-only] DMAMUX request line multiplexer interrupt clear flag register
    reserved_t<30>       _1;
    volatile uint32_t    RG0CR;                // [Read-write] DMAMux - DMA request generator channel x control register
    volatile uint32_t    RG1CR;                // [Read-write] DMAMux - DMA request generator channel x control register
    volatile uint32_t    RG2CR;                // [Read-write] DMAMux - DMA request generator channel x control register
    volatile uint32_t    RG3CR;                // [Read-write] DMAMux - DMA request generator channel x control register
    volatile uint32_t    RG4CR;                // [Read-write] DMAMux - DMA request generator channel x control register
    volatile uint32_t    RG5CR;                // [Read-write] DMAMux - DMA request generator channel x control register
    volatile uint32_t    RG6CR;                // [Read-write] DMAMux - DMA request generator channel x control register
    volatile uint32_t    RG7CR;                // [Read-write] DMAMux - DMA request generator channel x control register
    reserved_t<8>        _2;
    volatile uint32_t    RGSR;                 // [Read-only] DMAMux - DMA request generator status register
    volatile uint32_t    RGCFR;                // [Write-only] DMAMux - DMA request generator clear flag register

    template<uint32_t X>
    static constexpr uint32_t C0CR_DMAREQ_ID =           // Input DMA request line selected (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static constexpr uint32_t C0CR_SOIE = 0x100;         // Interrupt enable at synchronization event overrun
    static constexpr uint32_t C0CR_EGE = 0x200;          // Event generation enable/disable
    static constexpr uint32_t C0CR_SE = 0x10000;         // Synchronous operating mode enable/disable
    template<uint32_t X>
    static constexpr uint32_t C0CR_SPOL =                // Synchronization event type selector Defines the synchronization event on the selected synchronization input: (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C0CR_NBREQ =               // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset. (5 bits)
        bit_field_t<19, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C0CR_SYNC_ID =             // Synchronization input selected (5 bits)
        bit_field_t<24, 0x1f>::value<X>();
    static const uint32_t C0CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C1CR_DMAREQ_ID =           // Input DMA request line selected (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static constexpr uint32_t C1CR_SOIE = 0x100;         // Interrupt enable at synchronization event overrun
    static constexpr uint32_t C1CR_EGE = 0x200;          // Event generation enable/disable
    static constexpr uint32_t C1CR_SE = 0x10000;         // Synchronous operating mode enable/disable
    template<uint32_t X>
    static constexpr uint32_t C1CR_SPOL =                // Synchronization event type selector Defines the synchronization event on the selected synchronization input: (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C1CR_NBREQ =               // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset. (5 bits)
        bit_field_t<19, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C1CR_SYNC_ID =             // Synchronization input selected (5 bits)
        bit_field_t<24, 0x1f>::value<X>();
    static const uint32_t C1CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C2CR_DMAREQ_ID =           // Input DMA request line selected (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static constexpr uint32_t C2CR_SOIE = 0x100;         // Interrupt enable at synchronization event overrun
    static constexpr uint32_t C2CR_EGE = 0x200;          // Event generation enable/disable
    static constexpr uint32_t C2CR_SE = 0x10000;         // Synchronous operating mode enable/disable
    template<uint32_t X>
    static constexpr uint32_t C2CR_SPOL =                // Synchronization event type selector Defines the synchronization event on the selected synchronization input: (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C2CR_NBREQ =               // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset. (5 bits)
        bit_field_t<19, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C2CR_SYNC_ID =             // Synchronization input selected (5 bits)
        bit_field_t<24, 0x1f>::value<X>();
    static const uint32_t C2CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C3CR_DMAREQ_ID =           // Input DMA request line selected (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static constexpr uint32_t C3CR_SOIE = 0x100;         // Interrupt enable at synchronization event overrun
    static constexpr uint32_t C3CR_EGE = 0x200;          // Event generation enable/disable
    static constexpr uint32_t C3CR_SE = 0x10000;         // Synchronous operating mode enable/disable
    template<uint32_t X>
    static constexpr uint32_t C3CR_SPOL =                // Synchronization event type selector Defines the synchronization event on the selected synchronization input: (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C3CR_NBREQ =               // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset. (5 bits)
        bit_field_t<19, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C3CR_SYNC_ID =             // Synchronization input selected (5 bits)
        bit_field_t<24, 0x1f>::value<X>();
    static const uint32_t C3CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C4CR_DMAREQ_ID =           // Input DMA request line selected (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static constexpr uint32_t C4CR_SOIE = 0x100;         // Interrupt enable at synchronization event overrun
    static constexpr uint32_t C4CR_EGE = 0x200;          // Event generation enable/disable
    static constexpr uint32_t C4CR_SE = 0x10000;         // Synchronous operating mode enable/disable
    template<uint32_t X>
    static constexpr uint32_t C4CR_SPOL =                // Synchronization event type selector Defines the synchronization event on the selected synchronization input: (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C4CR_NBREQ =               // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset. (5 bits)
        bit_field_t<19, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C4CR_SYNC_ID =             // Synchronization input selected (5 bits)
        bit_field_t<24, 0x1f>::value<X>();
    static const uint32_t C4CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C5CR_DMAREQ_ID =           // Input DMA request line selected (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static constexpr uint32_t C5CR_SOIE = 0x100;         // Interrupt enable at synchronization event overrun
    static constexpr uint32_t C5CR_EGE = 0x200;          // Event generation enable/disable
    static constexpr uint32_t C5CR_SE = 0x10000;         // Synchronous operating mode enable/disable
    template<uint32_t X>
    static constexpr uint32_t C5CR_SPOL =                // Synchronization event type selector Defines the synchronization event on the selected synchronization input: (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C5CR_NBREQ =               // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset. (5 bits)
        bit_field_t<19, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C5CR_SYNC_ID =             // Synchronization input selected (5 bits)
        bit_field_t<24, 0x1f>::value<X>();
    static const uint32_t C5CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C6CR_DMAREQ_ID =           // Input DMA request line selected (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static constexpr uint32_t C6CR_SOIE = 0x100;         // Interrupt enable at synchronization event overrun
    static constexpr uint32_t C6CR_EGE = 0x200;          // Event generation enable/disable
    static constexpr uint32_t C6CR_SE = 0x10000;         // Synchronous operating mode enable/disable
    template<uint32_t X>
    static constexpr uint32_t C6CR_SPOL =                // Synchronization event type selector Defines the synchronization event on the selected synchronization input: (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C6CR_NBREQ =               // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset. (5 bits)
        bit_field_t<19, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C6CR_SYNC_ID =             // Synchronization input selected (5 bits)
        bit_field_t<24, 0x1f>::value<X>();
    static const uint32_t C6CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C7CR_DMAREQ_ID =           // Input DMA request line selected (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static constexpr uint32_t C7CR_SOIE = 0x100;         // Interrupt enable at synchronization event overrun
    static constexpr uint32_t C7CR_EGE = 0x200;          // Event generation enable/disable
    static constexpr uint32_t C7CR_SE = 0x10000;         // Synchronous operating mode enable/disable
    template<uint32_t X>
    static constexpr uint32_t C7CR_SPOL =                // Synchronization event type selector Defines the synchronization event on the selected synchronization input: (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C7CR_NBREQ =               // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset. (5 bits)
        bit_field_t<19, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C7CR_SYNC_ID =             // Synchronization input selected (5 bits)
        bit_field_t<24, 0x1f>::value<X>();
    static const uint32_t C7CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CSR_SOF =                 // Synchronization overrun event flag (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CSR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CFR_CSOF =                // Clear synchronization overrun event flag (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CFR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RG0CR_SIG_ID =              // DMA request trigger input selected (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static constexpr uint32_t RG0CR_OIE = 0x100;          // Interrupt enable at trigger event overrun
    static constexpr uint32_t RG0CR_GE = 0x10000;         // DMA request generator channel enable/disable
    template<uint32_t X>
    static constexpr uint32_t RG0CR_GPOL =                // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RG0CR_GNBREQ =              // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset. (5 bits)
        bit_field_t<19, 0x1f>::value<X>();
    static const uint32_t RG0CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RG1CR_SIG_ID =              // DMA request trigger input selected (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static constexpr uint32_t RG1CR_OIE = 0x100;          // Interrupt enable at trigger event overrun
    static constexpr uint32_t RG1CR_GE = 0x10000;         // DMA request generator channel enable/disable
    template<uint32_t X>
    static constexpr uint32_t RG1CR_GPOL =                // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RG1CR_GNBREQ =              // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset. (5 bits)
        bit_field_t<19, 0x1f>::value<X>();
    static const uint32_t RG1CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RG2CR_SIG_ID =              // DMA request trigger input selected (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static constexpr uint32_t RG2CR_OIE = 0x100;          // Interrupt enable at trigger event overrun
    static constexpr uint32_t RG2CR_GE = 0x10000;         // DMA request generator channel enable/disable
    template<uint32_t X>
    static constexpr uint32_t RG2CR_GPOL =                // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RG2CR_GNBREQ =              // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset. (5 bits)
        bit_field_t<19, 0x1f>::value<X>();
    static const uint32_t RG2CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RG3CR_SIG_ID =              // DMA request trigger input selected (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static constexpr uint32_t RG3CR_OIE = 0x100;          // Interrupt enable at trigger event overrun
    static constexpr uint32_t RG3CR_GE = 0x10000;         // DMA request generator channel enable/disable
    template<uint32_t X>
    static constexpr uint32_t RG3CR_GPOL =                // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RG3CR_GNBREQ =              // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset. (5 bits)
        bit_field_t<19, 0x1f>::value<X>();
    static const uint32_t RG3CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RG4CR_SIG_ID =              // DMA request trigger input selected (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static constexpr uint32_t RG4CR_OIE = 0x100;          // Interrupt enable at trigger event overrun
    static constexpr uint32_t RG4CR_GE = 0x10000;         // DMA request generator channel enable/disable
    template<uint32_t X>
    static constexpr uint32_t RG4CR_GPOL =                // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RG4CR_GNBREQ =              // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset. (5 bits)
        bit_field_t<19, 0x1f>::value<X>();
    static const uint32_t RG4CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RG5CR_SIG_ID =              // DMA request trigger input selected (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static constexpr uint32_t RG5CR_OIE = 0x100;          // Interrupt enable at trigger event overrun
    static constexpr uint32_t RG5CR_GE = 0x10000;         // DMA request generator channel enable/disable
    template<uint32_t X>
    static constexpr uint32_t RG5CR_GPOL =                // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RG5CR_GNBREQ =              // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset. (5 bits)
        bit_field_t<19, 0x1f>::value<X>();
    static const uint32_t RG5CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RG6CR_SIG_ID =              // DMA request trigger input selected (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static constexpr uint32_t RG6CR_OIE = 0x100;          // Interrupt enable at trigger event overrun
    static constexpr uint32_t RG6CR_GE = 0x10000;         // DMA request generator channel enable/disable
    template<uint32_t X>
    static constexpr uint32_t RG6CR_GPOL =                // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RG6CR_GNBREQ =              // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset. (5 bits)
        bit_field_t<19, 0x1f>::value<X>();
    static const uint32_t RG6CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RG7CR_SIG_ID =              // DMA request trigger input selected (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static constexpr uint32_t RG7CR_OIE = 0x100;          // Interrupt enable at trigger event overrun
    static constexpr uint32_t RG7CR_GE = 0x10000;         // DMA request generator channel enable/disable
    template<uint32_t X>
    static constexpr uint32_t RG7CR_GPOL =                // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RG7CR_GNBREQ =              // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset. (5 bits)
        bit_field_t<19, 0x1f>::value<X>();
    static const uint32_t RG7CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RGSR_OF =                  // Trigger event overrun flag The flag is set when a trigger event occurs on DMA request generator channel x, while the DMA request generator counter value is lower than GNBREQ. The flag is cleared by writing 1 to the corresponding COFx bit in DMAMUX_RGCFR register. (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t RGSR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RGCFR_COF =                 // Clear trigger event overrun flag Upon setting, this bit clears the corresponding overrun flag OFx in the DMAMUX_RGCSR register. (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t RGCFR_RESET_VALUE = 0x0;

    static constexpr uint8_t DMAMUX2_OVR = 128; // DMAMUX2 overrun interrupt
};

static dmamux2_t& DMAMUX2 = *reinterpret_cast<dmamux2_t*>(0x58025800);

#define HAVE_PERIPHERAL_DMAMUX2


////
//
//    FMC
//
////

struct fmc_t
{
    volatile uint32_t    BCR1;                 // [Read-write] This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.
    volatile uint32_t    BTR1;                 // [Read-write] This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.If the EXTMOD bit is set in the FMC_BCRx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (FMC_BWTRx registers).
    volatile uint32_t    BCR2;                 // [Read-write] This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.
    volatile uint32_t    BTR2;                 // [Read-write] This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.If the EXTMOD bit is set in the FMC_BCRx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (FMC_BWTRx registers).
    volatile uint32_t    BCR3;                 // [Read-write] This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.
    volatile uint32_t    BTR3;                 // [Read-write] This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.If the EXTMOD bit is set in the FMC_BCRx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (FMC_BWTRx registers).
    volatile uint32_t    BCR4;                 // [Read-write] This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.
    volatile uint32_t    BTR4;                 // [Read-write] This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.If the EXTMOD bit is set in the FMC_BCRx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (FMC_BWTRx registers).
    reserved_t<24>       _0;
    volatile uint32_t    PCR;                  // [Read-write] NAND Flash control registers
    volatile uint32_t    SR;                   // This register contains information about the FIFO status and interrupt. The FMC features a FIFO that is used when writing to memories to transfer up to 16 words of data.This is used to quickly write to the FIFO and free the AXI bus for transactions to peripherals other than the FMC, while the FMC is draining its FIFO into the memory. One of these register bits indicates the status of the FIFO, for ECC purposes.The ECC is calculated while the data are written to the memory. To read the correct ECC, the software must consequently wait until the FIFO is empty.
    volatile uint32_t    PMEM;                 // [Read-write] The FMC_PMEM read/write register contains the timing information for NAND Flash memory bank. This information is used to access either the common memory space of the NAND Flash for command, address write access and data read/write access.
    volatile uint32_t    PATT;                 // [Read-write] The FMC_PATT read/write register contains the timing information for NAND Flash memory bank. It is used for 8-bit accesses to the attribute memory space of the NAND Flash for the last address write access if the timing must differ from that of previous accesses (for Ready/Busy management, refer to Section20.8.5: NAND Flash prewait feature).
    reserved_t<1>        _1;
    volatile uint32_t    ECCR;                 // [Read-only] This register contain the current error correction code value computed by the ECC computation modules of the FMC NAND controller. When the CPU reads/writes the data from a NAND Flash memory page at the correct address (refer to Section20.8.6: Computation of the error correction code (ECC) in NAND Flash memory), the data read/written from/to the NAND Flash memory are processed automatically by the ECC computation module. When X bytes have been read (according to the ECCPS field in the FMC_PCR registers), the CPU must read the computed ECC value from the FMC_ECC registers. It then verifies if these computed parity data are the same as the parity value recorded in the spare area, to determine whether a page is valid, and, to correct it otherwise. The FMC_ECCR register should be cleared after being read by setting the ECCEN bit to 0. To compute a new data block, the ECCEN bit must be set to 1.
    reserved_t<27>       _2;
    volatile uint32_t    BWTR1;                // [Read-write] This register contains the control information of each memory bank. It is used for SRAMs, PSRAMs and NOR Flash memories. When the EXTMOD bit is set in the FMC_BCRx register, then this register is active for write access.
    reserved_t<1>        _3;
    volatile uint32_t    BWTR2;                // [Read-write] This register contains the control information of each memory bank. It is used for SRAMs, PSRAMs and NOR Flash memories. When the EXTMOD bit is set in the FMC_BCRx register, then this register is active for write access.
    reserved_t<1>        _4;
    volatile uint32_t    BWTR3;                // [Read-write] This register contains the control information of each memory bank. It is used for SRAMs, PSRAMs and NOR Flash memories. When the EXTMOD bit is set in the FMC_BCRx register, then this register is active for write access.
    reserved_t<1>        _5;
    volatile uint32_t    BWTR4;                // [Read-write] This register contains the control information of each memory bank. It is used for SRAMs, PSRAMs and NOR Flash memories. When the EXTMOD bit is set in the FMC_BCRx register, then this register is active for write access.
    reserved_t<8>        _6;
    volatile uint32_t    SDCR1;                // [Read-write] This register contains the control parameters for each SDRAM memory bank
    volatile uint32_t    SDCR2;                // [Read-write] This register contains the control parameters for each SDRAM memory bank
    volatile uint32_t    SDTR1;                // [Read-write] This register contains the timing parameters of each SDRAM bank
    volatile uint32_t    SDTR2;                // [Read-write] This register contains the timing parameters of each SDRAM bank
    volatile uint32_t    SDCMR;                // [Read-write] This register contains the command issued when the SDRAM device is accessed. This register is used to initialize the SDRAM device, and to activate the Self-refresh and the Power-down modes. As soon as the MODE field is written, the command will be issued only to one or to both SDRAM banks according to CTB1 and CTB2 command bits. This register is the same for both SDRAM banks.
    volatile uint32_t    SDRTR;                // This register sets the refresh rate in number of SDCLK clock cycles between the refresh cycles by configuring the Refresh Timer Count value.Examplewhere 64 ms is the SDRAM refresh period.The refresh rate must be increased by 20 SDRAM clock cycles (as in the above example) to obtain a safe margin if an internal refresh request occurs when a read request has been accepted. It corresponds to a COUNT value of 0000111000000 (448). This 13-bit field is loaded into a timer which is decremented using the SDRAM clock. This timer generates a refresh pulse when zero is reached. The COUNT value must be set at least to 41 SDRAM clock cycles.As soon as the FMC_SDRTR register is programmed, the timer starts counting. If the value programmed in the register is 0, no refresh is carried out. This register must not be reprogrammed after the initialization procedure to avoid modifying the refresh rate.Each time a refresh pulse is generated, this 13-bit COUNT field is reloaded into the counter.If a memory access is in progress, the Auto-refresh request is delayed. However, if the memory access and Auto-refresh requests are generated simultaneously, the Auto-refresh takes precedence. If the memory access occurs during a refresh operation, the request is buffered to be processed when the refresh is complete.This register is common to SDRAM bank 1 and bank 2.
    volatile uint32_t    SDSR;                 // [Read-only] SDRAM Status register

    static constexpr uint32_t BCR1_MBKEN = 0x1;          // Memory bank enable bit This bit enables the memory bank. After reset Bank1 is enabled, all others are disabled. Accessing a disabled bank causes an ERROR on AXI bus.
    static constexpr uint32_t BCR1_MUXEN = 0x2;          // Address/data multiplexing enable bit When this bit is set, the address and data values are multiplexed on the data bus, valid only with NOR and PSRAM memories:
    template<uint32_t X>
    static constexpr uint32_t BCR1_MTYP =                // Memory type These bits define the type of external memory attached to the corresponding memory bank: (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BCR1_MWID =                // Memory data bus width Defines the external memory device width, valid for all type of memories. (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static constexpr uint32_t BCR1_FACCEN = 0x40;        // Flash access enable This bit enables NOR Flash memory access operations.
    static constexpr uint32_t BCR1_BURSTEN = 0x100;      // Burst enable bit This bit enables/disables synchronous accesses during read operations. It is valid only for synchronous memories operating in Burst mode:
    static constexpr uint32_t BCR1_WAITPOL = 0x200;      // Wait signal polarity bit This bit defines the polarity of the wait signal from memory used for either in synchronous or asynchronous mode:
    static constexpr uint32_t BCR1_WAITCFG = 0x800;      // Wait timing configuration The NWAIT signal indicates whether the data from the memory are valid or if a wait state must be inserted when accessing the memory in synchronous mode. This configuration bit determines if NWAIT is asserted by the memory one clock cycle before the wait state or during the wait state:
    static constexpr uint32_t BCR1_WREN = 0x1000;        // Write enable bit This bit indicates whether write operations are enabled/disabled in the bank by the FMC:
    static constexpr uint32_t BCR1_WAITEN = 0x2000;      // Wait enable bit This bit enables/disables wait-state insertion via the NWAIT signal when accessing the memory in synchronous mode.
    static constexpr uint32_t BCR1_EXTMOD = 0x4000;      // Extended mode enable. This bit enables the FMC to program the write timings for asynchronous accesses inside the FMC_BWTR register, thus resulting in different timings for read and write operations. Note: When the extended mode is disabled, the FMC can operate in Mode1 or Mode2 as follows: ** Mode 1 is the default mode when the SRAM/PSRAM memory type is selected (MTYP =0x0 or 0x01) ** Mode 2 is the default mode when the NOR memory type is selected (MTYP = 0x10).
    static constexpr uint32_t BCR1_ASYNCWAIT = 0x8000;   // Wait signal during asynchronous transfers This bit enables/disables the FMC to use the wait signal even during an asynchronous protocol.
    template<uint32_t X>
    static constexpr uint32_t BCR1_CPSIZE =              // CRAM Page Size These are used for Cellular RAM 1.5 which does not allow burst access to cross the address boundaries between pages. When these bits are configured, the FMC controller splits automatically the burst access when the memory page size is reached (refer to memory datasheet for page size). Other configuration: reserved. (3 bits)
        bit_field_t<16, 0x7>::value<X>();
    static constexpr uint32_t BCR1_CBURSTRW = 0x80000;   // Write burst enable For PSRAM (CRAM) operating in Burst mode, the bit enables synchronous accesses during write operations. The enable bit for synchronous read accesses is the BURSTEN bit in the FMC_BCRx register.
    static constexpr uint32_t BCR1_CCLKEN = 0x100000;    // Continuous Clock Enable This bit enables the FMC_CLK clock output to external memory devices. Note: The CCLKEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. Bank 1 must be configured in synchronous mode to generate the FMC_CLK continuous clock. If CCLKEN bit is set, the FMC_CLK clock ratio is specified by CLKDIV value in the FMC_BTR1 register. CLKDIV in FMC_BWTR1 is dont care. If the synchronous mode is used and CCLKEN bit is set, the synchronous memories connected to other banks than Bank 1 are clocked by the same clock (the CLKDIV value in the FMC_BTR2..4 and FMC_BWTR2..4 registers for other banks has no effect.)
    static constexpr uint32_t BCR1_WFDIS = 0x200000;     // Write FIFO Disable This bit disables the Write FIFO used by the FMC controller. Note: The WFDIS bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
    template<uint32_t X>
    static constexpr uint32_t BCR1_BMAP =                // FMC bank mapping These bits allows different to remap SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.Refer to Table 10 for Note: The BMAP bits of the FMC_BCR2..4 registers are dont care. It is only enabled through the FMC_BCR1 register. (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    static constexpr uint32_t BCR1_FMCEN = 0x80000000;   // FMC controller Enable This bit enables/disables the FMC controller. Note: The FMCEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
    static const uint32_t BCR1_RESET_VALUE = 0x30db;

    template<uint32_t X>
    static constexpr uint32_t BTR1_ADDSET =              // Address setup phase duration These bits are written by software to define the duration of the address setup phase (refer to Figure81 to Figure93), used in SRAMs, ROMs and asynchronous NOR Flash: For each access mode address setup phase duration, please refer to the respective figure (refer to Figure81 to Figure93). Note: In synchronous accesses, this value is dont care. In Muxed mode or Mode D, the minimum value for ADDSET is 1. (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR1_ADDHLD =              // Address-hold phase duration These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in mode D or multiplexed accesses: For each access mode address-hold phase duration, please refer to the respective figure (Figure81 to Figure93). Note: In synchronous accesses, this value is not used, the address hold phase is always 1 memory clock period duration. (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR1_DATAST =              // Data-phase duration These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous accesses: For each memory type and access mode data-phase duration, please refer to the respective figure (Figure81 to Figure93). Example: Mode1, write access, DATAST=1: Data-phase duration= DATAST+1 = 2 KCK_FMC clock cycles. Note: In synchronous accesses, this value is dont care. (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR1_BUSTURN =             // Bus turnaround phase duration These bits are written by software to add a delay at the end of a write-to-read or read-to write transaction. The programmed bus turnaround delay is inserted between an asynchronous read (in muxed or mode D) or write transaction and any other asynchronous /synchronous read/write from/to a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except in muxed mode and mode D. There is a bus turnaround delay of 1 FMC clock cycle between: Two consecutive asynchronous read transfers to the same static memory bank except for modes muxed and D. An asynchronous read to an asynchronous or synchronous write to any static bank or dynamic bank except in modes muxed and D mode. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank. A synchronous write (burst or single) access and an asynchronous write or read transfer to or from static memory bank (the bank can be the same or a different one in case of a read operation. Two consecutive synchronous read operations (in Burst or Single mode) followed by any synchronous/asynchronous read or write from/to another static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write access (in Burst or Single mode) and a synchronous read from the same or a different bank. The bus turnaround delay allows to match the minimum time between consecutive transactions (tEHEL from NEx high to NEx low) and the maximum time required by the memory to free the data bus after a read access (tEHQZ): (BUSTRUN + 1) KCK_FMC period &amp;#8805; tEHELmin and (BUSTRUN + 2)KCK_FMC period &amp;#8805; tEHQZmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period &amp;#8805; max (tEHELmin, tEHQZmax) if EXTMOD = 126. ... (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR1_CLKDIV =              // Clock divide ratio (for FMC_CLK signal) These bits define the period of FMC_CLK clock output signal, expressed in number of KCK_FMC cycles: In asynchronous NOR Flash, SRAM or PSRAM accesses, this value is dont care. Note: Refer to Section20.6.5: Synchronous transactions for FMC_CLK divider ratio formula) (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR1_DATLAT =              // Data latency for synchronous memory For synchronous access with read write burst mode enabled these bits define the number of memory clock cycles (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR1_ACCMOD =              // Access mode These bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    static const uint32_t BTR1_RESET_VALUE = 0xfffffff;

    static constexpr uint32_t BCR2_MBKEN = 0x1;          // Memory bank enable bit This bit enables the memory bank. After reset Bank1 is enabled, all others are disabled. Accessing a disabled bank causes an ERROR on AXI bus.
    static constexpr uint32_t BCR2_MUXEN = 0x2;          // Address/data multiplexing enable bit When this bit is set, the address and data values are multiplexed on the data bus, valid only with NOR and PSRAM memories:
    template<uint32_t X>
    static constexpr uint32_t BCR2_MTYP =                // Memory type These bits define the type of external memory attached to the corresponding memory bank: (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BCR2_MWID =                // Memory data bus width Defines the external memory device width, valid for all type of memories. (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static constexpr uint32_t BCR2_FACCEN = 0x40;        // Flash access enable This bit enables NOR Flash memory access operations.
    static constexpr uint32_t BCR2_BURSTEN = 0x100;      // Burst enable bit This bit enables/disables synchronous accesses during read operations. It is valid only for synchronous memories operating in Burst mode:
    static constexpr uint32_t BCR2_WAITPOL = 0x200;      // Wait signal polarity bit This bit defines the polarity of the wait signal from memory used for either in synchronous or asynchronous mode:
    static constexpr uint32_t BCR2_WAITCFG = 0x800;      // Wait timing configuration The NWAIT signal indicates whether the data from the memory are valid or if a wait state must be inserted when accessing the memory in synchronous mode. This configuration bit determines if NWAIT is asserted by the memory one clock cycle before the wait state or during the wait state:
    static constexpr uint32_t BCR2_WREN = 0x1000;        // Write enable bit This bit indicates whether write operations are enabled/disabled in the bank by the FMC:
    static constexpr uint32_t BCR2_WAITEN = 0x2000;      // Wait enable bit This bit enables/disables wait-state insertion via the NWAIT signal when accessing the memory in synchronous mode.
    static constexpr uint32_t BCR2_EXTMOD = 0x4000;      // Extended mode enable. This bit enables the FMC to program the write timings for asynchronous accesses inside the FMC_BWTR register, thus resulting in different timings for read and write operations. Note: When the extended mode is disabled, the FMC can operate in Mode1 or Mode2 as follows: ** Mode 1 is the default mode when the SRAM/PSRAM memory type is selected (MTYP =0x0 or 0x01) ** Mode 2 is the default mode when the NOR memory type is selected (MTYP = 0x10).
    static constexpr uint32_t BCR2_ASYNCWAIT = 0x8000;   // Wait signal during asynchronous transfers This bit enables/disables the FMC to use the wait signal even during an asynchronous protocol.
    template<uint32_t X>
    static constexpr uint32_t BCR2_CPSIZE =              // CRAM Page Size These are used for Cellular RAM 1.5 which does not allow burst access to cross the address boundaries between pages. When these bits are configured, the FMC controller splits automatically the burst access when the memory page size is reached (refer to memory datasheet for page size). Other configuration: reserved. (3 bits)
        bit_field_t<16, 0x7>::value<X>();
    static constexpr uint32_t BCR2_CBURSTRW = 0x80000;   // Write burst enable For PSRAM (CRAM) operating in Burst mode, the bit enables synchronous accesses during write operations. The enable bit for synchronous read accesses is the BURSTEN bit in the FMC_BCRx register.
    static constexpr uint32_t BCR2_CCLKEN = 0x100000;    // Continuous Clock Enable This bit enables the FMC_CLK clock output to external memory devices. Note: The CCLKEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. Bank 1 must be configured in synchronous mode to generate the FMC_CLK continuous clock. If CCLKEN bit is set, the FMC_CLK clock ratio is specified by CLKDIV value in the FMC_BTR1 register. CLKDIV in FMC_BWTR1 is dont care. If the synchronous mode is used and CCLKEN bit is set, the synchronous memories connected to other banks than Bank 1 are clocked by the same clock (the CLKDIV value in the FMC_BTR2..4 and FMC_BWTR2..4 registers for other banks has no effect.)
    static constexpr uint32_t BCR2_WFDIS = 0x200000;     // Write FIFO Disable This bit disables the Write FIFO used by the FMC controller. Note: The WFDIS bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
    template<uint32_t X>
    static constexpr uint32_t BCR2_BMAP =                // FMC bank mapping These bits allows different to remap SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.Refer to Table 10 for Note: The BMAP bits of the FMC_BCR2..4 registers are dont care. It is only enabled through the FMC_BCR1 register. (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    static constexpr uint32_t BCR2_FMCEN = 0x80000000;   // FMC controller Enable This bit enables/disables the FMC controller. Note: The FMCEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
    static const uint32_t BCR2_RESET_VALUE = 0x30d2;

    template<uint32_t X>
    static constexpr uint32_t BTR2_ADDSET =              // Address setup phase duration These bits are written by software to define the duration of the address setup phase (refer to Figure81 to Figure93), used in SRAMs, ROMs and asynchronous NOR Flash: For each access mode address setup phase duration, please refer to the respective figure (refer to Figure81 to Figure93). Note: In synchronous accesses, this value is dont care. In Muxed mode or Mode D, the minimum value for ADDSET is 1. (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR2_ADDHLD =              // Address-hold phase duration These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in mode D or multiplexed accesses: For each access mode address-hold phase duration, please refer to the respective figure (Figure81 to Figure93). Note: In synchronous accesses, this value is not used, the address hold phase is always 1 memory clock period duration. (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR2_DATAST =              // Data-phase duration These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous accesses: For each memory type and access mode data-phase duration, please refer to the respective figure (Figure81 to Figure93). Example: Mode1, write access, DATAST=1: Data-phase duration= DATAST+1 = 2 KCK_FMC clock cycles. Note: In synchronous accesses, this value is dont care. (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR2_BUSTURN =             // Bus turnaround phase duration These bits are written by software to add a delay at the end of a write-to-read or read-to write transaction. The programmed bus turnaround delay is inserted between an asynchronous read (in muxed or mode D) or write transaction and any other asynchronous /synchronous read/write from/to a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except in muxed mode and mode D. There is a bus turnaround delay of 1 FMC clock cycle between: Two consecutive asynchronous read transfers to the same static memory bank except for modes muxed and D. An asynchronous read to an asynchronous or synchronous write to any static bank or dynamic bank except in modes muxed and D mode. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank. A synchronous write (burst or single) access and an asynchronous write or read transfer to or from static memory bank (the bank can be the same or a different one in case of a read operation. Two consecutive synchronous read operations (in Burst or Single mode) followed by any synchronous/asynchronous read or write from/to another static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write access (in Burst or Single mode) and a synchronous read from the same or a different bank. The bus turnaround delay allows to match the minimum time between consecutive transactions (tEHEL from NEx high to NEx low) and the maximum time required by the memory to free the data bus after a read access (tEHQZ): (BUSTRUN + 1) KCK_FMC period &amp;#8805; tEHELmin and (BUSTRUN + 2)KCK_FMC period &amp;#8805; tEHQZmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period &amp;#8805; max (tEHELmin, tEHQZmax) if EXTMOD = 1. ... (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR2_CLKDIV =              // Clock divide ratio (for FMC_CLK signal) These bits define the period of FMC_CLK clock output signal, expressed in number of KCK_FMC cycles: In asynchronous NOR Flash, SRAM or PSRAM accesses, this value is dont care. Note: Refer to Section20.6.5: Synchronous transactions for FMC_CLK divider ratio formula) (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR2_DATLAT =              // Data latency for synchronous memory For synchronous access with read write burst mode enabled these bits define the number of memory clock cycles (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR2_ACCMOD =              // Access mode These bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    static const uint32_t BTR2_RESET_VALUE = 0xfffffff;

    static constexpr uint32_t BCR3_MBKEN = 0x1;          // Memory bank enable bit This bit enables the memory bank. After reset Bank1 is enabled, all others are disabled. Accessing a disabled bank causes an ERROR on AXI bus.
    static constexpr uint32_t BCR3_MUXEN = 0x2;          // Address/data multiplexing enable bit When this bit is set, the address and data values are multiplexed on the data bus, valid only with NOR and PSRAM memories:
    template<uint32_t X>
    static constexpr uint32_t BCR3_MTYP =                // Memory type These bits define the type of external memory attached to the corresponding memory bank: (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BCR3_MWID =                // Memory data bus width Defines the external memory device width, valid for all type of memories. (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static constexpr uint32_t BCR3_FACCEN = 0x40;        // Flash access enable This bit enables NOR Flash memory access operations.
    static constexpr uint32_t BCR3_BURSTEN = 0x100;      // Burst enable bit This bit enables/disables synchronous accesses during read operations. It is valid only for synchronous memories operating in Burst mode:
    static constexpr uint32_t BCR3_WAITPOL = 0x200;      // Wait signal polarity bit This bit defines the polarity of the wait signal from memory used for either in synchronous or asynchronous mode:
    static constexpr uint32_t BCR3_WAITCFG = 0x800;      // Wait timing configuration The NWAIT signal indicates whether the data from the memory are valid or if a wait state must be inserted when accessing the memory in synchronous mode. This configuration bit determines if NWAIT is asserted by the memory one clock cycle before the wait state or during the wait state:
    static constexpr uint32_t BCR3_WREN = 0x1000;        // Write enable bit This bit indicates whether write operations are enabled/disabled in the bank by the FMC:
    static constexpr uint32_t BCR3_WAITEN = 0x2000;      // Wait enable bit This bit enables/disables wait-state insertion via the NWAIT signal when accessing the memory in synchronous mode.
    static constexpr uint32_t BCR3_EXTMOD = 0x4000;      // Extended mode enable. This bit enables the FMC to program the write timings for asynchronous accesses inside the FMC_BWTR register, thus resulting in different timings for read and write operations. Note: When the extended mode is disabled, the FMC can operate in Mode1 or Mode2 as follows: ** Mode 1 is the default mode when the SRAM/PSRAM memory type is selected (MTYP =0x0 or 0x01) ** Mode 2 is the default mode when the NOR memory type is selected (MTYP = 0x10).
    static constexpr uint32_t BCR3_ASYNCWAIT = 0x8000;   // Wait signal during asynchronous transfers This bit enables/disables the FMC to use the wait signal even during an asynchronous protocol.
    template<uint32_t X>
    static constexpr uint32_t BCR3_CPSIZE =              // CRAM Page Size These are used for Cellular RAM 1.5 which does not allow burst access to cross the address boundaries between pages. When these bits are configured, the FMC controller splits automatically the burst access when the memory page size is reached (refer to memory datasheet for page size). Other configuration: reserved. (3 bits)
        bit_field_t<16, 0x7>::value<X>();
    static constexpr uint32_t BCR3_CBURSTRW = 0x80000;   // Write burst enable For PSRAM (CRAM) operating in Burst mode, the bit enables synchronous accesses during write operations. The enable bit for synchronous read accesses is the BURSTEN bit in the FMC_BCRx register.
    static constexpr uint32_t BCR3_CCLKEN = 0x100000;    // Continuous Clock Enable This bit enables the FMC_CLK clock output to external memory devices. Note: The CCLKEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. Bank 1 must be configured in synchronous mode to generate the FMC_CLK continuous clock. If CCLKEN bit is set, the FMC_CLK clock ratio is specified by CLKDIV value in the FMC_BTR1 register. CLKDIV in FMC_BWTR1 is dont care. If the synchronous mode is used and CCLKEN bit is set, the synchronous memories connected to other banks than Bank 1 are clocked by the same clock (the CLKDIV value in the FMC_BTR2..4 and FMC_BWTR2..4 registers for other banks has no effect.)
    static constexpr uint32_t BCR3_WFDIS = 0x200000;     // Write FIFO Disable This bit disables the Write FIFO used by the FMC controller. Note: The WFDIS bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
    template<uint32_t X>
    static constexpr uint32_t BCR3_BMAP =                // FMC bank mapping These bits allows different to remap SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.Refer to Table 10 for Note: The BMAP bits of the FMC_BCR2..4 registers are dont care. It is only enabled through the FMC_BCR1 register. (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    static constexpr uint32_t BCR3_FMCEN = 0x80000000;   // FMC controller Enable This bit enables/disables the FMC controller. Note: The FMCEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
    static const uint32_t BCR3_RESET_VALUE = 0x30d2;

    template<uint32_t X>
    static constexpr uint32_t BTR3_ADDSET =              // Address setup phase duration These bits are written by software to define the duration of the address setup phase (refer to Figure81 to Figure93), used in SRAMs, ROMs and asynchronous NOR Flash: For each access mode address setup phase duration, please refer to the respective figure (refer to Figure81 to Figure93). Note: In synchronous accesses, this value is dont care. In Muxed mode or Mode D, the minimum value for ADDSET is 1. (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR3_ADDHLD =              // Address-hold phase duration These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in mode D or multiplexed accesses: For each access mode address-hold phase duration, please refer to the respective figure (Figure81 to Figure93). Note: In synchronous accesses, this value is not used, the address hold phase is always 1 memory clock period duration. (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR3_DATAST =              // Data-phase duration These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous accesses: For each memory type and access mode data-phase duration, please refer to the respective figure (Figure81 to Figure93). Example: Mode1, write access, DATAST=1: Data-phase duration= DATAST+1 = 2 KCK_FMC clock cycles. Note: In synchronous accesses, this value is dont care. (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR3_BUSTURN =             // Bus turnaround phase duration These bits are written by software to add a delay at the end of a write-to-read or read-to write transaction. The programmed bus turnaround delay is inserted between an asynchronous read (in muxed or mode D) or write transaction and any other asynchronous /synchronous read/write from/to a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except in muxed mode and mode D. There is a bus turnaround delay of 1 FMC clock cycle between: Two consecutive asynchronous read transfers to the same static memory bank except for modes muxed and D. An asynchronous read to an asynchronous or synchronous write to any static bank or dynamic bank except in modes muxed and D mode. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank. A synchronous write (burst or single) access and an asynchronous write or read transfer to or from static memory bank (the bank can be the same or a different one in case of a read operation. Two consecutive synchronous read operations (in Burst or Single mode) followed by any synchronous/asynchronous read or write from/to another static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write access (in Burst or Single mode) and a synchronous read from the same or a different bank. The bus turnaround delay allows to match the minimum time between consecutive transactions (tEHEL from NEx high to NEx low) and the maximum time required by the memory to free the data bus after a read access (tEHQZ): (BUSTRUN + 1) KCK_FMC period &amp;#8805; tEHELmin and (BUSTRUN + 2)KCK_FMC period &amp;#8805; tEHQZmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period &amp;#8805; max (tEHELmin, tEHQZmax) if EXTMOD =1. ... (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR3_CLKDIV =              // Clock divide ratio (for FMC_CLK signal) These bits define the period of FMC_CLK clock output signal, expressed in number of KCK_FMC cycles: In asynchronous NOR Flash, SRAM or PSRAM accesses, this value is dont care. Note: Refer to Section20.6.5: Synchronous transactions for FMC_CLK divider ratio formula) (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR3_DATLAT =              // Data latency for synchronous memory For synchronous access with read write burst mode enabled these bits define the number of memory clock cycles (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR3_ACCMOD =              // Access mode These bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    static const uint32_t BTR3_RESET_VALUE = 0xfffffff;

    static constexpr uint32_t BCR4_MBKEN = 0x1;          // Memory bank enable bit This bit enables the memory bank. After reset Bank1 is enabled, all others are disabled. Accessing a disabled bank causes an ERROR on AXI bus.
    static constexpr uint32_t BCR4_MUXEN = 0x2;          // Address/data multiplexing enable bit When this bit is set, the address and data values are multiplexed on the data bus, valid only with NOR and PSRAM memories:
    template<uint32_t X>
    static constexpr uint32_t BCR4_MTYP =                // Memory type These bits define the type of external memory attached to the corresponding memory bank: (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BCR4_MWID =                // Memory data bus width Defines the external memory device width, valid for all type of memories. (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static constexpr uint32_t BCR4_FACCEN = 0x40;        // Flash access enable This bit enables NOR Flash memory access operations.
    static constexpr uint32_t BCR4_BURSTEN = 0x100;      // Burst enable bit This bit enables/disables synchronous accesses during read operations. It is valid only for synchronous memories operating in Burst mode:
    static constexpr uint32_t BCR4_WAITPOL = 0x200;      // Wait signal polarity bit This bit defines the polarity of the wait signal from memory used for either in synchronous or asynchronous mode:
    static constexpr uint32_t BCR4_WAITCFG = 0x800;      // Wait timing configuration The NWAIT signal indicates whether the data from the memory are valid or if a wait state must be inserted when accessing the memory in synchronous mode. This configuration bit determines if NWAIT is asserted by the memory one clock cycle before the wait state or during the wait state:
    static constexpr uint32_t BCR4_WREN = 0x1000;        // Write enable bit This bit indicates whether write operations are enabled/disabled in the bank by the FMC:
    static constexpr uint32_t BCR4_WAITEN = 0x2000;      // Wait enable bit This bit enables/disables wait-state insertion via the NWAIT signal when accessing the memory in synchronous mode.
    static constexpr uint32_t BCR4_EXTMOD = 0x4000;      // Extended mode enable. This bit enables the FMC to program the write timings for asynchronous accesses inside the FMC_BWTR register, thus resulting in different timings for read and write operations. Note: When the extended mode is disabled, the FMC can operate in Mode1 or Mode2 as follows: ** Mode 1 is the default mode when the SRAM/PSRAM memory type is selected (MTYP =0x0 or 0x01) ** Mode 2 is the default mode when the NOR memory type is selected (MTYP = 0x10).
    static constexpr uint32_t BCR4_ASYNCWAIT = 0x8000;   // Wait signal during asynchronous transfers This bit enables/disables the FMC to use the wait signal even during an asynchronous protocol.
    template<uint32_t X>
    static constexpr uint32_t BCR4_CPSIZE =              // CRAM Page Size These are used for Cellular RAM 1.5 which does not allow burst access to cross the address boundaries between pages. When these bits are configured, the FMC controller splits automatically the burst access when the memory page size is reached (refer to memory datasheet for page size). Other configuration: reserved. (3 bits)
        bit_field_t<16, 0x7>::value<X>();
    static constexpr uint32_t BCR4_CBURSTRW = 0x80000;   // Write burst enable For PSRAM (CRAM) operating in Burst mode, the bit enables synchronous accesses during write operations. The enable bit for synchronous read accesses is the BURSTEN bit in the FMC_BCRx register.
    static constexpr uint32_t BCR4_CCLKEN = 0x100000;    // Continuous Clock Enable This bit enables the FMC_CLK clock output to external memory devices. Note: The CCLKEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. Bank 1 must be configured in synchronous mode to generate the FMC_CLK continuous clock. If CCLKEN bit is set, the FMC_CLK clock ratio is specified by CLKDIV value in the FMC_BTR1 register. CLKDIV in FMC_BWTR1 is dont care. If the synchronous mode is used and CCLKEN bit is set, the synchronous memories connected to other banks than Bank 1 are clocked by the same clock (the CLKDIV value in the FMC_BTR2..4 and FMC_BWTR2..4 registers for other banks has no effect.)
    static constexpr uint32_t BCR4_WFDIS = 0x200000;     // Write FIFO Disable This bit disables the Write FIFO used by the FMC controller. Note: The WFDIS bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
    template<uint32_t X>
    static constexpr uint32_t BCR4_BMAP =                // FMC bank mapping These bits allows different to remap SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.Refer to Table 10 for Note: The BMAP bits of the FMC_BCR2..4 registers are dont care. It is only enabled through the FMC_BCR1 register. (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    static constexpr uint32_t BCR4_FMCEN = 0x80000000;   // FMC controller Enable This bit enables/disables the FMC controller. Note: The FMCEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
    static const uint32_t BCR4_RESET_VALUE = 0x30d2;

    template<uint32_t X>
    static constexpr uint32_t BTR4_ADDSET =              // Address setup phase duration These bits are written by software to define the duration of the address setup phase (refer to Figure81 to Figure93), used in SRAMs, ROMs and asynchronous NOR Flash: For each access mode address setup phase duration, please refer to the respective figure (refer to Figure81 to Figure93). Note: In synchronous accesses, this value is dont care. In Muxed mode or Mode D, the minimum value for ADDSET is 1. (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR4_ADDHLD =              // Address-hold phase duration These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in mode D or multiplexed accesses: For each access mode address-hold phase duration, please refer to the respective figure (Figure81 to Figure93). Note: In synchronous accesses, this value is not used, the address hold phase is always 1 memory clock period duration. (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR4_DATAST =              // Data-phase duration These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous accesses: For each memory type and access mode data-phase duration, please refer to the respective figure (Figure81 to Figure93). Example: Mode1, write access, DATAST=1: Data-phase duration= DATAST+1 = 2 KCK_FMC clock cycles. Note: In synchronous accesses, this value is dont care. (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR4_BUSTURN =             // Bus turnaround phase duration These bits are written by software to add a delay at the end of a write-to-read or read-to write transaction. The programmed bus turnaround delay is inserted between an asynchronous read (in muxed or mode D) or write transaction and any other asynchronous /synchronous read/write from/to a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except in muxed mode and mode D. There is a bus turnaround delay of 1 FMC clock cycle between: Two consecutive asynchronous read transfers to the same static memory bank except for modes muxed and D. An asynchronous read to an asynchronous or synchronous write to any static bank or dynamic bank except in modes muxed and D mode. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank. A synchronous write (burst or single) access and an asynchronous write or read transfer to or from static memory bank (the bank can be the same or a different one in case of a read operation. Two consecutive synchronous read operations (in Burst or Single mode) followed by any synchronous/asynchronous read or write from/to another static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write access (in Burst or Single mode) and a synchronous read from the same or a different bank. The bus turnaround delay allows to match the minimum time between consecutive transactions (tEHEL from NEx high to NEx low) and the maximum time required by the memory to free the data bus after a read access (tEHQZ): (BUSTRUN + 1) KCK_FMC period &amp;#8805; tEHELmin and (BUSTRUN + 2)KCK_FMC period &amp;#8805; tEHQZmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period &amp;#8805; max (tEHELmin, tEHQZmax) if EXTMOD =1. ... (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR4_CLKDIV =              // Clock divide ratio (for FMC_CLK signal) These bits define the period of FMC_CLK clock output signal, expressed in number of KCK_FMC cycles: In asynchronous NOR Flash, SRAM or PSRAM accesses, this value is dont care. Note: Refer to Section20.6.5: Synchronous transactions for FMC_CLK divider ratio formula) (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR4_DATLAT =              // Data latency for synchronous memory For synchronous access with read write burst mode enabled these bits define the number of memory clock cycles (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR4_ACCMOD =              // Access mode These bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    static const uint32_t BTR4_RESET_VALUE = 0xfffffff;

    static constexpr uint32_t PCR_PWAITEN = 0x2;        // Wait feature enable bit. This bit enables the Wait feature for the NAND Flash memory bank:
    static constexpr uint32_t PCR_PBKEN = 0x4;          // NAND Flash memory bank enable bit. This bit enables the memory bank. Accessing a disabled memory bank causes an ERROR on AXI bus
    template<uint32_t X>
    static constexpr uint32_t PCR_PWID =                // Data bus width. These bits define the external memory device width. (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static constexpr uint32_t PCR_ECCEN = 0x40;         // ECC computation logic enable bit
    template<uint32_t X>
    static constexpr uint32_t PCR_TCLR =                // CLE to RE delay. These bits set time from CLE low to RE low in number of KCK_FMC clock cycles. The time is give by the following formula: t_clr = (TCLR + SET + 2) TKCK_FMC where TKCK_FMC is the KCK_FMC clock period Note: Set is MEMSET or ATTSET according to the addressed space. (4 bits)
        bit_field_t<9, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PCR_TAR =                 // ALE to RE delay. These bits set time from ALE low to RE low in number of KCK_FMC clock cycles. Time is: t_ar = (TAR + SET + 2) TKCK_FMC where TKCK_FMC is the FMC clock period Note: Set is MEMSET or ATTSET according to the addressed space. (4 bits)
        bit_field_t<13, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PCR_ECCPS =               // ECC page size. These bits define the page size for the extended ECC: (3 bits)
        bit_field_t<17, 0x7>::value<X>();
    static const uint32_t PCR_RESET_VALUE = 0x18;

    static constexpr uint32_t SR_IRS = 0x1;            // Interrupt rising edge status The flag is set by hardware and reset by software. Note: If this bit is written by software to 1 it will be set., Read-write
    static constexpr uint32_t SR_ILS = 0x2;            // Interrupt high-level status The flag is set by hardware and reset by software., Read-write
    static constexpr uint32_t SR_IFS = 0x4;            // Interrupt falling edge status The flag is set by hardware and reset by software. Note: If this bit is written by software to 1 it will be set., Read-write
    static constexpr uint32_t SR_IREN = 0x8;           // Interrupt rising edge detection enable bit, Read-write
    static constexpr uint32_t SR_ILEN = 0x10;          // Interrupt high-level detection enable bit, Read-write
    static constexpr uint32_t SR_IFEN = 0x20;          // Interrupt falling edge detection enable bit, Read-write
    static constexpr uint32_t SR_FEMPT = 0x40;         // FIFO empty. Read-only bit that provides the status of the FIFO, Read-only
    static const uint32_t SR_RESET_VALUE = 0x40;

    template<uint32_t X>
    static constexpr uint32_t PMEM_MEMSET =              // Common memory x setup time These bits define the number of KCK_FMC (+1) clock cycles to set up the address before the command assertion (NWE, NOE), for NAND Flash read or write access to common memory space: (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PMEM_MEMWAIT =             // Common memory wait time These bits define the minimum number of KCK_FMC (+1) clock cycles to assert the command (NWE, NOE), for NAND Flash read or write access to common memory space. The duration of command assertion is extended if the wait signal (NWAIT) is active (low) at the end of the programmed value of KCK_FMC: (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PMEM_MEMHOLD =             // Common memory hold time These bits define the number of KCK_FMC clock cycles for write accesses and KCK_FMC+1 clock cycles for read accesses during which the address is held (and data for write accesses) after the command is de-asserted (NWE, NOE), for NAND Flash read or write access to common memory space: (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PMEM_MEMHIZ =              // Common memory x data bus Hi-Z time These bits define the number of KCK_FMC clock cycles during which the data bus is kept Hi-Z after the start of a NAND Flash write access to common memory space. This is only valid for write transactions: (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t PMEM_RESET_VALUE = 0xfcfcfcfc;

    template<uint32_t X>
    static constexpr uint32_t PATT_ATTSET =              // Attribute memory setup time These bits define the number of KCK_FMC (+1) clock cycles to set up address before the command assertion (NWE, NOE), for NAND Flash read or write access to attribute memory space: (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PATT_ATTWAIT =             // Attribute memory wait time These bits define the minimum number of x KCK_FMC (+1) clock cycles to assert the command (NWE, NOE), for NAND Flash read or write access to attribute memory space. The duration for command assertion is extended if the wait signal (NWAIT) is active (low) at the end of the programmed value of KCK_FMC: (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PATT_ATTHOLD =             // Attribute memory hold time These bits define the number of KCK_FMC clock cycles during which the address is held (and data for write access) after the command de-assertion (NWE, NOE), for NAND Flash read or write access to attribute memory space: (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PATT_ATTHIZ =              // Attribute memory data bus Hi-Z time These bits define the number of KCK_FMC clock cycles during which the data bus is kept in Hi-Z after the start of a NAND Flash write access to attribute memory space on socket. Only valid for writ transaction: (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t PATT_RESET_VALUE = 0xfcfcfcfc;


    static const uint32_t ECCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BWTR1_ADDSET =              // Address setup phase duration. These bits are written by software to define the duration of the address setup phase in KCK_FMC cycles (refer to Figure81 to Figure93), used in asynchronous accesses: ... Note: In synchronous accesses, this value is not used, the address setup phase is always 1 Flash clock period duration. In muxed mode, the minimum ADDSET value is 1. (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BWTR1_ADDHLD =              // Address-hold phase duration. These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in asynchronous multiplexed accesses: ... Note: In synchronous NOR Flash accesses, this value is not used, the address hold phase is always 1 Flash clock period duration. (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BWTR1_DATAST =              // Data-phase duration. These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous SRAM, PSRAM and NOR Flash memory accesses: (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BWTR1_BUSTURN =             // Bus turnaround phase duration These bits are written by software to add a delay at the end of a write transaction to match the minimum time between consecutive transactions (tEHEL from ENx high to ENx low): (BUSTRUN + 1) KCK_FMC period &amp;#8805; tEHELmin. The programmed bus turnaround delay is inserted between a an asynchronous write transfer and any other asynchronous /synchronous read or write transfer to or from a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except for muxed mode and mode D. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank A synchronous write transfer ((in Burst or Single mode) and an asynchronous write or read transfer to or from static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write transfer (in Burst or Single mode) and a synchronous read from the same or a different bank. ... (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BWTR1_ACCMOD =              // Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.These bits are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    static const uint32_t BWTR1_RESET_VALUE = 0xfffffff;

    template<uint32_t X>
    static constexpr uint32_t BWTR2_ADDSET =              // Address setup phase duration. These bits are written by software to define the duration of the address setup phase in KCK_FMC cycles (refer to Figure81 to Figure93), used in asynchronous accesses: ... Note: In synchronous accesses, this value is not used, the address setup phase is always 1 Flash clock period duration. In muxed mode, the minimum ADDSET value is 1. (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BWTR2_ADDHLD =              // Address-hold phase duration. These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in asynchronous multiplexed accesses: ... Note: In synchronous NOR Flash accesses, this value is not used, the address hold phase is always 1 Flash clock period duration. (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BWTR2_DATAST =              // Data-phase duration. These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous SRAM, PSRAM and NOR Flash memory accesses: (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BWTR2_BUSTURN =             // Bus turnaround phase duration These bits are written by software to add a delay at the end of a write transaction to match the minimum time between consecutive transactions (tEHEL from ENx high to ENx low): (BUSTRUN + 1) KCK_FMC period &amp;#8805; tEHELmin. The programmed bus turnaround delay is inserted between a an asynchronous write transfer and any other asynchronous /synchronous read or write transfer to or from a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except for muxed mode and mode D. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank A synchronous write transfer ((in Burst or Single mode) and an asynchronous write or read transfer to or from static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write transfer (in Burst or Single mode) and a synchronous read from the same or a different bank. ... (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BWTR2_ACCMOD =              // Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.These bits are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    static const uint32_t BWTR2_RESET_VALUE = 0xfffffff;

    template<uint32_t X>
    static constexpr uint32_t BWTR3_ADDSET =              // Address setup phase duration. These bits are written by software to define the duration of the address setup phase in KCK_FMC cycles (refer to Figure81 to Figure93), used in asynchronous accesses: ... Note: In synchronous accesses, this value is not used, the address setup phase is always 1 Flash clock period duration. In muxed mode, the minimum ADDSET value is 1. (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BWTR3_ADDHLD =              // Address-hold phase duration. These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in asynchronous multiplexed accesses: ... Note: In synchronous NOR Flash accesses, this value is not used, the address hold phase is always 1 Flash clock period duration. (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BWTR3_DATAST =              // Data-phase duration. These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous SRAM, PSRAM and NOR Flash memory accesses: (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BWTR3_BUSTURN =             // Bus turnaround phase duration These bits are written by software to add a delay at the end of a write transaction to match the minimum time between consecutive transactions (tEHEL from ENx high to ENx low): (BUSTRUN + 1) KCK_FMC period &amp;#8805; tEHELmin. The programmed bus turnaround delay is inserted between a an asynchronous write transfer and any other asynchronous /synchronous read or write transfer to or from a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except for muxed mode and mode D. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank A synchronous write transfer ((in Burst or Single mode) and an asynchronous write or read transfer to or from static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write transfer (in Burst or Single mode) and a synchronous read from the same or a different bank. ... (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BWTR3_ACCMOD =              // Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.These bits are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    static const uint32_t BWTR3_RESET_VALUE = 0xfffffff;

    template<uint32_t X>
    static constexpr uint32_t BWTR4_ADDSET =              // Address setup phase duration. These bits are written by software to define the duration of the address setup phase in KCK_FMC cycles (refer to Figure81 to Figure93), used in asynchronous accesses: ... Note: In synchronous accesses, this value is not used, the address setup phase is always 1 Flash clock period duration. In muxed mode, the minimum ADDSET value is 1. (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BWTR4_ADDHLD =              // Address-hold phase duration. These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in asynchronous multiplexed accesses: ... Note: In synchronous NOR Flash accesses, this value is not used, the address hold phase is always 1 Flash clock period duration. (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BWTR4_DATAST =              // Data-phase duration. These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous SRAM, PSRAM and NOR Flash memory accesses: (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BWTR4_BUSTURN =             // Bus turnaround phase duration These bits are written by software to add a delay at the end of a write transaction to match the minimum time between consecutive transactions (tEHEL from ENx high to ENx low): (BUSTRUN + 1) KCK_FMC period &amp;#8805; tEHELmin. The programmed bus turnaround delay is inserted between a an asynchronous write transfer and any other asynchronous /synchronous read or write transfer to or from a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except for muxed mode and mode D. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank A synchronous write transfer ((in Burst or Single mode) and an asynchronous write or read transfer to or from static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write transfer (in Burst or Single mode) and a synchronous read from the same or a different bank. ... (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BWTR4_ACCMOD =              // Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.These bits are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    static const uint32_t BWTR4_RESET_VALUE = 0xfffffff;

    template<uint32_t X>
    static constexpr uint32_t SDCR1_NC =                  // Number of column address bits These bits define the number of bits of a column address. (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SDCR1_NR =                  // Number of row address bits These bits define the number of bits of a row address. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SDCR1_MWID =                // Memory data bus width. These bits define the memory device width. (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static constexpr uint32_t SDCR1_NB = 0x40;            // Number of internal banks This bit sets the number of internal banks.
    template<uint32_t X>
    static constexpr uint32_t SDCR1_CAS =                 // CAS Latency This bits sets the SDRAM CAS latency in number of memory clock cycles (2 bits)
        bit_field_t<7, 0x3>::value<X>();
    static constexpr uint32_t SDCR1_WP = 0x200;           // Write protection This bit enables write mode access to the SDRAM bank.
    template<uint32_t X>
    static constexpr uint32_t SDCR1_SDCLK =               // SDRAM clock configuration These bits define the SDRAM clock period for both SDRAM banks and allow disabling the clock before changing the frequency. In this case the SDRAM must be re-initialized. Note: The corresponding bits in the FMC_SDCR2 register is read only. (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    static constexpr uint32_t SDCR1_RBURST = 0x1000;      // Burst read This bit enables burst read mode. The SDRAM controller anticipates the next read commands during the CAS latency and stores data in the Read FIFO. Note: The corresponding bit in the FMC_SDCR2 register is read only.
    template<uint32_t X>
    static constexpr uint32_t SDCR1_RPIPE =               // Read pipe These bits define the delay, in KCK_FMC clock cycles, for reading data after CAS latency. Note: The corresponding bits in the FMC_SDCR2 register is read only. (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    static const uint32_t SDCR1_RESET_VALUE = 0x2d0;

    template<uint32_t X>
    static constexpr uint32_t SDCR2_NC =                  // Number of column address bits These bits define the number of bits of a column address. (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SDCR2_NR =                  // Number of row address bits These bits define the number of bits of a row address. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SDCR2_MWID =                // Memory data bus width. These bits define the memory device width. (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static constexpr uint32_t SDCR2_NB = 0x40;            // Number of internal banks This bit sets the number of internal banks.
    template<uint32_t X>
    static constexpr uint32_t SDCR2_CAS =                 // CAS Latency This bits sets the SDRAM CAS latency in number of memory clock cycles (2 bits)
        bit_field_t<7, 0x3>::value<X>();
    static constexpr uint32_t SDCR2_WP = 0x200;           // Write protection This bit enables write mode access to the SDRAM bank.
    template<uint32_t X>
    static constexpr uint32_t SDCR2_SDCLK =               // SDRAM clock configuration These bits define the SDRAM clock period for both SDRAM banks and allow disabling the clock before changing the frequency. In this case the SDRAM must be re-initialized. Note: The corresponding bits in the FMC_SDCR2 register is read only. (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    static constexpr uint32_t SDCR2_RBURST = 0x1000;      // Burst read This bit enables burst read mode. The SDRAM controller anticipates the next read commands during the CAS latency and stores data in the Read FIFO. Note: The corresponding bit in the FMC_SDCR2 register is read only.
    template<uint32_t X>
    static constexpr uint32_t SDCR2_RPIPE =               // Read pipe These bits define the delay, in KCK_FMC clock cycles, for reading data after CAS latency. Note: The corresponding bits in the FMC_SDCR2 register is read only. (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    static const uint32_t SDCR2_RESET_VALUE = 0x2d0;

    template<uint32_t X>
    static constexpr uint32_t SDTR1_TMRD =                // Load Mode Register to Active These bits define the delay between a Load Mode Register command and an Active or Refresh command in number of memory clock cycles. .... (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SDTR1_TXSR =                // Exit Self-refresh delay These bits define the delay from releasing the Self-refresh command to issuing the Activate command in number of memory clock cycles. .... Note: If two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2 must be programmed with the same TXSR timing corresponding to the slowest SDRAM device. (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SDTR1_TRAS =                // Self refresh time These bits define the minimum Self-refresh period in number of memory clock cycles. .... (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SDTR1_TRC =                 // Row cycle delay These bits define the delay between the Refresh command and the Activate command, as well as the delay between two consecutive Refresh commands. It is expressed in number of memory clock cycles. The TRC timing is only configured in the FMC_SDTR1 register. If two SDRAM devices are used, the TRC must be programmed with the timings of the slowest device. .... Note: TRC must match the TRC and TRFC (Auto Refresh period) timings defined in the SDRAM device datasheet. Note: The corresponding bits in the FMC_SDTR2 register are dont care. (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SDTR1_TWR =                 // Recovery delay These bits define the delay between a Write and a Precharge command in number of memory clock cycles. .... Note: TWR must be programmed to match the write recovery time (tWR) defined in the SDRAM datasheet, and to guarantee that: TWR &amp;#8805; TRAS - TRCD and TWR &amp;#8805;TRC - TRCD - TRP Example: TRAS= 4 cycles, TRCD= 2 cycles. So, TWR &amp;gt;= 2 cycles. TWR must be programmed to 0x1. If two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2 must be programmed with the same TWR timing corresponding to the slowest SDRAM device. (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SDTR1_TRP =                 // Row precharge delay These bits define the delay between a Precharge command and another command in number of memory clock cycles. The TRP timing is only configured in the FMC_SDTR1 register. If two SDRAM devices are used, the TRP must be programmed with the timing of the slowest device. .... Note: The corresponding bits in the FMC_SDTR2 register are dont care. (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SDTR1_TRCD =                // Row to column delay These bits define the delay between the Activate command and a Read/Write command in number of memory clock cycles. .... (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    static const uint32_t SDTR1_RESET_VALUE = 0xfffffff;

    template<uint32_t X>
    static constexpr uint32_t SDTR2_TMRD =                // Load Mode Register to Active These bits define the delay between a Load Mode Register command and an Active or Refresh command in number of memory clock cycles. .... (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SDTR2_TXSR =                // Exit Self-refresh delay These bits define the delay from releasing the Self-refresh command to issuing the Activate command in number of memory clock cycles. .... Note: If two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2 must be programmed with the same TXSR timing corresponding to the slowest SDRAM device. (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SDTR2_TRAS =                // Self refresh time These bits define the minimum Self-refresh period in number of memory clock cycles. .... (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SDTR2_TRC =                 // Row cycle delay These bits define the delay between the Refresh command and the Activate command, as well as the delay between two consecutive Refresh commands. It is expressed in number of memory clock cycles. The TRC timing is only configured in the FMC_SDTR1 register. If two SDRAM devices are used, the TRC must be programmed with the timings of the slowest device. .... Note: TRC must match the TRC and TRFC (Auto Refresh period) timings defined in the SDRAM device datasheet. Note: The corresponding bits in the FMC_SDTR2 register are dont care. (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SDTR2_TWR =                 // Recovery delay These bits define the delay between a Write and a Precharge command in number of memory clock cycles. .... Note: TWR must be programmed to match the write recovery time (tWR) defined in the SDRAM datasheet, and to guarantee that: TWR &amp;#8805; TRAS - TRCD and TWR &amp;#8805;TRC - TRCD - TRP Example: TRAS= 4 cycles, TRCD= 2 cycles. So, TWR &amp;gt;= 2 cycles. TWR must be programmed to 0x1. If two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2 must be programmed with the same TWR timing corresponding to the slowest SDRAM device. (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SDTR2_TRP =                 // Row precharge delay These bits define the delay between a Precharge command and another command in number of memory clock cycles. The TRP timing is only configured in the FMC_SDTR1 register. If two SDRAM devices are used, the TRP must be programmed with the timing of the slowest device. .... Note: The corresponding bits in the FMC_SDTR2 register are dont care. (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SDTR2_TRCD =                // Row to column delay These bits define the delay between the Activate command and a Read/Write command in number of memory clock cycles. .... (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    static const uint32_t SDTR2_RESET_VALUE = 0xfffffff;

    template<uint32_t X>
    static constexpr uint32_t SDCMR_MODE =                // Command mode These bits define the command issued to the SDRAM device. Note: When a command is issued, at least one Command Target Bank bit ( CTB1 or CTB2) must be set otherwise the command will be ignored. Note: If two SDRAM banks are used, the Auto-refresh and PALL command must be issued simultaneously to the two devices with CTB1 and CTB2 bits set otherwise the command will be ignored. Note: If only one SDRAM bank is used and a command is issued with its associated CTB bit set, the other CTB bit of the unused bank must be kept to 0. (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static constexpr uint32_t SDCMR_CTB2 = 0x8;           // Command Target Bank 2 This bit indicates whether the command will be issued to SDRAM Bank 2 or not.
    static constexpr uint32_t SDCMR_CTB1 = 0x10;          // Command Target Bank 1 This bit indicates whether the command will be issued to SDRAM Bank 1 or not.
    template<uint32_t X>
    static constexpr uint32_t SDCMR_NRFS =                // Number of Auto-refresh These bits define the number of consecutive Auto-refresh commands issued when MODE = 011. .... (4 bits)
        bit_field_t<5, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SDCMR_MRD =                 // Mode Register definition This 14-bit field defines the SDRAM Mode Register content. The Mode Register is programmed using the Load Mode Register command. The MRD[13:0] bits are also used to program the extended mode register for mobile SDRAM. (14 bits)
        bit_field_t<9, 0x3fff>::value<X>();
    static const uint32_t SDCMR_RESET_VALUE = 0x0;

    static constexpr uint32_t SDRTR_CRE = 0x1;            // Clear Refresh error flag This bit is used to clear the Refresh Error Flag (RE) in the Status Register., Write-only
    template<uint32_t X>
    static constexpr uint32_t SDRTR_COUNT =               // Refresh Timer Count This 13-bit field defines the refresh rate of the SDRAM device. It is expressed in number of memory clock cycles. It must be set at least to 41 SDRAM clock cycles (0x29). Refresh rate = (COUNT + 1) x SDRAM frequency clock COUNT = (SDRAM refresh period / Number of rows) - 20 (13 bits), Read-write
        bit_field_t<1, 0x1fff>::value<X>();
    static constexpr uint32_t SDRTR_REIE = 0x4000;        // RES Interrupt Enable, Read-write
    static const uint32_t SDRTR_RESET_VALUE = 0x0;

    static constexpr uint32_t SDSR_RE = 0x1;             // Refresh error flag An interrupt is generated if REIE = 1 and RE = 1
    template<uint32_t X>
    static constexpr uint32_t SDSR_MODES1 =              // Status Mode for Bank 1 These bits define the Status Mode of SDRAM Bank 1. (2 bits)
        bit_field_t<1, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SDSR_MODES2 =              // Status Mode for Bank 2 These bits define the Status Mode of SDRAM Bank 2. (2 bits)
        bit_field_t<3, 0x3>::value<X>();
    static const uint32_t SDSR_RESET_VALUE = 0x0;

    static constexpr uint8_t FMC = 48; // FMC global interrupt
};

static fmc_t& FMC = *reinterpret_cast<fmc_t*>(0x52004000);

#define HAVE_PERIPHERAL_FMC


////
//
//    CEC
//
////

struct cec_t
{
    volatile uint32_t    CR;                   // [Read-write] CEC control register
    volatile uint32_t    CFGR;                 // [Read-write] This register is used to configure the HDMI-CEC controller. It is mandatory to write CEC_CFGR only when CECEN=0.
    volatile uint32_t    TXDR;                 // [Write-only] CEC Tx data register
    volatile uint32_t    RXDR;                 // [Read-only] CEC Rx Data Register
    volatile uint32_t    ISR;                  // [Read-write] CEC Interrupt and Status Register
    volatile uint32_t    IER;                  // [Read-write] CEC interrupt enable register

    static constexpr uint32_t CR_CECEN = 0x1;          // CEC Enable The CECEN bit is set and cleared by software. CECEN=1 starts message reception and enables the TXSOM control. CECEN=0 disables the CEC peripheral, clears all bits of CEC_CR register and aborts any on-going reception or transmission.
    static constexpr uint32_t CR_TXSOM = 0x2;          // Tx Start Of Message TXSOM is set by software to command transmission of the first byte of a CEC message. If the CEC message consists of only one byte, TXEOM must be set before of TXSOM. Start-Bit is effectively started on the CEC line after SFT is counted. If TXSOM is set while a message reception is ongoing, transmission will start after the end of reception. TXSOM is cleared by hardware after the last byte of the message is sent with a positive acknowledge (TXEND=1), in case of transmission underrun (TXUDR=1), negative acknowledge (TXACKE=1), and transmission error (TXERR=1). It is also cleared by CECEN=0. It is not cleared and transmission is automatically retried in case of arbitration lost (ARBLST=1). TXSOM can be also used as a status bit informing application whether any transmission request is pending or under execution. The application can abort a transmission request at any time by clearing the CECEN bit. Note: TXSOM must be set when CECEN=1 TXSOM must be set when transmission data is available into TXDR HEADERs first four bits containing own peripheral address are taken from TXDR[7:4], not from CEC_CFGR.OAR which is used only for reception
    static constexpr uint32_t CR_TXEOM = 0x4;          // Tx End Of Message The TXEOM bit is set by software to command transmission of the last byte of a CEC message. TXEOM is cleared by hardware at the same time and under the same conditions as for TXSOM. Note: TXEOM must be set when CECEN=1 TXEOM must be set before writing transmission data to TXDR If TXEOM is set when TXSOM=0, transmitted message will consist of 1 byte (HEADER) only (PING message)
    static const uint32_t CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CFGR_SFT =                 // Signal Free Time SFT bits are set by software. In the SFT=0x0 configuration the number of nominal data bit periods waited before transmission is ruled by hardware according to the transmission history. In all the other configurations the SFT number is determined by software. * 0x0 ** 2.5 Data-Bit periods if CEC is the last bus initiator with unsuccessful transmission (ARBLST=1, TXERR=1, TXUDR=1 or TXACKE= 1) ** 4 Data-Bit periods if CEC is the new bus initiator ** 6 Data-Bit periods if CEC is the last bus initiator with successful transmission (TXEOM=1) * 0x1: 0.5 nominal data bit periods * 0x2: 1.5 nominal data bit periods * 0x3: 2.5 nominal data bit periods * 0x4: 3.5 nominal data bit periods * 0x5: 4.5 nominal data bit periods * 0x6: 5.5 nominal data bit periods * 0x7: 6.5 nominal data bit periods (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static constexpr uint32_t CFGR_RXTOL = 0x8;          // Rx-Tolerance The RXTOL bit is set and cleared by software. ** Start-Bit, +/- 200 s rise, +/- 200 s fall. ** Data-Bit: +/- 200 s rise. +/- 350 s fall. ** Start-Bit: +/- 400 s rise, +/- 400 s fall ** Data-Bit: +/-300 s rise, +/- 500 s fall
    static constexpr uint32_t CFGR_BRESTP = 0x10;        // Rx-Stop on Bit Rising Error The BRESTP bit is set and cleared by software.
    static constexpr uint32_t CFGR_BREGEN = 0x20;        // Generate Error-Bit on Bit Rising Error The BREGEN bit is set and cleared by software. Note: If BRDNOGEN=0, an Error-bit is generated upon BRE detection with BRESTP=1 in broadcast even if BREGEN=0
    static constexpr uint32_t CFGR_LBPEGEN = 0x40;       // Generate Error-Bit on Long Bit Period Error The LBPEGEN bit is set and cleared by software. Note: If BRDNOGEN=0, an Error-bit is generated upon LBPE detection in broadcast even if LBPEGEN=0
    static constexpr uint32_t CFGR_BRDNOGEN = 0x80;      // Avoid Error-Bit Generation in Broadcast The BRDNOGEN bit is set and cleared by software.
    static constexpr uint32_t CFGR_SFTOPT = 0x100;       // SFT Option Bit The SFTOPT bit is set and cleared by software.
    template<uint32_t X>
    static constexpr uint32_t CFGR_OAR =                 // Own addresses configuration The OAR bits are set by software to select which destination logical addresses has to be considered in receive mode. Each bit, when set, enables the CEC logical address identified by the given bit position. At the end of HEADER reception, the received destination address is compared with the enabled addresses. In case of matching address, the incoming message is acknowledged and received. In case of non-matching address, the incoming message is received only in listen mode (LSTN=1), but without acknowledge sent. Broadcast messages are always received. Example: OAR = 0b000 0000 0010 0001 means that CEC acknowledges addresses 0x0 and 0x5. Consequently, each message directed to one of these addresses is received. (15 bits)
        bit_field_t<16, 0x7fff>::value<X>();
    static constexpr uint32_t CFGR_LSTN = 0x80000000;    // Listen mode LSTN bit is set and cleared by software.
    static const uint32_t CFGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TXDR_TXD =                 // Tx Data register. TXD is a write-only register containing the data byte to be transmitted. Note: TXD must be written when TXSTART=1 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t TXDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RXDR_RXD =                 // Rx Data register. RXD is read-only and contains the last data byte which has been received from the CEC line. (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t RXDR_RESET_VALUE = 0x0;

    static constexpr uint32_t ISR_RXBR = 0x1;           // Rx-Byte Received The RXBR bit is set by hardware to inform application that a new byte has been received from the CEC line and stored into the RXD buffer. RXBR is cleared by software write at 1.
    static constexpr uint32_t ISR_RXEND = 0x2;          // End Of Reception RXEND is set by hardware to inform application that the last byte of a CEC message is received from the CEC line and stored into the RXD buffer. RXEND is set at the same time of RXBR. RXEND is cleared by software write at 1.
    static constexpr uint32_t ISR_RXOVR = 0x4;          // Rx-Overrun RXOVR is set by hardware if RXBR is not yet cleared at the time a new byte is received on the CEC line and stored into RXD. RXOVR assertion stops message reception so that no acknowledge is sent. In case of broadcast, a negative acknowledge is sent. RXOVR is cleared by software write at 1.
    static constexpr uint32_t ISR_BRE = 0x8;            // Rx-Bit Rising Error BRE is set by hardware in case a Data-Bit waveform is detected with Bit Rising Error. BRE is set either at the time the misplaced rising edge occurs, or at the end of the maximum BRE tolerance allowed by RXTOL, in case rising edge is still longing. BRE stops message reception if BRESTP=1. BRE generates an Error-Bit on the CEC line if BREGEN=1. BRE is cleared by software write at 1.
    static constexpr uint32_t ISR_SBPE = 0x10;          // Rx-Short Bit Period Error SBPE is set by hardware in case a Data-Bit waveform is detected with Short Bit Period Error. SBPE is set at the time the anticipated falling edge occurs. SBPE generates an Error-Bit on the CEC line. SBPE is cleared by software write at 1.
    static constexpr uint32_t ISR_LBPE = 0x20;          // Rx-Long Bit Period Error LBPE is set by hardware in case a Data-Bit waveform is detected with Long Bit Period Error. LBPE is set at the end of the maximum bit-extension tolerance allowed by RXTOL, in case falling edge is still longing. LBPE always stops reception of the CEC message. LBPE generates an Error-Bit on the CEC line if LBPEGEN=1. In case of broadcast, Error-Bit is generated even in case of LBPEGEN=0. LBPE is cleared by software write at 1.
    static constexpr uint32_t ISR_RXACKE = 0x40;        // Rx-Missing Acknowledge In receive mode, RXACKE is set by hardware to inform application that no acknowledge was seen on the CEC line. RXACKE applies only for broadcast messages and in listen mode also for not directly addressed messages (destination address not enabled in OAR). RXACKE aborts message reception. RXACKE is cleared by software write at 1.
    static constexpr uint32_t ISR_ARBLST = 0x80;        // Arbitration Lost ARBLST is set by hardware to inform application that CEC device is switching to reception due to arbitration lost event following the TXSOM command. ARBLST can be due either to a contending CEC device starting earlier or starting at the same time but with higher HEADER priority. After ARBLST assertion TXSOM bit keeps pending for next transmission attempt. ARBLST is cleared by software write at 1.
    static constexpr uint32_t ISR_TXBR = 0x100;         // Tx-Byte Request TXBR is set by hardware to inform application that the next transmission data has to be written to TXDR. TXBR is set when the 4th bit of currently transmitted byte is sent. Application must write the next byte to TXDR within 6 nominal data-bit periods before transmission underrun error occurs (TXUDR). TXBR is cleared by software write at 1.
    static constexpr uint32_t ISR_TXEND = 0x200;        // End of Transmission TXEND is set by hardware to inform application that the last byte of the CEC message has been successfully transmitted. TXEND clears the TXSOM and TXEOM control bits. TXEND is cleared by software write at 1.
    static constexpr uint32_t ISR_TXUDR = 0x400;        // Tx-Buffer Underrun In transmission mode, TXUDR is set by hardware if application was not in time to load TXDR before of next byte transmission. TXUDR aborts message transmission and clears TXSOM and TXEOM control bits. TXUDR is cleared by software write at 1
    static constexpr uint32_t ISR_TXERR = 0x800;        // Tx-Error In transmission mode, TXERR is set by hardware if the CEC initiator detects low impedance on the CEC line while it is released. TXERR aborts message transmission and clears TXSOM and TXEOM controls. TXERR is cleared by software write at 1.
    static constexpr uint32_t ISR_TXACKE = 0x1000;      // Tx-Missing Acknowledge Error In transmission mode, TXACKE is set by hardware to inform application that no acknowledge was received. In case of broadcast transmission, TXACKE informs application that a negative acknowledge was received. TXACKE aborts message transmission and clears TXSOM and TXEOM controls. TXACKE is cleared by software write at 1.
    static const uint32_t ISR_RESET_VALUE = 0x0;

    static constexpr uint32_t IER_RXBRIE = 0x1;         // Rx-Byte Received Interrupt Enable The RXBRIE bit is set and cleared by software.
    static constexpr uint32_t IER_RXENDIE = 0x2;        // End Of Reception Interrupt Enable The RXENDIE bit is set and cleared by software.
    static constexpr uint32_t IER_RXOVRIE = 0x4;        // Rx-Buffer Overrun Interrupt Enable The RXOVRIE bit is set and cleared by software.
    static constexpr uint32_t IER_BREIE = 0x8;          // Bit Rising Error Interrupt Enable The BREIE bit is set and cleared by software.
    static constexpr uint32_t IER_SBPEIE = 0x10;        // Short Bit Period Error Interrupt Enable The SBPEIE bit is set and cleared by software.
    static constexpr uint32_t IER_LBPEIE = 0x20;        // Long Bit Period Error Interrupt Enable The LBPEIE bit is set and cleared by software.
    static constexpr uint32_t IER_RXACKIE = 0x40;       // Rx-Missing Acknowledge Error Interrupt Enable The RXACKIE bit is set and cleared by software.
    static constexpr uint32_t IER_ARBLSTIE = 0x80;      // Arbitration Lost Interrupt Enable The ARBLSTIE bit is set and cleared by software.
    static constexpr uint32_t IER_TXBRIE = 0x100;       // Tx-Byte Request Interrupt Enable The TXBRIE bit is set and cleared by software.
    static constexpr uint32_t IER_TXENDIE = 0x200;      // Tx-End Of Message Interrupt Enable The TXENDIE bit is set and cleared by software.
    static constexpr uint32_t IER_TXUDRIE = 0x400;      // Tx-Underrun Interrupt Enable The TXUDRIE bit is set and cleared by software.
    static constexpr uint32_t IER_TXERRIE = 0x800;      // Tx-Error Interrupt Enable The TXERRIE bit is set and cleared by software.
    static constexpr uint32_t IER_TXACKIE = 0x1000;     // Tx-Missing Acknowledge Error Interrupt Enable The TXACKEIE bit is set and cleared by software.
    static const uint32_t IER_RESET_VALUE = 0x0;

    static constexpr uint8_t CEC = 94; // HDMI-CEC global interrupt
};

static cec_t& CEC = *reinterpret_cast<cec_t*>(0x40006c00);

#define HAVE_PERIPHERAL_CEC


////
//
//    HSEM
//
////

struct hsem_t
{
    volatile uint32_t    R0;                   // [Read-write] HSEM register HSEM_R0 HSEM_R31
    volatile uint32_t    R1;                   // [Read-write] HSEM register HSEM_R0 HSEM_R31
    volatile uint32_t    R2;                   // [Read-write] HSEM register HSEM_R0 HSEM_R31
    volatile uint32_t    R3;                   // [Read-write] HSEM register HSEM_R0 HSEM_R31
    volatile uint32_t    R4;                   // [Read-write] HSEM register HSEM_R0 HSEM_R31
    volatile uint32_t    R5;                   // [Read-write] HSEM register HSEM_R0 HSEM_R31
    volatile uint32_t    R6;                   // [Read-write] HSEM register HSEM_R0 HSEM_R31
    volatile uint32_t    R7;                   // [Read-write] HSEM register HSEM_R0 HSEM_R31
    volatile uint32_t    R8;                   // [Read-write] HSEM register HSEM_R0 HSEM_R31
    volatile uint32_t    R9;                   // [Read-write] HSEM register HSEM_R0 HSEM_R31
    volatile uint32_t    R10;                  // [Read-write] HSEM register HSEM_R0 HSEM_R31
    volatile uint32_t    R11;                  // [Read-write] HSEM register HSEM_R0 HSEM_R31
    volatile uint32_t    R12;                  // [Read-write] HSEM register HSEM_R0 HSEM_R31
    volatile uint32_t    R13;                  // [Read-write] HSEM register HSEM_R0 HSEM_R31
    volatile uint32_t    R14;                  // [Read-write] HSEM register HSEM_R0 HSEM_R31
    volatile uint32_t    R15;                  // [Read-write] HSEM register HSEM_R0 HSEM_R31
    volatile uint32_t    R16;                  // [Read-write] HSEM register HSEM_R0 HSEM_R31
    volatile uint32_t    R17;                  // [Read-write] HSEM register HSEM_R0 HSEM_R31
    volatile uint32_t    R18;                  // [Read-write] HSEM register HSEM_R0 HSEM_R31
    volatile uint32_t    R19;                  // [Read-write] HSEM register HSEM_R0 HSEM_R31
    volatile uint32_t    R20;                  // [Read-write] HSEM register HSEM_R0 HSEM_R31
    volatile uint32_t    R21;                  // [Read-write] HSEM register HSEM_R0 HSEM_R31
    volatile uint32_t    R22;                  // [Read-write] HSEM register HSEM_R0 HSEM_R31
    volatile uint32_t    R23;                  // [Read-write] HSEM register HSEM_R0 HSEM_R31
    volatile uint32_t    R24;                  // [Read-write] HSEM register HSEM_R0 HSEM_R31
    volatile uint32_t    R25;                  // [Read-write] HSEM register HSEM_R0 HSEM_R31
    volatile uint32_t    R26;                  // [Read-write] HSEM register HSEM_R0 HSEM_R31
    volatile uint32_t    R27;                  // [Read-write] HSEM register HSEM_R0 HSEM_R31
    volatile uint32_t    R28;                  // [Read-write] HSEM register HSEM_R0 HSEM_R31
    volatile uint32_t    R29;                  // [Read-write] HSEM register HSEM_R0 HSEM_R31
    volatile uint32_t    R30;                  // [Read-write] HSEM register HSEM_R0 HSEM_R31
    volatile uint32_t    R31;                  // [Read-write] HSEM register HSEM_R0 HSEM_R31
    volatile uint32_t    RLR0;                 // [Read-only] HSEM Read lock register
    volatile uint32_t    RLR1;                 // [Read-only] HSEM Read lock register
    volatile uint32_t    RLR2;                 // [Read-only] HSEM Read lock register
    volatile uint32_t    RLR3;                 // [Read-only] HSEM Read lock register
    volatile uint32_t    RLR4;                 // [Read-only] HSEM Read lock register
    volatile uint32_t    RLR5;                 // [Read-only] HSEM Read lock register
    volatile uint32_t    RLR6;                 // [Read-only] HSEM Read lock register
    volatile uint32_t    RLR7;                 // [Read-only] HSEM Read lock register
    volatile uint32_t    RLR8;                 // [Read-only] HSEM Read lock register
    volatile uint32_t    RLR9;                 // [Read-only] HSEM Read lock register
    volatile uint32_t    RLR10;                // [Read-only] HSEM Read lock register
    volatile uint32_t    RLR11;                // [Read-only] HSEM Read lock register
    volatile uint32_t    RLR12;                // [Read-only] HSEM Read lock register
    volatile uint32_t    RLR13;                // [Read-only] HSEM Read lock register
    volatile uint32_t    RLR14;                // [Read-only] HSEM Read lock register
    volatile uint32_t    RLR15;                // [Read-only] HSEM Read lock register
    volatile uint32_t    RLR16;                // [Read-only] HSEM Read lock register
    volatile uint32_t    RLR17;                // [Read-only] HSEM Read lock register
    volatile uint32_t    RLR18;                // [Read-only] HSEM Read lock register
    volatile uint32_t    RLR19;                // [Read-only] HSEM Read lock register
    volatile uint32_t    RLR20;                // [Read-only] HSEM Read lock register
    volatile uint32_t    RLR21;                // [Read-only] HSEM Read lock register
    volatile uint32_t    RLR22;                // [Read-only] HSEM Read lock register
    volatile uint32_t    RLR23;                // [Read-only] HSEM Read lock register
    volatile uint32_t    RLR24;                // [Read-only] HSEM Read lock register
    volatile uint32_t    RLR25;                // [Read-only] HSEM Read lock register
    volatile uint32_t    RLR26;                // [Read-only] HSEM Read lock register
    volatile uint32_t    RLR27;                // [Read-only] HSEM Read lock register
    volatile uint32_t    RLR28;                // [Read-only] HSEM Read lock register
    volatile uint32_t    RLR29;                // [Read-only] HSEM Read lock register
    volatile uint32_t    RLR30;                // [Read-only] HSEM Read lock register
    volatile uint32_t    RLR31;                // [Read-only] HSEM Read lock register
    volatile uint32_t    IER;                  // [Read-write] HSEM Interrupt enable register
    volatile uint32_t    ICR;                  // [Read-only] HSEM Interrupt clear register
    volatile uint32_t    ISR;                  // [Read-only] HSEM Interrupt status register
    volatile uint32_t    MISR;                 // [Read-only] HSEM Masked interrupt status register
    reserved_t<12>       _0;
    volatile uint32_t    CR;                   // [Read-write] HSEM Clear register
    volatile uint32_t    KEYR;                 // [Read-write] HSEM Interrupt clear register

    template<uint32_t X>
    static constexpr uint32_t R0_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t R0_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t R0_LOCK = 0x80000000;    // Lock indication
    static const uint32_t R0_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t R1_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t R1_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t R1_LOCK = 0x80000000;    // Lock indication
    static const uint32_t R1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t R2_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t R2_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t R2_LOCK = 0x80000000;    // Lock indication
    static const uint32_t R2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t R3_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t R3_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t R3_LOCK = 0x80000000;    // Lock indication
    static const uint32_t R3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t R4_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t R4_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t R4_LOCK = 0x80000000;    // Lock indication
    static const uint32_t R4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t R5_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t R5_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t R5_LOCK = 0x80000000;    // Lock indication
    static const uint32_t R5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t R6_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t R6_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t R6_LOCK = 0x80000000;    // Lock indication
    static const uint32_t R6_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t R7_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t R7_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t R7_LOCK = 0x80000000;    // Lock indication
    static const uint32_t R7_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t R8_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t R8_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t R8_LOCK = 0x80000000;    // Lock indication
    static const uint32_t R8_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t R9_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t R9_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t R9_LOCK = 0x80000000;    // Lock indication
    static const uint32_t R9_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t R10_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t R10_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t R10_LOCK = 0x80000000;    // Lock indication
    static const uint32_t R10_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t R11_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t R11_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t R11_LOCK = 0x80000000;    // Lock indication
    static const uint32_t R11_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t R12_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t R12_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t R12_LOCK = 0x80000000;    // Lock indication
    static const uint32_t R12_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t R13_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t R13_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t R13_LOCK = 0x80000000;    // Lock indication
    static const uint32_t R13_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t R14_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t R14_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t R14_LOCK = 0x80000000;    // Lock indication
    static const uint32_t R14_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t R15_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t R15_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t R15_LOCK = 0x80000000;    // Lock indication
    static const uint32_t R15_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t R16_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t R16_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t R16_LOCK = 0x80000000;    // Lock indication
    static const uint32_t R16_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t R17_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t R17_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t R17_LOCK = 0x80000000;    // Lock indication
    static const uint32_t R17_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t R18_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t R18_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t R18_LOCK = 0x80000000;    // Lock indication
    static const uint32_t R18_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t R19_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t R19_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t R19_LOCK = 0x80000000;    // Lock indication
    static const uint32_t R19_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t R20_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t R20_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t R20_LOCK = 0x80000000;    // Lock indication
    static const uint32_t R20_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t R21_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t R21_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t R21_LOCK = 0x80000000;    // Lock indication
    static const uint32_t R21_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t R22_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t R22_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t R22_LOCK = 0x80000000;    // Lock indication
    static const uint32_t R22_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t R23_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t R23_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t R23_LOCK = 0x80000000;    // Lock indication
    static const uint32_t R23_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t R24_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t R24_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t R24_LOCK = 0x80000000;    // Lock indication
    static const uint32_t R24_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t R25_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t R25_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t R25_LOCK = 0x80000000;    // Lock indication
    static const uint32_t R25_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t R26_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t R26_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t R26_LOCK = 0x80000000;    // Lock indication
    static const uint32_t R26_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t R27_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t R27_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t R27_LOCK = 0x80000000;    // Lock indication
    static const uint32_t R27_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t R28_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t R28_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t R28_LOCK = 0x80000000;    // Lock indication
    static const uint32_t R28_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t R29_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t R29_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t R29_LOCK = 0x80000000;    // Lock indication
    static const uint32_t R29_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t R30_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t R30_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t R30_LOCK = 0x80000000;    // Lock indication
    static const uint32_t R30_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t R31_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t R31_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t R31_LOCK = 0x80000000;    // Lock indication
    static const uint32_t R31_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RLR0_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RLR0_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t RLR0_LOCK = 0x80000000;    // Lock indication
    static const uint32_t RLR0_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RLR1_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RLR1_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t RLR1_LOCK = 0x80000000;    // Lock indication
    static const uint32_t RLR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RLR2_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RLR2_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t RLR2_LOCK = 0x80000000;    // Lock indication
    static const uint32_t RLR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RLR3_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RLR3_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t RLR3_LOCK = 0x80000000;    // Lock indication
    static const uint32_t RLR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RLR4_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RLR4_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t RLR4_LOCK = 0x80000000;    // Lock indication
    static const uint32_t RLR4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RLR5_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RLR5_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t RLR5_LOCK = 0x80000000;    // Lock indication
    static const uint32_t RLR5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RLR6_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RLR6_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t RLR6_LOCK = 0x80000000;    // Lock indication
    static const uint32_t RLR6_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RLR7_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RLR7_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t RLR7_LOCK = 0x80000000;    // Lock indication
    static const uint32_t RLR7_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RLR8_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RLR8_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t RLR8_LOCK = 0x80000000;    // Lock indication
    static const uint32_t RLR8_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RLR9_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RLR9_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t RLR9_LOCK = 0x80000000;    // Lock indication
    static const uint32_t RLR9_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RLR10_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RLR10_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t RLR10_LOCK = 0x80000000;    // Lock indication
    static const uint32_t RLR10_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RLR11_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RLR11_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t RLR11_LOCK = 0x80000000;    // Lock indication
    static const uint32_t RLR11_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RLR12_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RLR12_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t RLR12_LOCK = 0x80000000;    // Lock indication
    static const uint32_t RLR12_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RLR13_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RLR13_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t RLR13_LOCK = 0x80000000;    // Lock indication
    static const uint32_t RLR13_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RLR14_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RLR14_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t RLR14_LOCK = 0x80000000;    // Lock indication
    static const uint32_t RLR14_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RLR15_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RLR15_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t RLR15_LOCK = 0x80000000;    // Lock indication
    static const uint32_t RLR15_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RLR16_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RLR16_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t RLR16_LOCK = 0x80000000;    // Lock indication
    static const uint32_t RLR16_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RLR17_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RLR17_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t RLR17_LOCK = 0x80000000;    // Lock indication
    static const uint32_t RLR17_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RLR18_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RLR18_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t RLR18_LOCK = 0x80000000;    // Lock indication
    static const uint32_t RLR18_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RLR19_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RLR19_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t RLR19_LOCK = 0x80000000;    // Lock indication
    static const uint32_t RLR19_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RLR20_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RLR20_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t RLR20_LOCK = 0x80000000;    // Lock indication
    static const uint32_t RLR20_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RLR21_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RLR21_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t RLR21_LOCK = 0x80000000;    // Lock indication
    static const uint32_t RLR21_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RLR22_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RLR22_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t RLR22_LOCK = 0x80000000;    // Lock indication
    static const uint32_t RLR22_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RLR23_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RLR23_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t RLR23_LOCK = 0x80000000;    // Lock indication
    static const uint32_t RLR23_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RLR24_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RLR24_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t RLR24_LOCK = 0x80000000;    // Lock indication
    static const uint32_t RLR24_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RLR25_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RLR25_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t RLR25_LOCK = 0x80000000;    // Lock indication
    static const uint32_t RLR25_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RLR26_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RLR26_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t RLR26_LOCK = 0x80000000;    // Lock indication
    static const uint32_t RLR26_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RLR27_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RLR27_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t RLR27_LOCK = 0x80000000;    // Lock indication
    static const uint32_t RLR27_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RLR28_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RLR28_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t RLR28_LOCK = 0x80000000;    // Lock indication
    static const uint32_t RLR28_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RLR29_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RLR29_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t RLR29_LOCK = 0x80000000;    // Lock indication
    static const uint32_t RLR29_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RLR30_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RLR30_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t RLR30_LOCK = 0x80000000;    // Lock indication
    static const uint32_t RLR30_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RLR31_PROCID =              // Semaphore ProcessID (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RLR31_MASTERID =            // Semaphore MasterID (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t RLR31_LOCK = 0x80000000;    // Lock indication
    static const uint32_t RLR31_RESET_VALUE = 0x0;

    static constexpr uint32_t IER_ISEM0 = 0x1;          // Interrupt semaphore n enable bit
    static constexpr uint32_t IER_ISEM1 = 0x2;          // Interrupt semaphore n enable bit
    static constexpr uint32_t IER_ISEM2 = 0x4;          // Interrupt semaphore n enable bit
    static constexpr uint32_t IER_ISEM3 = 0x8;          // Interrupt semaphore n enable bit
    static constexpr uint32_t IER_ISEM4 = 0x10;         // Interrupt semaphore n enable bit
    static constexpr uint32_t IER_ISEM5 = 0x20;         // Interrupt semaphore n enable bit
    static constexpr uint32_t IER_ISEM6 = 0x40;         // Interrupt semaphore n enable bit
    static constexpr uint32_t IER_ISEM7 = 0x80;         // Interrupt semaphore n enable bit
    static constexpr uint32_t IER_ISEM8 = 0x100;        // Interrupt semaphore n enable bit
    static constexpr uint32_t IER_ISEM9 = 0x200;        // Interrupt semaphore n enable bit
    static constexpr uint32_t IER_ISEM10 = 0x400;       // Interrupt semaphore n enable bit
    static constexpr uint32_t IER_ISEM11 = 0x800;       // Interrupt semaphore n enable bit
    static constexpr uint32_t IER_ISEM12 = 0x1000;      // Interrupt semaphore n enable bit
    static constexpr uint32_t IER_ISEM13 = 0x2000;      // Interrupt semaphore n enable bit
    static constexpr uint32_t IER_ISEM14 = 0x4000;      // Interrupt semaphore n enable bit
    static constexpr uint32_t IER_ISEM15 = 0x8000;      // Interrupt semaphore n enable bit
    static constexpr uint32_t IER_ISEM16 = 0x10000;     // Interrupt semaphore n enable bit
    static constexpr uint32_t IER_ISEM17 = 0x20000;     // Interrupt semaphore n enable bit
    static constexpr uint32_t IER_ISEM18 = 0x40000;     // Interrupt semaphore n enable bit
    static constexpr uint32_t IER_ISEM19 = 0x80000;     // Interrupt semaphore n enable bit
    static constexpr uint32_t IER_ISEM20 = 0x100000;    // Interrupt semaphore n enable bit
    static constexpr uint32_t IER_ISEM21 = 0x200000;    // Interrupt semaphore n enable bit
    static constexpr uint32_t IER_ISEM22 = 0x400000;    // Interrupt semaphore n enable bit
    static constexpr uint32_t IER_ISEM23 = 0x800000;    // Interrupt semaphore n enable bit
    static constexpr uint32_t IER_ISEM24 = 0x1000000;   // Interrupt semaphore n enable bit
    static constexpr uint32_t IER_ISEM25 = 0x2000000;   // Interrupt semaphore n enable bit
    static constexpr uint32_t IER_ISEM26 = 0x4000000;   // Interrupt semaphore n enable bit
    static constexpr uint32_t IER_ISEM27 = 0x8000000;   // Interrupt semaphore n enable bit
    static constexpr uint32_t IER_ISEM28 = 0x10000000;  // Interrupt semaphore n enable bit
    static constexpr uint32_t IER_ISEM29 = 0x20000000;  // Interrupt semaphore n enable bit
    static constexpr uint32_t IER_ISEM30 = 0x40000000;  // Interrupt semaphore n enable bit
    static constexpr uint32_t IER_ISEM31 = 0x80000000;  // Interrupt(N) semaphore n enable bit.
    static const uint32_t IER_RESET_VALUE = 0x0;

    static constexpr uint32_t ICR_ISEM0 = 0x1;          // Interrupt(N) semaphore n clear bit
    static constexpr uint32_t ICR_ISEM1 = 0x2;          // Interrupt(N) semaphore n clear bit
    static constexpr uint32_t ICR_ISEM2 = 0x4;          // Interrupt(N) semaphore n clear bit
    static constexpr uint32_t ICR_ISEM3 = 0x8;          // Interrupt(N) semaphore n clear bit
    static constexpr uint32_t ICR_ISEM4 = 0x10;         // Interrupt(N) semaphore n clear bit
    static constexpr uint32_t ICR_ISEM5 = 0x20;         // Interrupt(N) semaphore n clear bit
    static constexpr uint32_t ICR_ISEM6 = 0x40;         // Interrupt(N) semaphore n clear bit
    static constexpr uint32_t ICR_ISEM7 = 0x80;         // Interrupt(N) semaphore n clear bit
    static constexpr uint32_t ICR_ISEM8 = 0x100;        // Interrupt(N) semaphore n clear bit
    static constexpr uint32_t ICR_ISEM9 = 0x200;        // Interrupt(N) semaphore n clear bit
    static constexpr uint32_t ICR_ISEM10 = 0x400;       // Interrupt(N) semaphore n clear bit
    static constexpr uint32_t ICR_ISEM11 = 0x800;       // Interrupt(N) semaphore n clear bit
    static constexpr uint32_t ICR_ISEM12 = 0x1000;      // Interrupt(N) semaphore n clear bit
    static constexpr uint32_t ICR_ISEM13 = 0x2000;      // Interrupt(N) semaphore n clear bit
    static constexpr uint32_t ICR_ISEM14 = 0x4000;      // Interrupt(N) semaphore n clear bit
    static constexpr uint32_t ICR_ISEM15 = 0x8000;      // Interrupt(N) semaphore n clear bit
    static constexpr uint32_t ICR_ISEM16 = 0x10000;     // Interrupt(N) semaphore n clear bit
    static constexpr uint32_t ICR_ISEM17 = 0x20000;     // Interrupt(N) semaphore n clear bit
    static constexpr uint32_t ICR_ISEM18 = 0x40000;     // Interrupt(N) semaphore n clear bit
    static constexpr uint32_t ICR_ISEM19 = 0x80000;     // Interrupt(N) semaphore n clear bit
    static constexpr uint32_t ICR_ISEM20 = 0x100000;    // Interrupt(N) semaphore n clear bit
    static constexpr uint32_t ICR_ISEM21 = 0x200000;    // Interrupt(N) semaphore n clear bit
    static constexpr uint32_t ICR_ISEM22 = 0x400000;    // Interrupt(N) semaphore n clear bit
    static constexpr uint32_t ICR_ISEM23 = 0x800000;    // Interrupt(N) semaphore n clear bit
    static constexpr uint32_t ICR_ISEM24 = 0x1000000;   // Interrupt(N) semaphore n clear bit
    static constexpr uint32_t ICR_ISEM25 = 0x2000000;   // Interrupt(N) semaphore n clear bit
    static constexpr uint32_t ICR_ISEM26 = 0x4000000;   // Interrupt(N) semaphore n clear bit
    static constexpr uint32_t ICR_ISEM27 = 0x8000000;   // Interrupt(N) semaphore n clear bit
    static constexpr uint32_t ICR_ISEM28 = 0x10000000;  // Interrupt(N) semaphore n clear bit
    static constexpr uint32_t ICR_ISEM29 = 0x20000000;  // Interrupt(N) semaphore n clear bit
    static constexpr uint32_t ICR_ISEM30 = 0x40000000;  // Interrupt(N) semaphore n clear bit
    static constexpr uint32_t ICR_ISEM31 = 0x80000000;  // Interrupt(N) semaphore n clear bit
    static const uint32_t ICR_RESET_VALUE = 0x0;

    static constexpr uint32_t ISR_ISEM0 = 0x1;          // Interrupt(N) semaphore n status bit before enable (mask)
    static constexpr uint32_t ISR_ISEM1 = 0x2;          // Interrupt(N) semaphore n status bit before enable (mask)
    static constexpr uint32_t ISR_ISEM2 = 0x4;          // Interrupt(N) semaphore n status bit before enable (mask)
    static constexpr uint32_t ISR_ISEM3 = 0x8;          // Interrupt(N) semaphore n status bit before enable (mask)
    static constexpr uint32_t ISR_ISEM4 = 0x10;         // Interrupt(N) semaphore n status bit before enable (mask)
    static constexpr uint32_t ISR_ISEM5 = 0x20;         // Interrupt(N) semaphore n status bit before enable (mask)
    static constexpr uint32_t ISR_ISEM6 = 0x40;         // Interrupt(N) semaphore n status bit before enable (mask)
    static constexpr uint32_t ISR_ISEM7 = 0x80;         // Interrupt(N) semaphore n status bit before enable (mask)
    static constexpr uint32_t ISR_ISEM8 = 0x100;        // Interrupt(N) semaphore n status bit before enable (mask)
    static constexpr uint32_t ISR_ISEM9 = 0x200;        // Interrupt(N) semaphore n status bit before enable (mask)
    static constexpr uint32_t ISR_ISEM10 = 0x400;       // Interrupt(N) semaphore n status bit before enable (mask)
    static constexpr uint32_t ISR_ISEM11 = 0x800;       // Interrupt(N) semaphore n status bit before enable (mask)
    static constexpr uint32_t ISR_ISEM12 = 0x1000;      // Interrupt(N) semaphore n status bit before enable (mask)
    static constexpr uint32_t ISR_ISEM13 = 0x2000;      // Interrupt(N) semaphore n status bit before enable (mask)
    static constexpr uint32_t ISR_ISEM14 = 0x4000;      // Interrupt(N) semaphore n status bit before enable (mask)
    static constexpr uint32_t ISR_ISEM15 = 0x8000;      // Interrupt(N) semaphore n status bit before enable (mask)
    static constexpr uint32_t ISR_ISEM16 = 0x10000;     // Interrupt(N) semaphore n status bit before enable (mask)
    static constexpr uint32_t ISR_ISEM17 = 0x20000;     // Interrupt(N) semaphore n status bit before enable (mask)
    static constexpr uint32_t ISR_ISEM18 = 0x40000;     // Interrupt(N) semaphore n status bit before enable (mask)
    static constexpr uint32_t ISR_ISEM19 = 0x80000;     // Interrupt(N) semaphore n status bit before enable (mask)
    static constexpr uint32_t ISR_ISEM20 = 0x100000;    // Interrupt(N) semaphore n status bit before enable (mask)
    static constexpr uint32_t ISR_ISEM21 = 0x200000;    // Interrupt(N) semaphore n status bit before enable (mask)
    static constexpr uint32_t ISR_ISEM22 = 0x400000;    // Interrupt(N) semaphore n status bit before enable (mask)
    static constexpr uint32_t ISR_ISEM23 = 0x800000;    // Interrupt(N) semaphore n status bit before enable (mask)
    static constexpr uint32_t ISR_ISEM24 = 0x1000000;   // Interrupt(N) semaphore n status bit before enable (mask)
    static constexpr uint32_t ISR_ISEM25 = 0x2000000;   // Interrupt(N) semaphore n status bit before enable (mask)
    static constexpr uint32_t ISR_ISEM26 = 0x4000000;   // Interrupt(N) semaphore n status bit before enable (mask)
    static constexpr uint32_t ISR_ISEM27 = 0x8000000;   // Interrupt(N) semaphore n status bit before enable (mask)
    static constexpr uint32_t ISR_ISEM28 = 0x10000000;  // Interrupt(N) semaphore n status bit before enable (mask)
    static constexpr uint32_t ISR_ISEM29 = 0x20000000;  // Interrupt(N) semaphore n status bit before enable (mask)
    static constexpr uint32_t ISR_ISEM30 = 0x40000000;  // Interrupt(N) semaphore n status bit before enable (mask)
    static constexpr uint32_t ISR_ISEM31 = 0x80000000;  // Interrupt(N) semaphore n status bit before enable (mask)
    static const uint32_t ISR_RESET_VALUE = 0x0;

    static constexpr uint32_t MISR_ISEM0 = 0x1;          // masked interrupt(N) semaphore n status bit after enable (mask)
    static constexpr uint32_t MISR_ISEM1 = 0x2;          // masked interrupt(N) semaphore n status bit after enable (mask)
    static constexpr uint32_t MISR_ISEM2 = 0x4;          // masked interrupt(N) semaphore n status bit after enable (mask)
    static constexpr uint32_t MISR_ISEM3 = 0x8;          // masked interrupt(N) semaphore n status bit after enable (mask)
    static constexpr uint32_t MISR_ISEM4 = 0x10;         // masked interrupt(N) semaphore n status bit after enable (mask)
    static constexpr uint32_t MISR_ISEM5 = 0x20;         // masked interrupt(N) semaphore n status bit after enable (mask)
    static constexpr uint32_t MISR_ISEM6 = 0x40;         // masked interrupt(N) semaphore n status bit after enable (mask)
    static constexpr uint32_t MISR_ISEM7 = 0x80;         // masked interrupt(N) semaphore n status bit after enable (mask)
    static constexpr uint32_t MISR_ISEM8 = 0x100;        // masked interrupt(N) semaphore n status bit after enable (mask)
    static constexpr uint32_t MISR_ISEM9 = 0x200;        // masked interrupt(N) semaphore n status bit after enable (mask)
    static constexpr uint32_t MISR_ISEM10 = 0x400;       // masked interrupt(N) semaphore n status bit after enable (mask)
    static constexpr uint32_t MISR_ISEM11 = 0x800;       // masked interrupt(N) semaphore n status bit after enable (mask)
    static constexpr uint32_t MISR_ISEM12 = 0x1000;      // masked interrupt(N) semaphore n status bit after enable (mask)
    static constexpr uint32_t MISR_ISEM13 = 0x2000;      // masked interrupt(N) semaphore n status bit after enable (mask)
    static constexpr uint32_t MISR_ISEM14 = 0x4000;      // masked interrupt(N) semaphore n status bit after enable (mask)
    static constexpr uint32_t MISR_ISEM15 = 0x8000;      // masked interrupt(N) semaphore n status bit after enable (mask)
    static constexpr uint32_t MISR_ISEM16 = 0x10000;     // masked interrupt(N) semaphore n status bit after enable (mask)
    static constexpr uint32_t MISR_ISEM17 = 0x20000;     // masked interrupt(N) semaphore n status bit after enable (mask)
    static constexpr uint32_t MISR_ISEM18 = 0x40000;     // masked interrupt(N) semaphore n status bit after enable (mask)
    static constexpr uint32_t MISR_ISEM19 = 0x80000;     // masked interrupt(N) semaphore n status bit after enable (mask)
    static constexpr uint32_t MISR_ISEM20 = 0x100000;    // masked interrupt(N) semaphore n status bit after enable (mask)
    static constexpr uint32_t MISR_ISEM21 = 0x200000;    // masked interrupt(N) semaphore n status bit after enable (mask)
    static constexpr uint32_t MISR_ISEM22 = 0x400000;    // masked interrupt(N) semaphore n status bit after enable (mask)
    static constexpr uint32_t MISR_ISEM23 = 0x800000;    // masked interrupt(N) semaphore n status bit after enable (mask)
    static constexpr uint32_t MISR_ISEM24 = 0x1000000;   // masked interrupt(N) semaphore n status bit after enable (mask)
    static constexpr uint32_t MISR_ISEM25 = 0x2000000;   // masked interrupt(N) semaphore n status bit after enable (mask)
    static constexpr uint32_t MISR_ISEM26 = 0x4000000;   // masked interrupt(N) semaphore n status bit after enable (mask)
    static constexpr uint32_t MISR_ISEM27 = 0x8000000;   // masked interrupt(N) semaphore n status bit after enable (mask)
    static constexpr uint32_t MISR_ISEM28 = 0x10000000;  // masked interrupt(N) semaphore n status bit after enable (mask)
    static constexpr uint32_t MISR_ISEM29 = 0x20000000;  // masked interrupt(N) semaphore n status bit after enable (mask)
    static constexpr uint32_t MISR_ISEM30 = 0x40000000;  // masked interrupt(N) semaphore n status bit after enable (mask)
    static constexpr uint32_t MISR_ISEM31 = 0x80000000;  // masked interrupt(N) semaphore n status bit after enable (mask)
    static const uint32_t MISR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CR_MASTERID =            // MasterID of semaphores to be cleared (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR_KEY =                 // Semaphore clear Key (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t KEYR_KEY =                 // Semaphore Clear Key (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t KEYR_RESET_VALUE = 0x0;

    static constexpr uint8_t HSEM0 = 125; // HSEM global interrupt 1
};

static hsem_t& HSEM = *reinterpret_cast<hsem_t*>(0x58026400);

#define HAVE_PERIPHERAL_HSEM


////
//
//    I2C
//
////

struct i2c1_t
{
    volatile uint32_t    CR1;                  // [Read-write] Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
    volatile uint32_t    CR2;                  // [Read-write] Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
    volatile uint32_t    OAR1;                 // [Read-write] Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
    volatile uint32_t    OAR2;                 // [Read-write] Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
    volatile uint32_t    TIMINGR;              // [Read-write] Access: No wait states
    volatile uint32_t    TIMEOUTR;             // [Read-write] Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
    volatile uint32_t    ISR;                  // Access: No wait states
    volatile uint32_t    ICR;                  // [Write-only] Access: No wait states
    volatile uint32_t    PECR;                 // [Read-only] Access: No wait states
    volatile uint32_t    RXDR;                 // [Read-only] Access: No wait states
    volatile uint32_t    TXDR;                 // [Read-write] Access: No wait states

    static constexpr uint32_t CR1_PE = 0x1;             // Peripheral enable Note: When PE=0, the I2C SCL and SDA lines are released. Internal state machines and status bits are put back to their reset value. When cleared, PE must be kept low for at least 3 APB clock cycles.
    static constexpr uint32_t CR1_TXIE = 0x2;           // TX Interrupt enable
    static constexpr uint32_t CR1_RXIE = 0x4;           // RX Interrupt enable
    static constexpr uint32_t CR1_ADDRIE = 0x8;         // Address match Interrupt enable (slave only)
    static constexpr uint32_t CR1_NACKIE = 0x10;        // Not acknowledge received Interrupt enable
    static constexpr uint32_t CR1_STOPIE = 0x20;        // STOP detection Interrupt enable
    static constexpr uint32_t CR1_TCIE = 0x40;          // Transfer Complete interrupt enable Note: Any of these events will generate an interrupt: Transfer Complete (TC) Transfer Complete Reload (TCR)
    static constexpr uint32_t CR1_ERRIE = 0x80;         // Error interrupts enable Note: Any of these errors generate an interrupt: Arbitration Loss (ARLO) Bus Error detection (BERR) Overrun/Underrun (OVR) Timeout detection (TIMEOUT) PEC error detection (PECERR) Alert pin event detection (ALERT)
    template<uint32_t X>
    static constexpr uint32_t CR1_DNF =                 // Digital noise filter These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter will filter spikes with a length of up to DNF[3:0] * tI2CCLK ... Note: If the analog filter is also enabled, the digital filter is added to the analog filter. This filter can only be programmed when the I2C is disabled (PE = 0). (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    static constexpr uint32_t CR1_ANFOFF = 0x1000;      // Analog noise filter OFF Note: This bit can only be programmed when the I2C is disabled (PE = 0).
    static constexpr uint32_t CR1_TXDMAEN = 0x4000;     // DMA transmission requests enable
    static constexpr uint32_t CR1_RXDMAEN = 0x8000;     // DMA reception requests enable
    static constexpr uint32_t CR1_SBC = 0x10000;        // Slave byte control This bit is used to enable hardware byte control in slave mode.
    static constexpr uint32_t CR1_NOSTRETCH = 0x20000;  // Clock stretching disable This bit is used to disable clock stretching in slave mode. It must be kept cleared in master mode. Note: This bit can only be programmed when the I2C is disabled (PE = 0).
    static constexpr uint32_t CR1_WUPEN = 0x40000;      // Wakeup from Stop mode enable Note: If the Wakeup from Stop mode feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation. Note: WUPEN can be set only when DNF = 0000
    static constexpr uint32_t CR1_GCEN = 0x80000;       // General call enable
    static constexpr uint32_t CR1_SMBHEN = 0x100000;    // SMBus Host address enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    static constexpr uint32_t CR1_SMBDEN = 0x200000;    // SMBus Device Default address enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    static constexpr uint32_t CR1_ALERTEN = 0x400000;   // SMBus alert enable Device mode (SMBHEN=0): Host mode (SMBHEN=1): Note: When ALERTEN=0, the SMBA pin can be used as a standard GPIO. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    static constexpr uint32_t CR1_PECEN = 0x800000;     // PEC enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    static const uint32_t CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CR2_SADD0 = 0x1;          // Slave address bit 0 (master mode) In 7-bit addressing mode (ADD10 = 0): This bit is dont care In 10-bit addressing mode (ADD10 = 1): This bit should be written with bit 0 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
    static constexpr uint32_t CR2_SADD1 = 0x2;          // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    static constexpr uint32_t CR2_SADD2 = 0x4;          // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    static constexpr uint32_t CR2_SADD3 = 0x8;          // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    static constexpr uint32_t CR2_SADD4 = 0x10;         // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    static constexpr uint32_t CR2_SADD5 = 0x20;         // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    static constexpr uint32_t CR2_SADD6 = 0x40;         // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    static constexpr uint32_t CR2_SADD7 = 0x80;         // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    static constexpr uint32_t CR2_SADD8 = 0x100;        // Slave address bit 9:8 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits are dont care In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 9:8 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
    static constexpr uint32_t CR2_SADD9 = 0x200;        // Slave address bit 9:8 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits are dont care In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 9:8 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
    static constexpr uint32_t CR2_RD_WRN = 0x400;       // Transfer direction (master mode) Note: Changing this bit when the START bit is set is not allowed.
    static constexpr uint32_t CR2_ADD10 = 0x800;        // 10-bit addressing mode (master mode) Note: Changing this bit when the START bit is set is not allowed.
    static constexpr uint32_t CR2_HEAD10R = 0x1000;     // 10-bit address header only read direction (master receiver mode) Note: Changing this bit when the START bit is set is not allowed.
    static constexpr uint32_t CR2_START = 0x2000;       // Start generation This bit is set by software, and cleared by hardware after the Start followed by the address sequence is sent, by an arbitration loss, by a timeout error detection, or when PE = 0. It can also be cleared by software by writing 1 to the ADDRCF bit in the I2C_ICR register. If the I2C is already in master mode with AUTOEND = 0, setting this bit generates a Repeated Start condition when RELOAD=0, after the end of the NBYTES transfer. Otherwise setting this bit will generate a START condition once the bus is free. Note: Writing 0 to this bit has no effect. The START bit can be set even if the bus is BUSY or I2C is in slave mode. This bit has no effect when RELOAD is set.
    static constexpr uint32_t CR2_STOP = 0x4000;        // Stop generation (master mode) The bit is set by software, cleared by hardware when a Stop condition is detected, or when PE = 0. In Master Mode: Note: Writing 0 to this bit has no effect.
    static constexpr uint32_t CR2_NACK = 0x8000;        // NACK generation (slave mode) The bit is set by software, cleared by hardware when the NACK is sent, or when a STOP condition or an Address matched is received, or when PE=0. Note: Writing 0 to this bit has no effect. This bit is used in slave mode only: in master receiver mode, NACK is automatically generated after last byte preceding STOP or RESTART condition, whatever the NACK bit value. When an overrun occurs in slave receiver NOSTRETCH mode, a NACK is automatically generated whatever the NACK bit value. When hardware PEC checking is enabled (PECBYTE=1), the PEC acknowledge value does not depend on the NACK value.
    template<uint32_t X>
    static constexpr uint32_t CR2_NBYTES =              // Number of bytes The number of bytes to be transmitted/received is programmed there. This field is dont care in slave mode with SBC=0. Note: Changing these bits when the START bit is set is not allowed. (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static constexpr uint32_t CR2_RELOAD = 0x1000000;   // NBYTES reload mode This bit is set and cleared by software.
    static constexpr uint32_t CR2_AUTOEND = 0x2000000;  // Automatic end mode (master mode) This bit is set and cleared by software. Note: This bit has no effect in slave mode or when the RELOAD bit is set.
    static constexpr uint32_t CR2_PECBYTE = 0x4000000;  // Packet error checking byte This bit is set by software, and cleared by hardware when the PEC is transferred, or when a STOP condition or an Address matched is received, also when PE=0. Note: Writing 0 to this bit has no effect. This bit has no effect when RELOAD is set. This bit has no effect is slave mode when SBC=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    static const uint32_t CR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OAR1_OA1 =                 // Interface address 7-bit addressing mode: dont care 10-bit addressing mode: bits 9:8 of address Note: These bits can be written only when OA1EN=0. OA1[7:1]: Interface address Bits 7:1 of address Note: These bits can be written only when OA1EN=0. OA1[0]: Interface address 7-bit addressing mode: dont care 10-bit addressing mode: bit 0 of address Note: This bit can be written only when OA1EN=0. (10 bits)
        bit_field_t<0, 0x3ff>::value<X>();
    static constexpr uint32_t OAR1_OA1MODE = 0x400;      // Own Address 1 10-bit mode Note: This bit can be written only when OA1EN=0.
    static constexpr uint32_t OAR1_OA1EN = 0x8000;       // Own Address 1 enable
    static const uint32_t OAR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OAR2_OA2 =                 // Interface address bits 7:1 of address Note: These bits can be written only when OA2EN=0. (7 bits)
        bit_field_t<1, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OAR2_OA2MSK =              // Own Address 2 masks Note: These bits can be written only when OA2EN=0. As soon as OA2MSK is not equal to 0, the reserved I2C addresses (0b0000xxx and 0b1111xxx) are not acknowledged even if the comparison matches. (3 bits)
        bit_field_t<8, 0x7>::value<X>();
    static constexpr uint32_t OAR2_OA2EN = 0x8000;       // Own Address 2 enable
    static const uint32_t OAR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TIMINGR_SCLL =                // SCL low period (master mode) This field is used to generate the SCL low period in master mode. tSCLL = (SCLL+1) x tPRESC Note: SCLL is also used to generate tBUF and tSU:STA timings. (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TIMINGR_SCLH =                // SCL high period (master mode) This field is used to generate the SCL high period in master mode. tSCLH = (SCLH+1) x tPRESC Note: SCLH is also used to generate tSU:STO and tHD:STA timing. (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TIMINGR_SDADEL =              // Data hold time This field is used to generate the delay tSDADEL between SCL falling edge and SDA edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tSDADEL. tSDADEL= SDADEL x tPRESC Note: SDADEL is used to generate tHD:DAT timing. (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TIMINGR_SCLDEL =              // Data setup time This field is used to generate a delay tSCLDEL between SDA edge and SCL rising edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tSCLDEL. tSCLDEL = (SCLDEL+1) x tPRESC Note: tSCLDEL is used to generate tSU:DAT timing. (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TIMINGR_PRESC =               // Timing prescaler This field is used to prescale I2CCLK in order to generate the clock period tPRESC used for data setup and hold counters (refer to I2C timings on page9) and for SCL high and low level counters (refer to I2C master initialization on page24). tPRESC = (PRESC+1) x tI2CCLK (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    static const uint32_t TIMINGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TIMEOUTR_TIMEOUTA =            // Bus Timeout A This field is used to configure: The SCL low timeout condition tTIMEOUT when TIDLE=0 tTIMEOUT= (TIMEOUTA+1) x 2048 x tI2CCLK The bus idle condition (both SCL and SDA high) when TIDLE=1 tIDLE= (TIMEOUTA+1) x 4 x tI2CCLK Note: These bits can be written only when TIMOUTEN=0. (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static constexpr uint32_t TIMEOUTR_TIDLE = 0x1000;       // Idle clock timeout detection Note: This bit can be written only when TIMOUTEN=0.
    static constexpr uint32_t TIMEOUTR_TIMOUTEN = 0x8000;    // Clock timeout enable
    template<uint32_t X>
    static constexpr uint32_t TIMEOUTR_TIMEOUTB =            // Bus timeout B This field is used to configure the cumulative clock extension timeout: In master mode, the master cumulative clock low extend time (tLOW:MEXT) is detected In slave mode, the slave cumulative clock low extend time (tLOW:SEXT) is detected tLOW:EXT= (TIMEOUTB+1) x 2048 x tI2CCLK Note: These bits can be written only when TEXTEN=0. (12 bits)
        bit_field_t<16, 0xfff>::value<X>();
    static constexpr uint32_t TIMEOUTR_TEXTEN = 0x80000000;  // Extended clock timeout enable
    static const uint32_t TIMEOUTR_RESET_VALUE = 0x0;

    static constexpr uint32_t ISR_TXE = 0x1;            // Transmit data register empty (transmitters) This bit is set by hardware when the I2C_TXDR register is empty. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software in order to flush the transmit data register I2C_TXDR. Note: This bit is set by hardware when PE=0., Read-write
    static constexpr uint32_t ISR_TXIS = 0x2;           // Transmit interrupt status (transmitters) This bit is set by hardware when the I2C_TXDR register is empty and the data to be transmitted must be written in the I2C_TXDR register. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software when NOSTRETCH=1 only, in order to generate a TXIS event (interrupt if TXIE=1 or DMA request if TXDMAEN=1). Note: This bit is cleared by hardware when PE=0., Read-write
    static constexpr uint32_t ISR_RXNE = 0x4;           // Receive data register not empty (receivers) This bit is set by hardware when the received data is copied into the I2C_RXDR register, and is ready to be read. It is cleared when I2C_RXDR is read. Note: This bit is cleared by hardware when PE=0., Read-only
    static constexpr uint32_t ISR_ADDR = 0x8;           // Address matched (slave mode) This bit is set by hardware as soon as the received slave address matched with one of the enabled slave addresses. It is cleared by software by setting ADDRCF bit. Note: This bit is cleared by hardware when PE=0., Read-only
    static constexpr uint32_t ISR_NACKF = 0x10;         // Not Acknowledge received flag This flag is set by hardware when a NACK is received after a byte transmission. It is cleared by software by setting the NACKCF bit. Note: This bit is cleared by hardware when PE=0., Read-only
    static constexpr uint32_t ISR_STOPF = 0x20;         // Stop detection flag This flag is set by hardware when a Stop condition is detected on the bus and the peripheral is involved in this transfer: either as a master, provided that the STOP condition is generated by the peripheral. or as a slave, provided that the peripheral has been addressed previously during this transfer. It is cleared by software by setting the STOPCF bit. Note: This bit is cleared by hardware when PE=0., Read-only
    static constexpr uint32_t ISR_TC = 0x40;            // Transfer Complete (master mode) This flag is set by hardware when RELOAD=0, AUTOEND=0 and NBYTES data have been transferred. It is cleared by software when START bit or STOP bit is set. Note: This bit is cleared by hardware when PE=0., Read-only
    static constexpr uint32_t ISR_TCR = 0x80;           // Transfer Complete Reload This flag is set by hardware when RELOAD=1 and NBYTES data have been transferred. It is cleared by software when NBYTES is written to a non-zero value. Note: This bit is cleared by hardware when PE=0. This flag is only for master mode, or for slave mode when the SBC bit is set., Read-only
    static constexpr uint32_t ISR_BERR = 0x100;         // Bus error This flag is set by hardware when a misplaced Start or Stop condition is detected whereas the peripheral is involved in the transfer. The flag is not set during the address phase in slave mode. It is cleared by software by setting BERRCF bit. Note: This bit is cleared by hardware when PE=0., Read-only
    static constexpr uint32_t ISR_ARLO = 0x200;         // Arbitration lost This flag is set by hardware in case of arbitration loss. It is cleared by software by setting the ARLOCF bit. Note: This bit is cleared by hardware when PE=0., Read-only
    static constexpr uint32_t ISR_OVR = 0x400;          // Overrun/Underrun (slave mode) This flag is set by hardware in slave mode with NOSTRETCH=1, when an overrun/underrun error occurs. It is cleared by software by setting the OVRCF bit. Note: This bit is cleared by hardware when PE=0., Read-only
    static constexpr uint32_t ISR_PECERR = 0x800;       // PEC Error in reception This flag is set by hardware when the received PEC does not match with the PEC register content. A NACK is automatically sent after the wrong PEC reception. It is cleared by software by setting the PECCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation., Read-only
    static constexpr uint32_t ISR_TIMEOUT = 0x1000;     // Timeout or tLOW detection flag This flag is set by hardware when a timeout or extended clock timeout occurred. It is cleared by software by setting the TIMEOUTCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation., Read-only
    static constexpr uint32_t ISR_ALERT = 0x2000;       // SMBus alert This flag is set by hardware when SMBHEN=1 (SMBus host configuration), ALERTEN=1 and a SMBALERT event (falling edge) is detected on SMBA pin. It is cleared by software by setting the ALERTCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation., Read-only
    static constexpr uint32_t ISR_BUSY = 0x8000;        // Bus busy This flag indicates that a communication is in progress on the bus. It is set by hardware when a START condition is detected. It is cleared by hardware when a Stop condition is detected, or when PE=0., Read-only
    static constexpr uint32_t ISR_DIR = 0x10000;        // Transfer direction (Slave mode) This flag is updated when an address match event occurs (ADDR=1)., Read-only
    template<uint32_t X>
    static constexpr uint32_t ISR_ADDCODE =             // Address match code (Slave mode) These bits are updated with the received address when an address match event occurs (ADDR = 1). In the case of a 10-bit address, ADDCODE provides the 10-bit header followed by the 2 MSBs of the address. (7 bits), Read-only
        bit_field_t<17, 0x7f>::value<X>();
    static const uint32_t ISR_RESET_VALUE = 0x1;

    static constexpr uint32_t ICR_ADDRCF = 0x8;         // Address matched flag clear Writing 1 to this bit clears the ADDR flag in the I2C_ISR register. Writing 1 to this bit also clears the START bit in the I2C_CR2 register.
    static constexpr uint32_t ICR_NACKCF = 0x10;        // Not Acknowledge flag clear Writing 1 to this bit clears the ACKF flag in I2C_ISR register.
    static constexpr uint32_t ICR_STOPCF = 0x20;        // Stop detection flag clear Writing 1 to this bit clears the STOPF flag in the I2C_ISR register.
    static constexpr uint32_t ICR_BERRCF = 0x100;       // Bus error flag clear Writing 1 to this bit clears the BERRF flag in the I2C_ISR register.
    static constexpr uint32_t ICR_ARLOCF = 0x200;       // Arbitration Lost flag clear Writing 1 to this bit clears the ARLO flag in the I2C_ISR register.
    static constexpr uint32_t ICR_OVRCF = 0x400;        // Overrun/Underrun flag clear Writing 1 to this bit clears the OVR flag in the I2C_ISR register.
    static constexpr uint32_t ICR_PECCF = 0x800;        // PEC Error flag clear Writing 1 to this bit clears the PECERR flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    static constexpr uint32_t ICR_TIMOUTCF = 0x1000;    // Timeout detection flag clear Writing 1 to this bit clears the TIMEOUT flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    static constexpr uint32_t ICR_ALERTCF = 0x2000;     // Alert flag clear Writing 1 to this bit clears the ALERT flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    static const uint32_t ICR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PECR_PEC =                 // Packet error checking register This field contains the internal PEC when PECEN=1. The PEC is cleared by hardware when PE=0. (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t PECR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RXDR_RXDATA =              // 8-bit receive data Data byte received from the I2C bus. (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t RXDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TXDR_TXDATA =              // 8-bit transmit data Data byte to be transmitted to the I2C bus. Note: These bits can be written only when TXE=1. (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t TXDR_RESET_VALUE = 0x0;

    static constexpr uint8_t I2C1_ER = 32; // I2C1 error interrupt
    static constexpr uint8_t I2C1_EV = 31; // I2C1 event interrupt
};

static i2c1_t& I2C1 = *reinterpret_cast<i2c1_t*>(0x40005400);

#define HAVE_PERIPHERAL_I2C1


////
//
//    I2C
//
////

struct i2c2_t
{
    volatile uint32_t    CR1;                  // [Read-write] Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
    volatile uint32_t    CR2;                  // [Read-write] Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
    volatile uint32_t    OAR1;                 // [Read-write] Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
    volatile uint32_t    OAR2;                 // [Read-write] Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
    volatile uint32_t    TIMINGR;              // [Read-write] Access: No wait states
    volatile uint32_t    TIMEOUTR;             // [Read-write] Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
    volatile uint32_t    ISR;                  // Access: No wait states
    volatile uint32_t    ICR;                  // [Write-only] Access: No wait states
    volatile uint32_t    PECR;                 // [Read-only] Access: No wait states
    volatile uint32_t    RXDR;                 // [Read-only] Access: No wait states
    volatile uint32_t    TXDR;                 // [Read-write] Access: No wait states

    static constexpr uint32_t CR1_PE = 0x1;             // Peripheral enable Note: When PE=0, the I2C SCL and SDA lines are released. Internal state machines and status bits are put back to their reset value. When cleared, PE must be kept low for at least 3 APB clock cycles.
    static constexpr uint32_t CR1_TXIE = 0x2;           // TX Interrupt enable
    static constexpr uint32_t CR1_RXIE = 0x4;           // RX Interrupt enable
    static constexpr uint32_t CR1_ADDRIE = 0x8;         // Address match Interrupt enable (slave only)
    static constexpr uint32_t CR1_NACKIE = 0x10;        // Not acknowledge received Interrupt enable
    static constexpr uint32_t CR1_STOPIE = 0x20;        // STOP detection Interrupt enable
    static constexpr uint32_t CR1_TCIE = 0x40;          // Transfer Complete interrupt enable Note: Any of these events will generate an interrupt: Transfer Complete (TC) Transfer Complete Reload (TCR)
    static constexpr uint32_t CR1_ERRIE = 0x80;         // Error interrupts enable Note: Any of these errors generate an interrupt: Arbitration Loss (ARLO) Bus Error detection (BERR) Overrun/Underrun (OVR) Timeout detection (TIMEOUT) PEC error detection (PECERR) Alert pin event detection (ALERT)
    template<uint32_t X>
    static constexpr uint32_t CR1_DNF =                 // Digital noise filter These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter will filter spikes with a length of up to DNF[3:0] * tI2CCLK ... Note: If the analog filter is also enabled, the digital filter is added to the analog filter. This filter can only be programmed when the I2C is disabled (PE = 0). (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    static constexpr uint32_t CR1_ANFOFF = 0x1000;      // Analog noise filter OFF Note: This bit can only be programmed when the I2C is disabled (PE = 0).
    static constexpr uint32_t CR1_TXDMAEN = 0x4000;     // DMA transmission requests enable
    static constexpr uint32_t CR1_RXDMAEN = 0x8000;     // DMA reception requests enable
    static constexpr uint32_t CR1_SBC = 0x10000;        // Slave byte control This bit is used to enable hardware byte control in slave mode.
    static constexpr uint32_t CR1_NOSTRETCH = 0x20000;  // Clock stretching disable This bit is used to disable clock stretching in slave mode. It must be kept cleared in master mode. Note: This bit can only be programmed when the I2C is disabled (PE = 0).
    static constexpr uint32_t CR1_WUPEN = 0x40000;      // Wakeup from Stop mode enable Note: If the Wakeup from Stop mode feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation. Note: WUPEN can be set only when DNF = 0000
    static constexpr uint32_t CR1_GCEN = 0x80000;       // General call enable
    static constexpr uint32_t CR1_SMBHEN = 0x100000;    // SMBus Host address enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    static constexpr uint32_t CR1_SMBDEN = 0x200000;    // SMBus Device Default address enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    static constexpr uint32_t CR1_ALERTEN = 0x400000;   // SMBus alert enable Device mode (SMBHEN=0): Host mode (SMBHEN=1): Note: When ALERTEN=0, the SMBA pin can be used as a standard GPIO. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    static constexpr uint32_t CR1_PECEN = 0x800000;     // PEC enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    static const uint32_t CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CR2_SADD0 = 0x1;          // Slave address bit 0 (master mode) In 7-bit addressing mode (ADD10 = 0): This bit is dont care In 10-bit addressing mode (ADD10 = 1): This bit should be written with bit 0 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
    static constexpr uint32_t CR2_SADD1 = 0x2;          // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    static constexpr uint32_t CR2_SADD2 = 0x4;          // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    static constexpr uint32_t CR2_SADD3 = 0x8;          // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    static constexpr uint32_t CR2_SADD4 = 0x10;         // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    static constexpr uint32_t CR2_SADD5 = 0x20;         // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    static constexpr uint32_t CR2_SADD6 = 0x40;         // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    static constexpr uint32_t CR2_SADD7 = 0x80;         // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    static constexpr uint32_t CR2_SADD8 = 0x100;        // Slave address bit 9:8 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits are dont care In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 9:8 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
    static constexpr uint32_t CR2_SADD9 = 0x200;        // Slave address bit 9:8 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits are dont care In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 9:8 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
    static constexpr uint32_t CR2_RD_WRN = 0x400;       // Transfer direction (master mode) Note: Changing this bit when the START bit is set is not allowed.
    static constexpr uint32_t CR2_ADD10 = 0x800;        // 10-bit addressing mode (master mode) Note: Changing this bit when the START bit is set is not allowed.
    static constexpr uint32_t CR2_HEAD10R = 0x1000;     // 10-bit address header only read direction (master receiver mode) Note: Changing this bit when the START bit is set is not allowed.
    static constexpr uint32_t CR2_START = 0x2000;       // Start generation This bit is set by software, and cleared by hardware after the Start followed by the address sequence is sent, by an arbitration loss, by a timeout error detection, or when PE = 0. It can also be cleared by software by writing 1 to the ADDRCF bit in the I2C_ICR register. If the I2C is already in master mode with AUTOEND = 0, setting this bit generates a Repeated Start condition when RELOAD=0, after the end of the NBYTES transfer. Otherwise setting this bit will generate a START condition once the bus is free. Note: Writing 0 to this bit has no effect. The START bit can be set even if the bus is BUSY or I2C is in slave mode. This bit has no effect when RELOAD is set.
    static constexpr uint32_t CR2_STOP = 0x4000;        // Stop generation (master mode) The bit is set by software, cleared by hardware when a Stop condition is detected, or when PE = 0. In Master Mode: Note: Writing 0 to this bit has no effect.
    static constexpr uint32_t CR2_NACK = 0x8000;        // NACK generation (slave mode) The bit is set by software, cleared by hardware when the NACK is sent, or when a STOP condition or an Address matched is received, or when PE=0. Note: Writing 0 to this bit has no effect. This bit is used in slave mode only: in master receiver mode, NACK is automatically generated after last byte preceding STOP or RESTART condition, whatever the NACK bit value. When an overrun occurs in slave receiver NOSTRETCH mode, a NACK is automatically generated whatever the NACK bit value. When hardware PEC checking is enabled (PECBYTE=1), the PEC acknowledge value does not depend on the NACK value.
    template<uint32_t X>
    static constexpr uint32_t CR2_NBYTES =              // Number of bytes The number of bytes to be transmitted/received is programmed there. This field is dont care in slave mode with SBC=0. Note: Changing these bits when the START bit is set is not allowed. (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static constexpr uint32_t CR2_RELOAD = 0x1000000;   // NBYTES reload mode This bit is set and cleared by software.
    static constexpr uint32_t CR2_AUTOEND = 0x2000000;  // Automatic end mode (master mode) This bit is set and cleared by software. Note: This bit has no effect in slave mode or when the RELOAD bit is set.
    static constexpr uint32_t CR2_PECBYTE = 0x4000000;  // Packet error checking byte This bit is set by software, and cleared by hardware when the PEC is transferred, or when a STOP condition or an Address matched is received, also when PE=0. Note: Writing 0 to this bit has no effect. This bit has no effect when RELOAD is set. This bit has no effect is slave mode when SBC=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    static const uint32_t CR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OAR1_OA1 =                 // Interface address 7-bit addressing mode: dont care 10-bit addressing mode: bits 9:8 of address Note: These bits can be written only when OA1EN=0. OA1[7:1]: Interface address Bits 7:1 of address Note: These bits can be written only when OA1EN=0. OA1[0]: Interface address 7-bit addressing mode: dont care 10-bit addressing mode: bit 0 of address Note: This bit can be written only when OA1EN=0. (10 bits)
        bit_field_t<0, 0x3ff>::value<X>();
    static constexpr uint32_t OAR1_OA1MODE = 0x400;      // Own Address 1 10-bit mode Note: This bit can be written only when OA1EN=0.
    static constexpr uint32_t OAR1_OA1EN = 0x8000;       // Own Address 1 enable
    static const uint32_t OAR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OAR2_OA2 =                 // Interface address bits 7:1 of address Note: These bits can be written only when OA2EN=0. (7 bits)
        bit_field_t<1, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OAR2_OA2MSK =              // Own Address 2 masks Note: These bits can be written only when OA2EN=0. As soon as OA2MSK is not equal to 0, the reserved I2C addresses (0b0000xxx and 0b1111xxx) are not acknowledged even if the comparison matches. (3 bits)
        bit_field_t<8, 0x7>::value<X>();
    static constexpr uint32_t OAR2_OA2EN = 0x8000;       // Own Address 2 enable
    static const uint32_t OAR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TIMINGR_SCLL =                // SCL low period (master mode) This field is used to generate the SCL low period in master mode. tSCLL = (SCLL+1) x tPRESC Note: SCLL is also used to generate tBUF and tSU:STA timings. (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TIMINGR_SCLH =                // SCL high period (master mode) This field is used to generate the SCL high period in master mode. tSCLH = (SCLH+1) x tPRESC Note: SCLH is also used to generate tSU:STO and tHD:STA timing. (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TIMINGR_SDADEL =              // Data hold time This field is used to generate the delay tSDADEL between SCL falling edge and SDA edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tSDADEL. tSDADEL= SDADEL x tPRESC Note: SDADEL is used to generate tHD:DAT timing. (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TIMINGR_SCLDEL =              // Data setup time This field is used to generate a delay tSCLDEL between SDA edge and SCL rising edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tSCLDEL. tSCLDEL = (SCLDEL+1) x tPRESC Note: tSCLDEL is used to generate tSU:DAT timing. (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TIMINGR_PRESC =               // Timing prescaler This field is used to prescale I2CCLK in order to generate the clock period tPRESC used for data setup and hold counters (refer to I2C timings on page9) and for SCL high and low level counters (refer to I2C master initialization on page24). tPRESC = (PRESC+1) x tI2CCLK (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    static const uint32_t TIMINGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TIMEOUTR_TIMEOUTA =            // Bus Timeout A This field is used to configure: The SCL low timeout condition tTIMEOUT when TIDLE=0 tTIMEOUT= (TIMEOUTA+1) x 2048 x tI2CCLK The bus idle condition (both SCL and SDA high) when TIDLE=1 tIDLE= (TIMEOUTA+1) x 4 x tI2CCLK Note: These bits can be written only when TIMOUTEN=0. (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static constexpr uint32_t TIMEOUTR_TIDLE = 0x1000;       // Idle clock timeout detection Note: This bit can be written only when TIMOUTEN=0.
    static constexpr uint32_t TIMEOUTR_TIMOUTEN = 0x8000;    // Clock timeout enable
    template<uint32_t X>
    static constexpr uint32_t TIMEOUTR_TIMEOUTB =            // Bus timeout B This field is used to configure the cumulative clock extension timeout: In master mode, the master cumulative clock low extend time (tLOW:MEXT) is detected In slave mode, the slave cumulative clock low extend time (tLOW:SEXT) is detected tLOW:EXT= (TIMEOUTB+1) x 2048 x tI2CCLK Note: These bits can be written only when TEXTEN=0. (12 bits)
        bit_field_t<16, 0xfff>::value<X>();
    static constexpr uint32_t TIMEOUTR_TEXTEN = 0x80000000;  // Extended clock timeout enable
    static const uint32_t TIMEOUTR_RESET_VALUE = 0x0;

    static constexpr uint32_t ISR_TXE = 0x1;            // Transmit data register empty (transmitters) This bit is set by hardware when the I2C_TXDR register is empty. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software in order to flush the transmit data register I2C_TXDR. Note: This bit is set by hardware when PE=0., Read-write
    static constexpr uint32_t ISR_TXIS = 0x2;           // Transmit interrupt status (transmitters) This bit is set by hardware when the I2C_TXDR register is empty and the data to be transmitted must be written in the I2C_TXDR register. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software when NOSTRETCH=1 only, in order to generate a TXIS event (interrupt if TXIE=1 or DMA request if TXDMAEN=1). Note: This bit is cleared by hardware when PE=0., Read-write
    static constexpr uint32_t ISR_RXNE = 0x4;           // Receive data register not empty (receivers) This bit is set by hardware when the received data is copied into the I2C_RXDR register, and is ready to be read. It is cleared when I2C_RXDR is read. Note: This bit is cleared by hardware when PE=0., Read-only
    static constexpr uint32_t ISR_ADDR = 0x8;           // Address matched (slave mode) This bit is set by hardware as soon as the received slave address matched with one of the enabled slave addresses. It is cleared by software by setting ADDRCF bit. Note: This bit is cleared by hardware when PE=0., Read-only
    static constexpr uint32_t ISR_NACKF = 0x10;         // Not Acknowledge received flag This flag is set by hardware when a NACK is received after a byte transmission. It is cleared by software by setting the NACKCF bit. Note: This bit is cleared by hardware when PE=0., Read-only
    static constexpr uint32_t ISR_STOPF = 0x20;         // Stop detection flag This flag is set by hardware when a Stop condition is detected on the bus and the peripheral is involved in this transfer: either as a master, provided that the STOP condition is generated by the peripheral. or as a slave, provided that the peripheral has been addressed previously during this transfer. It is cleared by software by setting the STOPCF bit. Note: This bit is cleared by hardware when PE=0., Read-only
    static constexpr uint32_t ISR_TC = 0x40;            // Transfer Complete (master mode) This flag is set by hardware when RELOAD=0, AUTOEND=0 and NBYTES data have been transferred. It is cleared by software when START bit or STOP bit is set. Note: This bit is cleared by hardware when PE=0., Read-only
    static constexpr uint32_t ISR_TCR = 0x80;           // Transfer Complete Reload This flag is set by hardware when RELOAD=1 and NBYTES data have been transferred. It is cleared by software when NBYTES is written to a non-zero value. Note: This bit is cleared by hardware when PE=0. This flag is only for master mode, or for slave mode when the SBC bit is set., Read-only
    static constexpr uint32_t ISR_BERR = 0x100;         // Bus error This flag is set by hardware when a misplaced Start or Stop condition is detected whereas the peripheral is involved in the transfer. The flag is not set during the address phase in slave mode. It is cleared by software by setting BERRCF bit. Note: This bit is cleared by hardware when PE=0., Read-only
    static constexpr uint32_t ISR_ARLO = 0x200;         // Arbitration lost This flag is set by hardware in case of arbitration loss. It is cleared by software by setting the ARLOCF bit. Note: This bit is cleared by hardware when PE=0., Read-only
    static constexpr uint32_t ISR_OVR = 0x400;          // Overrun/Underrun (slave mode) This flag is set by hardware in slave mode with NOSTRETCH=1, when an overrun/underrun error occurs. It is cleared by software by setting the OVRCF bit. Note: This bit is cleared by hardware when PE=0., Read-only
    static constexpr uint32_t ISR_PECERR = 0x800;       // PEC Error in reception This flag is set by hardware when the received PEC does not match with the PEC register content. A NACK is automatically sent after the wrong PEC reception. It is cleared by software by setting the PECCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation., Read-only
    static constexpr uint32_t ISR_TIMEOUT = 0x1000;     // Timeout or tLOW detection flag This flag is set by hardware when a timeout or extended clock timeout occurred. It is cleared by software by setting the TIMEOUTCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation., Read-only
    static constexpr uint32_t ISR_ALERT = 0x2000;       // SMBus alert This flag is set by hardware when SMBHEN=1 (SMBus host configuration), ALERTEN=1 and a SMBALERT event (falling edge) is detected on SMBA pin. It is cleared by software by setting the ALERTCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation., Read-only
    static constexpr uint32_t ISR_BUSY = 0x8000;        // Bus busy This flag indicates that a communication is in progress on the bus. It is set by hardware when a START condition is detected. It is cleared by hardware when a Stop condition is detected, or when PE=0., Read-only
    static constexpr uint32_t ISR_DIR = 0x10000;        // Transfer direction (Slave mode) This flag is updated when an address match event occurs (ADDR=1)., Read-only
    template<uint32_t X>
    static constexpr uint32_t ISR_ADDCODE =             // Address match code (Slave mode) These bits are updated with the received address when an address match event occurs (ADDR = 1). In the case of a 10-bit address, ADDCODE provides the 10-bit header followed by the 2 MSBs of the address. (7 bits), Read-only
        bit_field_t<17, 0x7f>::value<X>();
    static const uint32_t ISR_RESET_VALUE = 0x1;

    static constexpr uint32_t ICR_ADDRCF = 0x8;         // Address matched flag clear Writing 1 to this bit clears the ADDR flag in the I2C_ISR register. Writing 1 to this bit also clears the START bit in the I2C_CR2 register.
    static constexpr uint32_t ICR_NACKCF = 0x10;        // Not Acknowledge flag clear Writing 1 to this bit clears the ACKF flag in I2C_ISR register.
    static constexpr uint32_t ICR_STOPCF = 0x20;        // Stop detection flag clear Writing 1 to this bit clears the STOPF flag in the I2C_ISR register.
    static constexpr uint32_t ICR_BERRCF = 0x100;       // Bus error flag clear Writing 1 to this bit clears the BERRF flag in the I2C_ISR register.
    static constexpr uint32_t ICR_ARLOCF = 0x200;       // Arbitration Lost flag clear Writing 1 to this bit clears the ARLO flag in the I2C_ISR register.
    static constexpr uint32_t ICR_OVRCF = 0x400;        // Overrun/Underrun flag clear Writing 1 to this bit clears the OVR flag in the I2C_ISR register.
    static constexpr uint32_t ICR_PECCF = 0x800;        // PEC Error flag clear Writing 1 to this bit clears the PECERR flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    static constexpr uint32_t ICR_TIMOUTCF = 0x1000;    // Timeout detection flag clear Writing 1 to this bit clears the TIMEOUT flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    static constexpr uint32_t ICR_ALERTCF = 0x2000;     // Alert flag clear Writing 1 to this bit clears the ALERT flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    static const uint32_t ICR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PECR_PEC =                 // Packet error checking register This field contains the internal PEC when PECEN=1. The PEC is cleared by hardware when PE=0. (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t PECR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RXDR_RXDATA =              // 8-bit receive data Data byte received from the I2C bus. (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t RXDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TXDR_TXDATA =              // 8-bit transmit data Data byte to be transmitted to the I2C bus. Note: These bits can be written only when TXE=1. (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t TXDR_RESET_VALUE = 0x0;

    static constexpr uint8_t I2C2_ER = 34; // I2C2 error interrupt
    static constexpr uint8_t I2C2_EV = 33; // I2C2 event interrupt
};

static i2c2_t& I2C2 = *reinterpret_cast<i2c2_t*>(0x40005800);

#define HAVE_PERIPHERAL_I2C2


////
//
//    I2C
//
////

struct i2c3_t
{
    volatile uint32_t    CR1;                  // [Read-write] Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
    volatile uint32_t    CR2;                  // [Read-write] Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
    volatile uint32_t    OAR1;                 // [Read-write] Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
    volatile uint32_t    OAR2;                 // [Read-write] Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
    volatile uint32_t    TIMINGR;              // [Read-write] Access: No wait states
    volatile uint32_t    TIMEOUTR;             // [Read-write] Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
    volatile uint32_t    ISR;                  // Access: No wait states
    volatile uint32_t    ICR;                  // [Write-only] Access: No wait states
    volatile uint32_t    PECR;                 // [Read-only] Access: No wait states
    volatile uint32_t    RXDR;                 // [Read-only] Access: No wait states
    volatile uint32_t    TXDR;                 // [Read-write] Access: No wait states

    static constexpr uint32_t CR1_PE = 0x1;             // Peripheral enable Note: When PE=0, the I2C SCL and SDA lines are released. Internal state machines and status bits are put back to their reset value. When cleared, PE must be kept low for at least 3 APB clock cycles.
    static constexpr uint32_t CR1_TXIE = 0x2;           // TX Interrupt enable
    static constexpr uint32_t CR1_RXIE = 0x4;           // RX Interrupt enable
    static constexpr uint32_t CR1_ADDRIE = 0x8;         // Address match Interrupt enable (slave only)
    static constexpr uint32_t CR1_NACKIE = 0x10;        // Not acknowledge received Interrupt enable
    static constexpr uint32_t CR1_STOPIE = 0x20;        // STOP detection Interrupt enable
    static constexpr uint32_t CR1_TCIE = 0x40;          // Transfer Complete interrupt enable Note: Any of these events will generate an interrupt: Transfer Complete (TC) Transfer Complete Reload (TCR)
    static constexpr uint32_t CR1_ERRIE = 0x80;         // Error interrupts enable Note: Any of these errors generate an interrupt: Arbitration Loss (ARLO) Bus Error detection (BERR) Overrun/Underrun (OVR) Timeout detection (TIMEOUT) PEC error detection (PECERR) Alert pin event detection (ALERT)
    template<uint32_t X>
    static constexpr uint32_t CR1_DNF =                 // Digital noise filter These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter will filter spikes with a length of up to DNF[3:0] * tI2CCLK ... Note: If the analog filter is also enabled, the digital filter is added to the analog filter. This filter can only be programmed when the I2C is disabled (PE = 0). (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    static constexpr uint32_t CR1_ANFOFF = 0x1000;      // Analog noise filter OFF Note: This bit can only be programmed when the I2C is disabled (PE = 0).
    static constexpr uint32_t CR1_TXDMAEN = 0x4000;     // DMA transmission requests enable
    static constexpr uint32_t CR1_RXDMAEN = 0x8000;     // DMA reception requests enable
    static constexpr uint32_t CR1_SBC = 0x10000;        // Slave byte control This bit is used to enable hardware byte control in slave mode.
    static constexpr uint32_t CR1_NOSTRETCH = 0x20000;  // Clock stretching disable This bit is used to disable clock stretching in slave mode. It must be kept cleared in master mode. Note: This bit can only be programmed when the I2C is disabled (PE = 0).
    static constexpr uint32_t CR1_WUPEN = 0x40000;      // Wakeup from Stop mode enable Note: If the Wakeup from Stop mode feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation. Note: WUPEN can be set only when DNF = 0000
    static constexpr uint32_t CR1_GCEN = 0x80000;       // General call enable
    static constexpr uint32_t CR1_SMBHEN = 0x100000;    // SMBus Host address enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    static constexpr uint32_t CR1_SMBDEN = 0x200000;    // SMBus Device Default address enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    static constexpr uint32_t CR1_ALERTEN = 0x400000;   // SMBus alert enable Device mode (SMBHEN=0): Host mode (SMBHEN=1): Note: When ALERTEN=0, the SMBA pin can be used as a standard GPIO. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    static constexpr uint32_t CR1_PECEN = 0x800000;     // PEC enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    static const uint32_t CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CR2_SADD0 = 0x1;          // Slave address bit 0 (master mode) In 7-bit addressing mode (ADD10 = 0): This bit is dont care In 10-bit addressing mode (ADD10 = 1): This bit should be written with bit 0 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
    static constexpr uint32_t CR2_SADD1 = 0x2;          // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    static constexpr uint32_t CR2_SADD2 = 0x4;          // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    static constexpr uint32_t CR2_SADD3 = 0x8;          // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    static constexpr uint32_t CR2_SADD4 = 0x10;         // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    static constexpr uint32_t CR2_SADD5 = 0x20;         // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    static constexpr uint32_t CR2_SADD6 = 0x40;         // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    static constexpr uint32_t CR2_SADD7 = 0x80;         // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    static constexpr uint32_t CR2_SADD8 = 0x100;        // Slave address bit 9:8 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits are dont care In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 9:8 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
    static constexpr uint32_t CR2_SADD9 = 0x200;        // Slave address bit 9:8 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits are dont care In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 9:8 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
    static constexpr uint32_t CR2_RD_WRN = 0x400;       // Transfer direction (master mode) Note: Changing this bit when the START bit is set is not allowed.
    static constexpr uint32_t CR2_ADD10 = 0x800;        // 10-bit addressing mode (master mode) Note: Changing this bit when the START bit is set is not allowed.
    static constexpr uint32_t CR2_HEAD10R = 0x1000;     // 10-bit address header only read direction (master receiver mode) Note: Changing this bit when the START bit is set is not allowed.
    static constexpr uint32_t CR2_START = 0x2000;       // Start generation This bit is set by software, and cleared by hardware after the Start followed by the address sequence is sent, by an arbitration loss, by a timeout error detection, or when PE = 0. It can also be cleared by software by writing 1 to the ADDRCF bit in the I2C_ICR register. If the I2C is already in master mode with AUTOEND = 0, setting this bit generates a Repeated Start condition when RELOAD=0, after the end of the NBYTES transfer. Otherwise setting this bit will generate a START condition once the bus is free. Note: Writing 0 to this bit has no effect. The START bit can be set even if the bus is BUSY or I2C is in slave mode. This bit has no effect when RELOAD is set.
    static constexpr uint32_t CR2_STOP = 0x4000;        // Stop generation (master mode) The bit is set by software, cleared by hardware when a Stop condition is detected, or when PE = 0. In Master Mode: Note: Writing 0 to this bit has no effect.
    static constexpr uint32_t CR2_NACK = 0x8000;        // NACK generation (slave mode) The bit is set by software, cleared by hardware when the NACK is sent, or when a STOP condition or an Address matched is received, or when PE=0. Note: Writing 0 to this bit has no effect. This bit is used in slave mode only: in master receiver mode, NACK is automatically generated after last byte preceding STOP or RESTART condition, whatever the NACK bit value. When an overrun occurs in slave receiver NOSTRETCH mode, a NACK is automatically generated whatever the NACK bit value. When hardware PEC checking is enabled (PECBYTE=1), the PEC acknowledge value does not depend on the NACK value.
    template<uint32_t X>
    static constexpr uint32_t CR2_NBYTES =              // Number of bytes The number of bytes to be transmitted/received is programmed there. This field is dont care in slave mode with SBC=0. Note: Changing these bits when the START bit is set is not allowed. (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static constexpr uint32_t CR2_RELOAD = 0x1000000;   // NBYTES reload mode This bit is set and cleared by software.
    static constexpr uint32_t CR2_AUTOEND = 0x2000000;  // Automatic end mode (master mode) This bit is set and cleared by software. Note: This bit has no effect in slave mode or when the RELOAD bit is set.
    static constexpr uint32_t CR2_PECBYTE = 0x4000000;  // Packet error checking byte This bit is set by software, and cleared by hardware when the PEC is transferred, or when a STOP condition or an Address matched is received, also when PE=0. Note: Writing 0 to this bit has no effect. This bit has no effect when RELOAD is set. This bit has no effect is slave mode when SBC=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    static const uint32_t CR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OAR1_OA1 =                 // Interface address 7-bit addressing mode: dont care 10-bit addressing mode: bits 9:8 of address Note: These bits can be written only when OA1EN=0. OA1[7:1]: Interface address Bits 7:1 of address Note: These bits can be written only when OA1EN=0. OA1[0]: Interface address 7-bit addressing mode: dont care 10-bit addressing mode: bit 0 of address Note: This bit can be written only when OA1EN=0. (10 bits)
        bit_field_t<0, 0x3ff>::value<X>();
    static constexpr uint32_t OAR1_OA1MODE = 0x400;      // Own Address 1 10-bit mode Note: This bit can be written only when OA1EN=0.
    static constexpr uint32_t OAR1_OA1EN = 0x8000;       // Own Address 1 enable
    static const uint32_t OAR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OAR2_OA2 =                 // Interface address bits 7:1 of address Note: These bits can be written only when OA2EN=0. (7 bits)
        bit_field_t<1, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OAR2_OA2MSK =              // Own Address 2 masks Note: These bits can be written only when OA2EN=0. As soon as OA2MSK is not equal to 0, the reserved I2C addresses (0b0000xxx and 0b1111xxx) are not acknowledged even if the comparison matches. (3 bits)
        bit_field_t<8, 0x7>::value<X>();
    static constexpr uint32_t OAR2_OA2EN = 0x8000;       // Own Address 2 enable
    static const uint32_t OAR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TIMINGR_SCLL =                // SCL low period (master mode) This field is used to generate the SCL low period in master mode. tSCLL = (SCLL+1) x tPRESC Note: SCLL is also used to generate tBUF and tSU:STA timings. (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TIMINGR_SCLH =                // SCL high period (master mode) This field is used to generate the SCL high period in master mode. tSCLH = (SCLH+1) x tPRESC Note: SCLH is also used to generate tSU:STO and tHD:STA timing. (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TIMINGR_SDADEL =              // Data hold time This field is used to generate the delay tSDADEL between SCL falling edge and SDA edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tSDADEL. tSDADEL= SDADEL x tPRESC Note: SDADEL is used to generate tHD:DAT timing. (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TIMINGR_SCLDEL =              // Data setup time This field is used to generate a delay tSCLDEL between SDA edge and SCL rising edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tSCLDEL. tSCLDEL = (SCLDEL+1) x tPRESC Note: tSCLDEL is used to generate tSU:DAT timing. (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TIMINGR_PRESC =               // Timing prescaler This field is used to prescale I2CCLK in order to generate the clock period tPRESC used for data setup and hold counters (refer to I2C timings on page9) and for SCL high and low level counters (refer to I2C master initialization on page24). tPRESC = (PRESC+1) x tI2CCLK (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    static const uint32_t TIMINGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TIMEOUTR_TIMEOUTA =            // Bus Timeout A This field is used to configure: The SCL low timeout condition tTIMEOUT when TIDLE=0 tTIMEOUT= (TIMEOUTA+1) x 2048 x tI2CCLK The bus idle condition (both SCL and SDA high) when TIDLE=1 tIDLE= (TIMEOUTA+1) x 4 x tI2CCLK Note: These bits can be written only when TIMOUTEN=0. (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static constexpr uint32_t TIMEOUTR_TIDLE = 0x1000;       // Idle clock timeout detection Note: This bit can be written only when TIMOUTEN=0.
    static constexpr uint32_t TIMEOUTR_TIMOUTEN = 0x8000;    // Clock timeout enable
    template<uint32_t X>
    static constexpr uint32_t TIMEOUTR_TIMEOUTB =            // Bus timeout B This field is used to configure the cumulative clock extension timeout: In master mode, the master cumulative clock low extend time (tLOW:MEXT) is detected In slave mode, the slave cumulative clock low extend time (tLOW:SEXT) is detected tLOW:EXT= (TIMEOUTB+1) x 2048 x tI2CCLK Note: These bits can be written only when TEXTEN=0. (12 bits)
        bit_field_t<16, 0xfff>::value<X>();
    static constexpr uint32_t TIMEOUTR_TEXTEN = 0x80000000;  // Extended clock timeout enable
    static const uint32_t TIMEOUTR_RESET_VALUE = 0x0;

    static constexpr uint32_t ISR_TXE = 0x1;            // Transmit data register empty (transmitters) This bit is set by hardware when the I2C_TXDR register is empty. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software in order to flush the transmit data register I2C_TXDR. Note: This bit is set by hardware when PE=0., Read-write
    static constexpr uint32_t ISR_TXIS = 0x2;           // Transmit interrupt status (transmitters) This bit is set by hardware when the I2C_TXDR register is empty and the data to be transmitted must be written in the I2C_TXDR register. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software when NOSTRETCH=1 only, in order to generate a TXIS event (interrupt if TXIE=1 or DMA request if TXDMAEN=1). Note: This bit is cleared by hardware when PE=0., Read-write
    static constexpr uint32_t ISR_RXNE = 0x4;           // Receive data register not empty (receivers) This bit is set by hardware when the received data is copied into the I2C_RXDR register, and is ready to be read. It is cleared when I2C_RXDR is read. Note: This bit is cleared by hardware when PE=0., Read-only
    static constexpr uint32_t ISR_ADDR = 0x8;           // Address matched (slave mode) This bit is set by hardware as soon as the received slave address matched with one of the enabled slave addresses. It is cleared by software by setting ADDRCF bit. Note: This bit is cleared by hardware when PE=0., Read-only
    static constexpr uint32_t ISR_NACKF = 0x10;         // Not Acknowledge received flag This flag is set by hardware when a NACK is received after a byte transmission. It is cleared by software by setting the NACKCF bit. Note: This bit is cleared by hardware when PE=0., Read-only
    static constexpr uint32_t ISR_STOPF = 0x20;         // Stop detection flag This flag is set by hardware when a Stop condition is detected on the bus and the peripheral is involved in this transfer: either as a master, provided that the STOP condition is generated by the peripheral. or as a slave, provided that the peripheral has been addressed previously during this transfer. It is cleared by software by setting the STOPCF bit. Note: This bit is cleared by hardware when PE=0., Read-only
    static constexpr uint32_t ISR_TC = 0x40;            // Transfer Complete (master mode) This flag is set by hardware when RELOAD=0, AUTOEND=0 and NBYTES data have been transferred. It is cleared by software when START bit or STOP bit is set. Note: This bit is cleared by hardware when PE=0., Read-only
    static constexpr uint32_t ISR_TCR = 0x80;           // Transfer Complete Reload This flag is set by hardware when RELOAD=1 and NBYTES data have been transferred. It is cleared by software when NBYTES is written to a non-zero value. Note: This bit is cleared by hardware when PE=0. This flag is only for master mode, or for slave mode when the SBC bit is set., Read-only
    static constexpr uint32_t ISR_BERR = 0x100;         // Bus error This flag is set by hardware when a misplaced Start or Stop condition is detected whereas the peripheral is involved in the transfer. The flag is not set during the address phase in slave mode. It is cleared by software by setting BERRCF bit. Note: This bit is cleared by hardware when PE=0., Read-only
    static constexpr uint32_t ISR_ARLO = 0x200;         // Arbitration lost This flag is set by hardware in case of arbitration loss. It is cleared by software by setting the ARLOCF bit. Note: This bit is cleared by hardware when PE=0., Read-only
    static constexpr uint32_t ISR_OVR = 0x400;          // Overrun/Underrun (slave mode) This flag is set by hardware in slave mode with NOSTRETCH=1, when an overrun/underrun error occurs. It is cleared by software by setting the OVRCF bit. Note: This bit is cleared by hardware when PE=0., Read-only
    static constexpr uint32_t ISR_PECERR = 0x800;       // PEC Error in reception This flag is set by hardware when the received PEC does not match with the PEC register content. A NACK is automatically sent after the wrong PEC reception. It is cleared by software by setting the PECCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation., Read-only
    static constexpr uint32_t ISR_TIMEOUT = 0x1000;     // Timeout or tLOW detection flag This flag is set by hardware when a timeout or extended clock timeout occurred. It is cleared by software by setting the TIMEOUTCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation., Read-only
    static constexpr uint32_t ISR_ALERT = 0x2000;       // SMBus alert This flag is set by hardware when SMBHEN=1 (SMBus host configuration), ALERTEN=1 and a SMBALERT event (falling edge) is detected on SMBA pin. It is cleared by software by setting the ALERTCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation., Read-only
    static constexpr uint32_t ISR_BUSY = 0x8000;        // Bus busy This flag indicates that a communication is in progress on the bus. It is set by hardware when a START condition is detected. It is cleared by hardware when a Stop condition is detected, or when PE=0., Read-only
    static constexpr uint32_t ISR_DIR = 0x10000;        // Transfer direction (Slave mode) This flag is updated when an address match event occurs (ADDR=1)., Read-only
    template<uint32_t X>
    static constexpr uint32_t ISR_ADDCODE =             // Address match code (Slave mode) These bits are updated with the received address when an address match event occurs (ADDR = 1). In the case of a 10-bit address, ADDCODE provides the 10-bit header followed by the 2 MSBs of the address. (7 bits), Read-only
        bit_field_t<17, 0x7f>::value<X>();
    static const uint32_t ISR_RESET_VALUE = 0x1;

    static constexpr uint32_t ICR_ADDRCF = 0x8;         // Address matched flag clear Writing 1 to this bit clears the ADDR flag in the I2C_ISR register. Writing 1 to this bit also clears the START bit in the I2C_CR2 register.
    static constexpr uint32_t ICR_NACKCF = 0x10;        // Not Acknowledge flag clear Writing 1 to this bit clears the ACKF flag in I2C_ISR register.
    static constexpr uint32_t ICR_STOPCF = 0x20;        // Stop detection flag clear Writing 1 to this bit clears the STOPF flag in the I2C_ISR register.
    static constexpr uint32_t ICR_BERRCF = 0x100;       // Bus error flag clear Writing 1 to this bit clears the BERRF flag in the I2C_ISR register.
    static constexpr uint32_t ICR_ARLOCF = 0x200;       // Arbitration Lost flag clear Writing 1 to this bit clears the ARLO flag in the I2C_ISR register.
    static constexpr uint32_t ICR_OVRCF = 0x400;        // Overrun/Underrun flag clear Writing 1 to this bit clears the OVR flag in the I2C_ISR register.
    static constexpr uint32_t ICR_PECCF = 0x800;        // PEC Error flag clear Writing 1 to this bit clears the PECERR flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    static constexpr uint32_t ICR_TIMOUTCF = 0x1000;    // Timeout detection flag clear Writing 1 to this bit clears the TIMEOUT flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    static constexpr uint32_t ICR_ALERTCF = 0x2000;     // Alert flag clear Writing 1 to this bit clears the ALERT flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    static const uint32_t ICR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PECR_PEC =                 // Packet error checking register This field contains the internal PEC when PECEN=1. The PEC is cleared by hardware when PE=0. (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t PECR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RXDR_RXDATA =              // 8-bit receive data Data byte received from the I2C bus. (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t RXDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TXDR_TXDATA =              // 8-bit transmit data Data byte to be transmitted to the I2C bus. Note: These bits can be written only when TXE=1. (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t TXDR_RESET_VALUE = 0x0;

    static constexpr uint8_t I2C3_ER = 73; // I2C3 error interrupt
    static constexpr uint8_t I2C3_EV = 72; // I2C3 event interrupt
};

static i2c3_t& I2C3 = *reinterpret_cast<i2c3_t*>(0x40005c00);

#define HAVE_PERIPHERAL_I2C3


////
//
//    I2C
//
////

struct i2c4_t
{
    volatile uint32_t    CR1;                  // [Read-write] Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
    volatile uint32_t    CR2;                  // [Read-write] Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
    volatile uint32_t    OAR1;                 // [Read-write] Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
    volatile uint32_t    OAR2;                 // [Read-write] Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
    volatile uint32_t    TIMINGR;              // [Read-write] Access: No wait states
    volatile uint32_t    TIMEOUTR;             // [Read-write] Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
    volatile uint32_t    ISR;                  // Access: No wait states
    volatile uint32_t    ICR;                  // [Write-only] Access: No wait states
    volatile uint32_t    PECR;                 // [Read-only] Access: No wait states
    volatile uint32_t    RXDR;                 // [Read-only] Access: No wait states
    volatile uint32_t    TXDR;                 // [Read-write] Access: No wait states

    static constexpr uint32_t CR1_PE = 0x1;             // Peripheral enable Note: When PE=0, the I2C SCL and SDA lines are released. Internal state machines and status bits are put back to their reset value. When cleared, PE must be kept low for at least 3 APB clock cycles.
    static constexpr uint32_t CR1_TXIE = 0x2;           // TX Interrupt enable
    static constexpr uint32_t CR1_RXIE = 0x4;           // RX Interrupt enable
    static constexpr uint32_t CR1_ADDRIE = 0x8;         // Address match Interrupt enable (slave only)
    static constexpr uint32_t CR1_NACKIE = 0x10;        // Not acknowledge received Interrupt enable
    static constexpr uint32_t CR1_STOPIE = 0x20;        // STOP detection Interrupt enable
    static constexpr uint32_t CR1_TCIE = 0x40;          // Transfer Complete interrupt enable Note: Any of these events will generate an interrupt: Transfer Complete (TC) Transfer Complete Reload (TCR)
    static constexpr uint32_t CR1_ERRIE = 0x80;         // Error interrupts enable Note: Any of these errors generate an interrupt: Arbitration Loss (ARLO) Bus Error detection (BERR) Overrun/Underrun (OVR) Timeout detection (TIMEOUT) PEC error detection (PECERR) Alert pin event detection (ALERT)
    template<uint32_t X>
    static constexpr uint32_t CR1_DNF =                 // Digital noise filter These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter will filter spikes with a length of up to DNF[3:0] * tI2CCLK ... Note: If the analog filter is also enabled, the digital filter is added to the analog filter. This filter can only be programmed when the I2C is disabled (PE = 0). (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    static constexpr uint32_t CR1_ANFOFF = 0x1000;      // Analog noise filter OFF Note: This bit can only be programmed when the I2C is disabled (PE = 0).
    static constexpr uint32_t CR1_TXDMAEN = 0x4000;     // DMA transmission requests enable
    static constexpr uint32_t CR1_RXDMAEN = 0x8000;     // DMA reception requests enable
    static constexpr uint32_t CR1_SBC = 0x10000;        // Slave byte control This bit is used to enable hardware byte control in slave mode.
    static constexpr uint32_t CR1_NOSTRETCH = 0x20000;  // Clock stretching disable This bit is used to disable clock stretching in slave mode. It must be kept cleared in master mode. Note: This bit can only be programmed when the I2C is disabled (PE = 0).
    static constexpr uint32_t CR1_WUPEN = 0x40000;      // Wakeup from Stop mode enable Note: If the Wakeup from Stop mode feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation. Note: WUPEN can be set only when DNF = 0000
    static constexpr uint32_t CR1_GCEN = 0x80000;       // General call enable
    static constexpr uint32_t CR1_SMBHEN = 0x100000;    // SMBus Host address enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    static constexpr uint32_t CR1_SMBDEN = 0x200000;    // SMBus Device Default address enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    static constexpr uint32_t CR1_ALERTEN = 0x400000;   // SMBus alert enable Device mode (SMBHEN=0): Host mode (SMBHEN=1): Note: When ALERTEN=0, the SMBA pin can be used as a standard GPIO. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    static constexpr uint32_t CR1_PECEN = 0x800000;     // PEC enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    static const uint32_t CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CR2_SADD0 = 0x1;          // Slave address bit 0 (master mode) In 7-bit addressing mode (ADD10 = 0): This bit is dont care In 10-bit addressing mode (ADD10 = 1): This bit should be written with bit 0 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
    static constexpr uint32_t CR2_SADD1 = 0x2;          // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    static constexpr uint32_t CR2_SADD2 = 0x4;          // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    static constexpr uint32_t CR2_SADD3 = 0x8;          // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    static constexpr uint32_t CR2_SADD4 = 0x10;         // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    static constexpr uint32_t CR2_SADD5 = 0x20;         // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    static constexpr uint32_t CR2_SADD6 = 0x40;         // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    static constexpr uint32_t CR2_SADD7 = 0x80;         // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    static constexpr uint32_t CR2_SADD8 = 0x100;        // Slave address bit 9:8 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits are dont care In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 9:8 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
    static constexpr uint32_t CR2_SADD9 = 0x200;        // Slave address bit 9:8 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits are dont care In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 9:8 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
    static constexpr uint32_t CR2_RD_WRN = 0x400;       // Transfer direction (master mode) Note: Changing this bit when the START bit is set is not allowed.
    static constexpr uint32_t CR2_ADD10 = 0x800;        // 10-bit addressing mode (master mode) Note: Changing this bit when the START bit is set is not allowed.
    static constexpr uint32_t CR2_HEAD10R = 0x1000;     // 10-bit address header only read direction (master receiver mode) Note: Changing this bit when the START bit is set is not allowed.
    static constexpr uint32_t CR2_START = 0x2000;       // Start generation This bit is set by software, and cleared by hardware after the Start followed by the address sequence is sent, by an arbitration loss, by a timeout error detection, or when PE = 0. It can also be cleared by software by writing 1 to the ADDRCF bit in the I2C_ICR register. If the I2C is already in master mode with AUTOEND = 0, setting this bit generates a Repeated Start condition when RELOAD=0, after the end of the NBYTES transfer. Otherwise setting this bit will generate a START condition once the bus is free. Note: Writing 0 to this bit has no effect. The START bit can be set even if the bus is BUSY or I2C is in slave mode. This bit has no effect when RELOAD is set.
    static constexpr uint32_t CR2_STOP = 0x4000;        // Stop generation (master mode) The bit is set by software, cleared by hardware when a Stop condition is detected, or when PE = 0. In Master Mode: Note: Writing 0 to this bit has no effect.
    static constexpr uint32_t CR2_NACK = 0x8000;        // NACK generation (slave mode) The bit is set by software, cleared by hardware when the NACK is sent, or when a STOP condition or an Address matched is received, or when PE=0. Note: Writing 0 to this bit has no effect. This bit is used in slave mode only: in master receiver mode, NACK is automatically generated after last byte preceding STOP or RESTART condition, whatever the NACK bit value. When an overrun occurs in slave receiver NOSTRETCH mode, a NACK is automatically generated whatever the NACK bit value. When hardware PEC checking is enabled (PECBYTE=1), the PEC acknowledge value does not depend on the NACK value.
    template<uint32_t X>
    static constexpr uint32_t CR2_NBYTES =              // Number of bytes The number of bytes to be transmitted/received is programmed there. This field is dont care in slave mode with SBC=0. Note: Changing these bits when the START bit is set is not allowed. (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static constexpr uint32_t CR2_RELOAD = 0x1000000;   // NBYTES reload mode This bit is set and cleared by software.
    static constexpr uint32_t CR2_AUTOEND = 0x2000000;  // Automatic end mode (master mode) This bit is set and cleared by software. Note: This bit has no effect in slave mode or when the RELOAD bit is set.
    static constexpr uint32_t CR2_PECBYTE = 0x4000000;  // Packet error checking byte This bit is set by software, and cleared by hardware when the PEC is transferred, or when a STOP condition or an Address matched is received, also when PE=0. Note: Writing 0 to this bit has no effect. This bit has no effect when RELOAD is set. This bit has no effect is slave mode when SBC=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    static const uint32_t CR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OAR1_OA1 =                 // Interface address 7-bit addressing mode: dont care 10-bit addressing mode: bits 9:8 of address Note: These bits can be written only when OA1EN=0. OA1[7:1]: Interface address Bits 7:1 of address Note: These bits can be written only when OA1EN=0. OA1[0]: Interface address 7-bit addressing mode: dont care 10-bit addressing mode: bit 0 of address Note: This bit can be written only when OA1EN=0. (10 bits)
        bit_field_t<0, 0x3ff>::value<X>();
    static constexpr uint32_t OAR1_OA1MODE = 0x400;      // Own Address 1 10-bit mode Note: This bit can be written only when OA1EN=0.
    static constexpr uint32_t OAR1_OA1EN = 0x8000;       // Own Address 1 enable
    static const uint32_t OAR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OAR2_OA2 =                 // Interface address bits 7:1 of address Note: These bits can be written only when OA2EN=0. (7 bits)
        bit_field_t<1, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OAR2_OA2MSK =              // Own Address 2 masks Note: These bits can be written only when OA2EN=0. As soon as OA2MSK is not equal to 0, the reserved I2C addresses (0b0000xxx and 0b1111xxx) are not acknowledged even if the comparison matches. (3 bits)
        bit_field_t<8, 0x7>::value<X>();
    static constexpr uint32_t OAR2_OA2EN = 0x8000;       // Own Address 2 enable
    static const uint32_t OAR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TIMINGR_SCLL =                // SCL low period (master mode) This field is used to generate the SCL low period in master mode. tSCLL = (SCLL+1) x tPRESC Note: SCLL is also used to generate tBUF and tSU:STA timings. (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TIMINGR_SCLH =                // SCL high period (master mode) This field is used to generate the SCL high period in master mode. tSCLH = (SCLH+1) x tPRESC Note: SCLH is also used to generate tSU:STO and tHD:STA timing. (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TIMINGR_SDADEL =              // Data hold time This field is used to generate the delay tSDADEL between SCL falling edge and SDA edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tSDADEL. tSDADEL= SDADEL x tPRESC Note: SDADEL is used to generate tHD:DAT timing. (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TIMINGR_SCLDEL =              // Data setup time This field is used to generate a delay tSCLDEL between SDA edge and SCL rising edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tSCLDEL. tSCLDEL = (SCLDEL+1) x tPRESC Note: tSCLDEL is used to generate tSU:DAT timing. (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TIMINGR_PRESC =               // Timing prescaler This field is used to prescale I2CCLK in order to generate the clock period tPRESC used for data setup and hold counters (refer to I2C timings on page9) and for SCL high and low level counters (refer to I2C master initialization on page24). tPRESC = (PRESC+1) x tI2CCLK (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    static const uint32_t TIMINGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TIMEOUTR_TIMEOUTA =            // Bus Timeout A This field is used to configure: The SCL low timeout condition tTIMEOUT when TIDLE=0 tTIMEOUT= (TIMEOUTA+1) x 2048 x tI2CCLK The bus idle condition (both SCL and SDA high) when TIDLE=1 tIDLE= (TIMEOUTA+1) x 4 x tI2CCLK Note: These bits can be written only when TIMOUTEN=0. (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static constexpr uint32_t TIMEOUTR_TIDLE = 0x1000;       // Idle clock timeout detection Note: This bit can be written only when TIMOUTEN=0.
    static constexpr uint32_t TIMEOUTR_TIMOUTEN = 0x8000;    // Clock timeout enable
    template<uint32_t X>
    static constexpr uint32_t TIMEOUTR_TIMEOUTB =            // Bus timeout B This field is used to configure the cumulative clock extension timeout: In master mode, the master cumulative clock low extend time (tLOW:MEXT) is detected In slave mode, the slave cumulative clock low extend time (tLOW:SEXT) is detected tLOW:EXT= (TIMEOUTB+1) x 2048 x tI2CCLK Note: These bits can be written only when TEXTEN=0. (12 bits)
        bit_field_t<16, 0xfff>::value<X>();
    static constexpr uint32_t TIMEOUTR_TEXTEN = 0x80000000;  // Extended clock timeout enable
    static const uint32_t TIMEOUTR_RESET_VALUE = 0x0;

    static constexpr uint32_t ISR_TXE = 0x1;            // Transmit data register empty (transmitters) This bit is set by hardware when the I2C_TXDR register is empty. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software in order to flush the transmit data register I2C_TXDR. Note: This bit is set by hardware when PE=0., Read-write
    static constexpr uint32_t ISR_TXIS = 0x2;           // Transmit interrupt status (transmitters) This bit is set by hardware when the I2C_TXDR register is empty and the data to be transmitted must be written in the I2C_TXDR register. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software when NOSTRETCH=1 only, in order to generate a TXIS event (interrupt if TXIE=1 or DMA request if TXDMAEN=1). Note: This bit is cleared by hardware when PE=0., Read-write
    static constexpr uint32_t ISR_RXNE = 0x4;           // Receive data register not empty (receivers) This bit is set by hardware when the received data is copied into the I2C_RXDR register, and is ready to be read. It is cleared when I2C_RXDR is read. Note: This bit is cleared by hardware when PE=0., Read-only
    static constexpr uint32_t ISR_ADDR = 0x8;           // Address matched (slave mode) This bit is set by hardware as soon as the received slave address matched with one of the enabled slave addresses. It is cleared by software by setting ADDRCF bit. Note: This bit is cleared by hardware when PE=0., Read-only
    static constexpr uint32_t ISR_NACKF = 0x10;         // Not Acknowledge received flag This flag is set by hardware when a NACK is received after a byte transmission. It is cleared by software by setting the NACKCF bit. Note: This bit is cleared by hardware when PE=0., Read-only
    static constexpr uint32_t ISR_STOPF = 0x20;         // Stop detection flag This flag is set by hardware when a Stop condition is detected on the bus and the peripheral is involved in this transfer: either as a master, provided that the STOP condition is generated by the peripheral. or as a slave, provided that the peripheral has been addressed previously during this transfer. It is cleared by software by setting the STOPCF bit. Note: This bit is cleared by hardware when PE=0., Read-only
    static constexpr uint32_t ISR_TC = 0x40;            // Transfer Complete (master mode) This flag is set by hardware when RELOAD=0, AUTOEND=0 and NBYTES data have been transferred. It is cleared by software when START bit or STOP bit is set. Note: This bit is cleared by hardware when PE=0., Read-only
    static constexpr uint32_t ISR_TCR = 0x80;           // Transfer Complete Reload This flag is set by hardware when RELOAD=1 and NBYTES data have been transferred. It is cleared by software when NBYTES is written to a non-zero value. Note: This bit is cleared by hardware when PE=0. This flag is only for master mode, or for slave mode when the SBC bit is set., Read-only
    static constexpr uint32_t ISR_BERR = 0x100;         // Bus error This flag is set by hardware when a misplaced Start or Stop condition is detected whereas the peripheral is involved in the transfer. The flag is not set during the address phase in slave mode. It is cleared by software by setting BERRCF bit. Note: This bit is cleared by hardware when PE=0., Read-only
    static constexpr uint32_t ISR_ARLO = 0x200;         // Arbitration lost This flag is set by hardware in case of arbitration loss. It is cleared by software by setting the ARLOCF bit. Note: This bit is cleared by hardware when PE=0., Read-only
    static constexpr uint32_t ISR_OVR = 0x400;          // Overrun/Underrun (slave mode) This flag is set by hardware in slave mode with NOSTRETCH=1, when an overrun/underrun error occurs. It is cleared by software by setting the OVRCF bit. Note: This bit is cleared by hardware when PE=0., Read-only
    static constexpr uint32_t ISR_PECERR = 0x800;       // PEC Error in reception This flag is set by hardware when the received PEC does not match with the PEC register content. A NACK is automatically sent after the wrong PEC reception. It is cleared by software by setting the PECCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation., Read-only
    static constexpr uint32_t ISR_TIMEOUT = 0x1000;     // Timeout or tLOW detection flag This flag is set by hardware when a timeout or extended clock timeout occurred. It is cleared by software by setting the TIMEOUTCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation., Read-only
    static constexpr uint32_t ISR_ALERT = 0x2000;       // SMBus alert This flag is set by hardware when SMBHEN=1 (SMBus host configuration), ALERTEN=1 and a SMBALERT event (falling edge) is detected on SMBA pin. It is cleared by software by setting the ALERTCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation., Read-only
    static constexpr uint32_t ISR_BUSY = 0x8000;        // Bus busy This flag indicates that a communication is in progress on the bus. It is set by hardware when a START condition is detected. It is cleared by hardware when a Stop condition is detected, or when PE=0., Read-only
    static constexpr uint32_t ISR_DIR = 0x10000;        // Transfer direction (Slave mode) This flag is updated when an address match event occurs (ADDR=1)., Read-only
    template<uint32_t X>
    static constexpr uint32_t ISR_ADDCODE =             // Address match code (Slave mode) These bits are updated with the received address when an address match event occurs (ADDR = 1). In the case of a 10-bit address, ADDCODE provides the 10-bit header followed by the 2 MSBs of the address. (7 bits), Read-only
        bit_field_t<17, 0x7f>::value<X>();
    static const uint32_t ISR_RESET_VALUE = 0x1;

    static constexpr uint32_t ICR_ADDRCF = 0x8;         // Address matched flag clear Writing 1 to this bit clears the ADDR flag in the I2C_ISR register. Writing 1 to this bit also clears the START bit in the I2C_CR2 register.
    static constexpr uint32_t ICR_NACKCF = 0x10;        // Not Acknowledge flag clear Writing 1 to this bit clears the ACKF flag in I2C_ISR register.
    static constexpr uint32_t ICR_STOPCF = 0x20;        // Stop detection flag clear Writing 1 to this bit clears the STOPF flag in the I2C_ISR register.
    static constexpr uint32_t ICR_BERRCF = 0x100;       // Bus error flag clear Writing 1 to this bit clears the BERRF flag in the I2C_ISR register.
    static constexpr uint32_t ICR_ARLOCF = 0x200;       // Arbitration Lost flag clear Writing 1 to this bit clears the ARLO flag in the I2C_ISR register.
    static constexpr uint32_t ICR_OVRCF = 0x400;        // Overrun/Underrun flag clear Writing 1 to this bit clears the OVR flag in the I2C_ISR register.
    static constexpr uint32_t ICR_PECCF = 0x800;        // PEC Error flag clear Writing 1 to this bit clears the PECERR flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    static constexpr uint32_t ICR_TIMOUTCF = 0x1000;    // Timeout detection flag clear Writing 1 to this bit clears the TIMEOUT flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    static constexpr uint32_t ICR_ALERTCF = 0x2000;     // Alert flag clear Writing 1 to this bit clears the ALERT flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    static const uint32_t ICR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PECR_PEC =                 // Packet error checking register This field contains the internal PEC when PECEN=1. The PEC is cleared by hardware when PE=0. (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t PECR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RXDR_RXDATA =              // 8-bit receive data Data byte received from the I2C bus. (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t RXDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TXDR_TXDATA =              // 8-bit transmit data Data byte to be transmitted to the I2C bus. Note: These bits can be written only when TXE=1. (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t TXDR_RESET_VALUE = 0x0;

    static constexpr uint8_t I2C4_ER = 96; // I2C4 error interrupt
    static constexpr uint8_t I2C4_EV = 95; // I2C4 event interrupt
};

static i2c4_t& I2C4 = *reinterpret_cast<i2c4_t*>(0x58001c00);

#define HAVE_PERIPHERAL_I2C4


////
//
//    GPIO
//
////

struct gpioa_t
{
    volatile uint32_t    MODER;                // [Read-write] GPIO port mode register
    volatile uint32_t    OTYPER;               // [Read-write] GPIO port output type register
    volatile uint32_t    OSPEEDR;              // [Read-write] GPIO port output speed register
    volatile uint32_t    PUPDR;                // [Read-write] GPIO port pull-up/pull-down register
    volatile uint32_t    IDR;                  // [Read-only] GPIO port input data register
    volatile uint32_t    ODR;                  // [Read-write] GPIO port output data register
    volatile uint32_t    BSRR;                 // [Write-only] GPIO port bit set/reset register
    volatile uint32_t    LCKR;                 // [Read-write] This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence.Each lock bit freezes a specific configuration register (control and alternate function registers).
    volatile uint32_t    AFRL;                 // [Read-write] GPIO alternate function low register
    volatile uint32_t    AFRH;                 // [Read-write] GPIO alternate function high register

    template<uint32_t X>
    static constexpr uint32_t MODER_MODE0 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE1 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE2 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE3 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE4 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE5 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE6 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE7 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE8 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE9 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE10 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE11 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE12 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE13 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE14 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE15 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    static const uint32_t MODER_RESET_VALUE = 0xabffffff;

    static constexpr uint32_t OTYPER_OT0 = 0x1;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT1 = 0x2;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT2 = 0x4;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT3 = 0x8;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT4 = 0x10;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT5 = 0x20;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT6 = 0x40;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT7 = 0x80;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT8 = 0x100;          // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT9 = 0x200;          // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT10 = 0x400;         // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT11 = 0x800;         // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT12 = 0x1000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT13 = 0x2000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT14 = 0x4000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT15 = 0x8000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static const uint32_t OTYPER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED0 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED1 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED2 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED3 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED4 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED5 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED6 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED7 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED8 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED9 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED10 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED11 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED12 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED13 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED14 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED15 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    static const uint32_t OSPEEDR_RESET_VALUE = 0xc000000;

    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD0 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD1 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD2 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD3 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD4 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD5 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD6 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD7 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD8 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD9 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD10 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD11 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD12 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD13 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD14 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD15 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    static const uint32_t PUPDR_RESET_VALUE = 0x12100000;

    static constexpr uint32_t IDR_ID0 = 0x1;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID1 = 0x2;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID2 = 0x4;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID3 = 0x8;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID4 = 0x10;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID5 = 0x20;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID6 = 0x40;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID7 = 0x80;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID8 = 0x100;          // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID9 = 0x200;          // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID10 = 0x400;         // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID11 = 0x800;         // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID12 = 0x1000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID13 = 0x2000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID14 = 0x4000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID15 = 0x8000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static const uint32_t IDR_RESET_VALUE = 0x0;

    static constexpr uint32_t ODR_OD0 = 0x1;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD1 = 0x2;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD2 = 0x4;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD3 = 0x8;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD4 = 0x10;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD5 = 0x20;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD6 = 0x40;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD7 = 0x80;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD8 = 0x100;          // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD9 = 0x200;          // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD10 = 0x400;         // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD11 = 0x800;         // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD12 = 0x1000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD13 = 0x2000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD14 = 0x4000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD15 = 0x8000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static const uint32_t ODR_RESET_VALUE = 0x0;

    static constexpr uint32_t BSRR_BS0 = 0x1;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS1 = 0x2;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS2 = 0x4;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS3 = 0x8;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS4 = 0x10;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS5 = 0x20;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS6 = 0x40;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS7 = 0x80;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS8 = 0x100;          // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS9 = 0x200;          // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS10 = 0x400;         // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS11 = 0x800;         // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS12 = 0x1000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS13 = 0x2000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS14 = 0x4000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS15 = 0x8000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BR0 = 0x10000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR1 = 0x20000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR2 = 0x40000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR3 = 0x80000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR4 = 0x100000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR5 = 0x200000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR6 = 0x400000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR7 = 0x800000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR8 = 0x1000000;      // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR9 = 0x2000000;      // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR10 = 0x4000000;     // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR11 = 0x8000000;     // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR12 = 0x10000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR13 = 0x20000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR14 = 0x40000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR15 = 0x80000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static const uint32_t BSRR_RESET_VALUE = 0x0;

    static constexpr uint32_t LCKR_LCK0 = 0x1;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK1 = 0x2;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK2 = 0x4;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK3 = 0x8;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK4 = 0x10;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK5 = 0x20;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK6 = 0x40;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK7 = 0x80;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK8 = 0x100;         // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK9 = 0x200;         // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK10 = 0x400;        // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK11 = 0x800;        // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK12 = 0x1000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK13 = 0x2000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK14 = 0x4000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK15 = 0x8000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCKK = 0x10000;       // Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset.
    static const uint32_t LCKR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL0 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL1 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL2 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL3 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL4 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL5 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL6 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL7 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    static const uint32_t AFRL_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL8 =              // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL9 =              // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL10 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL11 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL12 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL13 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL14 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL15 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    static const uint32_t AFRH_RESET_VALUE = 0x0;
};

static gpioa_t& GPIOA = *reinterpret_cast<gpioa_t*>(0x58020000);

#define HAVE_PERIPHERAL_GPIOA


////
//
//    GPIO
//
////

struct gpiob_t
{
    volatile uint32_t    MODER;                // [Read-write] GPIO port mode register
    volatile uint32_t    OTYPER;               // [Read-write] GPIO port output type register
    volatile uint32_t    OSPEEDR;              // [Read-write] GPIO port output speed register
    volatile uint32_t    PUPDR;                // [Read-write] GPIO port pull-up/pull-down register
    volatile uint32_t    IDR;                  // [Read-only] GPIO port input data register
    volatile uint32_t    ODR;                  // [Read-write] GPIO port output data register
    volatile uint32_t    BSRR;                 // [Write-only] GPIO port bit set/reset register
    volatile uint32_t    LCKR;                 // [Read-write] This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence.Each lock bit freezes a specific configuration register (control and alternate function registers).
    volatile uint32_t    AFRL;                 // [Read-write] GPIO alternate function low register
    volatile uint32_t    AFRH;                 // [Read-write] GPIO alternate function high register

    template<uint32_t X>
    static constexpr uint32_t MODER_MODE0 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE1 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE2 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE3 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE4 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE5 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE6 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE7 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE8 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE9 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE10 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE11 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE12 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE13 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE14 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE15 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    static const uint32_t MODER_RESET_VALUE = 0xabffffff;

    static constexpr uint32_t OTYPER_OT0 = 0x1;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT1 = 0x2;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT2 = 0x4;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT3 = 0x8;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT4 = 0x10;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT5 = 0x20;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT6 = 0x40;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT7 = 0x80;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT8 = 0x100;          // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT9 = 0x200;          // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT10 = 0x400;         // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT11 = 0x800;         // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT12 = 0x1000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT13 = 0x2000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT14 = 0x4000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT15 = 0x8000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static const uint32_t OTYPER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED0 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED1 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED2 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED3 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED4 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED5 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED6 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED7 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED8 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED9 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED10 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED11 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED12 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED13 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED14 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED15 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    static const uint32_t OSPEEDR_RESET_VALUE = 0xc000000;

    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD0 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD1 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD2 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD3 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD4 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD5 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD6 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD7 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD8 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD9 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD10 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD11 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD12 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD13 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD14 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD15 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    static const uint32_t PUPDR_RESET_VALUE = 0x12100000;

    static constexpr uint32_t IDR_ID0 = 0x1;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID1 = 0x2;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID2 = 0x4;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID3 = 0x8;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID4 = 0x10;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID5 = 0x20;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID6 = 0x40;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID7 = 0x80;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID8 = 0x100;          // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID9 = 0x200;          // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID10 = 0x400;         // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID11 = 0x800;         // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID12 = 0x1000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID13 = 0x2000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID14 = 0x4000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID15 = 0x8000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static const uint32_t IDR_RESET_VALUE = 0x0;

    static constexpr uint32_t ODR_OD0 = 0x1;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD1 = 0x2;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD2 = 0x4;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD3 = 0x8;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD4 = 0x10;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD5 = 0x20;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD6 = 0x40;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD7 = 0x80;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD8 = 0x100;          // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD9 = 0x200;          // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD10 = 0x400;         // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD11 = 0x800;         // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD12 = 0x1000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD13 = 0x2000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD14 = 0x4000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD15 = 0x8000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static const uint32_t ODR_RESET_VALUE = 0x0;

    static constexpr uint32_t BSRR_BS0 = 0x1;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS1 = 0x2;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS2 = 0x4;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS3 = 0x8;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS4 = 0x10;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS5 = 0x20;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS6 = 0x40;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS7 = 0x80;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS8 = 0x100;          // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS9 = 0x200;          // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS10 = 0x400;         // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS11 = 0x800;         // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS12 = 0x1000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS13 = 0x2000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS14 = 0x4000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS15 = 0x8000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BR0 = 0x10000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR1 = 0x20000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR2 = 0x40000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR3 = 0x80000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR4 = 0x100000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR5 = 0x200000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR6 = 0x400000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR7 = 0x800000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR8 = 0x1000000;      // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR9 = 0x2000000;      // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR10 = 0x4000000;     // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR11 = 0x8000000;     // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR12 = 0x10000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR13 = 0x20000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR14 = 0x40000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR15 = 0x80000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static const uint32_t BSRR_RESET_VALUE = 0x0;

    static constexpr uint32_t LCKR_LCK0 = 0x1;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK1 = 0x2;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK2 = 0x4;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK3 = 0x8;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK4 = 0x10;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK5 = 0x20;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK6 = 0x40;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK7 = 0x80;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK8 = 0x100;         // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK9 = 0x200;         // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK10 = 0x400;        // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK11 = 0x800;        // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK12 = 0x1000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK13 = 0x2000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK14 = 0x4000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK15 = 0x8000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCKK = 0x10000;       // Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset.
    static const uint32_t LCKR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL0 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL1 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL2 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL3 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL4 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL5 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL6 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL7 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    static const uint32_t AFRL_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL8 =              // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL9 =              // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL10 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL11 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL12 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL13 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL14 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL15 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    static const uint32_t AFRH_RESET_VALUE = 0x0;
};

static gpiob_t& GPIOB = *reinterpret_cast<gpiob_t*>(0x58020400);

#define HAVE_PERIPHERAL_GPIOB


////
//
//    GPIO
//
////

struct gpioc_t
{
    volatile uint32_t    MODER;                // [Read-write] GPIO port mode register
    volatile uint32_t    OTYPER;               // [Read-write] GPIO port output type register
    volatile uint32_t    OSPEEDR;              // [Read-write] GPIO port output speed register
    volatile uint32_t    PUPDR;                // [Read-write] GPIO port pull-up/pull-down register
    volatile uint32_t    IDR;                  // [Read-only] GPIO port input data register
    volatile uint32_t    ODR;                  // [Read-write] GPIO port output data register
    volatile uint32_t    BSRR;                 // [Write-only] GPIO port bit set/reset register
    volatile uint32_t    LCKR;                 // [Read-write] This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence.Each lock bit freezes a specific configuration register (control and alternate function registers).
    volatile uint32_t    AFRL;                 // [Read-write] GPIO alternate function low register
    volatile uint32_t    AFRH;                 // [Read-write] GPIO alternate function high register

    template<uint32_t X>
    static constexpr uint32_t MODER_MODE0 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE1 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE2 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE3 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE4 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE5 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE6 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE7 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE8 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE9 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE10 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE11 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE12 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE13 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE14 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE15 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    static const uint32_t MODER_RESET_VALUE = 0xabffffff;

    static constexpr uint32_t OTYPER_OT0 = 0x1;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT1 = 0x2;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT2 = 0x4;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT3 = 0x8;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT4 = 0x10;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT5 = 0x20;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT6 = 0x40;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT7 = 0x80;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT8 = 0x100;          // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT9 = 0x200;          // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT10 = 0x400;         // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT11 = 0x800;         // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT12 = 0x1000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT13 = 0x2000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT14 = 0x4000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT15 = 0x8000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static const uint32_t OTYPER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED0 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED1 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED2 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED3 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED4 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED5 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED6 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED7 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED8 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED9 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED10 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED11 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED12 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED13 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED14 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED15 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    static const uint32_t OSPEEDR_RESET_VALUE = 0xc000000;

    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD0 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD1 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD2 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD3 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD4 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD5 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD6 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD7 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD8 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD9 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD10 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD11 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD12 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD13 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD14 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD15 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    static const uint32_t PUPDR_RESET_VALUE = 0x12100000;

    static constexpr uint32_t IDR_ID0 = 0x1;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID1 = 0x2;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID2 = 0x4;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID3 = 0x8;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID4 = 0x10;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID5 = 0x20;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID6 = 0x40;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID7 = 0x80;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID8 = 0x100;          // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID9 = 0x200;          // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID10 = 0x400;         // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID11 = 0x800;         // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID12 = 0x1000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID13 = 0x2000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID14 = 0x4000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID15 = 0x8000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static const uint32_t IDR_RESET_VALUE = 0x0;

    static constexpr uint32_t ODR_OD0 = 0x1;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD1 = 0x2;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD2 = 0x4;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD3 = 0x8;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD4 = 0x10;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD5 = 0x20;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD6 = 0x40;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD7 = 0x80;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD8 = 0x100;          // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD9 = 0x200;          // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD10 = 0x400;         // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD11 = 0x800;         // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD12 = 0x1000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD13 = 0x2000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD14 = 0x4000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD15 = 0x8000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static const uint32_t ODR_RESET_VALUE = 0x0;

    static constexpr uint32_t BSRR_BS0 = 0x1;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS1 = 0x2;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS2 = 0x4;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS3 = 0x8;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS4 = 0x10;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS5 = 0x20;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS6 = 0x40;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS7 = 0x80;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS8 = 0x100;          // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS9 = 0x200;          // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS10 = 0x400;         // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS11 = 0x800;         // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS12 = 0x1000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS13 = 0x2000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS14 = 0x4000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS15 = 0x8000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BR0 = 0x10000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR1 = 0x20000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR2 = 0x40000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR3 = 0x80000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR4 = 0x100000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR5 = 0x200000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR6 = 0x400000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR7 = 0x800000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR8 = 0x1000000;      // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR9 = 0x2000000;      // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR10 = 0x4000000;     // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR11 = 0x8000000;     // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR12 = 0x10000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR13 = 0x20000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR14 = 0x40000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR15 = 0x80000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static const uint32_t BSRR_RESET_VALUE = 0x0;

    static constexpr uint32_t LCKR_LCK0 = 0x1;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK1 = 0x2;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK2 = 0x4;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK3 = 0x8;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK4 = 0x10;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK5 = 0x20;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK6 = 0x40;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK7 = 0x80;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK8 = 0x100;         // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK9 = 0x200;         // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK10 = 0x400;        // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK11 = 0x800;        // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK12 = 0x1000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK13 = 0x2000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK14 = 0x4000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK15 = 0x8000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCKK = 0x10000;       // Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset.
    static const uint32_t LCKR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL0 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL1 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL2 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL3 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL4 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL5 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL6 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL7 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    static const uint32_t AFRL_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL8 =              // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL9 =              // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL10 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL11 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL12 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL13 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL14 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL15 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    static const uint32_t AFRH_RESET_VALUE = 0x0;
};

static gpioc_t& GPIOC = *reinterpret_cast<gpioc_t*>(0x58020800);

#define HAVE_PERIPHERAL_GPIOC


////
//
//    GPIO
//
////

struct gpiod_t
{
    volatile uint32_t    MODER;                // [Read-write] GPIO port mode register
    volatile uint32_t    OTYPER;               // [Read-write] GPIO port output type register
    volatile uint32_t    OSPEEDR;              // [Read-write] GPIO port output speed register
    volatile uint32_t    PUPDR;                // [Read-write] GPIO port pull-up/pull-down register
    volatile uint32_t    IDR;                  // [Read-only] GPIO port input data register
    volatile uint32_t    ODR;                  // [Read-write] GPIO port output data register
    volatile uint32_t    BSRR;                 // [Write-only] GPIO port bit set/reset register
    volatile uint32_t    LCKR;                 // [Read-write] This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence.Each lock bit freezes a specific configuration register (control and alternate function registers).
    volatile uint32_t    AFRL;                 // [Read-write] GPIO alternate function low register
    volatile uint32_t    AFRH;                 // [Read-write] GPIO alternate function high register

    template<uint32_t X>
    static constexpr uint32_t MODER_MODE0 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE1 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE2 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE3 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE4 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE5 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE6 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE7 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE8 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE9 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE10 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE11 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE12 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE13 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE14 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE15 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    static const uint32_t MODER_RESET_VALUE = 0xabffffff;

    static constexpr uint32_t OTYPER_OT0 = 0x1;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT1 = 0x2;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT2 = 0x4;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT3 = 0x8;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT4 = 0x10;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT5 = 0x20;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT6 = 0x40;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT7 = 0x80;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT8 = 0x100;          // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT9 = 0x200;          // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT10 = 0x400;         // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT11 = 0x800;         // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT12 = 0x1000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT13 = 0x2000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT14 = 0x4000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT15 = 0x8000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static const uint32_t OTYPER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED0 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED1 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED2 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED3 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED4 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED5 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED6 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED7 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED8 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED9 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED10 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED11 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED12 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED13 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED14 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED15 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    static const uint32_t OSPEEDR_RESET_VALUE = 0xc000000;

    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD0 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD1 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD2 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD3 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD4 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD5 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD6 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD7 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD8 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD9 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD10 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD11 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD12 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD13 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD14 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD15 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    static const uint32_t PUPDR_RESET_VALUE = 0x12100000;

    static constexpr uint32_t IDR_ID0 = 0x1;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID1 = 0x2;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID2 = 0x4;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID3 = 0x8;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID4 = 0x10;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID5 = 0x20;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID6 = 0x40;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID7 = 0x80;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID8 = 0x100;          // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID9 = 0x200;          // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID10 = 0x400;         // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID11 = 0x800;         // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID12 = 0x1000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID13 = 0x2000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID14 = 0x4000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID15 = 0x8000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static const uint32_t IDR_RESET_VALUE = 0x0;

    static constexpr uint32_t ODR_OD0 = 0x1;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD1 = 0x2;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD2 = 0x4;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD3 = 0x8;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD4 = 0x10;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD5 = 0x20;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD6 = 0x40;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD7 = 0x80;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD8 = 0x100;          // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD9 = 0x200;          // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD10 = 0x400;         // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD11 = 0x800;         // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD12 = 0x1000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD13 = 0x2000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD14 = 0x4000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD15 = 0x8000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static const uint32_t ODR_RESET_VALUE = 0x0;

    static constexpr uint32_t BSRR_BS0 = 0x1;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS1 = 0x2;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS2 = 0x4;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS3 = 0x8;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS4 = 0x10;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS5 = 0x20;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS6 = 0x40;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS7 = 0x80;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS8 = 0x100;          // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS9 = 0x200;          // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS10 = 0x400;         // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS11 = 0x800;         // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS12 = 0x1000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS13 = 0x2000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS14 = 0x4000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS15 = 0x8000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BR0 = 0x10000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR1 = 0x20000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR2 = 0x40000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR3 = 0x80000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR4 = 0x100000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR5 = 0x200000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR6 = 0x400000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR7 = 0x800000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR8 = 0x1000000;      // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR9 = 0x2000000;      // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR10 = 0x4000000;     // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR11 = 0x8000000;     // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR12 = 0x10000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR13 = 0x20000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR14 = 0x40000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR15 = 0x80000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static const uint32_t BSRR_RESET_VALUE = 0x0;

    static constexpr uint32_t LCKR_LCK0 = 0x1;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK1 = 0x2;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK2 = 0x4;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK3 = 0x8;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK4 = 0x10;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK5 = 0x20;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK6 = 0x40;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK7 = 0x80;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK8 = 0x100;         // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK9 = 0x200;         // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK10 = 0x400;        // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK11 = 0x800;        // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK12 = 0x1000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK13 = 0x2000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK14 = 0x4000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK15 = 0x8000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCKK = 0x10000;       // Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset.
    static const uint32_t LCKR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL0 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL1 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL2 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL3 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL4 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL5 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL6 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL7 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    static const uint32_t AFRL_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL8 =              // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL9 =              // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL10 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL11 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL12 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL13 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL14 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL15 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    static const uint32_t AFRH_RESET_VALUE = 0x0;
};

static gpiod_t& GPIOD = *reinterpret_cast<gpiod_t*>(0x58020c00);

#define HAVE_PERIPHERAL_GPIOD


////
//
//    GPIO
//
////

struct gpioe_t
{
    volatile uint32_t    MODER;                // [Read-write] GPIO port mode register
    volatile uint32_t    OTYPER;               // [Read-write] GPIO port output type register
    volatile uint32_t    OSPEEDR;              // [Read-write] GPIO port output speed register
    volatile uint32_t    PUPDR;                // [Read-write] GPIO port pull-up/pull-down register
    volatile uint32_t    IDR;                  // [Read-only] GPIO port input data register
    volatile uint32_t    ODR;                  // [Read-write] GPIO port output data register
    volatile uint32_t    BSRR;                 // [Write-only] GPIO port bit set/reset register
    volatile uint32_t    LCKR;                 // [Read-write] This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence.Each lock bit freezes a specific configuration register (control and alternate function registers).
    volatile uint32_t    AFRL;                 // [Read-write] GPIO alternate function low register
    volatile uint32_t    AFRH;                 // [Read-write] GPIO alternate function high register

    template<uint32_t X>
    static constexpr uint32_t MODER_MODE0 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE1 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE2 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE3 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE4 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE5 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE6 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE7 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE8 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE9 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE10 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE11 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE12 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE13 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE14 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE15 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    static const uint32_t MODER_RESET_VALUE = 0xabffffff;

    static constexpr uint32_t OTYPER_OT0 = 0x1;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT1 = 0x2;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT2 = 0x4;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT3 = 0x8;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT4 = 0x10;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT5 = 0x20;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT6 = 0x40;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT7 = 0x80;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT8 = 0x100;          // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT9 = 0x200;          // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT10 = 0x400;         // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT11 = 0x800;         // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT12 = 0x1000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT13 = 0x2000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT14 = 0x4000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT15 = 0x8000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static const uint32_t OTYPER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED0 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED1 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED2 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED3 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED4 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED5 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED6 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED7 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED8 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED9 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED10 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED11 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED12 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED13 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED14 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED15 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    static const uint32_t OSPEEDR_RESET_VALUE = 0xc000000;

    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD0 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD1 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD2 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD3 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD4 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD5 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD6 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD7 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD8 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD9 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD10 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD11 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD12 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD13 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD14 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD15 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    static const uint32_t PUPDR_RESET_VALUE = 0x12100000;

    static constexpr uint32_t IDR_ID0 = 0x1;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID1 = 0x2;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID2 = 0x4;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID3 = 0x8;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID4 = 0x10;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID5 = 0x20;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID6 = 0x40;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID7 = 0x80;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID8 = 0x100;          // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID9 = 0x200;          // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID10 = 0x400;         // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID11 = 0x800;         // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID12 = 0x1000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID13 = 0x2000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID14 = 0x4000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID15 = 0x8000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static const uint32_t IDR_RESET_VALUE = 0x0;

    static constexpr uint32_t ODR_OD0 = 0x1;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD1 = 0x2;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD2 = 0x4;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD3 = 0x8;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD4 = 0x10;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD5 = 0x20;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD6 = 0x40;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD7 = 0x80;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD8 = 0x100;          // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD9 = 0x200;          // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD10 = 0x400;         // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD11 = 0x800;         // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD12 = 0x1000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD13 = 0x2000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD14 = 0x4000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD15 = 0x8000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static const uint32_t ODR_RESET_VALUE = 0x0;

    static constexpr uint32_t BSRR_BS0 = 0x1;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS1 = 0x2;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS2 = 0x4;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS3 = 0x8;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS4 = 0x10;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS5 = 0x20;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS6 = 0x40;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS7 = 0x80;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS8 = 0x100;          // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS9 = 0x200;          // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS10 = 0x400;         // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS11 = 0x800;         // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS12 = 0x1000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS13 = 0x2000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS14 = 0x4000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS15 = 0x8000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BR0 = 0x10000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR1 = 0x20000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR2 = 0x40000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR3 = 0x80000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR4 = 0x100000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR5 = 0x200000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR6 = 0x400000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR7 = 0x800000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR8 = 0x1000000;      // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR9 = 0x2000000;      // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR10 = 0x4000000;     // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR11 = 0x8000000;     // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR12 = 0x10000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR13 = 0x20000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR14 = 0x40000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR15 = 0x80000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static const uint32_t BSRR_RESET_VALUE = 0x0;

    static constexpr uint32_t LCKR_LCK0 = 0x1;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK1 = 0x2;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK2 = 0x4;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK3 = 0x8;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK4 = 0x10;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK5 = 0x20;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK6 = 0x40;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK7 = 0x80;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK8 = 0x100;         // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK9 = 0x200;         // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK10 = 0x400;        // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK11 = 0x800;        // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK12 = 0x1000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK13 = 0x2000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK14 = 0x4000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK15 = 0x8000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCKK = 0x10000;       // Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset.
    static const uint32_t LCKR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL0 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL1 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL2 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL3 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL4 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL5 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL6 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL7 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    static const uint32_t AFRL_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL8 =              // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL9 =              // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL10 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL11 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL12 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL13 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL14 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL15 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    static const uint32_t AFRH_RESET_VALUE = 0x0;
};

static gpioe_t& GPIOE = *reinterpret_cast<gpioe_t*>(0x58021000);

#define HAVE_PERIPHERAL_GPIOE


////
//
//    GPIO
//
////

struct gpiof_t
{
    volatile uint32_t    MODER;                // [Read-write] GPIO port mode register
    volatile uint32_t    OTYPER;               // [Read-write] GPIO port output type register
    volatile uint32_t    OSPEEDR;              // [Read-write] GPIO port output speed register
    volatile uint32_t    PUPDR;                // [Read-write] GPIO port pull-up/pull-down register
    volatile uint32_t    IDR;                  // [Read-only] GPIO port input data register
    volatile uint32_t    ODR;                  // [Read-write] GPIO port output data register
    volatile uint32_t    BSRR;                 // [Write-only] GPIO port bit set/reset register
    volatile uint32_t    LCKR;                 // [Read-write] This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence.Each lock bit freezes a specific configuration register (control and alternate function registers).
    volatile uint32_t    AFRL;                 // [Read-write] GPIO alternate function low register
    volatile uint32_t    AFRH;                 // [Read-write] GPIO alternate function high register

    template<uint32_t X>
    static constexpr uint32_t MODER_MODE0 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE1 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE2 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE3 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE4 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE5 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE6 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE7 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE8 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE9 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE10 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE11 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE12 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE13 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE14 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE15 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    static const uint32_t MODER_RESET_VALUE = 0xabffffff;

    static constexpr uint32_t OTYPER_OT0 = 0x1;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT1 = 0x2;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT2 = 0x4;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT3 = 0x8;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT4 = 0x10;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT5 = 0x20;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT6 = 0x40;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT7 = 0x80;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT8 = 0x100;          // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT9 = 0x200;          // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT10 = 0x400;         // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT11 = 0x800;         // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT12 = 0x1000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT13 = 0x2000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT14 = 0x4000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT15 = 0x8000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static const uint32_t OTYPER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED0 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED1 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED2 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED3 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED4 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED5 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED6 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED7 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED8 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED9 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED10 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED11 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED12 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED13 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED14 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED15 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    static const uint32_t OSPEEDR_RESET_VALUE = 0xc000000;

    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD0 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD1 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD2 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD3 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD4 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD5 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD6 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD7 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD8 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD9 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD10 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD11 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD12 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD13 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD14 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD15 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    static const uint32_t PUPDR_RESET_VALUE = 0x12100000;

    static constexpr uint32_t IDR_ID0 = 0x1;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID1 = 0x2;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID2 = 0x4;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID3 = 0x8;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID4 = 0x10;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID5 = 0x20;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID6 = 0x40;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID7 = 0x80;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID8 = 0x100;          // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID9 = 0x200;          // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID10 = 0x400;         // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID11 = 0x800;         // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID12 = 0x1000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID13 = 0x2000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID14 = 0x4000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID15 = 0x8000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static const uint32_t IDR_RESET_VALUE = 0x0;

    static constexpr uint32_t ODR_OD0 = 0x1;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD1 = 0x2;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD2 = 0x4;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD3 = 0x8;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD4 = 0x10;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD5 = 0x20;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD6 = 0x40;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD7 = 0x80;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD8 = 0x100;          // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD9 = 0x200;          // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD10 = 0x400;         // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD11 = 0x800;         // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD12 = 0x1000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD13 = 0x2000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD14 = 0x4000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD15 = 0x8000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static const uint32_t ODR_RESET_VALUE = 0x0;

    static constexpr uint32_t BSRR_BS0 = 0x1;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS1 = 0x2;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS2 = 0x4;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS3 = 0x8;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS4 = 0x10;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS5 = 0x20;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS6 = 0x40;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS7 = 0x80;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS8 = 0x100;          // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS9 = 0x200;          // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS10 = 0x400;         // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS11 = 0x800;         // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS12 = 0x1000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS13 = 0x2000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS14 = 0x4000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS15 = 0x8000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BR0 = 0x10000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR1 = 0x20000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR2 = 0x40000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR3 = 0x80000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR4 = 0x100000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR5 = 0x200000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR6 = 0x400000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR7 = 0x800000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR8 = 0x1000000;      // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR9 = 0x2000000;      // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR10 = 0x4000000;     // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR11 = 0x8000000;     // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR12 = 0x10000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR13 = 0x20000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR14 = 0x40000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR15 = 0x80000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static const uint32_t BSRR_RESET_VALUE = 0x0;

    static constexpr uint32_t LCKR_LCK0 = 0x1;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK1 = 0x2;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK2 = 0x4;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK3 = 0x8;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK4 = 0x10;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK5 = 0x20;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK6 = 0x40;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK7 = 0x80;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK8 = 0x100;         // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK9 = 0x200;         // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK10 = 0x400;        // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK11 = 0x800;        // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK12 = 0x1000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK13 = 0x2000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK14 = 0x4000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK15 = 0x8000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCKK = 0x10000;       // Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset.
    static const uint32_t LCKR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL0 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL1 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL2 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL3 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL4 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL5 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL6 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL7 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    static const uint32_t AFRL_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL8 =              // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL9 =              // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL10 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL11 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL12 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL13 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL14 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL15 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    static const uint32_t AFRH_RESET_VALUE = 0x0;
};

static gpiof_t& GPIOF = *reinterpret_cast<gpiof_t*>(0x58021400);

#define HAVE_PERIPHERAL_GPIOF


////
//
//    GPIO
//
////

struct gpiog_t
{
    volatile uint32_t    MODER;                // [Read-write] GPIO port mode register
    volatile uint32_t    OTYPER;               // [Read-write] GPIO port output type register
    volatile uint32_t    OSPEEDR;              // [Read-write] GPIO port output speed register
    volatile uint32_t    PUPDR;                // [Read-write] GPIO port pull-up/pull-down register
    volatile uint32_t    IDR;                  // [Read-only] GPIO port input data register
    volatile uint32_t    ODR;                  // [Read-write] GPIO port output data register
    volatile uint32_t    BSRR;                 // [Write-only] GPIO port bit set/reset register
    volatile uint32_t    LCKR;                 // [Read-write] This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence.Each lock bit freezes a specific configuration register (control and alternate function registers).
    volatile uint32_t    AFRL;                 // [Read-write] GPIO alternate function low register
    volatile uint32_t    AFRH;                 // [Read-write] GPIO alternate function high register

    template<uint32_t X>
    static constexpr uint32_t MODER_MODE0 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE1 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE2 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE3 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE4 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE5 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE6 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE7 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE8 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE9 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE10 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE11 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE12 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE13 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE14 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE15 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    static const uint32_t MODER_RESET_VALUE = 0xabffffff;

    static constexpr uint32_t OTYPER_OT0 = 0x1;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT1 = 0x2;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT2 = 0x4;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT3 = 0x8;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT4 = 0x10;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT5 = 0x20;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT6 = 0x40;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT7 = 0x80;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT8 = 0x100;          // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT9 = 0x200;          // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT10 = 0x400;         // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT11 = 0x800;         // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT12 = 0x1000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT13 = 0x2000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT14 = 0x4000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT15 = 0x8000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static const uint32_t OTYPER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED0 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED1 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED2 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED3 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED4 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED5 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED6 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED7 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED8 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED9 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED10 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED11 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED12 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED13 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED14 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED15 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    static const uint32_t OSPEEDR_RESET_VALUE = 0xc000000;

    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD0 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD1 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD2 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD3 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD4 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD5 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD6 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD7 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD8 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD9 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD10 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD11 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD12 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD13 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD14 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD15 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    static const uint32_t PUPDR_RESET_VALUE = 0x12100000;

    static constexpr uint32_t IDR_ID0 = 0x1;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID1 = 0x2;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID2 = 0x4;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID3 = 0x8;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID4 = 0x10;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID5 = 0x20;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID6 = 0x40;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID7 = 0x80;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID8 = 0x100;          // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID9 = 0x200;          // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID10 = 0x400;         // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID11 = 0x800;         // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID12 = 0x1000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID13 = 0x2000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID14 = 0x4000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID15 = 0x8000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static const uint32_t IDR_RESET_VALUE = 0x0;

    static constexpr uint32_t ODR_OD0 = 0x1;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD1 = 0x2;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD2 = 0x4;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD3 = 0x8;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD4 = 0x10;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD5 = 0x20;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD6 = 0x40;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD7 = 0x80;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD8 = 0x100;          // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD9 = 0x200;          // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD10 = 0x400;         // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD11 = 0x800;         // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD12 = 0x1000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD13 = 0x2000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD14 = 0x4000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD15 = 0x8000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static const uint32_t ODR_RESET_VALUE = 0x0;

    static constexpr uint32_t BSRR_BS0 = 0x1;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS1 = 0x2;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS2 = 0x4;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS3 = 0x8;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS4 = 0x10;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS5 = 0x20;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS6 = 0x40;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS7 = 0x80;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS8 = 0x100;          // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS9 = 0x200;          // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS10 = 0x400;         // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS11 = 0x800;         // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS12 = 0x1000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS13 = 0x2000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS14 = 0x4000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS15 = 0x8000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BR0 = 0x10000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR1 = 0x20000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR2 = 0x40000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR3 = 0x80000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR4 = 0x100000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR5 = 0x200000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR6 = 0x400000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR7 = 0x800000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR8 = 0x1000000;      // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR9 = 0x2000000;      // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR10 = 0x4000000;     // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR11 = 0x8000000;     // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR12 = 0x10000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR13 = 0x20000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR14 = 0x40000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR15 = 0x80000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static const uint32_t BSRR_RESET_VALUE = 0x0;

    static constexpr uint32_t LCKR_LCK0 = 0x1;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK1 = 0x2;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK2 = 0x4;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK3 = 0x8;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK4 = 0x10;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK5 = 0x20;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK6 = 0x40;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK7 = 0x80;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK8 = 0x100;         // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK9 = 0x200;         // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK10 = 0x400;        // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK11 = 0x800;        // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK12 = 0x1000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK13 = 0x2000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK14 = 0x4000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK15 = 0x8000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCKK = 0x10000;       // Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset.
    static const uint32_t LCKR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL0 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL1 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL2 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL3 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL4 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL5 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL6 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL7 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    static const uint32_t AFRL_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL8 =              // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL9 =              // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL10 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL11 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL12 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL13 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL14 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL15 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    static const uint32_t AFRH_RESET_VALUE = 0x0;
};

static gpiog_t& GPIOG = *reinterpret_cast<gpiog_t*>(0x58021800);

#define HAVE_PERIPHERAL_GPIOG


////
//
//    GPIO
//
////

struct gpioh_t
{
    volatile uint32_t    MODER;                // [Read-write] GPIO port mode register
    volatile uint32_t    OTYPER;               // [Read-write] GPIO port output type register
    volatile uint32_t    OSPEEDR;              // [Read-write] GPIO port output speed register
    volatile uint32_t    PUPDR;                // [Read-write] GPIO port pull-up/pull-down register
    volatile uint32_t    IDR;                  // [Read-only] GPIO port input data register
    volatile uint32_t    ODR;                  // [Read-write] GPIO port output data register
    volatile uint32_t    BSRR;                 // [Write-only] GPIO port bit set/reset register
    volatile uint32_t    LCKR;                 // [Read-write] This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence.Each lock bit freezes a specific configuration register (control and alternate function registers).
    volatile uint32_t    AFRL;                 // [Read-write] GPIO alternate function low register
    volatile uint32_t    AFRH;                 // [Read-write] GPIO alternate function high register

    template<uint32_t X>
    static constexpr uint32_t MODER_MODE0 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE1 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE2 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE3 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE4 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE5 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE6 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE7 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE8 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE9 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE10 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE11 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE12 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE13 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE14 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE15 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    static const uint32_t MODER_RESET_VALUE = 0xabffffff;

    static constexpr uint32_t OTYPER_OT0 = 0x1;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT1 = 0x2;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT2 = 0x4;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT3 = 0x8;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT4 = 0x10;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT5 = 0x20;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT6 = 0x40;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT7 = 0x80;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT8 = 0x100;          // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT9 = 0x200;          // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT10 = 0x400;         // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT11 = 0x800;         // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT12 = 0x1000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT13 = 0x2000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT14 = 0x4000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT15 = 0x8000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static const uint32_t OTYPER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED0 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED1 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED2 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED3 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED4 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED5 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED6 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED7 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED8 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED9 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED10 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED11 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED12 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED13 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED14 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED15 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    static const uint32_t OSPEEDR_RESET_VALUE = 0xc000000;

    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD0 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD1 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD2 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD3 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD4 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD5 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD6 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD7 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD8 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD9 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD10 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD11 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD12 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD13 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD14 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD15 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    static const uint32_t PUPDR_RESET_VALUE = 0x12100000;

    static constexpr uint32_t IDR_ID0 = 0x1;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID1 = 0x2;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID2 = 0x4;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID3 = 0x8;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID4 = 0x10;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID5 = 0x20;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID6 = 0x40;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID7 = 0x80;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID8 = 0x100;          // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID9 = 0x200;          // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID10 = 0x400;         // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID11 = 0x800;         // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID12 = 0x1000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID13 = 0x2000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID14 = 0x4000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID15 = 0x8000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static const uint32_t IDR_RESET_VALUE = 0x0;

    static constexpr uint32_t ODR_OD0 = 0x1;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD1 = 0x2;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD2 = 0x4;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD3 = 0x8;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD4 = 0x10;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD5 = 0x20;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD6 = 0x40;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD7 = 0x80;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD8 = 0x100;          // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD9 = 0x200;          // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD10 = 0x400;         // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD11 = 0x800;         // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD12 = 0x1000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD13 = 0x2000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD14 = 0x4000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD15 = 0x8000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static const uint32_t ODR_RESET_VALUE = 0x0;

    static constexpr uint32_t BSRR_BS0 = 0x1;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS1 = 0x2;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS2 = 0x4;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS3 = 0x8;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS4 = 0x10;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS5 = 0x20;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS6 = 0x40;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS7 = 0x80;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS8 = 0x100;          // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS9 = 0x200;          // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS10 = 0x400;         // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS11 = 0x800;         // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS12 = 0x1000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS13 = 0x2000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS14 = 0x4000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS15 = 0x8000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BR0 = 0x10000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR1 = 0x20000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR2 = 0x40000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR3 = 0x80000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR4 = 0x100000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR5 = 0x200000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR6 = 0x400000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR7 = 0x800000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR8 = 0x1000000;      // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR9 = 0x2000000;      // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR10 = 0x4000000;     // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR11 = 0x8000000;     // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR12 = 0x10000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR13 = 0x20000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR14 = 0x40000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR15 = 0x80000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static const uint32_t BSRR_RESET_VALUE = 0x0;

    static constexpr uint32_t LCKR_LCK0 = 0x1;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK1 = 0x2;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK2 = 0x4;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK3 = 0x8;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK4 = 0x10;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK5 = 0x20;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK6 = 0x40;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK7 = 0x80;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK8 = 0x100;         // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK9 = 0x200;         // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK10 = 0x400;        // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK11 = 0x800;        // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK12 = 0x1000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK13 = 0x2000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK14 = 0x4000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK15 = 0x8000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCKK = 0x10000;       // Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset.
    static const uint32_t LCKR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL0 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL1 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL2 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL3 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL4 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL5 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL6 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL7 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    static const uint32_t AFRL_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL8 =              // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL9 =              // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL10 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL11 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL12 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL13 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL14 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL15 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    static const uint32_t AFRH_RESET_VALUE = 0x0;
};

static gpioh_t& GPIOH = *reinterpret_cast<gpioh_t*>(0x58021c00);

#define HAVE_PERIPHERAL_GPIOH


////
//
//    GPIO
//
////

struct gpioi_t
{
    volatile uint32_t    MODER;                // [Read-write] GPIO port mode register
    volatile uint32_t    OTYPER;               // [Read-write] GPIO port output type register
    volatile uint32_t    OSPEEDR;              // [Read-write] GPIO port output speed register
    volatile uint32_t    PUPDR;                // [Read-write] GPIO port pull-up/pull-down register
    volatile uint32_t    IDR;                  // [Read-only] GPIO port input data register
    volatile uint32_t    ODR;                  // [Read-write] GPIO port output data register
    volatile uint32_t    BSRR;                 // [Write-only] GPIO port bit set/reset register
    volatile uint32_t    LCKR;                 // [Read-write] This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence.Each lock bit freezes a specific configuration register (control and alternate function registers).
    volatile uint32_t    AFRL;                 // [Read-write] GPIO alternate function low register
    volatile uint32_t    AFRH;                 // [Read-write] GPIO alternate function high register

    template<uint32_t X>
    static constexpr uint32_t MODER_MODE0 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE1 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE2 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE3 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE4 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE5 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE6 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE7 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE8 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE9 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE10 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE11 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE12 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE13 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE14 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE15 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    static const uint32_t MODER_RESET_VALUE = 0xabffffff;

    static constexpr uint32_t OTYPER_OT0 = 0x1;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT1 = 0x2;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT2 = 0x4;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT3 = 0x8;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT4 = 0x10;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT5 = 0x20;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT6 = 0x40;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT7 = 0x80;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT8 = 0x100;          // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT9 = 0x200;          // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT10 = 0x400;         // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT11 = 0x800;         // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT12 = 0x1000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT13 = 0x2000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT14 = 0x4000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT15 = 0x8000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static const uint32_t OTYPER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED0 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED1 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED2 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED3 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED4 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED5 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED6 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED7 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED8 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED9 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED10 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED11 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED12 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED13 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED14 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED15 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    static const uint32_t OSPEEDR_RESET_VALUE = 0xc000000;

    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD0 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD1 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD2 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD3 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD4 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD5 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD6 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD7 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD8 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD9 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD10 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD11 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD12 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD13 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD14 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD15 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    static const uint32_t PUPDR_RESET_VALUE = 0x12100000;

    static constexpr uint32_t IDR_ID0 = 0x1;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID1 = 0x2;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID2 = 0x4;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID3 = 0x8;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID4 = 0x10;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID5 = 0x20;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID6 = 0x40;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID7 = 0x80;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID8 = 0x100;          // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID9 = 0x200;          // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID10 = 0x400;         // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID11 = 0x800;         // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID12 = 0x1000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID13 = 0x2000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID14 = 0x4000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID15 = 0x8000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static const uint32_t IDR_RESET_VALUE = 0x0;

    static constexpr uint32_t ODR_OD0 = 0x1;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD1 = 0x2;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD2 = 0x4;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD3 = 0x8;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD4 = 0x10;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD5 = 0x20;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD6 = 0x40;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD7 = 0x80;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD8 = 0x100;          // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD9 = 0x200;          // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD10 = 0x400;         // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD11 = 0x800;         // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD12 = 0x1000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD13 = 0x2000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD14 = 0x4000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD15 = 0x8000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static const uint32_t ODR_RESET_VALUE = 0x0;

    static constexpr uint32_t BSRR_BS0 = 0x1;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS1 = 0x2;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS2 = 0x4;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS3 = 0x8;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS4 = 0x10;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS5 = 0x20;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS6 = 0x40;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS7 = 0x80;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS8 = 0x100;          // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS9 = 0x200;          // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS10 = 0x400;         // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS11 = 0x800;         // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS12 = 0x1000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS13 = 0x2000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS14 = 0x4000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS15 = 0x8000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BR0 = 0x10000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR1 = 0x20000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR2 = 0x40000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR3 = 0x80000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR4 = 0x100000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR5 = 0x200000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR6 = 0x400000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR7 = 0x800000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR8 = 0x1000000;      // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR9 = 0x2000000;      // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR10 = 0x4000000;     // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR11 = 0x8000000;     // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR12 = 0x10000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR13 = 0x20000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR14 = 0x40000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR15 = 0x80000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static const uint32_t BSRR_RESET_VALUE = 0x0;

    static constexpr uint32_t LCKR_LCK0 = 0x1;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK1 = 0x2;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK2 = 0x4;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK3 = 0x8;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK4 = 0x10;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK5 = 0x20;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK6 = 0x40;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK7 = 0x80;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK8 = 0x100;         // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK9 = 0x200;         // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK10 = 0x400;        // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK11 = 0x800;        // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK12 = 0x1000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK13 = 0x2000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK14 = 0x4000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK15 = 0x8000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCKK = 0x10000;       // Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset.
    static const uint32_t LCKR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL0 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL1 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL2 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL3 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL4 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL5 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL6 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL7 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    static const uint32_t AFRL_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL8 =              // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL9 =              // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL10 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL11 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL12 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL13 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL14 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL15 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    static const uint32_t AFRH_RESET_VALUE = 0x0;
};

static gpioi_t& GPIOI = *reinterpret_cast<gpioi_t*>(0x58022000);

#define HAVE_PERIPHERAL_GPIOI


////
//
//    GPIO
//
////

struct gpioj_t
{
    volatile uint32_t    MODER;                // [Read-write] GPIO port mode register
    volatile uint32_t    OTYPER;               // [Read-write] GPIO port output type register
    volatile uint32_t    OSPEEDR;              // [Read-write] GPIO port output speed register
    volatile uint32_t    PUPDR;                // [Read-write] GPIO port pull-up/pull-down register
    volatile uint32_t    IDR;                  // [Read-only] GPIO port input data register
    volatile uint32_t    ODR;                  // [Read-write] GPIO port output data register
    volatile uint32_t    BSRR;                 // [Write-only] GPIO port bit set/reset register
    volatile uint32_t    LCKR;                 // [Read-write] This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence.Each lock bit freezes a specific configuration register (control and alternate function registers).
    volatile uint32_t    AFRL;                 // [Read-write] GPIO alternate function low register
    volatile uint32_t    AFRH;                 // [Read-write] GPIO alternate function high register

    template<uint32_t X>
    static constexpr uint32_t MODER_MODE0 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE1 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE2 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE3 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE4 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE5 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE6 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE7 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE8 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE9 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE10 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE11 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE12 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE13 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE14 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE15 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    static const uint32_t MODER_RESET_VALUE = 0xabffffff;

    static constexpr uint32_t OTYPER_OT0 = 0x1;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT1 = 0x2;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT2 = 0x4;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT3 = 0x8;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT4 = 0x10;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT5 = 0x20;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT6 = 0x40;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT7 = 0x80;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT8 = 0x100;          // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT9 = 0x200;          // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT10 = 0x400;         // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT11 = 0x800;         // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT12 = 0x1000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT13 = 0x2000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT14 = 0x4000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT15 = 0x8000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static const uint32_t OTYPER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED0 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED1 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED2 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED3 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED4 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED5 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED6 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED7 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED8 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED9 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED10 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED11 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED12 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED13 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED14 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED15 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    static const uint32_t OSPEEDR_RESET_VALUE = 0xc000000;

    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD0 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD1 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD2 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD3 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD4 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD5 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD6 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD7 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD8 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD9 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD10 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD11 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD12 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD13 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD14 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD15 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    static const uint32_t PUPDR_RESET_VALUE = 0x12100000;

    static constexpr uint32_t IDR_ID0 = 0x1;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID1 = 0x2;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID2 = 0x4;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID3 = 0x8;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID4 = 0x10;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID5 = 0x20;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID6 = 0x40;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID7 = 0x80;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID8 = 0x100;          // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID9 = 0x200;          // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID10 = 0x400;         // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID11 = 0x800;         // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID12 = 0x1000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID13 = 0x2000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID14 = 0x4000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID15 = 0x8000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static const uint32_t IDR_RESET_VALUE = 0x0;

    static constexpr uint32_t ODR_OD0 = 0x1;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD1 = 0x2;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD2 = 0x4;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD3 = 0x8;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD4 = 0x10;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD5 = 0x20;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD6 = 0x40;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD7 = 0x80;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD8 = 0x100;          // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD9 = 0x200;          // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD10 = 0x400;         // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD11 = 0x800;         // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD12 = 0x1000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD13 = 0x2000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD14 = 0x4000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD15 = 0x8000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static const uint32_t ODR_RESET_VALUE = 0x0;

    static constexpr uint32_t BSRR_BS0 = 0x1;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS1 = 0x2;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS2 = 0x4;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS3 = 0x8;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS4 = 0x10;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS5 = 0x20;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS6 = 0x40;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS7 = 0x80;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS8 = 0x100;          // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS9 = 0x200;          // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS10 = 0x400;         // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS11 = 0x800;         // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS12 = 0x1000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS13 = 0x2000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS14 = 0x4000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS15 = 0x8000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BR0 = 0x10000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR1 = 0x20000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR2 = 0x40000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR3 = 0x80000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR4 = 0x100000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR5 = 0x200000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR6 = 0x400000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR7 = 0x800000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR8 = 0x1000000;      // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR9 = 0x2000000;      // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR10 = 0x4000000;     // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR11 = 0x8000000;     // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR12 = 0x10000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR13 = 0x20000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR14 = 0x40000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR15 = 0x80000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static const uint32_t BSRR_RESET_VALUE = 0x0;

    static constexpr uint32_t LCKR_LCK0 = 0x1;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK1 = 0x2;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK2 = 0x4;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK3 = 0x8;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK4 = 0x10;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK5 = 0x20;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK6 = 0x40;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK7 = 0x80;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK8 = 0x100;         // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK9 = 0x200;         // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK10 = 0x400;        // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK11 = 0x800;        // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK12 = 0x1000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK13 = 0x2000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK14 = 0x4000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK15 = 0x8000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCKK = 0x10000;       // Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset.
    static const uint32_t LCKR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL0 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL1 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL2 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL3 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL4 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL5 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL6 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL7 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    static const uint32_t AFRL_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL8 =              // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL9 =              // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL10 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL11 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL12 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL13 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL14 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL15 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    static const uint32_t AFRH_RESET_VALUE = 0x0;
};

static gpioj_t& GPIOJ = *reinterpret_cast<gpioj_t*>(0x58022400);

#define HAVE_PERIPHERAL_GPIOJ


////
//
//    GPIO
//
////

struct gpiok_t
{
    volatile uint32_t    MODER;                // [Read-write] GPIO port mode register
    volatile uint32_t    OTYPER;               // [Read-write] GPIO port output type register
    volatile uint32_t    OSPEEDR;              // [Read-write] GPIO port output speed register
    volatile uint32_t    PUPDR;                // [Read-write] GPIO port pull-up/pull-down register
    volatile uint32_t    IDR;                  // [Read-only] GPIO port input data register
    volatile uint32_t    ODR;                  // [Read-write] GPIO port output data register
    volatile uint32_t    BSRR;                 // [Write-only] GPIO port bit set/reset register
    volatile uint32_t    LCKR;                 // [Read-write] This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence.Each lock bit freezes a specific configuration register (control and alternate function registers).
    volatile uint32_t    AFRL;                 // [Read-write] GPIO alternate function low register
    volatile uint32_t    AFRH;                 // [Read-write] GPIO alternate function high register

    template<uint32_t X>
    static constexpr uint32_t MODER_MODE0 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE1 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE2 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE3 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE4 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE5 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE6 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE7 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE8 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE9 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE10 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE11 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE12 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE13 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE14 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODE15 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode. (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    static const uint32_t MODER_RESET_VALUE = 0xabffffff;

    static constexpr uint32_t OTYPER_OT0 = 0x1;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT1 = 0x2;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT2 = 0x4;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT3 = 0x8;            // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT4 = 0x10;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT5 = 0x20;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT6 = 0x40;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT7 = 0x80;           // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT8 = 0x100;          // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT9 = 0x200;          // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT10 = 0x400;         // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT11 = 0x800;         // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT12 = 0x1000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT13 = 0x2000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT14 = 0x4000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static constexpr uint32_t OTYPER_OT15 = 0x8000;        // Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    static const uint32_t OTYPER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED0 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED1 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED2 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED3 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED4 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED5 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED6 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED7 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED8 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED9 =             // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED10 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED11 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED12 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED13 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED14 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEED15 =            // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    static const uint32_t OSPEEDR_RESET_VALUE = 0xc000000;

    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD0 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD1 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD2 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD3 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD4 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD5 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD6 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD7 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD8 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD9 =               // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD10 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD11 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD12 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD13 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD14 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPD15 =              // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    static const uint32_t PUPDR_RESET_VALUE = 0x12100000;

    static constexpr uint32_t IDR_ID0 = 0x1;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID1 = 0x2;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID2 = 0x4;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID3 = 0x8;            // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID4 = 0x10;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID5 = 0x20;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID6 = 0x40;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID7 = 0x80;           // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID8 = 0x100;          // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID9 = 0x200;          // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID10 = 0x400;         // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID11 = 0x800;         // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID12 = 0x1000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID13 = 0x2000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID14 = 0x4000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static constexpr uint32_t IDR_ID15 = 0x8000;        // Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    static const uint32_t IDR_RESET_VALUE = 0x0;

    static constexpr uint32_t ODR_OD0 = 0x1;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD1 = 0x2;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD2 = 0x4;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD3 = 0x8;            // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD4 = 0x10;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD5 = 0x20;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD6 = 0x40;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD7 = 0x80;           // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD8 = 0x100;          // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD9 = 0x200;          // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD10 = 0x400;         // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD11 = 0x800;         // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD12 = 0x1000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD13 = 0x2000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD14 = 0x4000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static constexpr uint32_t ODR_OD15 = 0x8000;        // Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    static const uint32_t ODR_RESET_VALUE = 0x0;

    static constexpr uint32_t BSRR_BS0 = 0x1;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS1 = 0x2;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS2 = 0x4;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS3 = 0x8;            // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS4 = 0x10;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS5 = 0x20;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS6 = 0x40;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS7 = 0x80;           // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS8 = 0x100;          // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS9 = 0x200;          // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS10 = 0x400;         // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS11 = 0x800;         // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS12 = 0x1000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS13 = 0x2000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS14 = 0x4000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BS15 = 0x8000;        // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    static constexpr uint32_t BSRR_BR0 = 0x10000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR1 = 0x20000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR2 = 0x40000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR3 = 0x80000;        // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR4 = 0x100000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR5 = 0x200000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR6 = 0x400000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR7 = 0x800000;       // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR8 = 0x1000000;      // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR9 = 0x2000000;      // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR10 = 0x4000000;     // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR11 = 0x8000000;     // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR12 = 0x10000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR13 = 0x20000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR14 = 0x40000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static constexpr uint32_t BSRR_BR15 = 0x80000000;    // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    static const uint32_t BSRR_RESET_VALUE = 0x0;

    static constexpr uint32_t LCKR_LCK0 = 0x1;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK1 = 0x2;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK2 = 0x4;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK3 = 0x8;           // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK4 = 0x10;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK5 = 0x20;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK6 = 0x40;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK7 = 0x80;          // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK8 = 0x100;         // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK9 = 0x200;         // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK10 = 0x400;        // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK11 = 0x800;        // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK12 = 0x1000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK13 = 0x2000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK14 = 0x4000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCK15 = 0x8000;       // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    static constexpr uint32_t LCKR_LCKK = 0x10000;       // Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset.
    static const uint32_t LCKR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL0 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL1 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL2 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL3 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL4 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL5 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL6 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFSEL7 =              // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection: (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    static const uint32_t AFRL_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL8 =              // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL9 =              // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL10 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL11 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL12 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL13 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL14 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFSEL15 =             // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    static const uint32_t AFRH_RESET_VALUE = 0x0;
};

static gpiok_t& GPIOK = *reinterpret_cast<gpiok_t*>(0x58022800);

#define HAVE_PERIPHERAL_GPIOK


////
//
//    JPEG
//
////

struct jpeg_t
{
    volatile uint32_t    CONFR0;               // [Write-only] JPEG codec control register
    volatile uint32_t    CONFR1;               // [Read-write] JPEG codec configuration register 1
    volatile uint32_t    CONFR2;               // [Read-write] JPEG codec configuration register 2
    volatile uint32_t    CONFR3;               // [Read-write] JPEG codec configuration register 3
    volatile uint32_t    CONFRN1;              // [Read-write] JPEG codec configuration register 4-7
    volatile uint32_t    CONFRN2;              // [Read-write] JPEG codec configuration register 4-7
    volatile uint32_t    CONFRN3;              // [Read-write] JPEG codec configuration register 4-7
    volatile uint32_t    CONFRN4;              // [Read-write] JPEG codec configuration register 4-7
    reserved_t<4>        _0;
    volatile uint32_t    CR;                   // [Read-write] JPEG control register
    volatile uint32_t    SR;                   // [Read-only] JPEG status register
    volatile uint32_t    CFR;                  // [Read-write] JPEG clear flag register
    reserved_t<1>        _1;
    volatile uint32_t    DIR;                  // [Write-only] JPEG data input register
    volatile uint32_t    DOR;                  // [Read-only] JPEG data output register

    static constexpr uint32_t CONFR0_START = 0x1;          // Start This bit start or stop the encoding or decoding process. Read this register always return 0.
    static const uint32_t CONFR0_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CONFR1_NF =                  // Number of color components This field defines the number of color components minus 1. (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static constexpr uint32_t CONFR1_DE = 0x8;             // Decoding Enable This bit selects the coding or decoding process
    template<uint32_t X>
    static constexpr uint32_t CONFR1_COLORSPACE =          // Color Space This filed defines the number of quantization tables minus 1 to insert in the output stream. (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CONFR1_NS =                  // Number of components for Scan This field defines the number of components minus 1 for scan header marker segment. (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t CONFR1_HDR = 0x100;          // Header Processing This bit enable the header processing (generation/parsing).
    template<uint32_t X>
    static constexpr uint32_t CONFR1_YSIZE =               // Y Size This field defines the number of lines in source image. (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t CONFR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CONFR2_NMCU =                // Number of MCU For encoding: this field defines the number of MCU units minus 1 to encode. For decoding: this field indicates the number of complete MCU units minus 1 to be decoded (this field is updated after the JPEG header parsing). If the decoded image size has not a X or Y size multiple of 8 or 16 (depending on the sub-sampling process), the resulting incomplete or empty MCU must be added to this value to get the total number of MCU generated. (26 bits)
        bit_field_t<0, 0x3ffffff>::value<X>();
    static const uint32_t CONFR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CONFR3_XSIZE =               // X size This field defines the number of pixels per line. (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t CONFR3_RESET_VALUE = 0x0;

    static constexpr uint32_t CONFRN1_HD = 0x1;             // Huffman DC Selects the Huffman table for encoding the DC coefficients.
    static constexpr uint32_t CONFRN1_HA = 0x2;             // Huffman AC Selects the Huffman table for encoding the AC coefficients.
    template<uint32_t X>
    static constexpr uint32_t CONFRN1_QT =                  // Quantization Table Selects quantization table associated with a color component. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CONFRN1_NB =                  // Number of Block Number of data units minus 1 that belong to a particular color in the MCU. (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CONFRN1_VSF =                 // Vertical Sampling Factor Vertical sampling factor for component i. (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CONFRN1_HSF =                 // Horizontal Sampling Factor Horizontal sampling factor for component i. (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    static const uint32_t CONFRN1_RESET_VALUE = 0x0;

    static constexpr uint32_t CONFRN2_HD = 0x1;             // Huffman DC Selects the Huffman table for encoding the DC coefficients.
    static constexpr uint32_t CONFRN2_HA = 0x2;             // Huffman AC Selects the Huffman table for encoding the AC coefficients.
    template<uint32_t X>
    static constexpr uint32_t CONFRN2_QT =                  // Quantization Table Selects quantization table associated with a color component. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CONFRN2_NB =                  // Number of Block Number of data units minus 1 that belong to a particular color in the MCU. (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CONFRN2_VSF =                 // Vertical Sampling Factor Vertical sampling factor for component i. (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CONFRN2_HSF =                 // Horizontal Sampling Factor Horizontal sampling factor for component i. (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    static const uint32_t CONFRN2_RESET_VALUE = 0x0;

    static constexpr uint32_t CONFRN3_HD = 0x1;             // Huffman DC Selects the Huffman table for encoding the DC coefficients.
    static constexpr uint32_t CONFRN3_HA = 0x2;             // Huffman AC Selects the Huffman table for encoding the AC coefficients.
    template<uint32_t X>
    static constexpr uint32_t CONFRN3_QT =                  // Quantization Table Selects quantization table associated with a color component. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CONFRN3_NB =                  // Number of Block Number of data units minus 1 that belong to a particular color in the MCU. (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CONFRN3_VSF =                 // Vertical Sampling Factor Vertical sampling factor for component i. (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CONFRN3_HSF =                 // Horizontal Sampling Factor Horizontal sampling factor for component i. (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    static const uint32_t CONFRN3_RESET_VALUE = 0x0;

    static constexpr uint32_t CONFRN4_HD = 0x1;             // Huffman DC Selects the Huffman table for encoding the DC coefficients.
    static constexpr uint32_t CONFRN4_HA = 0x2;             // Huffman AC Selects the Huffman table for encoding the AC coefficients.
    template<uint32_t X>
    static constexpr uint32_t CONFRN4_QT =                  // Quantization Table Selects quantization table associated with a color component. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CONFRN4_NB =                  // Number of Block Number of data units minus 1 that belong to a particular color in the MCU. (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CONFRN4_VSF =                 // Vertical Sampling Factor Vertical sampling factor for component i. (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CONFRN4_HSF =                 // Horizontal Sampling Factor Horizontal sampling factor for component i. (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    static const uint32_t CONFRN4_RESET_VALUE = 0x0;

    static constexpr uint32_t CR_JCEN = 0x1;           // JPEG Core Enable Enable the JPEG codec Core.
    static constexpr uint32_t CR_IFTIE = 0x2;          // Input FIFO Threshold Interrupt Enable This bit enables the interrupt generation when input FIFO reach the threshold.
    static constexpr uint32_t CR_IFNFIE = 0x4;         // Input FIFO Not Full Interrupt Enable This bit enables the interrupt generation when input FIFO is not empty.
    static constexpr uint32_t CR_OFTIE = 0x8;          // Output FIFO Threshold Interrupt Enable This bit enables the interrupt generation when output FIFO reach the threshold.
    static constexpr uint32_t CR_OFNEIE = 0x10;        // Output FIFO Not Empty Interrupt Enable This bit enables the interrupt generation when output FIFO is not empty.
    static constexpr uint32_t CR_EOCIE = 0x20;         // End of Conversion Interrupt Enable This bit enables the interrupt generation on the end of conversion.
    static constexpr uint32_t CR_HPDIE = 0x40;         // Header Parsing Done Interrupt Enable This bit enables the interrupt generation on the Header Parsing Operation.
    static constexpr uint32_t CR_IDMAEN = 0x800;       // Input DMA Enable Enable the DMA request generation for the input FIFO.
    static constexpr uint32_t CR_ODMAEN = 0x1000;      // Output DMA Enable Enable the DMA request generation for the output FIFO.
    static constexpr uint32_t CR_IFF = 0x2000;         // Input FIFO Flush This bit flush the input FIFO. This bit is always read as 0.
    static constexpr uint32_t CR_OFF = 0x4000;         // Output FIFO Flush This bit flush the output FIFO. This bit is always read as 0.
    static const uint32_t CR_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_IFTF = 0x2;           // Input FIFO Threshold Flag This bit is set when the input FIFO is not full and is bellow its threshold.
    static constexpr uint32_t SR_IFNFF = 0x4;          // Input FIFO Not Full Flag This bit is set when the input FIFO is not full (a data can be written).
    static constexpr uint32_t SR_OFTF = 0x8;           // Output FIFO Threshold Flag This bit is set when the output FIFO is not empty and has reach its threshold.
    static constexpr uint32_t SR_OFNEF = 0x10;         // Output FIFO Not Empty Flag This bit is set when the output FIFO is not empty (a data is available).
    static constexpr uint32_t SR_EOCF = 0x20;          // End of Conversion Flag This bit is set when the JPEG codec core has finished the encoding or the decoding process and than last data has been sent to the output FIFO.
    static constexpr uint32_t SR_HPDF = 0x40;          // Header Parsing Done Flag This bit is set in decode mode when the JPEG codec has finished the parsing of the headers and the internal registers have been updated.
    static constexpr uint32_t SR_COF = 0x80;           // Codec Operation Flag This bit is set when when a JPEG codec operation is on going (encoding or decoding).
    static const uint32_t SR_RESET_VALUE = 0x6;

    static constexpr uint32_t CFR_CEOCF = 0x20;         // Clear End of Conversion Flag Writing 1 clears the End of Conversion Flag of the JPEG Status Register.
    static constexpr uint32_t CFR_CHPDF = 0x40;         // Clear Header Parsing Done Flag Writing 1 clears the Header Parsing Done Flag of the JPEG Status Register.
    static const uint32_t CFR_RESET_VALUE = 0x0;


    static const uint32_t DIR_RESET_VALUE = 0x0;


    static const uint32_t DOR_RESET_VALUE = 0x0;

    static constexpr uint8_t JPEG = 121; // JPEG global interrupt
};

static jpeg_t& JPEG = *reinterpret_cast<jpeg_t*>(0x52003000);

#define HAVE_PERIPHERAL_JPEG


////
//
//    MDMA
//
////

struct mdma_t
{
    volatile uint32_t    GISR0;                // [Read-only] MDMA Global Interrupt/Status Register
    reserved_t<15>       _0;
    volatile uint32_t    C0ISR;                // [Read-only] MDMA channel x interrupt/status register
    volatile uint32_t    C0IFCR;               // [Write-only] MDMA channel x interrupt flag clear register
    volatile uint32_t    C0ESR;                // [Read-only] MDMA Channel x error status register
    volatile uint32_t    C0CR;                 // This register is used to control the concerned channel.
    volatile uint32_t    C0TCR;                // [Read-write] This register is used to configure the concerned channel.
    volatile uint32_t    C0BNDTR;              // [Read-write] MDMA Channel x block number of data register
    volatile uint32_t    C0SAR;                // [Read-write] MDMA channel x source address register
    volatile uint32_t    C0DAR;                // [Read-write] MDMA channel x destination address register
    volatile uint32_t    C0BRUR;               // [Read-write] MDMA channel x Block Repeat address Update register
    volatile uint32_t    C0LAR;                // [Read-write] MDMA channel x Link Address register
    volatile uint32_t    C0TBR;                // [Read-write] MDMA channel x Trigger and Bus selection Register
    reserved_t<1>        _1;
    volatile uint32_t    C0MAR;                // [Read-write] MDMA channel x Mask address register
    volatile uint32_t    C0MDR;                // [Read-write] MDMA channel x Mask Data register
    reserved_t<2>        _2;
    volatile uint32_t    C1ISR;                // [Read-only] MDMA channel x interrupt/status register
    volatile uint32_t    C1IFCR;               // [Write-only] MDMA channel x interrupt flag clear register
    volatile uint32_t    C1ESR;                // [Read-only] MDMA Channel x error status register
    volatile uint32_t    C1CR;                 // This register is used to control the concerned channel.
    volatile uint32_t    C1TCR;                // [Read-write] This register is used to configure the concerned channel.
    volatile uint32_t    C1BNDTR;              // [Read-write] MDMA Channel x block number of data register
    volatile uint32_t    C1SAR;                // [Read-write] MDMA channel x source address register
    volatile uint32_t    C1DAR;                // [Read-write] MDMA channel x destination address register
    volatile uint32_t    C1BRUR;               // [Read-write] MDMA channel x Block Repeat address Update register
    volatile uint32_t    C1LAR;                // [Read-write] MDMA channel x Link Address register
    volatile uint32_t    C1TBR;                // [Read-write] MDMA channel x Trigger and Bus selection Register
    reserved_t<1>        _3;
    volatile uint32_t    C1MAR;                // [Read-write] MDMA channel x Mask address register
    volatile uint32_t    C1MDR;                // [Read-write] MDMA channel x Mask Data register
    reserved_t<2>        _4;
    volatile uint32_t    C2ISR;                // [Read-only] MDMA channel x interrupt/status register
    volatile uint32_t    C2IFCR;               // [Write-only] MDMA channel x interrupt flag clear register
    volatile uint32_t    C2ESR;                // [Read-only] MDMA Channel x error status register
    volatile uint32_t    C2CR;                 // This register is used to control the concerned channel.
    volatile uint32_t    C2TCR;                // [Read-write] This register is used to configure the concerned channel.
    volatile uint32_t    C2BNDTR;              // [Read-write] MDMA Channel x block number of data register
    volatile uint32_t    C2SAR;                // [Read-write] MDMA channel x source address register
    volatile uint32_t    C2DAR;                // [Read-write] MDMA channel x destination address register
    volatile uint32_t    C2BRUR;               // [Read-write] MDMA channel x Block Repeat address Update register
    volatile uint32_t    C2LAR;                // [Read-write] MDMA channel x Link Address register
    volatile uint32_t    C2TBR;                // [Read-write] MDMA channel x Trigger and Bus selection Register
    reserved_t<1>        _5;
    volatile uint32_t    C2MAR;                // [Read-write] MDMA channel x Mask address register
    volatile uint32_t    C2MDR;                // [Read-write] MDMA channel x Mask Data register
    reserved_t<2>        _6;
    volatile uint32_t    C3ISR;                // [Read-only] MDMA channel x interrupt/status register
    volatile uint32_t    C3IFCR;               // [Write-only] MDMA channel x interrupt flag clear register
    volatile uint32_t    C3ESR;                // [Read-only] MDMA Channel x error status register
    volatile uint32_t    C3CR;                 // This register is used to control the concerned channel.
    volatile uint32_t    C3TCR;                // [Read-write] This register is used to configure the concerned channel.
    volatile uint32_t    C3BNDTR;              // [Read-write] MDMA Channel x block number of data register
    volatile uint32_t    C3SAR;                // [Read-write] MDMA channel x source address register
    volatile uint32_t    C3DAR;                // [Read-write] MDMA channel x destination address register
    volatile uint32_t    C3BRUR;               // [Read-write] MDMA channel x Block Repeat address Update register
    volatile uint32_t    C3LAR;                // [Read-write] MDMA channel x Link Address register
    volatile uint32_t    C3TBR;                // [Read-write] MDMA channel x Trigger and Bus selection Register
    reserved_t<1>        _7;
    volatile uint32_t    C3MAR;                // [Read-write] MDMA channel x Mask address register
    volatile uint32_t    C3MDR;                // [Read-write] MDMA channel x Mask Data register
    reserved_t<2>        _8;
    volatile uint32_t    C4ISR;                // [Read-only] MDMA channel x interrupt/status register
    volatile uint32_t    C4IFCR;               // [Write-only] MDMA channel x interrupt flag clear register
    volatile uint32_t    C4ESR;                // [Read-only] MDMA Channel x error status register
    volatile uint32_t    C4CR;                 // This register is used to control the concerned channel.
    volatile uint32_t    C4TCR;                // [Read-write] This register is used to configure the concerned channel.
    volatile uint32_t    C4BNDTR;              // [Read-write] MDMA Channel x block number of data register
    volatile uint32_t    C4SAR;                // [Read-write] MDMA channel x source address register
    volatile uint32_t    C4DAR;                // [Read-write] MDMA channel x destination address register
    volatile uint32_t    C4BRUR;               // [Read-write] MDMA channel x Block Repeat address Update register
    volatile uint32_t    C4LAR;                // [Read-write] MDMA channel x Link Address register
    volatile uint32_t    C4TBR;                // [Read-write] MDMA channel x Trigger and Bus selection Register
    reserved_t<1>        _9;
    volatile uint32_t    C4MAR;                // [Read-write] MDMA channel x Mask address register
    volatile uint32_t    C4MDR;                // [Read-write] MDMA channel x Mask Data register
    reserved_t<2>        _10;
    volatile uint32_t    C5ISR;                // [Read-only] MDMA channel x interrupt/status register
    volatile uint32_t    C5IFCR;               // [Write-only] MDMA channel x interrupt flag clear register
    volatile uint32_t    C5ESR;                // [Read-only] MDMA Channel x error status register
    volatile uint32_t    C5CR;                 // This register is used to control the concerned channel.
    volatile uint32_t    C5TCR;                // [Read-write] This register is used to configure the concerned channel.
    volatile uint32_t    C5BNDTR;              // [Read-write] MDMA Channel x block number of data register
    volatile uint32_t    C5SAR;                // [Read-write] MDMA channel x source address register
    volatile uint32_t    C5DAR;                // [Read-write] MDMA channel x destination address register
    volatile uint32_t    C5BRUR;               // [Read-write] MDMA channel x Block Repeat address Update register
    volatile uint32_t    C5LAR;                // [Read-write] MDMA channel x Link Address register
    volatile uint32_t    C5TBR;                // [Read-write] MDMA channel x Trigger and Bus selection Register
    reserved_t<1>        _11;
    volatile uint32_t    C5MAR;                // [Read-write] MDMA channel x Mask address register
    volatile uint32_t    C5MDR;                // [Read-write] MDMA channel x Mask Data register
    reserved_t<2>        _12;
    volatile uint32_t    C6ISR;                // [Read-only] MDMA channel x interrupt/status register
    volatile uint32_t    C6IFCR;               // [Write-only] MDMA channel x interrupt flag clear register
    volatile uint32_t    C6ESR;                // [Read-only] MDMA Channel x error status register
    volatile uint32_t    C6CR;                 // This register is used to control the concerned channel.
    volatile uint32_t    C6TCR;                // [Read-write] This register is used to configure the concerned channel.
    volatile uint32_t    C6BNDTR;              // [Read-write] MDMA Channel x block number of data register
    volatile uint32_t    C6SAR;                // [Read-write] MDMA channel x source address register
    volatile uint32_t    C6DAR;                // [Read-write] MDMA channel x destination address register
    volatile uint32_t    C6BRUR;               // [Read-write] MDMA channel x Block Repeat address Update register
    volatile uint32_t    C6LAR;                // [Read-write] MDMA channel x Link Address register
    volatile uint32_t    C6TBR;                // [Read-write] MDMA channel x Trigger and Bus selection Register
    reserved_t<1>        _13;
    volatile uint32_t    C6MAR;                // [Read-write] MDMA channel x Mask address register
    volatile uint32_t    C6MDR;                // [Read-write] MDMA channel x Mask Data register
    reserved_t<2>        _14;
    volatile uint32_t    C7ISR;                // [Read-only] MDMA channel x interrupt/status register
    volatile uint32_t    C7IFCR;               // [Write-only] MDMA channel x interrupt flag clear register
    volatile uint32_t    C7ESR;                // [Read-only] MDMA Channel x error status register
    volatile uint32_t    C7CR;                 // This register is used to control the concerned channel.
    volatile uint32_t    C7TCR;                // [Read-write] This register is used to configure the concerned channel.
    volatile uint32_t    C7BNDTR;              // [Read-write] MDMA Channel x block number of data register
    volatile uint32_t    C7SAR;                // [Read-write] MDMA channel x source address register
    volatile uint32_t    C7DAR;                // [Read-write] MDMA channel x destination address register
    volatile uint32_t    C7BRUR;               // [Read-write] MDMA channel x Block Repeat address Update register
    volatile uint32_t    C7LAR;                // [Read-write] MDMA channel x Link Address register
    volatile uint32_t    C7TBR;                // [Read-write] MDMA channel x Trigger and Bus selection Register
    reserved_t<1>        _15;
    volatile uint32_t    C7MAR;                // [Read-write] MDMA channel x Mask address register
    volatile uint32_t    C7MDR;                // [Read-write] MDMA channel x Mask Data register
    reserved_t<2>        _16;
    volatile uint32_t    C8ISR;                // [Read-only] MDMA channel x interrupt/status register
    volatile uint32_t    C8IFCR;               // [Write-only] MDMA channel x interrupt flag clear register
    volatile uint32_t    C8ESR;                // [Read-only] MDMA Channel x error status register
    volatile uint32_t    C8CR;                 // This register is used to control the concerned channel.
    volatile uint32_t    C8TCR;                // [Read-write] This register is used to configure the concerned channel.
    volatile uint32_t    C8BNDTR;              // [Read-write] MDMA Channel x block number of data register
    volatile uint32_t    C8SAR;                // [Read-write] MDMA channel x source address register
    volatile uint32_t    C8DAR;                // [Read-write] MDMA channel x destination address register
    volatile uint32_t    C8BRUR;               // [Read-write] MDMA channel x Block Repeat address Update register
    volatile uint32_t    C8LAR;                // [Read-write] MDMA channel x Link Address register
    volatile uint32_t    C8TBR;                // [Read-write] MDMA channel x Trigger and Bus selection Register
    reserved_t<1>        _17;
    volatile uint32_t    C8MAR;                // [Read-write] MDMA channel x Mask address register
    volatile uint32_t    C8MDR;                // [Read-write] MDMA channel x Mask Data register
    reserved_t<2>        _18;
    volatile uint32_t    C9ISR;                // [Read-only] MDMA channel x interrupt/status register
    volatile uint32_t    C9IFCR;               // [Write-only] MDMA channel x interrupt flag clear register
    volatile uint32_t    C9ESR;                // [Read-only] MDMA Channel x error status register
    volatile uint32_t    C9CR;                 // This register is used to control the concerned channel.
    volatile uint32_t    C9TCR;                // [Read-write] This register is used to configure the concerned channel.
    volatile uint32_t    C9BNDTR;              // [Read-write] MDMA Channel x block number of data register
    volatile uint32_t    C9SAR;                // [Read-write] MDMA channel x source address register
    volatile uint32_t    C9DAR;                // [Read-write] MDMA channel x destination address register
    volatile uint32_t    C9BRUR;               // [Read-write] MDMA channel x Block Repeat address Update register
    volatile uint32_t    C9LAR;                // [Read-write] MDMA channel x Link Address register
    volatile uint32_t    C9TBR;                // [Read-write] MDMA channel x Trigger and Bus selection Register
    reserved_t<1>        _19;
    volatile uint32_t    C9MAR;                // [Read-write] MDMA channel x Mask address register
    volatile uint32_t    C9MDR;                // [Read-write] MDMA channel x Mask Data register
    reserved_t<2>        _20;
    volatile uint32_t    C10ISR;               // [Read-only] MDMA channel x interrupt/status register
    volatile uint32_t    C10IFCR;              // [Write-only] MDMA channel x interrupt flag clear register
    volatile uint32_t    C10ESR;               // [Read-only] MDMA Channel x error status register
    volatile uint32_t    C10CR;                // This register is used to control the concerned channel.
    volatile uint32_t    C10TCR;               // [Read-write] This register is used to configure the concerned channel.
    volatile uint32_t    C10BNDTR;             // [Read-write] MDMA Channel x block number of data register
    volatile uint32_t    C10SAR;               // [Read-write] MDMA channel x source address register
    volatile uint32_t    C10DAR;               // [Read-write] MDMA channel x destination address register
    volatile uint32_t    C10BRUR;              // [Read-write] MDMA channel x Block Repeat address Update register
    volatile uint32_t    C10LAR;               // [Read-write] MDMA channel x Link Address register
    volatile uint32_t    C10TBR;               // [Read-write] MDMA channel x Trigger and Bus selection Register
    reserved_t<1>        _21;
    volatile uint32_t    C10MAR;               // [Read-write] MDMA channel x Mask address register
    volatile uint32_t    C10MDR;               // [Read-write] MDMA channel x Mask Data register
    reserved_t<2>        _22;
    volatile uint32_t    C11ISR;               // [Read-only] MDMA channel x interrupt/status register
    volatile uint32_t    C11IFCR;              // [Write-only] MDMA channel x interrupt flag clear register
    volatile uint32_t    C11ESR;               // [Read-only] MDMA Channel x error status register
    volatile uint32_t    C11CR;                // This register is used to control the concerned channel.
    volatile uint32_t    C11TCR;               // [Read-write] This register is used to configure the concerned channel.
    volatile uint32_t    C11BNDTR;             // [Read-write] MDMA Channel x block number of data register
    volatile uint32_t    C11SAR;               // [Read-write] MDMA channel x source address register
    volatile uint32_t    C11DAR;               // [Read-write] MDMA channel x destination address register
    volatile uint32_t    C11BRUR;              // [Read-write] MDMA channel x Block Repeat address Update register
    volatile uint32_t    C11LAR;               // [Read-write] MDMA channel x Link Address register
    volatile uint32_t    C11TBR;               // [Read-write] MDMA channel x Trigger and Bus selection Register
    reserved_t<1>        _23;
    volatile uint32_t    C11MAR;               // [Read-write] MDMA channel x Mask address register
    volatile uint32_t    C11MDR;               // [Read-write] MDMA channel x Mask Data register
    reserved_t<2>        _24;
    volatile uint32_t    C12ISR;               // [Read-only] MDMA channel x interrupt/status register
    volatile uint32_t    C12IFCR;              // [Write-only] MDMA channel x interrupt flag clear register
    volatile uint32_t    C12ESR;               // [Read-only] MDMA Channel x error status register
    volatile uint32_t    C12CR;                // This register is used to control the concerned channel.
    volatile uint32_t    C12TCR;               // [Read-write] This register is used to configure the concerned channel.
    volatile uint32_t    C12BNDTR;             // [Read-write] MDMA Channel x block number of data register
    volatile uint32_t    C12SAR;               // [Read-write] MDMA channel x source address register
    volatile uint32_t    C12DAR;               // [Read-write] MDMA channel x destination address register
    volatile uint32_t    C12BRUR;              // [Read-write] MDMA channel x Block Repeat address Update register
    volatile uint32_t    C12LAR;               // [Read-write] MDMA channel x Link Address register
    volatile uint32_t    C12TBR;               // [Read-write] MDMA channel x Trigger and Bus selection Register
    reserved_t<1>        _25;
    volatile uint32_t    C12MAR;               // [Read-write] MDMA channel x Mask address register
    volatile uint32_t    C12MDR;               // [Read-write] MDMA channel x Mask Data register
    reserved_t<2>        _26;
    volatile uint32_t    C13ISR;               // [Read-only] MDMA channel x interrupt/status register
    volatile uint32_t    C13IFCR;              // [Write-only] MDMA channel x interrupt flag clear register
    volatile uint32_t    C13ESR;               // [Read-only] MDMA Channel x error status register
    volatile uint32_t    C13CR;                // This register is used to control the concerned channel.
    volatile uint32_t    C13TCR;               // [Read-write] This register is used to configure the concerned channel.
    volatile uint32_t    C13BNDTR;             // [Read-write] MDMA Channel x block number of data register
    volatile uint32_t    C13SAR;               // [Read-write] MDMA channel x source address register
    volatile uint32_t    C13DAR;               // [Read-write] MDMA channel x destination address register
    volatile uint32_t    C13BRUR;              // [Read-write] MDMA channel x Block Repeat address Update register
    volatile uint32_t    C13LAR;               // [Read-write] MDMA channel x Link Address register
    volatile uint32_t    C13TBR;               // [Read-write] MDMA channel x Trigger and Bus selection Register
    reserved_t<1>        _27;
    volatile uint32_t    C13MAR;               // [Read-write] MDMA channel x Mask address register
    volatile uint32_t    C13MDR;               // [Read-write] MDMA channel x Mask Data register
    reserved_t<2>        _28;
    volatile uint32_t    C14ISR;               // [Read-only] MDMA channel x interrupt/status register
    volatile uint32_t    C14IFCR;              // [Write-only] MDMA channel x interrupt flag clear register
    volatile uint32_t    C14ESR;               // [Read-only] MDMA Channel x error status register
    volatile uint32_t    C14CR;                // This register is used to control the concerned channel.
    volatile uint32_t    C14TCR;               // [Read-write] This register is used to configure the concerned channel.
    volatile uint32_t    C14BNDTR;             // [Read-write] MDMA Channel x block number of data register
    volatile uint32_t    C14SAR;               // [Read-write] MDMA channel x source address register
    volatile uint32_t    C14DAR;               // [Read-write] MDMA channel x destination address register
    volatile uint32_t    C14BRUR;              // [Read-write] MDMA channel x Block Repeat address Update register
    volatile uint32_t    C14LAR;               // [Read-write] MDMA channel x Link Address register
    volatile uint32_t    C14TBR;               // [Read-write] MDMA channel x Trigger and Bus selection Register
    reserved_t<1>        _29;
    volatile uint32_t    C14MAR;               // [Read-write] MDMA channel x Mask address register
    volatile uint32_t    C14MDR;               // [Read-write] MDMA channel x Mask Data register
    reserved_t<2>        _30;
    volatile uint32_t    C15ISR;               // [Read-only] MDMA channel x interrupt/status register
    volatile uint32_t    C15IFCR;              // [Write-only] MDMA channel x interrupt flag clear register
    volatile uint32_t    C15ESR;               // [Read-only] MDMA Channel x error status register
    volatile uint32_t    C15CR;                // This register is used to control the concerned channel.
    volatile uint32_t    C15TCR;               // [Read-write] This register is used to configure the concerned channel.
    volatile uint32_t    C15BNDTR;             // [Read-write] MDMA Channel x block number of data register
    volatile uint32_t    C15SAR;               // [Read-write] MDMA channel x source address register
    volatile uint32_t    C15DAR;               // [Read-write] MDMA channel x destination address register
    volatile uint32_t    C15BRUR;              // [Read-write] MDMA channel x Block Repeat address Update register
    volatile uint32_t    C15LAR;               // [Read-write] MDMA channel x Link Address register
    volatile uint32_t    C15TBR;               // [Read-write] MDMA channel x Trigger and Bus selection Register
    reserved_t<1>        _31;
    volatile uint32_t    C15MAR;               // [Read-write] MDMA channel x Mask address register
    volatile uint32_t    C15MDR;               // [Read-write] MDMA channel x Mask Data register

    static constexpr uint32_t GISR0_GIF0 = 0x1;           // Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
    static constexpr uint32_t GISR0_GIF1 = 0x2;           // Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
    static constexpr uint32_t GISR0_GIF2 = 0x4;           // Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
    static constexpr uint32_t GISR0_GIF3 = 0x8;           // Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
    static constexpr uint32_t GISR0_GIF4 = 0x10;          // Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
    static constexpr uint32_t GISR0_GIF5 = 0x20;          // Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
    static constexpr uint32_t GISR0_GIF6 = 0x40;          // Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
    static constexpr uint32_t GISR0_GIF7 = 0x80;          // Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
    static constexpr uint32_t GISR0_GIF8 = 0x100;         // Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
    static constexpr uint32_t GISR0_GIF9 = 0x200;         // Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
    static constexpr uint32_t GISR0_GIF10 = 0x400;        // Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
    static constexpr uint32_t GISR0_GIF11 = 0x800;        // Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
    static constexpr uint32_t GISR0_GIF12 = 0x1000;       // Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
    static constexpr uint32_t GISR0_GIF13 = 0x2000;       // Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
    static constexpr uint32_t GISR0_GIF14 = 0x4000;       // Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
    static constexpr uint32_t GISR0_GIF15 = 0x8000;       // Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
    static const uint32_t GISR0_RESET_VALUE = 0x0;

    static constexpr uint32_t C0ISR_TEIF0 = 0x1;          // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C0ISR_CTCIF0 = 0x2;         // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
    static constexpr uint32_t C0ISR_BRTIF0 = 0x4;         // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C0ISR_BTIF0 = 0x8;          // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C0ISR_TCIF0 = 0x10;         // channel x buffer transfer complete
    static constexpr uint32_t C0ISR_CRQA0 = 0x10000;      // channel x request active flag
    static const uint32_t C0ISR_RESET_VALUE = 0x0;

    static constexpr uint32_t C0IFCR_CTEIF0 = 0x1;         // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
    static constexpr uint32_t C0IFCR_CCTCIF0 = 0x2;        // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
    static constexpr uint32_t C0IFCR_CBRTIF0 = 0x4;        // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
    static constexpr uint32_t C0IFCR_CBTIF0 = 0x8;         // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
    static constexpr uint32_t C0IFCR_CLTCIF0 = 0x10;       // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
    static const uint32_t C0IFCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C0ESR_TEA =                 // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error. (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    static constexpr uint32_t C0ESR_TED = 0x80;           // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
    static constexpr uint32_t C0ESR_TELD = 0x100;         // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C0ESR_TEMD = 0x200;         // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C0ESR_ASE = 0x400;          // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C0ESR_BSE = 0x800;          // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static const uint32_t C0ESR_RESET_VALUE = 0x0;

    static constexpr uint32_t C0CR_EN = 0x1;             // channel enable, Read-write
    static constexpr uint32_t C0CR_TEIE = 0x2;           // Transfer error interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C0CR_CTCIE = 0x4;          // Channel Transfer Complete interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C0CR_BRTIE = 0x8;          // Block Repeat transfer interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C0CR_BTIE = 0x10;          // Block Transfer interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C0CR_TCIE = 0x20;          // buffer Transfer Complete interrupt enable This bit is set and cleared by software., Read-write
    template<uint32_t X>
    static constexpr uint32_t C0CR_PL =                  // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. (2 bits), Read-write
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t C0CR_BEX = 0x1000;         // byte Endianness exchange, Read-write
    static constexpr uint32_t C0CR_HEX = 0x2000;         // Half word Endianes exchange, Read-write
    static constexpr uint32_t C0CR_WEX = 0x4000;         // Word Endianness exchange, Read-write
    static constexpr uint32_t C0CR_SWRQ = 0x10000;       // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access)., Write-only
    static const uint32_t C0CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C0TCR_SINC =                // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C0TCR_DINC =                // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C0TCR_SSIZE =               // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &amp;lt; SSIZE and SINC &amp;#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C0TCR_DSIZE =               // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &amp;lt; DSIZE and DINC &amp;#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C0TCR_SINCOS =              // source increment offset size (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C0TCR_DINCOS =              // Destination increment offset (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C0TCR_SBURST =              // source burst transfer configuration (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C0TCR_DBURST =              // Destination burst transfer configuration (3 bits)
        bit_field_t<15, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C0TCR_TLEN =                // buffer transfer lengh (7 bits)
        bit_field_t<18, 0x7f>::value<X>();
    static constexpr uint32_t C0TCR_PKE = 0x2000000;      // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
    template<uint32_t X>
    static constexpr uint32_t C0TCR_PAM =                 // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C0TCR_TRGM =                // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    static constexpr uint32_t C0TCR_SWRM = 0x40000000;    // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
    static constexpr uint32_t C0TCR_BWM = 0x80000000;     // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
    static const uint32_t C0TCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C0BNDTR_BNDT =                // block number of data to transfer (17 bits)
        bit_field_t<0, 0x1ffff>::value<X>();
    static constexpr uint32_t C0BNDTR_BRSUM = 0x40000;      // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
    static constexpr uint32_t C0BNDTR_BRDUM = 0x80000;      // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
    template<uint32_t X>
    static constexpr uint32_t C0BNDTR_BRC =                 // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0. (12 bits)
        bit_field_t<20, 0xfff>::value<X>();
    static const uint32_t C0BNDTR_RESET_VALUE = 0x0;


    static const uint32_t C0SAR_RESET_VALUE = 0x0;


    static const uint32_t C0DAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C0BRUR_SUV =                 // source adresse update value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C0BRUR_DUV =                 // destination address update (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t C0BRUR_RESET_VALUE = 0x0;


    static const uint32_t C0LAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C0TBR_TSEL =                // Trigger selection (6 bits)
        bit_field_t<0, 0x3f>::value<X>();
    static constexpr uint32_t C0TBR_SBUS = 0x10000;       // Source BUS select This bit is protected and can be written only if EN is 0.
    static constexpr uint32_t C0TBR_DBUS = 0x20000;       // Destination BUS slect This bit is protected and can be written only if EN is 0.
    static const uint32_t C0TBR_RESET_VALUE = 0x0;


    static const uint32_t C0MAR_RESET_VALUE = 0x0;


    static const uint32_t C0MDR_RESET_VALUE = 0x0;

    static constexpr uint32_t C1ISR_TEIF1 = 0x1;          // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C1ISR_CTCIF1 = 0x2;         // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
    static constexpr uint32_t C1ISR_BRTIF1 = 0x4;         // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C1ISR_BTIF1 = 0x8;          // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C1ISR_TCIF1 = 0x10;         // channel x buffer transfer complete
    static constexpr uint32_t C1ISR_CRQA1 = 0x10000;      // channel x request active flag
    static const uint32_t C1ISR_RESET_VALUE = 0x0;

    static constexpr uint32_t C1IFCR_CTEIF1 = 0x1;         // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
    static constexpr uint32_t C1IFCR_CCTCIF1 = 0x2;        // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
    static constexpr uint32_t C1IFCR_CBRTIF1 = 0x4;        // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
    static constexpr uint32_t C1IFCR_CBTIF1 = 0x8;         // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
    static constexpr uint32_t C1IFCR_CLTCIF1 = 0x10;       // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
    static const uint32_t C1IFCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C1ESR_TEA =                 // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error. (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    static constexpr uint32_t C1ESR_TED = 0x80;           // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
    static constexpr uint32_t C1ESR_TELD = 0x100;         // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C1ESR_TEMD = 0x200;         // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C1ESR_ASE = 0x400;          // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C1ESR_BSE = 0x800;          // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static const uint32_t C1ESR_RESET_VALUE = 0x0;

    static constexpr uint32_t C1CR_EN = 0x1;             // channel enable, Read-write
    static constexpr uint32_t C1CR_TEIE = 0x2;           // Transfer error interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C1CR_CTCIE = 0x4;          // Channel Transfer Complete interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C1CR_BRTIE = 0x8;          // Block Repeat transfer interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C1CR_BTIE = 0x10;          // Block Transfer interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C1CR_TCIE = 0x20;          // buffer Transfer Complete interrupt enable This bit is set and cleared by software., Read-write
    template<uint32_t X>
    static constexpr uint32_t C1CR_PL =                  // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. (2 bits), Read-write
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t C1CR_BEX = 0x1000;         // byte Endianness exchange, Read-write
    static constexpr uint32_t C1CR_HEX = 0x2000;         // Half word Endianes exchange, Read-write
    static constexpr uint32_t C1CR_WEX = 0x4000;         // Word Endianness exchange, Read-write
    static constexpr uint32_t C1CR_SWRQ = 0x10000;       // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access)., Write-only
    static const uint32_t C1CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C1TCR_SINC =                // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C1TCR_DINC =                // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C1TCR_SSIZE =               // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &amp;lt; SSIZE and SINC &amp;#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C1TCR_DSIZE =               // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &amp;lt; DSIZE and DINC &amp;#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C1TCR_SINCOS =              // source increment offset size (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C1TCR_DINCOS =              // Destination increment offset (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C1TCR_SBURST =              // source burst transfer configuration (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C1TCR_DBURST =              // Destination burst transfer configuration (3 bits)
        bit_field_t<15, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C1TCR_TLEN =                // buffer transfer lengh (7 bits)
        bit_field_t<18, 0x7f>::value<X>();
    static constexpr uint32_t C1TCR_PKE = 0x2000000;      // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
    template<uint32_t X>
    static constexpr uint32_t C1TCR_PAM =                 // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C1TCR_TRGM =                // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    static constexpr uint32_t C1TCR_SWRM = 0x40000000;    // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
    static constexpr uint32_t C1TCR_BWM = 0x80000000;     // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
    static const uint32_t C1TCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C1BNDTR_BNDT =                // block number of data to transfer (17 bits)
        bit_field_t<0, 0x1ffff>::value<X>();
    static constexpr uint32_t C1BNDTR_BRSUM = 0x40000;      // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
    static constexpr uint32_t C1BNDTR_BRDUM = 0x80000;      // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
    template<uint32_t X>
    static constexpr uint32_t C1BNDTR_BRC =                 // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0. (12 bits)
        bit_field_t<20, 0xfff>::value<X>();
    static const uint32_t C1BNDTR_RESET_VALUE = 0x0;


    static const uint32_t C1SAR_RESET_VALUE = 0x0;


    static const uint32_t C1DAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C1BRUR_SUV =                 // source adresse update value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C1BRUR_DUV =                 // destination address update (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t C1BRUR_RESET_VALUE = 0x0;


    static const uint32_t C1LAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C1TBR_TSEL =                // Trigger selection (6 bits)
        bit_field_t<0, 0x3f>::value<X>();
    static constexpr uint32_t C1TBR_SBUS = 0x10000;       // Source BUS select This bit is protected and can be written only if EN is 0.
    static constexpr uint32_t C1TBR_DBUS = 0x20000;       // Destination BUS slect This bit is protected and can be written only if EN is 0.
    static const uint32_t C1TBR_RESET_VALUE = 0x0;


    static const uint32_t C1MAR_RESET_VALUE = 0x0;


    static const uint32_t C1MDR_RESET_VALUE = 0x0;

    static constexpr uint32_t C2ISR_TEIF2 = 0x1;          // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C2ISR_CTCIF2 = 0x2;         // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
    static constexpr uint32_t C2ISR_BRTIF2 = 0x4;         // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C2ISR_BTIF2 = 0x8;          // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C2ISR_TCIF2 = 0x10;         // channel x buffer transfer complete
    static constexpr uint32_t C2ISR_CRQA2 = 0x10000;      // channel x request active flag
    static const uint32_t C2ISR_RESET_VALUE = 0x0;

    static constexpr uint32_t C2IFCR_CTEIF2 = 0x1;         // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
    static constexpr uint32_t C2IFCR_CCTCIF2 = 0x2;        // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
    static constexpr uint32_t C2IFCR_CBRTIF2 = 0x4;        // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
    static constexpr uint32_t C2IFCR_CBTIF2 = 0x8;         // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
    static constexpr uint32_t C2IFCR_CLTCIF2 = 0x10;       // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
    static const uint32_t C2IFCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C2ESR_TEA =                 // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error. (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    static constexpr uint32_t C2ESR_TED = 0x80;           // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
    static constexpr uint32_t C2ESR_TELD = 0x100;         // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C2ESR_TEMD = 0x200;         // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C2ESR_ASE = 0x400;          // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C2ESR_BSE = 0x800;          // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static const uint32_t C2ESR_RESET_VALUE = 0x0;

    static constexpr uint32_t C2CR_EN = 0x1;             // channel enable, Read-write
    static constexpr uint32_t C2CR_TEIE = 0x2;           // Transfer error interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C2CR_CTCIE = 0x4;          // Channel Transfer Complete interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C2CR_BRTIE = 0x8;          // Block Repeat transfer interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C2CR_BTIE = 0x10;          // Block Transfer interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C2CR_TCIE = 0x20;          // buffer Transfer Complete interrupt enable This bit is set and cleared by software., Read-write
    template<uint32_t X>
    static constexpr uint32_t C2CR_PL =                  // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. (2 bits), Read-write
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t C2CR_BEX = 0x1000;         // byte Endianness exchange, Read-write
    static constexpr uint32_t C2CR_HEX = 0x2000;         // Half word Endianes exchange, Read-write
    static constexpr uint32_t C2CR_WEX = 0x4000;         // Word Endianness exchange, Read-write
    static constexpr uint32_t C2CR_SWRQ = 0x10000;       // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access)., Write-only
    static const uint32_t C2CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C2TCR_SINC =                // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C2TCR_DINC =                // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C2TCR_SSIZE =               // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &amp;lt; SSIZE and SINC &amp;#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C2TCR_DSIZE =               // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &amp;lt; DSIZE and DINC &amp;#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C2TCR_SINCOS =              // source increment offset size (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C2TCR_DINCOS =              // Destination increment offset (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C2TCR_SBURST =              // source burst transfer configuration (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C2TCR_DBURST =              // Destination burst transfer configuration (3 bits)
        bit_field_t<15, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C2TCR_TLEN =                // buffer transfer lengh (7 bits)
        bit_field_t<18, 0x7f>::value<X>();
    static constexpr uint32_t C2TCR_PKE = 0x2000000;      // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
    template<uint32_t X>
    static constexpr uint32_t C2TCR_PAM =                 // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C2TCR_TRGM =                // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    static constexpr uint32_t C2TCR_SWRM = 0x40000000;    // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
    static constexpr uint32_t C2TCR_BWM = 0x80000000;     // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
    static const uint32_t C2TCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C2BNDTR_BNDT =                // block number of data to transfer (17 bits)
        bit_field_t<0, 0x1ffff>::value<X>();
    static constexpr uint32_t C2BNDTR_BRSUM = 0x40000;      // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
    static constexpr uint32_t C2BNDTR_BRDUM = 0x80000;      // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
    template<uint32_t X>
    static constexpr uint32_t C2BNDTR_BRC =                 // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0. (12 bits)
        bit_field_t<20, 0xfff>::value<X>();
    static const uint32_t C2BNDTR_RESET_VALUE = 0x0;


    static const uint32_t C2SAR_RESET_VALUE = 0x0;


    static const uint32_t C2DAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C2BRUR_SUV =                 // source adresse update value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C2BRUR_DUV =                 // destination address update (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t C2BRUR_RESET_VALUE = 0x0;


    static const uint32_t C2LAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C2TBR_TSEL =                // Trigger selection (6 bits)
        bit_field_t<0, 0x3f>::value<X>();
    static constexpr uint32_t C2TBR_SBUS = 0x10000;       // Source BUS select This bit is protected and can be written only if EN is 0.
    static constexpr uint32_t C2TBR_DBUS = 0x20000;       // Destination BUS slect This bit is protected and can be written only if EN is 0.
    static const uint32_t C2TBR_RESET_VALUE = 0x0;


    static const uint32_t C2MAR_RESET_VALUE = 0x0;


    static const uint32_t C2MDR_RESET_VALUE = 0x0;

    static constexpr uint32_t C3ISR_TEIF3 = 0x1;          // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C3ISR_CTCIF3 = 0x2;         // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
    static constexpr uint32_t C3ISR_BRTIF3 = 0x4;         // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C3ISR_BTIF3 = 0x8;          // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C3ISR_TCIF3 = 0x10;         // channel x buffer transfer complete
    static constexpr uint32_t C3ISR_CRQA3 = 0x10000;      // channel x request active flag
    static const uint32_t C3ISR_RESET_VALUE = 0x0;

    static constexpr uint32_t C3IFCR_CTEIF3 = 0x1;         // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
    static constexpr uint32_t C3IFCR_CCTCIF3 = 0x2;        // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
    static constexpr uint32_t C3IFCR_CBRTIF3 = 0x4;        // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
    static constexpr uint32_t C3IFCR_CBTIF3 = 0x8;         // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
    static constexpr uint32_t C3IFCR_CLTCIF3 = 0x10;       // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
    static const uint32_t C3IFCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C3ESR_TEA =                 // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error. (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    static constexpr uint32_t C3ESR_TED = 0x80;           // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
    static constexpr uint32_t C3ESR_TELD = 0x100;         // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C3ESR_TEMD = 0x200;         // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C3ESR_ASE = 0x400;          // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C3ESR_BSE = 0x800;          // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static const uint32_t C3ESR_RESET_VALUE = 0x0;

    static constexpr uint32_t C3CR_EN = 0x1;             // channel enable, Read-write
    static constexpr uint32_t C3CR_TEIE = 0x2;           // Transfer error interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C3CR_CTCIE = 0x4;          // Channel Transfer Complete interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C3CR_BRTIE = 0x8;          // Block Repeat transfer interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C3CR_BTIE = 0x10;          // Block Transfer interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C3CR_TCIE = 0x20;          // buffer Transfer Complete interrupt enable This bit is set and cleared by software., Read-write
    template<uint32_t X>
    static constexpr uint32_t C3CR_PL =                  // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. (2 bits), Read-write
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t C3CR_BEX = 0x1000;         // byte Endianness exchange, Read-write
    static constexpr uint32_t C3CR_HEX = 0x2000;         // Half word Endianes exchange, Read-write
    static constexpr uint32_t C3CR_WEX = 0x4000;         // Word Endianness exchange, Read-write
    static constexpr uint32_t C3CR_SWRQ = 0x10000;       // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access)., Write-only
    static const uint32_t C3CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C3TCR_SINC =                // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C3TCR_DINC =                // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C3TCR_SSIZE =               // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &amp;lt; SSIZE and SINC &amp;#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C3TCR_DSIZE =               // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &amp;lt; DSIZE and DINC &amp;#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C3TCR_SINCOS =              // source increment offset size (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C3TCR_DINCOS =              // Destination increment offset (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C3TCR_SBURST =              // source burst transfer configuration (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C3TCR_DBURST =              // Destination burst transfer configuration (3 bits)
        bit_field_t<15, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C3TCR_TLEN =                // buffer transfer lengh (7 bits)
        bit_field_t<18, 0x7f>::value<X>();
    static constexpr uint32_t C3TCR_PKE = 0x2000000;      // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
    template<uint32_t X>
    static constexpr uint32_t C3TCR_PAM =                 // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C3TCR_TRGM =                // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    static constexpr uint32_t C3TCR_SWRM = 0x40000000;    // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
    static constexpr uint32_t C3TCR_BWM = 0x80000000;     // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
    static const uint32_t C3TCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C3BNDTR_BNDT =                // block number of data to transfer (17 bits)
        bit_field_t<0, 0x1ffff>::value<X>();
    static constexpr uint32_t C3BNDTR_BRSUM = 0x40000;      // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
    static constexpr uint32_t C3BNDTR_BRDUM = 0x80000;      // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
    template<uint32_t X>
    static constexpr uint32_t C3BNDTR_BRC =                 // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0. (12 bits)
        bit_field_t<20, 0xfff>::value<X>();
    static const uint32_t C3BNDTR_RESET_VALUE = 0x0;


    static const uint32_t C3SAR_RESET_VALUE = 0x0;


    static const uint32_t C3DAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C3BRUR_SUV =                 // source adresse update value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C3BRUR_DUV =                 // destination address update (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t C3BRUR_RESET_VALUE = 0x0;


    static const uint32_t C3LAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C3TBR_TSEL =                // Trigger selection (6 bits)
        bit_field_t<0, 0x3f>::value<X>();
    static constexpr uint32_t C3TBR_SBUS = 0x10000;       // Source BUS select This bit is protected and can be written only if EN is 0.
    static constexpr uint32_t C3TBR_DBUS = 0x20000;       // Destination BUS slect This bit is protected and can be written only if EN is 0.
    static const uint32_t C3TBR_RESET_VALUE = 0x0;


    static const uint32_t C3MAR_RESET_VALUE = 0x0;


    static const uint32_t C3MDR_RESET_VALUE = 0x0;

    static constexpr uint32_t C4ISR_TEIF4 = 0x1;          // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C4ISR_CTCIF4 = 0x2;         // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
    static constexpr uint32_t C4ISR_BRTIF4 = 0x4;         // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C4ISR_BTIF4 = 0x8;          // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C4ISR_TCIF4 = 0x10;         // channel x buffer transfer complete
    static constexpr uint32_t C4ISR_CRQA4 = 0x10000;      // channel x request active flag
    static const uint32_t C4ISR_RESET_VALUE = 0x0;

    static constexpr uint32_t C4IFCR_CTEIF4 = 0x1;         // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
    static constexpr uint32_t C4IFCR_CCTCIF4 = 0x2;        // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
    static constexpr uint32_t C4IFCR_CBRTIF4 = 0x4;        // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
    static constexpr uint32_t C4IFCR_CBTIF4 = 0x8;         // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
    static constexpr uint32_t C4IFCR_CLTCIF4 = 0x10;       // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
    static const uint32_t C4IFCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C4ESR_TEA =                 // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error. (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    static constexpr uint32_t C4ESR_TED = 0x80;           // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
    static constexpr uint32_t C4ESR_TELD = 0x100;         // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C4ESR_TEMD = 0x200;         // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C4ESR_ASE = 0x400;          // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C4ESR_BSE = 0x800;          // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static const uint32_t C4ESR_RESET_VALUE = 0x0;

    static constexpr uint32_t C4CR_EN = 0x1;             // channel enable, Read-write
    static constexpr uint32_t C4CR_TEIE = 0x2;           // Transfer error interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C4CR_CTCIE = 0x4;          // Channel Transfer Complete interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C4CR_BRTIE = 0x8;          // Block Repeat transfer interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C4CR_BTIE = 0x10;          // Block Transfer interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C4CR_TCIE = 0x20;          // buffer Transfer Complete interrupt enable This bit is set and cleared by software., Read-write
    template<uint32_t X>
    static constexpr uint32_t C4CR_PL =                  // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. (2 bits), Read-write
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t C4CR_BEX = 0x1000;         // byte Endianness exchange, Read-write
    static constexpr uint32_t C4CR_HEX = 0x2000;         // Half word Endianes exchange, Read-write
    static constexpr uint32_t C4CR_WEX = 0x4000;         // Word Endianness exchange, Read-write
    static constexpr uint32_t C4CR_SWRQ = 0x10000;       // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access)., Write-only
    static const uint32_t C4CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C4TCR_SINC =                // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C4TCR_DINC =                // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C4TCR_SSIZE =               // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &amp;lt; SSIZE and SINC &amp;#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C4TCR_DSIZE =               // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &amp;lt; DSIZE and DINC &amp;#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C4TCR_SINCOS =              // source increment offset size (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C4TCR_DINCOS =              // Destination increment offset (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C4TCR_SBURST =              // source burst transfer configuration (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C4TCR_DBURST =              // Destination burst transfer configuration (3 bits)
        bit_field_t<15, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C4TCR_TLEN =                // buffer transfer lengh (7 bits)
        bit_field_t<18, 0x7f>::value<X>();
    static constexpr uint32_t C4TCR_PKE = 0x2000000;      // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
    template<uint32_t X>
    static constexpr uint32_t C4TCR_PAM =                 // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C4TCR_TRGM =                // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    static constexpr uint32_t C4TCR_SWRM = 0x40000000;    // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
    static constexpr uint32_t C4TCR_BWM = 0x80000000;     // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
    static const uint32_t C4TCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C4BNDTR_BNDT =                // block number of data to transfer (17 bits)
        bit_field_t<0, 0x1ffff>::value<X>();
    static constexpr uint32_t C4BNDTR_BRSUM = 0x40000;      // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
    static constexpr uint32_t C4BNDTR_BRDUM = 0x80000;      // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
    template<uint32_t X>
    static constexpr uint32_t C4BNDTR_BRC =                 // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0. (12 bits)
        bit_field_t<20, 0xfff>::value<X>();
    static const uint32_t C4BNDTR_RESET_VALUE = 0x0;


    static const uint32_t C4SAR_RESET_VALUE = 0x0;


    static const uint32_t C4DAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C4BRUR_SUV =                 // source adresse update value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C4BRUR_DUV =                 // destination address update (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t C4BRUR_RESET_VALUE = 0x0;


    static const uint32_t C4LAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C4TBR_TSEL =                // Trigger selection (6 bits)
        bit_field_t<0, 0x3f>::value<X>();
    static constexpr uint32_t C4TBR_SBUS = 0x10000;       // Source BUS select This bit is protected and can be written only if EN is 0.
    static constexpr uint32_t C4TBR_DBUS = 0x20000;       // Destination BUS slect This bit is protected and can be written only if EN is 0.
    static const uint32_t C4TBR_RESET_VALUE = 0x0;


    static const uint32_t C4MAR_RESET_VALUE = 0x0;


    static const uint32_t C4MDR_RESET_VALUE = 0x0;

    static constexpr uint32_t C5ISR_TEIF5 = 0x1;          // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C5ISR_CTCIF5 = 0x2;         // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
    static constexpr uint32_t C5ISR_BRTIF5 = 0x4;         // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C5ISR_BTIF5 = 0x8;          // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C5ISR_TCIF5 = 0x10;         // channel x buffer transfer complete
    static constexpr uint32_t C5ISR_CRQA5 = 0x10000;      // channel x request active flag
    static const uint32_t C5ISR_RESET_VALUE = 0x0;

    static constexpr uint32_t C5IFCR_CTEIF5 = 0x1;         // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
    static constexpr uint32_t C5IFCR_CCTCIF5 = 0x2;        // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
    static constexpr uint32_t C5IFCR_CBRTIF5 = 0x4;        // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
    static constexpr uint32_t C5IFCR_CBTIF5 = 0x8;         // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
    static constexpr uint32_t C5IFCR_CLTCIF5 = 0x10;       // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
    static const uint32_t C5IFCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C5ESR_TEA =                 // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error. (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    static constexpr uint32_t C5ESR_TED = 0x80;           // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
    static constexpr uint32_t C5ESR_TELD = 0x100;         // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C5ESR_TEMD = 0x200;         // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C5ESR_ASE = 0x400;          // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C5ESR_BSE = 0x800;          // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static const uint32_t C5ESR_RESET_VALUE = 0x0;

    static constexpr uint32_t C5CR_EN = 0x1;             // channel enable, Read-write
    static constexpr uint32_t C5CR_TEIE = 0x2;           // Transfer error interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C5CR_CTCIE = 0x4;          // Channel Transfer Complete interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C5CR_BRTIE = 0x8;          // Block Repeat transfer interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C5CR_BTIE = 0x10;          // Block Transfer interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C5CR_TCIE = 0x20;          // buffer Transfer Complete interrupt enable This bit is set and cleared by software., Read-write
    template<uint32_t X>
    static constexpr uint32_t C5CR_PL =                  // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. (2 bits), Read-write
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t C5CR_BEX = 0x1000;         // byte Endianness exchange, Read-write
    static constexpr uint32_t C5CR_HEX = 0x2000;         // Half word Endianes exchange, Read-write
    static constexpr uint32_t C5CR_WEX = 0x4000;         // Word Endianness exchange, Read-write
    static constexpr uint32_t C5CR_SWRQ = 0x10000;       // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access)., Write-only
    static const uint32_t C5CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C5TCR_SINC =                // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C5TCR_DINC =                // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C5TCR_SSIZE =               // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &amp;lt; SSIZE and SINC &amp;#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C5TCR_DSIZE =               // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &amp;lt; DSIZE and DINC &amp;#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C5TCR_SINCOS =              // source increment offset size (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C5TCR_DINCOS =              // Destination increment offset (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C5TCR_SBURST =              // source burst transfer configuration (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C5TCR_DBURST =              // Destination burst transfer configuration (3 bits)
        bit_field_t<15, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C5TCR_TLEN =                // buffer transfer lengh (7 bits)
        bit_field_t<18, 0x7f>::value<X>();
    static constexpr uint32_t C5TCR_PKE = 0x2000000;      // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
    template<uint32_t X>
    static constexpr uint32_t C5TCR_PAM =                 // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C5TCR_TRGM =                // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    static constexpr uint32_t C5TCR_SWRM = 0x40000000;    // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
    static constexpr uint32_t C5TCR_BWM = 0x80000000;     // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
    static const uint32_t C5TCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C5BNDTR_BNDT =                // block number of data to transfer (17 bits)
        bit_field_t<0, 0x1ffff>::value<X>();
    static constexpr uint32_t C5BNDTR_BRSUM = 0x40000;      // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
    static constexpr uint32_t C5BNDTR_BRDUM = 0x80000;      // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
    template<uint32_t X>
    static constexpr uint32_t C5BNDTR_BRC =                 // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0. (12 bits)
        bit_field_t<20, 0xfff>::value<X>();
    static const uint32_t C5BNDTR_RESET_VALUE = 0x0;


    static const uint32_t C5SAR_RESET_VALUE = 0x0;


    static const uint32_t C5DAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C5BRUR_SUV =                 // source adresse update value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C5BRUR_DUV =                 // destination address update (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t C5BRUR_RESET_VALUE = 0x0;


    static const uint32_t C5LAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C5TBR_TSEL =                // Trigger selection (6 bits)
        bit_field_t<0, 0x3f>::value<X>();
    static constexpr uint32_t C5TBR_SBUS = 0x10000;       // Source BUS select This bit is protected and can be written only if EN is 0.
    static constexpr uint32_t C5TBR_DBUS = 0x20000;       // Destination BUS slect This bit is protected and can be written only if EN is 0.
    static const uint32_t C5TBR_RESET_VALUE = 0x0;


    static const uint32_t C5MAR_RESET_VALUE = 0x0;


    static const uint32_t C5MDR_RESET_VALUE = 0x0;

    static constexpr uint32_t C6ISR_TEIF6 = 0x1;          // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C6ISR_CTCIF6 = 0x2;         // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
    static constexpr uint32_t C6ISR_BRTIF6 = 0x4;         // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C6ISR_BTIF6 = 0x8;          // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C6ISR_TCIF6 = 0x10;         // channel x buffer transfer complete
    static constexpr uint32_t C6ISR_CRQA6 = 0x10000;      // channel x request active flag
    static const uint32_t C6ISR_RESET_VALUE = 0x0;

    static constexpr uint32_t C6IFCR_CTEIF6 = 0x1;         // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
    static constexpr uint32_t C6IFCR_CCTCIF6 = 0x2;        // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
    static constexpr uint32_t C6IFCR_CBRTIF6 = 0x4;        // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
    static constexpr uint32_t C6IFCR_CBTIF6 = 0x8;         // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
    static constexpr uint32_t C6IFCR_CLTCIF6 = 0x10;       // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
    static const uint32_t C6IFCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C6ESR_TEA =                 // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error. (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    static constexpr uint32_t C6ESR_TED = 0x80;           // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
    static constexpr uint32_t C6ESR_TELD = 0x100;         // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C6ESR_TEMD = 0x200;         // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C6ESR_ASE = 0x400;          // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C6ESR_BSE = 0x800;          // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static const uint32_t C6ESR_RESET_VALUE = 0x0;

    static constexpr uint32_t C6CR_EN = 0x1;             // channel enable, Read-write
    static constexpr uint32_t C6CR_TEIE = 0x2;           // Transfer error interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C6CR_CTCIE = 0x4;          // Channel Transfer Complete interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C6CR_BRTIE = 0x8;          // Block Repeat transfer interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C6CR_BTIE = 0x10;          // Block Transfer interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C6CR_TCIE = 0x20;          // buffer Transfer Complete interrupt enable This bit is set and cleared by software., Read-write
    template<uint32_t X>
    static constexpr uint32_t C6CR_PL =                  // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. (2 bits), Read-write
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t C6CR_BEX = 0x1000;         // byte Endianness exchange, Read-write
    static constexpr uint32_t C6CR_HEX = 0x2000;         // Half word Endianes exchange, Read-write
    static constexpr uint32_t C6CR_WEX = 0x4000;         // Word Endianness exchange, Read-write
    static constexpr uint32_t C6CR_SWRQ = 0x10000;       // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access)., Write-only
    static const uint32_t C6CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C6TCR_SINC =                // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C6TCR_DINC =                // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C6TCR_SSIZE =               // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &amp;lt; SSIZE and SINC &amp;#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C6TCR_DSIZE =               // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &amp;lt; DSIZE and DINC &amp;#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C6TCR_SINCOS =              // source increment offset size (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C6TCR_DINCOS =              // Destination increment offset (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C6TCR_SBURST =              // source burst transfer configuration (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C6TCR_DBURST =              // Destination burst transfer configuration (3 bits)
        bit_field_t<15, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C6TCR_TLEN =                // buffer transfer lengh (7 bits)
        bit_field_t<18, 0x7f>::value<X>();
    static constexpr uint32_t C6TCR_PKE = 0x2000000;      // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
    template<uint32_t X>
    static constexpr uint32_t C6TCR_PAM =                 // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C6TCR_TRGM =                // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    static constexpr uint32_t C6TCR_SWRM = 0x40000000;    // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
    static constexpr uint32_t C6TCR_BWM = 0x80000000;     // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
    static const uint32_t C6TCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C6BNDTR_BNDT =                // block number of data to transfer (17 bits)
        bit_field_t<0, 0x1ffff>::value<X>();
    static constexpr uint32_t C6BNDTR_BRSUM = 0x40000;      // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
    static constexpr uint32_t C6BNDTR_BRDUM = 0x80000;      // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
    template<uint32_t X>
    static constexpr uint32_t C6BNDTR_BRC =                 // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0 (12 bits)
        bit_field_t<20, 0xfff>::value<X>();
    static const uint32_t C6BNDTR_RESET_VALUE = 0x0;


    static const uint32_t C6SAR_RESET_VALUE = 0x0;


    static const uint32_t C6DAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C6BRUR_SUV =                 // source adresse update value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C6BRUR_DUV =                 // destination address update (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t C6BRUR_RESET_VALUE = 0x0;


    static const uint32_t C6LAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C6TBR_TSEL =                // Trigger selection (6 bits)
        bit_field_t<0, 0x3f>::value<X>();
    static constexpr uint32_t C6TBR_SBUS = 0x10000;       // Source BUS select This bit is protected and can be written only if EN is 0.
    static constexpr uint32_t C6TBR_DBUS = 0x20000;       // Destination BUS slect This bit is protected and can be written only if EN is 0.
    static const uint32_t C6TBR_RESET_VALUE = 0x0;


    static const uint32_t C6MAR_RESET_VALUE = 0x0;


    static const uint32_t C6MDR_RESET_VALUE = 0x0;

    static constexpr uint32_t C7ISR_TEIF7 = 0x1;          // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C7ISR_CTCIF7 = 0x2;         // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
    static constexpr uint32_t C7ISR_BRTIF7 = 0x4;         // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C7ISR_BTIF7 = 0x8;          // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C7ISR_TCIF7 = 0x10;         // channel x buffer transfer complete
    static constexpr uint32_t C7ISR_CRQA7 = 0x10000;      // channel x request active flag
    static const uint32_t C7ISR_RESET_VALUE = 0x0;

    static constexpr uint32_t C7IFCR_CTEIF7 = 0x1;         // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
    static constexpr uint32_t C7IFCR_CCTCIF7 = 0x2;        // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
    static constexpr uint32_t C7IFCR_CBRTIF7 = 0x4;        // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
    static constexpr uint32_t C7IFCR_CBTIF7 = 0x8;         // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
    static constexpr uint32_t C7IFCR_CLTCIF7 = 0x10;       // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
    static const uint32_t C7IFCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C7ESR_TEA =                 // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error. (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    static constexpr uint32_t C7ESR_TED = 0x80;           // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
    static constexpr uint32_t C7ESR_TELD = 0x100;         // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C7ESR_TEMD = 0x200;         // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C7ESR_ASE = 0x400;          // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C7ESR_BSE = 0x800;          // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static const uint32_t C7ESR_RESET_VALUE = 0x0;

    static constexpr uint32_t C7CR_EN = 0x1;             // channel enable, Read-write
    static constexpr uint32_t C7CR_TEIE = 0x2;           // Transfer error interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C7CR_CTCIE = 0x4;          // Channel Transfer Complete interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C7CR_BRTIE = 0x8;          // Block Repeat transfer interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C7CR_BTIE = 0x10;          // Block Transfer interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C7CR_TCIE = 0x20;          // buffer Transfer Complete interrupt enable This bit is set and cleared by software., Read-write
    template<uint32_t X>
    static constexpr uint32_t C7CR_PL =                  // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. (2 bits), Read-write
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t C7CR_BEX = 0x1000;         // byte Endianness exchange, Read-write
    static constexpr uint32_t C7CR_HEX = 0x2000;         // Half word Endianes exchange, Read-write
    static constexpr uint32_t C7CR_WEX = 0x4000;         // Word Endianness exchange, Read-write
    static constexpr uint32_t C7CR_SWRQ = 0x10000;       // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access)., Write-only
    static const uint32_t C7CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C7TCR_SINC =                // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C7TCR_DINC =                // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C7TCR_SSIZE =               // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &amp;lt; SSIZE and SINC &amp;#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C7TCR_DSIZE =               // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &amp;lt; DSIZE and DINC &amp;#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C7TCR_SINCOS =              // source increment offset size (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C7TCR_DINCOS =              // Destination increment offset (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C7TCR_SBURST =              // source burst transfer configuration (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C7TCR_DBURST =              // Destination burst transfer configuration (3 bits)
        bit_field_t<15, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C7TCR_TLEN =                // buffer transfer lengh (7 bits)
        bit_field_t<18, 0x7f>::value<X>();
    static constexpr uint32_t C7TCR_PKE = 0x2000000;      // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
    template<uint32_t X>
    static constexpr uint32_t C7TCR_PAM =                 // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C7TCR_TRGM =                // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    static constexpr uint32_t C7TCR_SWRM = 0x40000000;    // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
    static constexpr uint32_t C7TCR_BWM = 0x80000000;     // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
    static const uint32_t C7TCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C7BNDTR_BNDT =                // block number of data to transfer (17 bits)
        bit_field_t<0, 0x1ffff>::value<X>();
    static constexpr uint32_t C7BNDTR_BRSUM = 0x40000;      // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
    static constexpr uint32_t C7BNDTR_BRDUM = 0x80000;      // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
    template<uint32_t X>
    static constexpr uint32_t C7BNDTR_BRC =                 // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0. (12 bits)
        bit_field_t<20, 0xfff>::value<X>();
    static const uint32_t C7BNDTR_RESET_VALUE = 0x0;


    static const uint32_t C7SAR_RESET_VALUE = 0x0;


    static const uint32_t C7DAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C7BRUR_SUV =                 // source adresse update value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C7BRUR_DUV =                 // destination address update (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t C7BRUR_RESET_VALUE = 0x0;


    static const uint32_t C7LAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C7TBR_TSEL =                // Trigger selection (6 bits)
        bit_field_t<0, 0x3f>::value<X>();
    static constexpr uint32_t C7TBR_SBUS = 0x10000;       // Source BUS select This bit is protected and can be written only if EN is 0.
    static constexpr uint32_t C7TBR_DBUS = 0x20000;       // Destination BUS slect This bit is protected and can be written only if EN is 0.
    static const uint32_t C7TBR_RESET_VALUE = 0x0;


    static const uint32_t C7MAR_RESET_VALUE = 0x0;


    static const uint32_t C7MDR_RESET_VALUE = 0x0;

    static constexpr uint32_t C8ISR_TEIF8 = 0x1;          // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C8ISR_CTCIF8 = 0x2;         // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
    static constexpr uint32_t C8ISR_BRTIF8 = 0x4;         // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C8ISR_BTIF8 = 0x8;          // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C8ISR_TCIF8 = 0x10;         // channel x buffer transfer complete
    static constexpr uint32_t C8ISR_CRQA8 = 0x10000;      // channel x request active flag
    static const uint32_t C8ISR_RESET_VALUE = 0x0;

    static constexpr uint32_t C8IFCR_CTEIF8 = 0x1;         // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
    static constexpr uint32_t C8IFCR_CCTCIF8 = 0x2;        // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
    static constexpr uint32_t C8IFCR_CBRTIF8 = 0x4;        // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
    static constexpr uint32_t C8IFCR_CBTIF8 = 0x8;         // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
    static constexpr uint32_t C8IFCR_CLTCIF8 = 0x10;       // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
    static const uint32_t C8IFCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C8ESR_TEA =                 // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error. (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    static constexpr uint32_t C8ESR_TED = 0x80;           // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
    static constexpr uint32_t C8ESR_TELD = 0x100;         // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C8ESR_TEMD = 0x200;         // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C8ESR_ASE = 0x400;          // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C8ESR_BSE = 0x800;          // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static const uint32_t C8ESR_RESET_VALUE = 0x0;

    static constexpr uint32_t C8CR_EN = 0x1;             // channel enable, Read-write
    static constexpr uint32_t C8CR_TEIE = 0x2;           // Transfer error interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C8CR_CTCIE = 0x4;          // Channel Transfer Complete interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C8CR_BRTIE = 0x8;          // Block Repeat transfer interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C8CR_BTIE = 0x10;          // Block Transfer interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C8CR_TCIE = 0x20;          // buffer Transfer Complete interrupt enable This bit is set and cleared by software., Read-write
    template<uint32_t X>
    static constexpr uint32_t C8CR_PL =                  // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. (2 bits), Read-write
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t C8CR_BEX = 0x1000;         // byte Endianness exchange, Read-write
    static constexpr uint32_t C8CR_HEX = 0x2000;         // Half word Endianes exchange, Read-write
    static constexpr uint32_t C8CR_WEX = 0x4000;         // Word Endianness exchange, Read-write
    static constexpr uint32_t C8CR_SWRQ = 0x10000;       // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access)., Write-only
    static const uint32_t C8CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C8TCR_SINC =                // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C8TCR_DINC =                // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C8TCR_SSIZE =               // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &amp;lt; SSIZE and SINC &amp;#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C8TCR_DSIZE =               // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &amp;lt; DSIZE and DINC &amp;#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C8TCR_SINCOS =              // source increment offset size (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C8TCR_DINCOS =              // Destination increment offset (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C8TCR_SBURST =              // source burst transfer configuration (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C8TCR_DBURST =              // Destination burst transfer configuration (3 bits)
        bit_field_t<15, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C8TCR_TLEN =                // buffer transfer lengh (7 bits)
        bit_field_t<18, 0x7f>::value<X>();
    static constexpr uint32_t C8TCR_PKE = 0x2000000;      // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
    template<uint32_t X>
    static constexpr uint32_t C8TCR_PAM =                 // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C8TCR_TRGM =                // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    static constexpr uint32_t C8TCR_SWRM = 0x40000000;    // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
    static constexpr uint32_t C8TCR_BWM = 0x80000000;     // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
    static const uint32_t C8TCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C8BNDTR_BNDT =                // block number of data to transfer (17 bits)
        bit_field_t<0, 0x1ffff>::value<X>();
    static constexpr uint32_t C8BNDTR_BRSUM = 0x40000;      // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
    static constexpr uint32_t C8BNDTR_BRDUM = 0x80000;      // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
    template<uint32_t X>
    static constexpr uint32_t C8BNDTR_BRC =                 // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0. (12 bits)
        bit_field_t<20, 0xfff>::value<X>();
    static const uint32_t C8BNDTR_RESET_VALUE = 0x0;


    static const uint32_t C8SAR_RESET_VALUE = 0x0;


    static const uint32_t C8DAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C8BRUR_SUV =                 // source adresse update value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C8BRUR_DUV =                 // destination address update (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t C8BRUR_RESET_VALUE = 0x0;


    static const uint32_t C8LAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C8TBR_TSEL =                // Trigger selection (6 bits)
        bit_field_t<0, 0x3f>::value<X>();
    static constexpr uint32_t C8TBR_SBUS = 0x10000;       // Source BUS select This bit is protected and can be written only if EN is 0.
    static constexpr uint32_t C8TBR_DBUS = 0x20000;       // Destination BUS slect This bit is protected and can be written only if EN is 0.
    static const uint32_t C8TBR_RESET_VALUE = 0x0;


    static const uint32_t C8MAR_RESET_VALUE = 0x0;


    static const uint32_t C8MDR_RESET_VALUE = 0x0;

    static constexpr uint32_t C9ISR_TEIF9 = 0x1;          // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C9ISR_CTCIF9 = 0x2;         // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
    static constexpr uint32_t C9ISR_BRTIF9 = 0x4;         // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C9ISR_BTIF9 = 0x8;          // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C9ISR_TCIF9 = 0x10;         // channel x buffer transfer complete
    static constexpr uint32_t C9ISR_CRQA9 = 0x10000;      // channel x request active flag
    static const uint32_t C9ISR_RESET_VALUE = 0x0;

    static constexpr uint32_t C9IFCR_CTEIF9 = 0x1;         // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
    static constexpr uint32_t C9IFCR_CCTCIF9 = 0x2;        // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
    static constexpr uint32_t C9IFCR_CBRTIF9 = 0x4;        // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
    static constexpr uint32_t C9IFCR_CBTIF9 = 0x8;         // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
    static constexpr uint32_t C9IFCR_CLTCIF9 = 0x10;       // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
    static const uint32_t C9IFCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C9ESR_TEA =                 // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error. (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    static constexpr uint32_t C9ESR_TED = 0x80;           // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
    static constexpr uint32_t C9ESR_TELD = 0x100;         // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C9ESR_TEMD = 0x200;         // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C9ESR_ASE = 0x400;          // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C9ESR_BSE = 0x800;          // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static const uint32_t C9ESR_RESET_VALUE = 0x0;

    static constexpr uint32_t C9CR_EN = 0x1;             // channel enable, Read-write
    static constexpr uint32_t C9CR_TEIE = 0x2;           // Transfer error interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C9CR_CTCIE = 0x4;          // Channel Transfer Complete interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C9CR_BRTIE = 0x8;          // Block Repeat transfer interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C9CR_BTIE = 0x10;          // Block Transfer interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C9CR_TCIE = 0x20;          // buffer Transfer Complete interrupt enable This bit is set and cleared by software., Read-write
    template<uint32_t X>
    static constexpr uint32_t C9CR_PL =                  // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. (2 bits), Read-write
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t C9CR_BEX = 0x1000;         // byte Endianness exchange, Read-write
    static constexpr uint32_t C9CR_HEX = 0x2000;         // Half word Endianes exchange, Read-write
    static constexpr uint32_t C9CR_WEX = 0x4000;         // Word Endianness exchange, Read-write
    static constexpr uint32_t C9CR_SWRQ = 0x10000;       // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access)., Write-only
    static const uint32_t C9CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C9TCR_SINC =                // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C9TCR_DINC =                // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C9TCR_SSIZE =               // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &amp;lt; SSIZE and SINC &amp;#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C9TCR_DSIZE =               // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &amp;lt; DSIZE and DINC &amp;#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C9TCR_SINCOS =              // source increment offset size (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C9TCR_DINCOS =              // Destination increment offset (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C9TCR_SBURST =              // source burst transfer configuration (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C9TCR_DBURST =              // Destination burst transfer configuration (3 bits)
        bit_field_t<15, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C9TCR_TLEN =                // buffer transfer lengh (7 bits)
        bit_field_t<18, 0x7f>::value<X>();
    static constexpr uint32_t C9TCR_PKE = 0x2000000;      // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
    template<uint32_t X>
    static constexpr uint32_t C9TCR_PAM =                 // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C9TCR_TRGM =                // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    static constexpr uint32_t C9TCR_SWRM = 0x40000000;    // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
    static constexpr uint32_t C9TCR_BWM = 0x80000000;     // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
    static const uint32_t C9TCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C9BNDTR_BNDT =                // block number of data to transfer (17 bits)
        bit_field_t<0, 0x1ffff>::value<X>();
    static constexpr uint32_t C9BNDTR_BRSUM = 0x40000;      // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
    static constexpr uint32_t C9BNDTR_BRDUM = 0x80000;      // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
    template<uint32_t X>
    static constexpr uint32_t C9BNDTR_BRC =                 // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0. (12 bits)
        bit_field_t<20, 0xfff>::value<X>();
    static const uint32_t C9BNDTR_RESET_VALUE = 0x0;


    static const uint32_t C9SAR_RESET_VALUE = 0x0;


    static const uint32_t C9DAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C9BRUR_SUV =                 // source adresse update value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C9BRUR_DUV =                 // destination address update (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t C9BRUR_RESET_VALUE = 0x0;


    static const uint32_t C9LAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C9TBR_TSEL =                // Trigger selection (6 bits)
        bit_field_t<0, 0x3f>::value<X>();
    static constexpr uint32_t C9TBR_SBUS = 0x10000;       // Source BUS select This bit is protected and can be written only if EN is 0.
    static constexpr uint32_t C9TBR_DBUS = 0x20000;       // Destination BUS slect This bit is protected and can be written only if EN is 0.
    static const uint32_t C9TBR_RESET_VALUE = 0x0;


    static const uint32_t C9MAR_RESET_VALUE = 0x0;


    static const uint32_t C9MDR_RESET_VALUE = 0x0;

    static constexpr uint32_t C10ISR_TEIF10 = 0x1;         // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C10ISR_CTCIF10 = 0x2;        // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
    static constexpr uint32_t C10ISR_BRTIF10 = 0x4;        // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C10ISR_BTIF10 = 0x8;         // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C10ISR_TCIF10 = 0x10;        // channel x buffer transfer complete
    static constexpr uint32_t C10ISR_CRQA10 = 0x10000;     // channel x request active flag
    static const uint32_t C10ISR_RESET_VALUE = 0x0;

    static constexpr uint32_t C10IFCR_CTEIF10 = 0x1;        // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
    static constexpr uint32_t C10IFCR_CCTCIF10 = 0x2;       // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
    static constexpr uint32_t C10IFCR_CBRTIF10 = 0x4;       // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
    static constexpr uint32_t C10IFCR_CBTIF10 = 0x8;        // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
    static constexpr uint32_t C10IFCR_CLTCIF10 = 0x10;      // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
    static const uint32_t C10IFCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C10ESR_TEA =                 // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error. (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    static constexpr uint32_t C10ESR_TED = 0x80;           // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
    static constexpr uint32_t C10ESR_TELD = 0x100;         // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C10ESR_TEMD = 0x200;         // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C10ESR_ASE = 0x400;          // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C10ESR_BSE = 0x800;          // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static const uint32_t C10ESR_RESET_VALUE = 0x0;

    static constexpr uint32_t C10CR_EN = 0x1;             // channel enable, Read-write
    static constexpr uint32_t C10CR_TEIE = 0x2;           // Transfer error interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C10CR_CTCIE = 0x4;          // Channel Transfer Complete interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C10CR_BRTIE = 0x8;          // Block Repeat transfer interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C10CR_BTIE = 0x10;          // Block Transfer interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C10CR_TCIE = 0x20;          // buffer Transfer Complete interrupt enable This bit is set and cleared by software., Read-write
    template<uint32_t X>
    static constexpr uint32_t C10CR_PL =                  // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. (2 bits), Read-write
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t C10CR_BEX = 0x1000;         // byte Endianness exchange, Read-write
    static constexpr uint32_t C10CR_HEX = 0x2000;         // Half word Endianes exchange, Read-write
    static constexpr uint32_t C10CR_WEX = 0x4000;         // Word Endianness exchange, Read-write
    static constexpr uint32_t C10CR_SWRQ = 0x10000;       // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access)., Write-only
    static const uint32_t C10CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C10TCR_SINC =                // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C10TCR_DINC =                // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C10TCR_SSIZE =               // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &amp;lt; SSIZE and SINC &amp;#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C10TCR_DSIZE =               // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &amp;lt; DSIZE and DINC &amp;#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C10TCR_SINCOS =              // source increment offset size (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C10TCR_DINCOS =              // Destination increment offset (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C10TCR_SBURST =              // source burst transfer configuration (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C10TCR_DBURST =              // Destination burst transfer configuration (3 bits)
        bit_field_t<15, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C10TCR_TLEN =                // buffer transfer lengh (7 bits)
        bit_field_t<18, 0x7f>::value<X>();
    static constexpr uint32_t C10TCR_PKE = 0x2000000;      // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
    template<uint32_t X>
    static constexpr uint32_t C10TCR_PAM =                 // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C10TCR_TRGM =                // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    static constexpr uint32_t C10TCR_SWRM = 0x40000000;    // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
    static constexpr uint32_t C10TCR_BWM = 0x80000000;     // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
    static const uint32_t C10TCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C10BNDTR_BNDT =                // block number of data to transfer (17 bits)
        bit_field_t<0, 0x1ffff>::value<X>();
    static constexpr uint32_t C10BNDTR_BRSUM = 0x40000;      // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
    static constexpr uint32_t C10BNDTR_BRDUM = 0x80000;      // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
    template<uint32_t X>
    static constexpr uint32_t C10BNDTR_BRC =                 // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0. (12 bits)
        bit_field_t<20, 0xfff>::value<X>();
    static const uint32_t C10BNDTR_RESET_VALUE = 0x0;


    static const uint32_t C10SAR_RESET_VALUE = 0x0;


    static const uint32_t C10DAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C10BRUR_SUV =                 // source adresse update value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C10BRUR_DUV =                 // destination address update (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t C10BRUR_RESET_VALUE = 0x0;


    static const uint32_t C10LAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C10TBR_TSEL =                // Trigger selection (6 bits)
        bit_field_t<0, 0x3f>::value<X>();
    static constexpr uint32_t C10TBR_SBUS = 0x10000;       // Source BUS select This bit is protected and can be written only if EN is 0.
    static constexpr uint32_t C10TBR_DBUS = 0x20000;       // Destination BUS slect This bit is protected and can be written only if EN is 0.
    static const uint32_t C10TBR_RESET_VALUE = 0x0;


    static const uint32_t C10MAR_RESET_VALUE = 0x0;


    static const uint32_t C10MDR_RESET_VALUE = 0x0;

    static constexpr uint32_t C11ISR_TEIF11 = 0x1;         // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C11ISR_CTCIF11 = 0x2;        // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
    static constexpr uint32_t C11ISR_BRTIF11 = 0x4;        // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C11ISR_BTIF11 = 0x8;         // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C11ISR_TCIF11 = 0x10;        // channel x buffer transfer complete
    static constexpr uint32_t C11ISR_CRQA11 = 0x10000;     // channel x request active flag
    static const uint32_t C11ISR_RESET_VALUE = 0x0;

    static constexpr uint32_t C11IFCR_CTEIF11 = 0x1;        // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
    static constexpr uint32_t C11IFCR_CCTCIF11 = 0x2;       // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
    static constexpr uint32_t C11IFCR_CBRTIF11 = 0x4;       // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
    static constexpr uint32_t C11IFCR_CBTIF11 = 0x8;        // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
    static constexpr uint32_t C11IFCR_CLTCIF11 = 0x10;      // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
    static const uint32_t C11IFCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C11ESR_TEA =                 // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error. (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    static constexpr uint32_t C11ESR_TED = 0x80;           // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
    static constexpr uint32_t C11ESR_TELD = 0x100;         // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C11ESR_TEMD = 0x200;         // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C11ESR_ASE = 0x400;          // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C11ESR_BSE = 0x800;          // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static const uint32_t C11ESR_RESET_VALUE = 0x0;

    static constexpr uint32_t C11CR_EN = 0x1;             // channel enable, Read-write
    static constexpr uint32_t C11CR_TEIE = 0x2;           // Transfer error interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C11CR_CTCIE = 0x4;          // Channel Transfer Complete interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C11CR_BRTIE = 0x8;          // Block Repeat transfer interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C11CR_BTIE = 0x10;          // Block Transfer interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C11CR_TCIE = 0x20;          // buffer Transfer Complete interrupt enable This bit is set and cleared by software., Read-write
    template<uint32_t X>
    static constexpr uint32_t C11CR_PL =                  // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. (2 bits), Read-write
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t C11CR_BEX = 0x1000;         // byte Endianness exchange, Read-write
    static constexpr uint32_t C11CR_HEX = 0x2000;         // Half word Endianes exchange, Read-write
    static constexpr uint32_t C11CR_WEX = 0x4000;         // Word Endianness exchange, Read-write
    static constexpr uint32_t C11CR_SWRQ = 0x10000;       // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access)., Write-only
    static const uint32_t C11CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C11TCR_SINC =                // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C11TCR_DINC =                // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C11TCR_SSIZE =               // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &amp;lt; SSIZE and SINC &amp;#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C11TCR_DSIZE =               // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &amp;lt; DSIZE and DINC &amp;#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C11TCR_SINCOS =              // source increment offset size (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C11TCR_DINCOS =              // Destination increment offset (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C11TCR_SBURST =              // source burst transfer configuration (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C11TCR_DBURST =              // Destination burst transfer configuration (3 bits)
        bit_field_t<15, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C11TCR_TLEN =                // buffer transfer lengh (7 bits)
        bit_field_t<18, 0x7f>::value<X>();
    static constexpr uint32_t C11TCR_PKE = 0x2000000;      // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
    template<uint32_t X>
    static constexpr uint32_t C11TCR_PAM =                 // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C11TCR_TRGM =                // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    static constexpr uint32_t C11TCR_SWRM = 0x40000000;    // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
    static constexpr uint32_t C11TCR_BWM = 0x80000000;     // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
    static const uint32_t C11TCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C11BNDTR_BNDT =                // block number of data to transfer (17 bits)
        bit_field_t<0, 0x1ffff>::value<X>();
    static constexpr uint32_t C11BNDTR_BRSUM = 0x40000;      // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
    static constexpr uint32_t C11BNDTR_BRDUM = 0x80000;      // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
    template<uint32_t X>
    static constexpr uint32_t C11BNDTR_BRC =                 // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0. (12 bits)
        bit_field_t<20, 0xfff>::value<X>();
    static const uint32_t C11BNDTR_RESET_VALUE = 0x0;


    static const uint32_t C11SAR_RESET_VALUE = 0x0;


    static const uint32_t C11DAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C11BRUR_SUV =                 // source adresse update value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C11BRUR_DUV =                 // destination address update (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t C11BRUR_RESET_VALUE = 0x0;


    static const uint32_t C11LAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C11TBR_TSEL =                // Trigger selection (6 bits)
        bit_field_t<0, 0x3f>::value<X>();
    static constexpr uint32_t C11TBR_SBUS = 0x10000;       // Source BUS select This bit is protected and can be written only if EN is 0.
    static constexpr uint32_t C11TBR_DBUS = 0x20000;       // Destination BUS slect This bit is protected and can be written only if EN is 0.
    static const uint32_t C11TBR_RESET_VALUE = 0x0;


    static const uint32_t C11MAR_RESET_VALUE = 0x0;


    static const uint32_t C11MDR_RESET_VALUE = 0x0;

    static constexpr uint32_t C12ISR_TEIF12 = 0x1;         // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C12ISR_CTCIF12 = 0x2;        // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
    static constexpr uint32_t C12ISR_BRTIF12 = 0x4;        // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C12ISR_BTIF12 = 0x8;         // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C12ISR_TCIF12 = 0x10;        // channel x buffer transfer complete
    static constexpr uint32_t C12ISR_CRQA12 = 0x10000;     // channel x request active flag
    static const uint32_t C12ISR_RESET_VALUE = 0x0;

    static constexpr uint32_t C12IFCR_CTEIF12 = 0x1;        // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
    static constexpr uint32_t C12IFCR_CCTCIF12 = 0x2;       // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
    static constexpr uint32_t C12IFCR_CBRTIF12 = 0x4;       // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
    static constexpr uint32_t C12IFCR_CBTIF12 = 0x8;        // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
    static constexpr uint32_t C12IFCR_CLTCIF12 = 0x10;      // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
    static const uint32_t C12IFCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C12ESR_TEA =                 // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error. (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    static constexpr uint32_t C12ESR_TED = 0x80;           // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
    static constexpr uint32_t C12ESR_TELD = 0x100;         // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C12ESR_TEMD = 0x200;         // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C12ESR_ASE = 0x400;          // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C12ESR_BSE = 0x800;          // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static const uint32_t C12ESR_RESET_VALUE = 0x0;

    static constexpr uint32_t C12CR_EN = 0x1;             // channel enable, Read-write
    static constexpr uint32_t C12CR_TEIE = 0x2;           // Transfer error interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C12CR_CTCIE = 0x4;          // Channel Transfer Complete interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C12CR_BRTIE = 0x8;          // Block Repeat transfer interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C12CR_BTIE = 0x10;          // Block Transfer interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C12CR_TCIE = 0x20;          // buffer Transfer Complete interrupt enable This bit is set and cleared by software., Read-write
    template<uint32_t X>
    static constexpr uint32_t C12CR_PL =                  // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. (2 bits), Read-write
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t C12CR_BEX = 0x1000;         // byte Endianness exchange, Read-write
    static constexpr uint32_t C12CR_HEX = 0x2000;         // Half word Endianes exchange, Read-write
    static constexpr uint32_t C12CR_WEX = 0x4000;         // Word Endianness exchange, Read-write
    static constexpr uint32_t C12CR_SWRQ = 0x10000;       // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access)., Write-only
    static const uint32_t C12CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C12TCR_SINC =                // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C12TCR_DINC =                // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C12TCR_SSIZE =               // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &amp;lt; SSIZE and SINC &amp;#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C12TCR_DSIZE =               // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &amp;lt; DSIZE and DINC &amp;#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C12TCR_SINCOS =              // source increment offset size (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C12TCR_DINCOS =              // Destination increment offset (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C12TCR_SBURST =              // source burst transfer configuration (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C12TCR_DBURST =              // Destination burst transfer configuration (3 bits)
        bit_field_t<15, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C12TCR_TLEN =                // buffer transfer lengh (7 bits)
        bit_field_t<18, 0x7f>::value<X>();
    static constexpr uint32_t C12TCR_PKE = 0x2000000;      // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
    template<uint32_t X>
    static constexpr uint32_t C12TCR_PAM =                 // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C12TCR_TRGM =                // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    static constexpr uint32_t C12TCR_SWRM = 0x40000000;    // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
    static constexpr uint32_t C12TCR_BWM = 0x80000000;     // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
    static const uint32_t C12TCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C12BNDTR_BNDT =                // block number of data to transfer (17 bits)
        bit_field_t<0, 0x1ffff>::value<X>();
    static constexpr uint32_t C12BNDTR_BRSUM = 0x40000;      // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
    static constexpr uint32_t C12BNDTR_BRDUM = 0x80000;      // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
    template<uint32_t X>
    static constexpr uint32_t C12BNDTR_BRC =                 // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0. (12 bits)
        bit_field_t<20, 0xfff>::value<X>();
    static const uint32_t C12BNDTR_RESET_VALUE = 0x0;


    static const uint32_t C12SAR_RESET_VALUE = 0x0;


    static const uint32_t C12DAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C12BRUR_SUV =                 // source adresse update value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C12BRUR_DUV =                 // destination address update (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t C12BRUR_RESET_VALUE = 0x0;


    static const uint32_t C12LAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C12TBR_TSEL =                // Trigger selection (6 bits)
        bit_field_t<0, 0x3f>::value<X>();
    static constexpr uint32_t C12TBR_SBUS = 0x10000;       // Source BUS select This bit is protected and can be written only if EN is 0.
    static constexpr uint32_t C12TBR_DBUS = 0x20000;       // Destination BUS slect This bit is protected and can be written only if EN is 0.
    static const uint32_t C12TBR_RESET_VALUE = 0x0;


    static const uint32_t C12MAR_RESET_VALUE = 0x0;


    static const uint32_t C12MDR_RESET_VALUE = 0x0;

    static constexpr uint32_t C13ISR_TEIF13 = 0x1;         // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C13ISR_CTCIF13 = 0x2;        // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
    static constexpr uint32_t C13ISR_BRTIF13 = 0x4;        // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C13ISR_BTIF13 = 0x8;         // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C13ISR_TCIF13 = 0x10;        // channel x buffer transfer complete
    static constexpr uint32_t C13ISR_CRQA13 = 0x10000;     // channel x request active flag
    static const uint32_t C13ISR_RESET_VALUE = 0x0;

    static constexpr uint32_t C13IFCR_CTEIF13 = 0x1;        // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
    static constexpr uint32_t C13IFCR_CCTCIF13 = 0x2;       // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
    static constexpr uint32_t C13IFCR_CBRTIF13 = 0x4;       // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
    static constexpr uint32_t C13IFCR_CBTIF13 = 0x8;        // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
    static constexpr uint32_t C13IFCR_CLTCIF13 = 0x10;      // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
    static const uint32_t C13IFCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C13ESR_TEA =                 // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error. (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    static constexpr uint32_t C13ESR_TED = 0x80;           // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
    static constexpr uint32_t C13ESR_TELD = 0x100;         // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C13ESR_TEMD = 0x200;         // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C13ESR_ASE = 0x400;          // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C13ESR_BSE = 0x800;          // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static const uint32_t C13ESR_RESET_VALUE = 0x0;

    static constexpr uint32_t C13CR_EN = 0x1;             // channel enable, Read-write
    static constexpr uint32_t C13CR_TEIE = 0x2;           // Transfer error interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C13CR_CTCIE = 0x4;          // Channel Transfer Complete interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C13CR_BRTIE = 0x8;          // Block Repeat transfer interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C13CR_BTIE = 0x10;          // Block Transfer interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C13CR_TCIE = 0x20;          // buffer Transfer Complete interrupt enable This bit is set and cleared by software., Read-write
    template<uint32_t X>
    static constexpr uint32_t C13CR_PL =                  // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. (2 bits), Read-write
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t C13CR_BEX = 0x1000;         // byte Endianness exchange, Read-write
    static constexpr uint32_t C13CR_HEX = 0x2000;         // Half word Endianes exchange, Read-write
    static constexpr uint32_t C13CR_WEX = 0x4000;         // Word Endianness exchange, Read-write
    static constexpr uint32_t C13CR_SWRQ = 0x10000;       // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access)., Write-only
    static const uint32_t C13CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C13TCR_SINC =                // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C13TCR_DINC =                // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C13TCR_SSIZE =               // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &amp;lt; SSIZE and SINC &amp;#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C13TCR_DSIZE =               // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &amp;lt; DSIZE and DINC &amp;#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C13TCR_SINCOS =              // source increment offset size (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C13TCR_DINCOS =              // Destination increment offset (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C13TCR_SBURST =              // source burst transfer configuration (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C13TCR_DBURST =              // Destination burst transfer configuration (3 bits)
        bit_field_t<15, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C13TCR_TLEN =                // buffer transfer lengh (7 bits)
        bit_field_t<18, 0x7f>::value<X>();
    static constexpr uint32_t C13TCR_PKE = 0x2000000;      // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
    template<uint32_t X>
    static constexpr uint32_t C13TCR_PAM =                 // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C13TCR_TRGM =                // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    static constexpr uint32_t C13TCR_SWRM = 0x40000000;    // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
    static constexpr uint32_t C13TCR_BWM = 0x80000000;     // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
    static const uint32_t C13TCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C13BNDTR_BNDT =                // block number of data to transfer (17 bits)
        bit_field_t<0, 0x1ffff>::value<X>();
    static constexpr uint32_t C13BNDTR_BRSUM = 0x40000;      // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
    static constexpr uint32_t C13BNDTR_BRDUM = 0x80000;      // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
    template<uint32_t X>
    static constexpr uint32_t C13BNDTR_BRC =                 // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0. (12 bits)
        bit_field_t<20, 0xfff>::value<X>();
    static const uint32_t C13BNDTR_RESET_VALUE = 0x0;


    static const uint32_t C13SAR_RESET_VALUE = 0x0;


    static const uint32_t C13DAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C13BRUR_SUV =                 // source adresse update value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C13BRUR_DUV =                 // destination address update (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t C13BRUR_RESET_VALUE = 0x0;


    static const uint32_t C13LAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C13TBR_TSEL =                // Trigger selection (6 bits)
        bit_field_t<0, 0x3f>::value<X>();
    static constexpr uint32_t C13TBR_SBUS = 0x10000;       // Source BUS select This bit is protected and can be written only if EN is 0.
    static constexpr uint32_t C13TBR_DBUS = 0x20000;       // Destination BUS slect This bit is protected and can be written only if EN is 0.
    static const uint32_t C13TBR_RESET_VALUE = 0x0;


    static const uint32_t C13MAR_RESET_VALUE = 0x0;


    static const uint32_t C13MDR_RESET_VALUE = 0x0;

    static constexpr uint32_t C14ISR_TEIF14 = 0x1;         // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C14ISR_CTCIF14 = 0x2;        // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
    static constexpr uint32_t C14ISR_BRTIF14 = 0x4;        // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C14ISR_BTIF14 = 0x8;         // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C14ISR_TCIF14 = 0x10;        // channel x buffer transfer complete
    static constexpr uint32_t C14ISR_CRQA14 = 0x10000;     // channel x request active flag
    static const uint32_t C14ISR_RESET_VALUE = 0x0;

    static constexpr uint32_t C14IFCR_CTEIF14 = 0x1;        // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
    static constexpr uint32_t C14IFCR_CCTCIF14 = 0x2;       // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
    static constexpr uint32_t C14IFCR_CBRTIF14 = 0x4;       // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
    static constexpr uint32_t C14IFCR_CBTIF14 = 0x8;        // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
    static constexpr uint32_t C14IFCR_CLTCIF14 = 0x10;      // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
    static const uint32_t C14IFCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C14ESR_TEA =                 // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error. (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    static constexpr uint32_t C14ESR_TED = 0x80;           // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
    static constexpr uint32_t C14ESR_TELD = 0x100;         // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C14ESR_TEMD = 0x200;         // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C14ESR_ASE = 0x400;          // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C14ESR_BSE = 0x800;          // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static const uint32_t C14ESR_RESET_VALUE = 0x0;

    static constexpr uint32_t C14CR_EN = 0x1;             // channel enable, Read-write
    static constexpr uint32_t C14CR_TEIE = 0x2;           // Transfer error interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C14CR_CTCIE = 0x4;          // Channel Transfer Complete interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C14CR_BRTIE = 0x8;          // Block Repeat transfer interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C14CR_BTIE = 0x10;          // Block Transfer interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C14CR_TCIE = 0x20;          // buffer Transfer Complete interrupt enable This bit is set and cleared by software., Read-write
    template<uint32_t X>
    static constexpr uint32_t C14CR_PL =                  // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. (2 bits), Read-write
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t C14CR_BEX = 0x1000;         // byte Endianness exchange, Read-write
    static constexpr uint32_t C14CR_HEX = 0x2000;         // Half word Endianes exchange, Read-write
    static constexpr uint32_t C14CR_WEX = 0x4000;         // Word Endianness exchange, Read-write
    static constexpr uint32_t C14CR_SWRQ = 0x10000;       // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access)., Write-only
    static const uint32_t C14CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C14TCR_SINC =                // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C14TCR_DINC =                // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C14TCR_SSIZE =               // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &amp;lt; SSIZE and SINC &amp;#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C14TCR_DSIZE =               // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &amp;lt; DSIZE and DINC &amp;#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C14TCR_SINCOS =              // source increment offset size (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C14TCR_DINCOS =              // Destination increment offset (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C14TCR_SBURST =              // source burst transfer configuration (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C14TCR_DBURST =              // Destination burst transfer configuration (3 bits)
        bit_field_t<15, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C14TCR_TLEN =                // buffer transfer lengh (7 bits)
        bit_field_t<18, 0x7f>::value<X>();
    static constexpr uint32_t C14TCR_PKE = 0x2000000;      // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
    template<uint32_t X>
    static constexpr uint32_t C14TCR_PAM =                 // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C14TCR_TRGM =                // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    static constexpr uint32_t C14TCR_SWRM = 0x40000000;    // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
    static constexpr uint32_t C14TCR_BWM = 0x80000000;     // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
    static const uint32_t C14TCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C14BNDTR_BNDT =                // block number of data to transfer (17 bits)
        bit_field_t<0, 0x1ffff>::value<X>();
    static constexpr uint32_t C14BNDTR_BRSUM = 0x40000;      // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
    static constexpr uint32_t C14BNDTR_BRDUM = 0x80000;      // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
    template<uint32_t X>
    static constexpr uint32_t C14BNDTR_BRC =                 // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0. (12 bits)
        bit_field_t<20, 0xfff>::value<X>();
    static const uint32_t C14BNDTR_RESET_VALUE = 0x0;


    static const uint32_t C14SAR_RESET_VALUE = 0x0;


    static const uint32_t C14DAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C14BRUR_SUV =                 // source adresse update value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C14BRUR_DUV =                 // destination address update (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t C14BRUR_RESET_VALUE = 0x0;


    static const uint32_t C14LAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C14TBR_TSEL =                // Trigger selection (6 bits)
        bit_field_t<0, 0x3f>::value<X>();
    static constexpr uint32_t C14TBR_SBUS = 0x10000;       // Source BUS select This bit is protected and can be written only if EN is 0.
    static constexpr uint32_t C14TBR_DBUS = 0x20000;       // Destination BUS slect This bit is protected and can be written only if EN is 0.
    static const uint32_t C14TBR_RESET_VALUE = 0x0;


    static const uint32_t C14MAR_RESET_VALUE = 0x0;


    static const uint32_t C14MDR_RESET_VALUE = 0x0;

    static constexpr uint32_t C15ISR_TEIF15 = 0x1;         // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C15ISR_CTCIF15 = 0x2;        // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
    static constexpr uint32_t C15ISR_BRTIF15 = 0x4;        // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C15ISR_BTIF15 = 0x8;         // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    static constexpr uint32_t C15ISR_TCIF15 = 0x10;        // channel x buffer transfer complete
    static constexpr uint32_t C15ISR_CRQA15 = 0x10000;     // channel x request active flag
    static const uint32_t C15ISR_RESET_VALUE = 0x0;

    static constexpr uint32_t C15IFCR_CTEIF15 = 0x1;        // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
    static constexpr uint32_t C15IFCR_CCTCIF15 = 0x2;       // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
    static constexpr uint32_t C15IFCR_CBRTIF15 = 0x4;       // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
    static constexpr uint32_t C15IFCR_CBTIF15 = 0x8;        // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
    static constexpr uint32_t C15IFCR_CLTCIF15 = 0x10;      // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
    static const uint32_t C15IFCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C15ESR_TEA =                 // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error. (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    static constexpr uint32_t C15ESR_TED = 0x80;           // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
    static constexpr uint32_t C15ESR_TELD = 0x100;         // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C15ESR_TEMD = 0x200;         // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C15ESR_ASE = 0x400;          // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static constexpr uint32_t C15ESR_BSE = 0x800;          // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    static const uint32_t C15ESR_RESET_VALUE = 0x0;

    static constexpr uint32_t C15CR_EN = 0x1;             // channel enable, Read-write
    static constexpr uint32_t C15CR_TEIE = 0x2;           // Transfer error interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C15CR_CTCIE = 0x4;          // Channel Transfer Complete interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C15CR_BRTIE = 0x8;          // Block Repeat transfer interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C15CR_BTIE = 0x10;          // Block Transfer interrupt enable This bit is set and cleared by software., Read-write
    static constexpr uint32_t C15CR_TCIE = 0x20;          // buffer Transfer Complete interrupt enable This bit is set and cleared by software., Read-write
    template<uint32_t X>
    static constexpr uint32_t C15CR_PL =                  // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. (2 bits), Read-write
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t C15CR_BEX = 0x1000;         // byte Endianness exchange, Read-write
    static constexpr uint32_t C15CR_HEX = 0x2000;         // Half word Endianes exchange, Read-write
    static constexpr uint32_t C15CR_WEX = 0x4000;         // Word Endianness exchange, Read-write
    static constexpr uint32_t C15CR_SWRQ = 0x10000;       // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access)., Write-only
    static const uint32_t C15CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C15TCR_SINC =                // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C15TCR_DINC =                // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C15TCR_SSIZE =               // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &amp;lt; SSIZE and SINC &amp;#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C15TCR_DSIZE =               // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &amp;lt; DSIZE and DINC &amp;#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C15TCR_SINCOS =              // source increment offset size (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C15TCR_DINCOS =              // Destination increment offset (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C15TCR_SBURST =              // source burst transfer configuration (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C15TCR_DBURST =              // Destination burst transfer configuration (3 bits)
        bit_field_t<15, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C15TCR_TLEN =                // buffer transfer lengh (7 bits)
        bit_field_t<18, 0x7f>::value<X>();
    static constexpr uint32_t C15TCR_PKE = 0x2000000;      // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
    template<uint32_t X>
    static constexpr uint32_t C15TCR_PAM =                 // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C15TCR_TRGM =                // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    static constexpr uint32_t C15TCR_SWRM = 0x40000000;    // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
    static constexpr uint32_t C15TCR_BWM = 0x80000000;     // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
    static const uint32_t C15TCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C15BNDTR_BNDT =                // block number of data to transfer (17 bits)
        bit_field_t<0, 0x1ffff>::value<X>();
    static constexpr uint32_t C15BNDTR_BRSUM = 0x40000;      // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
    static constexpr uint32_t C15BNDTR_BRDUM = 0x80000;      // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
    template<uint32_t X>
    static constexpr uint32_t C15BNDTR_BRC =                 // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0. (12 bits)
        bit_field_t<20, 0xfff>::value<X>();
    static const uint32_t C15BNDTR_RESET_VALUE = 0x0;


    static const uint32_t C15SAR_RESET_VALUE = 0x0;


    static const uint32_t C15DAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C15BRUR_SUV =                 // source adresse update value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C15BRUR_DUV =                 // destination address update (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t C15BRUR_RESET_VALUE = 0x0;


    static const uint32_t C15LAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C15TBR_TSEL =                // Trigger selection (6 bits)
        bit_field_t<0, 0x3f>::value<X>();
    static constexpr uint32_t C15TBR_SBUS = 0x10000;       // Source BUS select This bit is protected and can be written only if EN is 0.
    static constexpr uint32_t C15TBR_DBUS = 0x20000;       // Destination BUS slect This bit is protected and can be written only if EN is 0.
    static const uint32_t C15TBR_RESET_VALUE = 0x0;


    static const uint32_t C15MAR_RESET_VALUE = 0x0;


    static const uint32_t C15MDR_RESET_VALUE = 0x0;

    static constexpr uint8_t MDMA = 122; // MDMA
};

static mdma_t& MDMA = *reinterpret_cast<mdma_t*>(0x52000000);

#define HAVE_PERIPHERAL_MDMA


////
//
//    QUADSPI
//
////

struct quadspi_t
{
    volatile uint32_t    CR;                   // [Read-write] QUADSPI control register
    volatile uint32_t    DCR;                  // [Read-write] QUADSPI device configuration register
    volatile uint32_t    SR;                   // [Read-only] QUADSPI status register
    volatile uint32_t    FCR;                  // [Read-write] QUADSPI flag clear register
    volatile uint32_t    DLR;                  // [Read-write] QUADSPI data length register
    volatile uint32_t    CCR;                  // [Read-write] QUADSPI communication configuration register
    volatile uint32_t    AR;                   // [Read-write] QUADSPI address register
    volatile uint32_t    ABR;                  // [Read-write] QUADSPI alternate bytes registers
    volatile uint32_t    DR;                   // [Read-write] QUADSPI data register
    volatile uint32_t    PSMKR;                // [Read-write] QUADSPI polling status mask register
    volatile uint32_t    PSMAR;                // [Read-write] QUADSPI polling status match register
    volatile uint32_t    PIR;                  // [Read-write] QUADSPI polling interval register
    volatile uint32_t    LPTR;                 // [Read-write] QUADSPI low-power timeout register

    static constexpr uint32_t CR_EN = 0x1;             // Enable Enable the QUADSPI.
    static constexpr uint32_t CR_ABORT = 0x2;          // Abort request This bit aborts the on-going command sequence. It is automatically reset once the abort is complete. This bit stops the current transfer. In polling mode or memory-mapped mode, this bit also reset the APM bit or the DM bit.
    static constexpr uint32_t CR_DMAEN = 0x4;          // DMA enable In indirect mode, DMA can be used to input or output data via the QUADSPI_DR register. DMA transfers are initiated when the FIFO threshold flag, FTF, is set.
    static constexpr uint32_t CR_TCEN = 0x8;           // Timeout counter enable This bit is valid only when memory-mapped mode (FMODE = 11) is selected. Activating this bit causes the chip select (nCS) to be released (and thus reduces consumption) if there has not been an access after a certain amount of time, where this time is defined by TIMEOUT[15:0] (QUADSPI_LPTR). Enable the timeout counter. By default, the QUADSPI never stops its prefetch operation, keeping the previous read operation active with nCS maintained low, even if no access to the Flash memory occurs for a long time. Since Flash memories tend to consume more when nCS is held low, the application might want to activate the timeout counter (TCEN = 1, QUADSPI_CR[3]) so that nCS is released after a period of TIMEOUT[15:0] (QUADSPI_LPTR) cycles have elapsed without an access since when the FIFO becomes full with prefetch data. This bit can be modified only when BUSY = 0.
    static constexpr uint32_t CR_SSHIFT = 0x10;        // Sample shift By default, the QUADSPI samples data 1/2 of a CLK cycle after the data is driven by the Flash memory. This bit allows the data is to be sampled later in order to account for external signal delays. Firmware must assure that SSHIFT = 0 when in DDR mode (when DDRM = 1). This field can be modified only when BUSY = 0.
    static constexpr uint32_t CR_DFM = 0x40;           // Dual-flash mode This bit activates dual-flash mode, where two external Flash memories are used simultaneously to double throughput and capacity. This bit can be modified only when BUSY = 0.
    static constexpr uint32_t CR_FSEL = 0x80;          // Flash memory selection This bit selects the Flash memory to be addressed in single flash mode (when DFM = 0). This bit can be modified only when BUSY = 0. This bit is ignored when DFM = 1.
    template<uint32_t X>
    static constexpr uint32_t CR_FTHRES =              // FIFO threshold level Defines, in indirect mode, the threshold number of bytes in the FIFO that will cause the FIFO threshold flag (FTF, QUADSPI_SR[2]) to be set. In indirect write mode (FMODE = 00): ... In indirect read mode (FMODE = 01): ... If DMAEN = 1, then the DMA controller for the corresponding channel must be disabled before changing the FTHRES value. (5 bits)
        bit_field_t<8, 0x1f>::value<X>();
    static constexpr uint32_t CR_TEIE = 0x10000;       // Transfer error interrupt enable This bit enables the transfer error interrupt.
    static constexpr uint32_t CR_TCIE = 0x20000;       // Transfer complete interrupt enable This bit enables the transfer complete interrupt.
    static constexpr uint32_t CR_FTIE = 0x40000;       // FIFO threshold interrupt enable This bit enables the FIFO threshold interrupt.
    static constexpr uint32_t CR_SMIE = 0x80000;       // Status match interrupt enable This bit enables the status match interrupt.
    static constexpr uint32_t CR_TOIE = 0x100000;      // TimeOut interrupt enable This bit enables the TimeOut interrupt.
    static constexpr uint32_t CR_APMS = 0x400000;      // Automatic poll mode stop This bit determines if automatic polling is stopped after a match. This bit can be modified only when BUSY = 0.
    static constexpr uint32_t CR_PMM = 0x800000;       // Polling match mode This bit indicates which method should be used for determining a match during automatic polling mode. This bit can be modified only when BUSY = 0.
    template<uint32_t X>
    static constexpr uint32_t CR_PRESCALER =           // clock prescaler (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t CR_RESET_VALUE = 0x0;

    static constexpr uint32_t DCR_CKMODE = 0x1;         // indicates the level that clk takes between command
    template<uint32_t X>
    static constexpr uint32_t DCR_CSHT =                // Chip select high time CSHT+1 defines the minimum number of CLK cycles which the chip select (nCS) must remain high between commands issued to the Flash memory. ... This field can be modified only when BUSY = 0. (3 bits)
        bit_field_t<8, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DCR_FSIZE =               // Flash memory size This field defines the size of external memory using the following formula: Number of bytes in Flash memory = 2[FSIZE+1] FSIZE+1 is effectively the number of address bits required to address the Flash memory. The Flash memory capacity can be up to 4GB (addressed using 32 bits) in indirect mode, but the addressable space in memory-mapped mode is limited to 256MB. If DFM = 1, FSIZE indicates the total capacity of the two Flash memories together. This field can be modified only when BUSY = 0. (5 bits)
        bit_field_t<16, 0x1f>::value<X>();
    static const uint32_t DCR_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_TEF = 0x1;            // Transfer error flag This bit is set in indirect mode when an invalid address is being accessed in indirect mode. It is cleared by writing 1 to CTEF.
    static constexpr uint32_t SR_TCF = 0x2;            // Transfer complete flag This bit is set in indirect mode when the programmed number of data has been transferred or in any mode when the transfer has been aborted.It is cleared by writing 1 to CTCF.
    static constexpr uint32_t SR_FTF = 0x4;            // FIFO threshold flag In indirect mode, this bit is set when the FIFO threshold has been reached, or if there is any data left in the FIFO after reads from the Flash memory are complete. It is cleared automatically as soon as threshold condition is no longer true. In automatic polling mode this bit is set every time the status register is read, and the bit is cleared when the data register is read.
    static constexpr uint32_t SR_SMF = 0x8;            // Status match flag This bit is set in automatic polling mode when the unmasked received data matches the corresponding bits in the match register (QUADSPI_PSMAR). It is cleared by writing 1 to CSMF.
    static constexpr uint32_t SR_TOF = 0x10;           // Timeout flag This bit is set when timeout occurs. It is cleared by writing 1 to CTOF.
    static constexpr uint32_t SR_BUSY = 0x20;          // Busy This bit is set when an operation is on going. This bit clears automatically when the operation with the Flash memory is finished and the FIFO is empty.
    template<uint32_t X>
    static constexpr uint32_t SR_FLEVEL =              // FIFO level This field gives the number of valid bytes which are being held in the FIFO. FLEVEL = 0 when the FIFO is empty, and 16 when it is full. In memory-mapped mode and in automatic status polling mode, FLEVEL is zero. (6 bits)
        bit_field_t<8, 0x3f>::value<X>();
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint32_t FCR_CTEF = 0x1;           // Clear transfer error flag Writing 1 clears the TEF flag in the QUADSPI_SR register
    static constexpr uint32_t FCR_CTCF = 0x2;           // Clear transfer complete flag Writing 1 clears the TCF flag in the QUADSPI_SR register
    static constexpr uint32_t FCR_CSMF = 0x8;           // Clear status match flag Writing 1 clears the SMF flag in the QUADSPI_SR register
    static constexpr uint32_t FCR_CTOF = 0x10;          // Clear timeout flag Writing 1 clears the TOF flag in the QUADSPI_SR register
    static const uint32_t FCR_RESET_VALUE = 0x0;


    static const uint32_t DLR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR_INSTRUCTION =         // Instruction Instruction to be send to the external SPI device. This field can be written only when BUSY = 0. (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR_IMODE =               // Instruction mode This field defines the instruction phase mode of operation: This field can be written only when BUSY = 0. (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR_ADMODE =              // Address mode This field defines the address phase mode of operation: This field can be written only when BUSY = 0. (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR_ADSIZE =              // Address size This bit defines address size: This field can be written only when BUSY = 0. (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR_ABMODE =              // Alternate bytes mode This field defines the alternate-bytes phase mode of operation: This field can be written only when BUSY = 0. (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR_ABSIZE =              // Alternate bytes size This bit defines alternate bytes size: This field can be written only when BUSY = 0. (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR_DCYC =                // Number of dummy cycles This field defines the duration of the dummy phase. In both SDR and DDR modes, it specifies a number of CLK cycles (0-31). This field can be written only when BUSY = 0. (5 bits)
        bit_field_t<18, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR_DMODE =               // Data mode This field defines the data phases mode of operation: This field also determines the dummy phase mode of operation. This field can be written only when BUSY = 0. (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR_FMODE =               // Functional mode This field defines the QUADSPI functional mode of operation. If DMAEN = 1 already, then the DMA controller for the corresponding channel must be disabled before changing the FMODE value. This field can be written only when BUSY = 0. (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    static constexpr uint32_t CCR_SIOO = 0x10000000;    // Send instruction only once mode See Section15.3.11: Sending the instruction only once on page13. This bit has no effect when IMODE = 00. This field can be written only when BUSY = 0.
    static constexpr uint32_t CCR_DHHC = 0x40000000;    // DDR hold Delay the data output by 1/4 of the QUADSPI output clock cycle in DDR mode: This feature is only active in DDR mode. This field can be written only when BUSY = 0.
    static constexpr uint32_t CCR_DDRM = 0x80000000;    // Double data rate mode This bit sets the DDR mode for the address, alternate byte and data phase: This field can be written only when BUSY = 0.
    static const uint32_t CCR_RESET_VALUE = 0x0;


    static const uint32_t AR_RESET_VALUE = 0x0;


    static const uint32_t ABR_RESET_VALUE = 0x0;


    static const uint32_t DR_RESET_VALUE = 0x0;


    static const uint32_t PSMKR_RESET_VALUE = 0x0;


    static const uint32_t PSMAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PIR_INTERVAL =            // Polling interval Number of CLK cycles between to read during automatic polling phases. This field can be written only when BUSY = 0. (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t PIR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t LPTR_TIMEOUT =             // Timeout period After each access in memory-mapped mode, the QUADSPI prefetches the subsequent bytes and holds these bytes in the FIFO. This field indicates how many CLK cycles the QUADSPI waits after the FIFO becomes full until it raises nCS, putting the Flash memory in a lower-consumption state. This field can be written only when BUSY = 0. (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t LPTR_RESET_VALUE = 0x0;

    static constexpr uint8_t QUADSPI = 92; // QuadSPI global interrupt
};

static quadspi_t& QUADSPI = *reinterpret_cast<quadspi_t*>(0x52005000);

#define HAVE_PERIPHERAL_QUADSPI


////
//
//    RNG
//
////

struct rng_t
{
    volatile uint32_t    CR;                   // [Read-write] RNG control register
    volatile uint32_t    SR;                   // RNG status register
    volatile uint32_t    DR;                   // [Read-only] The RNG_DR register is a read-only register that delivers a 32-bit random value when read. The content of this register is valid when DRDY= 1, even if RNGEN=0.

    static constexpr uint32_t CR_RNGEN = 0x4;          // Random number generator enable
    static constexpr uint32_t CR_IE = 0x8;             // Interrupt enable
    static constexpr uint32_t CR_CED = 0x20;           // Clock error detection Note: The clock error detection can be used only when ck_rc48 or ck_pll1_q (ck_pll1_q = 48MHz) source is selected otherwise, CED bit must be equal to 1. The clock error detection cannot be enabled nor disabled on the fly when RNG peripheral is enabled, to enable or disable CED the RNG must be disabled.
    static const uint32_t CR_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_DRDY = 0x1;           // Data ready Note: If IE=1 in RNG_CR, an interrupt is generated when DRDY=1. It can rise when the peripheral is disabled. When the output buffer becomes empty (after reading RNG_DR), this bit returns to 0 until a new random value is generated., Read-only
    static constexpr uint32_t SR_CECS = 0x2;           // Clock error current status Note: This bit is meaningless if CED (Clock error detection) bit in RNG_CR is equal to 1., Read-only
    static constexpr uint32_t SR_SECS = 0x4;           // Seed error current status ** More than 64 consecutive bits at the same value (0 or 1) ** More than 32 consecutive alternances of 0 and 1 (0101010101...01), Read-only
    static constexpr uint32_t SR_CEIS = 0x20;          // Clock error interrupt status This bit is set at the same time as CECS. It is cleared by writing it to 0. An interrupt is pending if IE = 1 in the RNG_CR register. Note: This bit is meaningless if CED (Clock error detection) bit in RNG_CR is equal to 1., Read-write
    static constexpr uint32_t SR_SEIS = 0x40;          // Seed error interrupt status This bit is set at the same time as SECS. It is cleared by writing it to 0. ** More than 64 consecutive bits at the same value (0 or 1) ** More than 32 consecutive alternances of 0 and 1 (0101010101...01) An interrupt is pending if IE = 1 in the RNG_CR register., Read-write
    static const uint32_t SR_RESET_VALUE = 0x0;


    static const uint32_t DR_RESET_VALUE = 0x0;
};

static rng_t& RNG = *reinterpret_cast<rng_t*>(0x48021800);

#define HAVE_PERIPHERAL_RNG


////
//
//    RTC
//
////

struct rtc_t
{
    volatile uint32_t    TR;                   // [Read-write] The RTC_TR is the calendar time shadow register. This register must be written in initialization mode only. Refer to Calendar initialization and configuration on page9 and Reading the calendar on page10.This register is write protected. The write access procedure is described in RTC register write protection on page9.
    volatile uint32_t    DR;                   // [Read-write] The RTC_DR is the calendar date shadow register. This register must be written in initialization mode only. Refer to Calendar initialization and configuration on page9 and Reading the calendar on page10.This register is write protected. The write access procedure is described in RTC register write protection on page9.
    volatile uint32_t    CR;                   // RTC control register
    volatile uint32_t    ISR;                  // This register is write protected (except for RTC_ISR[13:8] bits). The write access procedure is described in RTC register write protection on page9.
    volatile uint32_t    PRER;                 // [Read-write] This register must be written in initialization mode only. The initialization must be performed in two separate write accesses. Refer to Calendar initialization and configuration on page9.This register is write protected. The write access procedure is described in RTC register write protection on page9.
    volatile uint32_t    WUTR;                 // [Read-write] This register can be written only when WUTWF is set to 1 in RTC_ISR.This register is write protected. The write access procedure is described in RTC register write protection on page9.
    reserved_t<1>        _0;
    volatile uint32_t    ALRMAR;               // [Read-write] This register can be written only when ALRAWF is set to 1 in RTC_ISR, or in initialization mode.This register is write protected. The write access procedure is described in RTC register write protection on page9.
    volatile uint32_t    ALRMBR;               // [Read-write] This register can be written only when ALRBWF is set to 1 in RTC_ISR, or in initialization mode.This register is write protected. The write access procedure is described in RTC register write protection on page9.
    volatile uint32_t    WPR;                  // [Write-only] RTC write protection register
    volatile uint32_t    SSR;                  // [Read-only] RTC sub second register
    volatile uint32_t    SHIFTR;               // [Write-only] This register is write protected. The write access procedure is described in RTC register write protection on page9.
    volatile uint32_t    TSTR;                 // [Read-only] The content of this register is valid only when TSF is set to 1 in RTC_ISR. It is cleared when TSF bit is reset.
    volatile uint32_t    TSDR;                 // [Read-only] The content of this register is valid only when TSF is set to 1 in RTC_ISR. It is cleared when TSF bit is reset.
    volatile uint32_t    TSSSR;                // [Read-only] The content of this register is valid only when RTC_ISR/TSF is set. It is cleared when the RTC_ISR/TSF bit is reset.
    volatile uint32_t    CALR;                 // [Read-write] This register is write protected. The write access procedure is described in RTC register write protection on page9.
    volatile uint32_t    TAMPCR;               // [Read-write] RTC tamper and alternate function configuration register
    volatile uint32_t    ALRMASSR;             // [Read-write] This register can be written only when ALRAE is reset in RTC_CR register, or in initialization mode.This register is write protected. The write access procedure is described in RTC register write protection on page9
    volatile uint32_t    ALRMBSSR;             // [Read-write] This register can be written only when ALRBE is reset in RTC_CR register, or in initialization mode.This register is write protected.The write access procedure is described in Section: RTC register write protection.
    volatile uint32_t    OR;                   // [Read-write] RTC option register
    volatile uint32_t    BKP0R;                // [Read-write] RTC backup registers
    volatile uint32_t    BKP1R;                // [Read-write] RTC backup registers
    volatile uint32_t    BKP2R;                // [Read-write] RTC backup registers
    volatile uint32_t    BKP3R;                // [Read-write] RTC backup registers
    volatile uint32_t    BKP4R;                // [Read-write] RTC backup registers
    volatile uint32_t    BKP5R;                // [Read-write] RTC backup registers
    volatile uint32_t    BKP6R;                // [Read-write] RTC backup registers
    volatile uint32_t    BKP7R;                // [Read-write] RTC backup registers
    volatile uint32_t    BKP8R;                // [Read-write] RTC backup registers
    volatile uint32_t    BKP9R;                // [Read-write] RTC backup registers
    volatile uint32_t    BKP10R;               // [Read-write] RTC backup registers
    volatile uint32_t    BKP11R;               // [Read-write] RTC backup registers
    volatile uint32_t    BKP12R;               // [Read-write] RTC backup registers
    volatile uint32_t    BKP13R;               // [Read-write] RTC backup registers
    volatile uint32_t    BKP14R;               // [Read-write] RTC backup registers
    volatile uint32_t    BKP15R;               // [Read-write] RTC backup registers
    volatile uint32_t    BKP16R;               // [Read-write] RTC backup registers
    volatile uint32_t    BKP17R;               // [Read-write] RTC backup registers
    volatile uint32_t    BKP18R;               // [Read-write] RTC backup registers
    volatile uint32_t    BKP19R;               // [Read-write] RTC backup registers
    volatile uint32_t    BKP20R;               // [Read-write] RTC backup registers
    volatile uint32_t    BKP21R;               // [Read-write] RTC backup registers
    volatile uint32_t    BKP22R;               // [Read-write] RTC backup registers
    volatile uint32_t    BKP23R;               // [Read-write] RTC backup registers
    volatile uint32_t    BKP24R;               // [Read-write] RTC backup registers
    volatile uint32_t    BKP25R;               // [Read-write] RTC backup registers
    volatile uint32_t    BKP26R;               // [Read-write] RTC backup registers
    volatile uint32_t    BKP27R;               // [Read-write] RTC backup registers
    volatile uint32_t    BKP28R;               // [Read-write] RTC backup registers
    volatile uint32_t    BKP29R;               // [Read-write] RTC backup registers
    volatile uint32_t    BKP30R;               // [Read-write] RTC backup registers
    volatile uint32_t    BKP31R;               // [Read-write] RTC backup registers

    template<uint32_t X>
    static constexpr uint32_t TR_SU =                  // Second units in BCD format (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TR_ST =                  // Second tens in BCD format (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TR_MNU =                 // Minute units in BCD format (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TR_MNT =                 // Minute tens in BCD format (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TR_HU =                  // Hour units in BCD format (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TR_HT =                  // Hour tens in BCD format (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    static constexpr uint32_t TR_PM = 0x400000;        // AM/PM notation
    static const uint32_t TR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DR_DU =                  // Date units in BCD format (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DR_DT =                  // Date tens in BCD format (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DR_MU =                  // Month units in BCD format (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    static constexpr uint32_t DR_MT = 0x1000;          // Month tens in BCD format
    template<uint32_t X>
    static constexpr uint32_t DR_WDU =                 // Week day units (3 bits)
        bit_field_t<13, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DR_YU =                  // Year units in BCD format (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DR_YT =                  // Year tens in BCD format (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    static const uint32_t DR_RESET_VALUE = 0x2101;

    template<uint32_t X>
    static constexpr uint32_t CR_WUCKSEL =             // Wakeup clock selection (3 bits), Read-write
        bit_field_t<0, 0x7>::value<X>();
    static constexpr uint32_t CR_TSEDGE = 0x8;         // Time-stamp event active edge TSE must be reset when TSEDGE is changed to avoid unwanted TSF setting., Read-write
    static constexpr uint32_t CR_REFCKON = 0x10;       // RTC_REFIN reference clock detection enable (50 or 60Hz) Note: PREDIV_S must be 0x00FF., Read-write
    static constexpr uint32_t CR_BYPSHAD = 0x20;       // Bypass the shadow registers Note: If the frequency of the APB clock is less than seven times the frequency of RTCCLK, BYPSHAD must be set to 1., Read-write
    static constexpr uint32_t CR_FMT = 0x40;           // Hour format, Read-write
    static constexpr uint32_t CR_ALRAE = 0x100;        // Alarm A enable, Read-write
    static constexpr uint32_t CR_ALRBE = 0x200;        // Alarm B enable, Read-write
    static constexpr uint32_t CR_WUTE = 0x400;         // Wakeup timer enable, Read-write
    static constexpr uint32_t CR_TSE = 0x800;          // timestamp enable, Read-write
    static constexpr uint32_t CR_ALRAIE = 0x1000;      // Alarm A interrupt enable, Read-write
    static constexpr uint32_t CR_ALRBIE = 0x2000;      // Alarm B interrupt enable, Read-write
    static constexpr uint32_t CR_WUTIE = 0x4000;       // Wakeup timer interrupt enable, Read-write
    static constexpr uint32_t CR_TSIE = 0x8000;        // Time-stamp interrupt enable, Read-write
    static constexpr uint32_t CR_ADD1H = 0x10000;      // Add 1 hour (summer time change) When this bit is set outside initialization mode, 1 hour is added to the calendar time. This bit is always read as 0., Write-only
    static constexpr uint32_t CR_SUB1H = 0x20000;      // Subtract 1 hour (winter time change) When this bit is set outside initialization mode, 1 hour is subtracted to the calendar time if the current hour is not 0. This bit is always read as 0. Setting this bit has no effect when current hour is 0., Write-only
    static constexpr uint32_t CR_BKP = 0x40000;        // Backup This bit can be written by the user to memorize whether the daylight saving time change has been performed or not., Read-write
    static constexpr uint32_t CR_COSEL = 0x80000;      // Calibration output selection When COE=1, this bit selects which signal is output on RTC_CALIB. These frequencies are valid for RTCCLK at 32.768 kHz and prescalers at their default values (PREDIV_A=127 and PREDIV_S=255). Refer to Section24.3.15: Calibration clock output, Read-write
    static constexpr uint32_t CR_POL = 0x100000;       // Output polarity This bit is used to configure the polarity of RTC_ALARM output, Read-write
    template<uint32_t X>
    static constexpr uint32_t CR_OSEL =                // Output selection These bits are used to select the flag to be routed to RTC_ALARM output (2 bits), Read-write
        bit_field_t<21, 0x3>::value<X>();
    static constexpr uint32_t CR_COE = 0x800000;       // Calibration output enable This bit enables the RTC_CALIB output, Read-write
    static constexpr uint32_t CR_ITSE = 0x1000000;     // timestamp on internal event enable, Read-write
    static const uint32_t CR_RESET_VALUE = 0x0;

    static constexpr uint32_t ISR_ALRAWF = 0x1;         // Alarm A write flag This bit is set by hardware when Alarm A values can be changed, after the ALRAE bit has been set to 0 in RTC_CR. It is cleared by hardware in initialization mode., Read-only
    static constexpr uint32_t ISR_ALRBWF = 0x2;         // Alarm B write flag This bit is set by hardware when Alarm B values can be changed, after the ALRBE bit has been set to 0 in RTC_CR. It is cleared by hardware in initialization mode., Read-only
    static constexpr uint32_t ISR_WUTWF = 0x4;          // Wakeup timer write flag This bit is set by hardware up to 2 RTCCLK cycles after the WUTE bit has been set to 0 in RTC_CR, and is cleared up to 2 RTCCLK cycles after the WUTE bit has been set to 1. The wakeup timer values can be changed when WUTE bit is cleared and WUTWF is set., Read-only
    static constexpr uint32_t ISR_SHPF = 0x8;           // Shift operation pending This flag is set by hardware as soon as a shift operation is initiated by a write to the RTC_SHIFTR register. It is cleared by hardware when the corresponding shift operation has been executed. Writing to the SHPF bit has no effect., Read-only
    static constexpr uint32_t ISR_INITS = 0x10;         // Initialization status flag This bit is set by hardware when the calendar year field is different from 0 (Backup domain reset state)., Read-only
    static constexpr uint32_t ISR_RSF = 0x20;           // Registers synchronization flag This bit is set by hardware each time the calendar registers are copied into the shadow registers (RTC_SSRx, RTC_TRx and RTC_DRx). This bit is cleared by hardware in initialization mode, while a shift operation is pending (SHPF=1), or when in bypass shadow register mode (BYPSHAD=1). This bit can also be cleared by software. It is cleared either by software or by hardware in initialization mode., Read-write
    static constexpr uint32_t ISR_INITF = 0x40;         // Initialization flag When this bit is set to 1, the RTC is in initialization state, and the time, date and prescaler registers can be updated., Read-only
    static constexpr uint32_t ISR_INIT = 0x80;          // Initialization mode, Read-write
    static constexpr uint32_t ISR_ALRAF = 0x100;        // Alarm A flag This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the Alarm A register (RTC_ALRMAR). This flag is cleared by software by writing 0., Read-write
    static constexpr uint32_t ISR_ALRBF = 0x200;        // Alarm B flag This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the Alarm B register (RTC_ALRMBR). This flag is cleared by software by writing 0., Read-write
    static constexpr uint32_t ISR_WUTF = 0x400;         // Wakeup timer flag This flag is set by hardware when the wakeup auto-reload counter reaches 0. This flag is cleared by software by writing 0. This flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is set to 1 again., Read-write
    static constexpr uint32_t ISR_TSF = 0x800;          // Time-stamp flag This flag is set by hardware when a time-stamp event occurs. This flag is cleared by software by writing 0., Read-write
    static constexpr uint32_t ISR_TSOVF = 0x1000;       // Time-stamp overflow flag This flag is set by hardware when a time-stamp event occurs while TSF is already set. This flag is cleared by software by writing 0. It is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a time-stamp event occurs immediately before the TSF bit is cleared., Read-write
    static constexpr uint32_t ISR_TAMP1F = 0x2000;      // RTC_TAMP1 detection flag This flag is set by hardware when a tamper detection event is detected on the RTC_TAMP1 input. It is cleared by software writing 0, Read-write
    static constexpr uint32_t ISR_TAMP2F = 0x4000;      // RTC_TAMP2 detection flag This flag is set by hardware when a tamper detection event is detected on the RTC_TAMP2 input. It is cleared by software writing 0, Read-write
    static constexpr uint32_t ISR_TAMP3F = 0x8000;      // RTC_TAMP3 detection flag This flag is set by hardware when a tamper detection event is detected on the RTC_TAMP3 input. It is cleared by software writing 0, Read-write
    static constexpr uint32_t ISR_RECALPF = 0x10000;    // Recalibration pending Flag The RECALPF status flag is automatically set to 1 when software writes to the RTC_CALR register, indicating that the RTC_CALR register is blocked. When the new calibration settings are taken into account, this bit returns to 0. Refer to Re-calibration on-the-fly., Read-only
    static constexpr uint32_t ISR_ITSF = 0x20000;       // Internal tTime-stamp flag, Read-write
    static const uint32_t ISR_RESET_VALUE = 0x7;

    template<uint32_t X>
    static constexpr uint32_t PRER_PREDIV_S =            // Synchronous prescaler factor This is the synchronous division factor: ck_spre frequency = ck_apre frequency/(PREDIV_S+1) (15 bits)
        bit_field_t<0, 0x7fff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PRER_PREDIV_A =            // Asynchronous prescaler factor This is the asynchronous division factor: ck_apre frequency = RTCCLK frequency/(PREDIV_A+1) (7 bits)
        bit_field_t<16, 0x7f>::value<X>();
    static const uint32_t PRER_RESET_VALUE = 0x7f00ff;

    template<uint32_t X>
    static constexpr uint32_t WUTR_WUT =                 // Wakeup auto-reload value bits When the wakeup timer is enabled (WUTE set to 1), the WUTF flag is set every (WUT[15:0] + 1) ck_wut cycles. The ck_wut period is selected through WUCKSEL[2:0] bits of the RTC_CR register When WUCKSEL[2] = 1, the wakeup timer becomes 17-bits and WUCKSEL[1] effectively becomes WUT[16] the most-significant bit to be reloaded into the timer. The first assertion of WUTF occurs (WUT+1) ck_wut cycles after WUTE is set. Setting WUT[15:0] to 0x0000 with WUCKSEL[2:0] =011 (RTCCLK/2) is forbidden. (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t WUTR_RESET_VALUE = 0xffff;

    template<uint32_t X>
    static constexpr uint32_t ALRMAR_SU =                  // Second units in BCD format. (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ALRMAR_ST =                  // Second tens in BCD format. (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t ALRMAR_MSK1 = 0x80;          // Alarm A seconds mask
    template<uint32_t X>
    static constexpr uint32_t ALRMAR_MNU =                 // Minute units in BCD format. (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ALRMAR_MNT =                 // Minute tens in BCD format. (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    static constexpr uint32_t ALRMAR_MSK2 = 0x8000;        // Alarm A minutes mask
    template<uint32_t X>
    static constexpr uint32_t ALRMAR_HU =                  // Hour units in BCD format. (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ALRMAR_HT =                  // Hour tens in BCD format. (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    static constexpr uint32_t ALRMAR_PM = 0x400000;        // AM/PM notation
    static constexpr uint32_t ALRMAR_MSK3 = 0x800000;      // Alarm A hours mask
    template<uint32_t X>
    static constexpr uint32_t ALRMAR_DU =                  // Date units or day in BCD format. (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ALRMAR_DT =                  // Date tens in BCD format. (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    static constexpr uint32_t ALRMAR_WDSEL = 0x40000000;   // Week day selection
    static constexpr uint32_t ALRMAR_MSK4 = 0x80000000;    // Alarm A date mask
    static const uint32_t ALRMAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ALRMBR_SU =                  // Second units in BCD format (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ALRMBR_ST =                  // Second tens in BCD format (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t ALRMBR_MSK1 = 0x80;          // Alarm B seconds mask
    template<uint32_t X>
    static constexpr uint32_t ALRMBR_MNU =                 // Minute units in BCD format (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ALRMBR_MNT =                 // Minute tens in BCD format (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    static constexpr uint32_t ALRMBR_MSK2 = 0x8000;        // Alarm B minutes mask
    template<uint32_t X>
    static constexpr uint32_t ALRMBR_HU =                  // Hour units in BCD format (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ALRMBR_HT =                  // Hour tens in BCD format (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    static constexpr uint32_t ALRMBR_PM = 0x400000;        // AM/PM notation
    static constexpr uint32_t ALRMBR_MSK3 = 0x800000;      // Alarm B hours mask
    template<uint32_t X>
    static constexpr uint32_t ALRMBR_DU =                  // Date units or day in BCD format (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ALRMBR_DT =                  // Date tens in BCD format (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    static constexpr uint32_t ALRMBR_WDSEL = 0x40000000;   // Week day selection
    static constexpr uint32_t ALRMBR_MSK4 = 0x80000000;    // Alarm B date mask
    static const uint32_t ALRMBR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t WPR_KEY =                 // Write protection key This byte is written by software. Reading this byte always returns 0x00. Refer to RTC register write protection for a description of how to unlock RTC register write protection. (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t WPR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SSR_SS =                  // Sub second value SS[15:0] is the value in the synchronous prescaler counter. The fraction of a second is given by the formula below: Second fraction = (PREDIV_S - SS) / (PREDIV_S + 1) Note: SS can be larger than PREDIV_S only after a shift operation. In that case, the correct time/date is one second less than as indicated by RTC_TR/RTC_DR. (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t SSR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SHIFTR_SUBFS =               // Subtract a fraction of a second These bits are write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF=1, in RTC_ISR). The value which is written to SUBFS is added to the synchronous prescaler counter. Since this counter counts down, this operation effectively subtracts from (delays) the clock by: Delay (seconds) = SUBFS / (PREDIV_S + 1) A fraction of a second can effectively be added to the clock (advancing the clock) when the ADD1S function is used in conjunction with SUBFS, effectively advancing the clock by: Advance (seconds) = (1 - (SUBFS / (PREDIV_S + 1))). Note: Writing to SUBFS causes RSF to be cleared. Software can then wait until RSF=1 to be sure that the shadow registers have been updated with the shifted time. (15 bits)
        bit_field_t<0, 0x7fff>::value<X>();
    static constexpr uint32_t SHIFTR_ADD1S = 0x80000000;   // Add one second This bit is write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF=1, in RTC_ISR). This function is intended to be used with SUBFS (see description below) in order to effectively add a fraction of a second to the clock in an atomic operation.
    static const uint32_t SHIFTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TSTR_SU =                  // Second units in BCD format. (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TSTR_ST =                  // Second tens in BCD format. (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TSTR_MNU =                 // Minute units in BCD format. (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TSTR_MNT =                 // Minute tens in BCD format. (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TSTR_HU =                  // Hour units in BCD format. (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TSTR_HT =                  // Hour tens in BCD format. (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    static constexpr uint32_t TSTR_PM = 0x400000;        // AM/PM notation
    static const uint32_t TSTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TSDR_DU =                  // Date units in BCD format (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TSDR_DT =                  // Date tens in BCD format (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TSDR_MU =                  // Month units in BCD format (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    static constexpr uint32_t TSDR_MT = 0x1000;          // Month tens in BCD format
    template<uint32_t X>
    static constexpr uint32_t TSDR_WDU =                 // Week day units (3 bits)
        bit_field_t<13, 0x7>::value<X>();
    static const uint32_t TSDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TSSSR_SS =                  // Sub second value SS[15:0] is the value of the synchronous prescaler counter when the timestamp event occurred. (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t TSSSR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CALR_CALM =                // Calibration minus The frequency of the calendar is reduced by masking CALM out of 220 RTCCLK pulses (32 seconds if the input frequency is 32768 Hz). This decreases the frequency of the calendar with a resolution of 0.9537 ppm. To increase the frequency of the calendar, this feature should be used in conjunction with CALP. See Section24.3.12: RTC smooth digital calibration on page13. (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static constexpr uint32_t CALR_CALW16 = 0x2000;      // Use a 16-second calibration cycle period When CALW16 is set to 1, the 16-second calibration cycle period is selected.This bit must not be set to 1 if CALW8=1. Note: CALM[0] is stuck at 0 when CALW16= 1. Refer to Section24.3.12: RTC smooth digital calibration.
    static constexpr uint32_t CALR_CALW8 = 0x4000;       // Use an 8-second calibration cycle period When CALW8 is set to 1, the 8-second calibration cycle period is selected. Note: CALM[1:0] are stuck at 00; when CALW8= 1. Refer to Section24.3.12: RTC smooth digital calibration.
    static constexpr uint32_t CALR_CALP = 0x8000;        // Increase frequency of RTC by 488.5 ppm This feature is intended to be used in conjunction with CALM, which lowers the frequency of the calendar with a fine resolution. if the input frequency is 32768 Hz, the number of RTCCLK pulses added during a 32-second window is calculated as follows: (512 * CALP) - CALM. Refer to Section24.3.12: RTC smooth digital calibration.
    static const uint32_t CALR_RESET_VALUE = 0x0;

    static constexpr uint32_t TAMPCR_TAMP1E = 0x1;         // RTC_TAMP1 input detection enable
    static constexpr uint32_t TAMPCR_TAMP1TRG = 0x2;       // Active level for RTC_TAMP1 input If TAMPFLT != 00 if TAMPFLT = 00:
    static constexpr uint32_t TAMPCR_TAMPIE = 0x4;         // Tamper interrupt enable
    static constexpr uint32_t TAMPCR_TAMP2E = 0x8;         // RTC_TAMP2 input detection enable
    static constexpr uint32_t TAMPCR_TAMP2TRG = 0x10;      // Active level for RTC_TAMP2 input if TAMPFLT != 00: if TAMPFLT = 00:
    static constexpr uint32_t TAMPCR_TAMP3E = 0x20;        // RTC_TAMP3 detection enable
    static constexpr uint32_t TAMPCR_TAMP3TRG = 0x40;      // Active level for RTC_TAMP3 input if TAMPFLT != 00: if TAMPFLT = 00:
    static constexpr uint32_t TAMPCR_TAMPTS = 0x80;        // Activate timestamp on tamper detection event TAMPTS is valid even if TSE=0 in the RTC_CR register.
    template<uint32_t X>
    static constexpr uint32_t TAMPCR_TAMPFREQ =            // Tamper sampling frequency Determines the frequency at which each of the RTC_TAMPx inputs are sampled. (3 bits)
        bit_field_t<8, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TAMPCR_TAMPFLT =             // RTC_TAMPx filter count These bits determines the number of consecutive samples at the specified level (TAMP*TRG) needed to activate a Tamper event. TAMPFLT is valid for each of the RTC_TAMPx inputs. (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TAMPCR_TAMPPRCH =            // RTC_TAMPx precharge duration These bit determines the duration of time during which the pull-up/is activated before each sample. TAMPPRCH is valid for each of the RTC_TAMPx inputs. (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    static constexpr uint32_t TAMPCR_TAMPPUDIS = 0x8000;   // RTC_TAMPx pull-up disable This bit determines if each of the RTC_TAMPx pins are pre-charged before each sample.
    static constexpr uint32_t TAMPCR_TAMP1IE = 0x10000;    // Tamper 1 interrupt enable
    static constexpr uint32_t TAMPCR_TAMP1NOERASE = 0x20000;// Tamper 1 no erase
    static constexpr uint32_t TAMPCR_TAMP1MF = 0x40000;    // Tamper 1 mask flag
    static constexpr uint32_t TAMPCR_TAMP2IE = 0x80000;    // Tamper 2 interrupt enable
    static constexpr uint32_t TAMPCR_TAMP2NOERASE = 0x100000;// Tamper 2 no erase
    static constexpr uint32_t TAMPCR_TAMP2MF = 0x200000;   // Tamper 2 mask flag
    static constexpr uint32_t TAMPCR_TAMP3IE = 0x400000;   // Tamper 3 interrupt enable
    static constexpr uint32_t TAMPCR_TAMP3NOERASE = 0x800000;// Tamper 3 no erase
    static constexpr uint32_t TAMPCR_TAMP3MF = 0x1000000;  // Tamper 3 mask flag
    static const uint32_t TAMPCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ALRMASSR_SS =                  // Sub seconds value This value is compared with the contents of the synchronous prescaler counter to determine if Alarm A is to be activated. Only bits 0 up MASKSS-1 are compared. (15 bits)
        bit_field_t<0, 0x7fff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ALRMASSR_MASKSS =              // Mask the most-significant bits starting at this bit ... The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation. (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    static const uint32_t ALRMASSR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ALRMBSSR_SS =                  // Sub seconds value This value is compared with the contents of the synchronous prescaler counter to determine if Alarm B is to be activated. Only bits 0 up to MASKSS-1 are compared. (15 bits)
        bit_field_t<0, 0x7fff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ALRMBSSR_MASKSS =              // Mask the most-significant bits starting at this bit ... The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation. (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    static const uint32_t ALRMBSSR_RESET_VALUE = 0x0;

    static constexpr uint32_t OR_RTC_ALARM_TYPE = 0x1; // RTC_ALARM output type on PC13
    static constexpr uint32_t OR_RTC_OUT_RMP = 0x2;    // RTC_OUT remap
    static const uint32_t OR_RESET_VALUE = 0x0;


    static const uint32_t BKP0R_RESET_VALUE = 0x0;


    static const uint32_t BKP1R_RESET_VALUE = 0x0;


    static const uint32_t BKP2R_RESET_VALUE = 0x0;


    static const uint32_t BKP3R_RESET_VALUE = 0x0;


    static const uint32_t BKP4R_RESET_VALUE = 0x0;


    static const uint32_t BKP5R_RESET_VALUE = 0x0;


    static const uint32_t BKP6R_RESET_VALUE = 0x0;


    static const uint32_t BKP7R_RESET_VALUE = 0x0;


    static const uint32_t BKP8R_RESET_VALUE = 0x0;


    static const uint32_t BKP9R_RESET_VALUE = 0x0;


    static const uint32_t BKP10R_RESET_VALUE = 0x0;


    static const uint32_t BKP11R_RESET_VALUE = 0x0;


    static const uint32_t BKP12R_RESET_VALUE = 0x0;


    static const uint32_t BKP13R_RESET_VALUE = 0x0;


    static const uint32_t BKP14R_RESET_VALUE = 0x0;


    static const uint32_t BKP15R_RESET_VALUE = 0x0;


    static const uint32_t BKP16R_RESET_VALUE = 0x0;


    static const uint32_t BKP17R_RESET_VALUE = 0x0;


    static const uint32_t BKP18R_RESET_VALUE = 0x0;


    static const uint32_t BKP19R_RESET_VALUE = 0x0;


    static const uint32_t BKP20R_RESET_VALUE = 0x0;


    static const uint32_t BKP21R_RESET_VALUE = 0x0;


    static const uint32_t BKP22R_RESET_VALUE = 0x0;


    static const uint32_t BKP23R_RESET_VALUE = 0x0;


    static const uint32_t BKP24R_RESET_VALUE = 0x0;


    static const uint32_t BKP25R_RESET_VALUE = 0x0;


    static const uint32_t BKP26R_RESET_VALUE = 0x0;


    static const uint32_t BKP27R_RESET_VALUE = 0x0;


    static const uint32_t BKP28R_RESET_VALUE = 0x0;


    static const uint32_t BKP29R_RESET_VALUE = 0x0;


    static const uint32_t BKP30R_RESET_VALUE = 0x0;


    static const uint32_t BKP31R_RESET_VALUE = 0x0;

    static constexpr uint8_t RTC_TAMP_STAMP_CSS_LSE = 2; // RTC tamper, timestamp
    static constexpr uint8_t RTC_WKUP = 3; // RTC Wakeup interrupt
};

static rtc_t& RTC = *reinterpret_cast<rtc_t*>(0x58004000);

#define HAVE_PERIPHERAL_RTC


////
//
//    SAI
//
////

struct sai4_t
{
    volatile uint32_t    GCR;                  // [Read-write] Global configuration register
    volatile uint32_t    ACR1;                 // [Read-write] Configuration register 1
    volatile uint32_t    ACR2;                 // Configuration register 2
    volatile uint32_t    AFRCR;                // This register has no meaning in AC97 and SPDIF audio protocol
    volatile uint32_t    ASLOTR;               // [Read-write] This register has no meaning in AC97 and SPDIF audio protocol
    volatile uint32_t    AIM;                  // [Read-write] Interrupt mask register 2
    volatile uint32_t    ASR;                  // [Read-only] Status register
    volatile uint32_t    ACLRFR;               // [Write-only] Clear flag register
    volatile uint32_t    ADR;                  // [Read-write] Data register
    volatile uint32_t    BCR1;                 // [Read-write] Configuration register 1
    volatile uint32_t    BCR2;                 // Configuration register 2
    volatile uint32_t    BFRCR;                // This register has no meaning in AC97 and SPDIF audio protocol
    volatile uint32_t    BSLOTR;               // [Read-write] This register has no meaning in AC97 and SPDIF audio protocol
    volatile uint32_t    BIM;                  // [Read-write] Interrupt mask register 2
    volatile uint32_t    BSR;                  // [Read-only] Status register
    volatile uint32_t    BCLRFR;               // [Write-only] Clear flag register
    volatile uint32_t    BDR;                  // [Read-write] Data register
    volatile uint32_t    PDMCR;                // [Read-write] PDM control register
    volatile uint32_t    PDMDLY;               // [Read-write] PDM delay register

    template<uint32_t X>
    static constexpr uint32_t GCR_SYNCOUT =             // Synchronization outputs These bits are set and cleared by software. (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GCR_SYNCIN =              // Synchronization inputs (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t GCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ACR1_MODE =                // SAIx audio block mode immediately (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ACR1_PRTCFG =              // Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ACR1_DS =                  // Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled. (3 bits)
        bit_field_t<5, 0x7>::value<X>();
    static constexpr uint32_t ACR1_LSBFIRST = 0x100;     // Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first.
    static constexpr uint32_t ACR1_CKSTR = 0x200;        // Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol.
    template<uint32_t X>
    static constexpr uint32_t ACR1_SYNCEN =              // Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: The audio sub-block should be configured as asynchronous when SPDIF mode is enabled. (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    static constexpr uint32_t ACR1_MONO = 0x1000;        // Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to Section: Mono/stereo mode for more details.
    static constexpr uint32_t ACR1_OUTDRIV = 0x2000;     // Output drive. This bit is set and cleared by software. Note: This bit has to be set before enabling the audio block and after the audio block configuration.
    static constexpr uint32_t ACR1_SAIXEN = 0x10000;     // Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of SAIx audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: When SAIx block is configured in master mode, the clock must be present on the input of SAIx before setting SAIXEN bit.
    static constexpr uint32_t ACR1_DMAEN = 0x20000;      // DMA enable. This bit is set and cleared by software. Note: Since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode.
    static constexpr uint32_t ACR1_NOMCK = 0x80000;      // No divider
    template<uint32_t X>
    static constexpr uint32_t ACR1_MCKDIV =              // Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula: (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    static constexpr uint32_t ACR1_OSR = 0x4000000;      // Oversampling ratio for master clock
    static const uint32_t ACR1_RESET_VALUE = 0x40;

    template<uint32_t X>
    static constexpr uint32_t ACR2_FTH =                 // FIFO threshold. This bit is set and cleared by software. (3 bits), Read-write
        bit_field_t<0, 0x7>::value<X>();
    static constexpr uint32_t ACR2_FFLUSH = 0x8;         // FIFO flush. This bit is set by software. It is always read as 0. This bit should be configured when the SAI is disabled., Write-only
    static constexpr uint32_t ACR2_TRIS = 0x10;          // Tristate management on data line. This bit is set and cleared by software. It is meaningful only if the audio block is configured as a transmitter. This bit is not used when the audio block is configured in SPDIF mode. It should be configured when SAI is disabled. Refer to Section: Output data line management on an inactive slot for more details., Read-write
    static constexpr uint32_t ACR2_MUTE = 0x20;          // Mute. This bit is set and cleared by software. It is meaningful only when the audio block operates as a transmitter. The MUTE value is linked to value of MUTEVAL if the number of slots is lower or equal to 2, or equal to 0 if it is greater than 2. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks., Read-write
    static constexpr uint32_t ACR2_MUTEVAL = 0x40;       // Mute value. This bit is set and cleared by software.It must be written before enabling the audio block: SAIXEN. This bit is meaningful only when the audio block operates as a transmitter, the number of slots is lower or equal to 2 and the MUTE bit is set. If more slots are declared, the bit value sent during the transmission in mute mode is equal to 0, whatever the value of MUTEVAL. if the number of slot is lower or equal to 2 and MUTEVAL = 1, the MUTE value transmitted for each slot is the one sent during the previous frame. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks., Read-write
    template<uint32_t X>
    static constexpr uint32_t ACR2_MUTECNT =             // Mute counter. These bits are set and cleared by software. They are used only in reception mode. The value set in these bits is compared to the number of consecutive mute frames detected in reception. When the number of mute frames is equal to this value, the flag MUTEDET will be set and an interrupt will be generated if bit MUTEDETIE is set. Refer to Section: Mute mode for more details. (6 bits), Read-write
        bit_field_t<7, 0x3f>::value<X>();
    static constexpr uint32_t ACR2_CPL = 0x2000;         // Complement bit. This bit is set and cleared by software. It defines the type of complement to be used for companding mode Note: This bit has effect only when the companding mode is -Law algorithm or A-Law algorithm., Read-write
    template<uint32_t X>
    static constexpr uint32_t ACR2_COMP =                // Companding mode. These bits are set and cleared by software. The -Law and the A-Law log are a part of the CCITT G.711 recommendation, the type of complement that will be used depends on CPL bit. The data expansion or data compression are determined by the state of bit MODE[0]. The data compression is applied if the audio block is configured as a transmitter. The data expansion is automatically applied when the audio block is configured as a receiver. Refer to Section: Companding mode for more details. Note: Companding mode is applicable only when TDM is selected. (2 bits), Read-write
        bit_field_t<14, 0x3>::value<X>();
    static const uint32_t ACR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRCR_FRL =                 // Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of SAI_xSLOTR register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on MCLK_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. (8 bits), Read-write
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRCR_FSALL =               // Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled. (7 bits), Read-write
        bit_field_t<8, 0x7f>::value<X>();
    static constexpr uint32_t AFRCR_FSDEF = 0x10000;      // Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the SAI_xSLOTR register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or MSB/LSB-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled., Read-only
    static constexpr uint32_t AFRCR_FSPOL = 0x20000;      // Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled., Read-write
    static constexpr uint32_t AFRCR_FSOFF = 0x40000;      // Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled., Read-write
    static const uint32_t AFRCR_RESET_VALUE = 0x7;

    template<uint32_t X>
    static constexpr uint32_t ASLOTR_FBOFF =               // First bit offset These bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ASLOTR_SLOTSZ =              // Slot size This bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to Section: Output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ASLOTR_NBSLOT =              // Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the SAI_xFRCR register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode. (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ASLOTR_SLOTEN =              // Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode. (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t ASLOTR_RESET_VALUE = 0x0;

    static constexpr uint32_t AIM_OVRUDRIE = 0x1;       // Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the SAI_xSR register is set.
    static constexpr uint32_t AIM_MUTEDETIE = 0x2;      // Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the SAI_xSR register is set. This bit has a meaning only if the audio block is configured in receiver mode.
    static constexpr uint32_t AIM_WCKCFGIE = 0x4;       // Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the SAI_xSR register is set. Note: This bit is used only in TDM mode and is meaningless in other modes.
    static constexpr uint32_t AIM_FREQIE = 0x8;         // FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the SAI_xSR register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode,
    static constexpr uint32_t AIM_CNRDYIE = 0x10;       // Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the Codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the SAI_xSR register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver.
    static constexpr uint32_t AIM_AFSDETIE = 0x20;      // Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the SAI_xSR register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
    static constexpr uint32_t AIM_LFSDETIE = 0x40;      // Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the SAI_xSR register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
    static const uint32_t AIM_RESET_VALUE = 0x0;

    static constexpr uint32_t ASR_OVRUDR = 0x1;         // Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in SAI_xIM register. This flag is cleared when the software sets COVRUDR bit in SAI_xCLRFR register.
    static constexpr uint32_t ASR_MUTEDET = 0x2;        // Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the SAI_xCR2 register). It can generate an interrupt if MUTEDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets bit CMUTEDET in the SAI_xCLRFR register.
    static constexpr uint32_t ASR_WCKCFG = 0x4;         // Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in SAI_xIM register. This flag is cleared when the software sets CWCKCFG bit in SAI_xCLRFR register.
    static constexpr uint32_t ASR_FREQ = 0x8;           // FIFO request. This bit is read only. The request depends on the audio block configuration: If the block is configured in transmission mode, the FIFO request is related to a write request operation in the SAI_xDR. If the block configured in reception, the FIFO request related to a read request operation from the SAI_xDR. This flag can generate an interrupt if FREQIE bit is set in SAI_xIM register.
    static constexpr uint32_t ASR_CNRDY = 0x10;         // Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in SAI_xIM register. This flag is cleared when the software sets CCNRDY bit in SAI_xCLRFR register.
    static constexpr uint32_t ASR_AFSDET = 0x20;        // Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets CAFSDET bit in SAI_xCLRFR register.
    static constexpr uint32_t ASR_LFSDET = 0x40;        // Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the SAI_xIM register. This flag is cleared when the software sets bit CLFSDET in SAI_xCLRFR register
    template<uint32_t X>
    static constexpr uint32_t ASR_FLVL =                // FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: If SAI block is configured as receiver: (3 bits)
        bit_field_t<16, 0x7>::value<X>();
    static const uint32_t ASR_RESET_VALUE = 0x8;

    static constexpr uint32_t ACLRFR_COVRUDR = 0x1;        // Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the SAI_xSR register. Reading this bit always returns the value 0.
    static constexpr uint32_t ACLRFR_CMUTEDET = 0x2;       // Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the SAI_xSR register. Reading this bit always returns the value 0.
    static constexpr uint32_t ACLRFR_CWCKCFG = 0x4;        // Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the SAI_xSR register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the SAI_xCR1 register. Reading this bit always returns the value 0.
    static constexpr uint32_t ACLRFR_CCNRDY = 0x10;        // Clear Codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the SAI_xSR register. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register. Reading this bit always returns the value 0.
    static constexpr uint32_t ACLRFR_CAFSDET = 0x20;       // Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the SAI_xSR register. It is not used in AC97or SPDIF mode. Reading this bit always returns the value 0.
    static constexpr uint32_t ACLRFR_CLFSDET = 0x40;       // Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the SAI_xSR register. This bit is not used in AC97or SPDIF mode Reading this bit always returns the value 0.
    static const uint32_t ACLRFR_RESET_VALUE = 0x0;


    static const uint32_t ADR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BCR1_MODE =                // SAIx audio block mode immediately (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BCR1_PRTCFG =              // Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BCR1_DS =                  // Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled. (3 bits)
        bit_field_t<5, 0x7>::value<X>();
    static constexpr uint32_t BCR1_LSBFIRST = 0x100;     // Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first.
    static constexpr uint32_t BCR1_CKSTR = 0x200;        // Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol.
    template<uint32_t X>
    static constexpr uint32_t BCR1_SYNCEN =              // Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: The audio sub-block should be configured as asynchronous when SPDIF mode is enabled. (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    static constexpr uint32_t BCR1_MONO = 0x1000;        // Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to Section: Mono/stereo mode for more details.
    static constexpr uint32_t BCR1_OUTDRIV = 0x2000;     // Output drive. This bit is set and cleared by software. Note: This bit has to be set before enabling the audio block and after the audio block configuration.
    static constexpr uint32_t BCR1_SAIXEN = 0x10000;     // Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of SAIx audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: When SAIx block is configured in master mode, the clock must be present on the input of SAIx before setting SAIXEN bit.
    static constexpr uint32_t BCR1_DMAEN = 0x20000;      // DMA enable. This bit is set and cleared by software. Note: Since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode.
    static constexpr uint32_t BCR1_NOMCK = 0x80000;      // No divider
    template<uint32_t X>
    static constexpr uint32_t BCR1_MCKDIV =              // Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula: (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    static constexpr uint32_t BCR1_OSR = 0x4000000;      // Oversampling ratio for master clock
    static const uint32_t BCR1_RESET_VALUE = 0x40;

    template<uint32_t X>
    static constexpr uint32_t BCR2_FTH =                 // FIFO threshold. This bit is set and cleared by software. (3 bits), Read-write
        bit_field_t<0, 0x7>::value<X>();
    static constexpr uint32_t BCR2_FFLUSH = 0x8;         // FIFO flush. This bit is set by software. It is always read as 0. This bit should be configured when the SAI is disabled., Write-only
    static constexpr uint32_t BCR2_TRIS = 0x10;          // Tristate management on data line. This bit is set and cleared by software. It is meaningful only if the audio block is configured as a transmitter. This bit is not used when the audio block is configured in SPDIF mode. It should be configured when SAI is disabled. Refer to Section: Output data line management on an inactive slot for more details., Read-write
    static constexpr uint32_t BCR2_MUTE = 0x20;          // Mute. This bit is set and cleared by software. It is meaningful only when the audio block operates as a transmitter. The MUTE value is linked to value of MUTEVAL if the number of slots is lower or equal to 2, or equal to 0 if it is greater than 2. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks., Read-write
    static constexpr uint32_t BCR2_MUTEVAL = 0x40;       // Mute value. This bit is set and cleared by software.It must be written before enabling the audio block: SAIXEN. This bit is meaningful only when the audio block operates as a transmitter, the number of slots is lower or equal to 2 and the MUTE bit is set. If more slots are declared, the bit value sent during the transmission in mute mode is equal to 0, whatever the value of MUTEVAL. if the number of slot is lower or equal to 2 and MUTEVAL = 1, the MUTE value transmitted for each slot is the one sent during the previous frame. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks., Read-write
    template<uint32_t X>
    static constexpr uint32_t BCR2_MUTECNT =             // Mute counter. These bits are set and cleared by software. They are used only in reception mode. The value set in these bits is compared to the number of consecutive mute frames detected in reception. When the number of mute frames is equal to this value, the flag MUTEDET will be set and an interrupt will be generated if bit MUTEDETIE is set. Refer to Section: Mute mode for more details. (6 bits), Read-write
        bit_field_t<7, 0x3f>::value<X>();
    static constexpr uint32_t BCR2_CPL = 0x2000;         // Complement bit. This bit is set and cleared by software. It defines the type of complement to be used for companding mode Note: This bit has effect only when the companding mode is -Law algorithm or A-Law algorithm., Read-write
    template<uint32_t X>
    static constexpr uint32_t BCR2_COMP =                // Companding mode. These bits are set and cleared by software. The -Law and the A-Law log are a part of the CCITT G.711 recommendation, the type of complement that will be used depends on CPL bit. The data expansion or data compression are determined by the state of bit MODE[0]. The data compression is applied if the audio block is configured as a transmitter. The data expansion is automatically applied when the audio block is configured as a receiver. Refer to Section: Companding mode for more details. Note: Companding mode is applicable only when TDM is selected. (2 bits), Read-write
        bit_field_t<14, 0x3>::value<X>();
    static const uint32_t BCR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BFRCR_FRL =                 // Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of SAI_xSLOTR register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on MCLK_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. (8 bits), Read-write
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BFRCR_FSALL =               // Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled. (7 bits), Read-write
        bit_field_t<8, 0x7f>::value<X>();
    static constexpr uint32_t BFRCR_FSDEF = 0x10000;      // Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the SAI_xSLOTR register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or MSB/LSB-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled., Read-only
    static constexpr uint32_t BFRCR_FSPOL = 0x20000;      // Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled., Read-write
    static constexpr uint32_t BFRCR_FSOFF = 0x40000;      // Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled., Read-write
    static const uint32_t BFRCR_RESET_VALUE = 0x7;

    template<uint32_t X>
    static constexpr uint32_t BSLOTR_FBOFF =               // First bit offset These bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BSLOTR_SLOTSZ =              // Slot size This bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to Section: Output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BSLOTR_NBSLOT =              // Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the SAI_xFRCR register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode. (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BSLOTR_SLOTEN =              // Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode. (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t BSLOTR_RESET_VALUE = 0x0;

    static constexpr uint32_t BIM_OVRUDRIE = 0x1;       // Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the SAI_xSR register is set.
    static constexpr uint32_t BIM_MUTEDETIE = 0x2;      // Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the SAI_xSR register is set. This bit has a meaning only if the audio block is configured in receiver mode.
    static constexpr uint32_t BIM_WCKCFGIE = 0x4;       // Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the SAI_xSR register is set. Note: This bit is used only in TDM mode and is meaningless in other modes.
    static constexpr uint32_t BIM_FREQIE = 0x8;         // FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the SAI_xSR register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode,
    static constexpr uint32_t BIM_CNRDYIE = 0x10;       // Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the Codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the SAI_xSR register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver.
    static constexpr uint32_t BIM_AFSDETIE = 0x20;      // Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the SAI_xSR register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
    static constexpr uint32_t BIM_LFSDETIE = 0x40;      // Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the SAI_xSR register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
    static const uint32_t BIM_RESET_VALUE = 0x0;

    static constexpr uint32_t BSR_OVRUDR = 0x1;         // Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in SAI_xIM register. This flag is cleared when the software sets COVRUDR bit in SAI_xCLRFR register.
    static constexpr uint32_t BSR_MUTEDET = 0x2;        // Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the SAI_xCR2 register). It can generate an interrupt if MUTEDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets bit CMUTEDET in the SAI_xCLRFR register.
    static constexpr uint32_t BSR_WCKCFG = 0x4;         // Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in SAI_xIM register. This flag is cleared when the software sets CWCKCFG bit in SAI_xCLRFR register.
    static constexpr uint32_t BSR_FREQ = 0x8;           // FIFO request. This bit is read only. The request depends on the audio block configuration: If the block is configured in transmission mode, the FIFO request is related to a write request operation in the SAI_xDR. If the block configured in reception, the FIFO request related to a read request operation from the SAI_xDR. This flag can generate an interrupt if FREQIE bit is set in SAI_xIM register.
    static constexpr uint32_t BSR_CNRDY = 0x10;         // Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in SAI_xIM register. This flag is cleared when the software sets CCNRDY bit in SAI_xCLRFR register.
    static constexpr uint32_t BSR_AFSDET = 0x20;        // Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets CAFSDET bit in SAI_xCLRFR register.
    static constexpr uint32_t BSR_LFSDET = 0x40;        // Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the SAI_xIM register. This flag is cleared when the software sets bit CLFSDET in SAI_xCLRFR register
    template<uint32_t X>
    static constexpr uint32_t BSR_FLVL =                // FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: If SAI block is configured as receiver: (3 bits)
        bit_field_t<16, 0x7>::value<X>();
    static const uint32_t BSR_RESET_VALUE = 0x8;

    static constexpr uint32_t BCLRFR_COVRUDR = 0x1;        // Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the SAI_xSR register. Reading this bit always returns the value 0.
    static constexpr uint32_t BCLRFR_CMUTEDET = 0x2;       // Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the SAI_xSR register. Reading this bit always returns the value 0.
    static constexpr uint32_t BCLRFR_CWCKCFG = 0x4;        // Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the SAI_xSR register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the SAI_xCR1 register. Reading this bit always returns the value 0.
    static constexpr uint32_t BCLRFR_CCNRDY = 0x10;        // Clear Codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the SAI_xSR register. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register. Reading this bit always returns the value 0.
    static constexpr uint32_t BCLRFR_CAFSDET = 0x20;       // Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the SAI_xSR register. It is not used in AC97or SPDIF mode. Reading this bit always returns the value 0.
    static constexpr uint32_t BCLRFR_CLFSDET = 0x40;       // Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the SAI_xSR register. This bit is not used in AC97or SPDIF mode Reading this bit always returns the value 0.
    static const uint32_t BCLRFR_RESET_VALUE = 0x0;


    static const uint32_t BDR_RESET_VALUE = 0x0;

    static constexpr uint32_t PDMCR_PDMEN = 0x1;          // PDM enable
    template<uint32_t X>
    static constexpr uint32_t PDMCR_MICNBR =              // Number of microphones (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static constexpr uint32_t PDMCR_CKEN1 = 0x100;        // Clock enable of bitstream clock number 1
    static constexpr uint32_t PDMCR_CKEN2 = 0x200;        // Clock enable of bitstream clock number 2
    static constexpr uint32_t PDMCR_CKEN3 = 0x400;        // Clock enable of bitstream clock number 3
    static constexpr uint32_t PDMCR_CKEN4 = 0x800;        // Clock enable of bitstream clock number 4
    static const uint32_t PDMCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PDMDLY_DLYM1L =              // Delay line adjust for first microphone of pair 1 (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PDMDLY_DLYM1R =              // Delay line adjust for second microphone of pair 1 (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PDMDLY_DLYM2L =              // Delay line for first microphone of pair 2 (3 bits)
        bit_field_t<8, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PDMDLY_DLYM2R =              // Delay line for second microphone of pair 2 (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PDMDLY_DLYM3L =              // Delay line for first microphone of pair 3 (3 bits)
        bit_field_t<16, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PDMDLY_DLYM3R =              // Delay line for second microphone of pair 3 (3 bits)
        bit_field_t<20, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PDMDLY_DLYM4L =              // Delay line for first microphone of pair 4 (3 bits)
        bit_field_t<24, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PDMDLY_DLYM4R =              // Delay line for second microphone of pair 4 (3 bits)
        bit_field_t<28, 0x7>::value<X>();
    static const uint32_t PDMDLY_RESET_VALUE = 0x0;

    static constexpr uint8_t SAI4 = 146; // SAI4 global interrupt
};

static sai4_t& SAI4 = *reinterpret_cast<sai4_t*>(0x58005400);

#define HAVE_PERIPHERAL_SAI4


////
//
//    SAI
//
////

struct sai1_t
{
    volatile uint32_t    GCR;                  // [Read-write] Global configuration register
    volatile uint32_t    ACR1;                 // [Read-write] Configuration register 1
    volatile uint32_t    ACR2;                 // Configuration register 2
    volatile uint32_t    AFRCR;                // This register has no meaning in AC97 and SPDIF audio protocol
    volatile uint32_t    ASLOTR;               // [Read-write] This register has no meaning in AC97 and SPDIF audio protocol
    volatile uint32_t    AIM;                  // [Read-write] Interrupt mask register 2
    volatile uint32_t    ASR;                  // [Read-only] Status register
    volatile uint32_t    ACLRFR;               // [Write-only] Clear flag register
    volatile uint32_t    ADR;                  // [Read-write] Data register
    volatile uint32_t    BCR1;                 // [Read-write] Configuration register 1
    volatile uint32_t    BCR2;                 // Configuration register 2
    volatile uint32_t    BFRCR;                // This register has no meaning in AC97 and SPDIF audio protocol
    volatile uint32_t    BSLOTR;               // [Read-write] This register has no meaning in AC97 and SPDIF audio protocol
    volatile uint32_t    BIM;                  // [Read-write] Interrupt mask register 2
    volatile uint32_t    BSR;                  // [Read-only] Status register
    volatile uint32_t    BCLRFR;               // [Write-only] Clear flag register
    volatile uint32_t    BDR;                  // [Read-write] Data register
    volatile uint32_t    PDMCR;                // [Read-write] PDM control register
    volatile uint32_t    PDMDLY;               // [Read-write] PDM delay register

    template<uint32_t X>
    static constexpr uint32_t GCR_SYNCOUT =             // Synchronization outputs These bits are set and cleared by software. (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GCR_SYNCIN =              // Synchronization inputs (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t GCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ACR1_MODE =                // SAIx audio block mode immediately (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ACR1_PRTCFG =              // Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ACR1_DS =                  // Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled. (3 bits)
        bit_field_t<5, 0x7>::value<X>();
    static constexpr uint32_t ACR1_LSBFIRST = 0x100;     // Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first.
    static constexpr uint32_t ACR1_CKSTR = 0x200;        // Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol.
    template<uint32_t X>
    static constexpr uint32_t ACR1_SYNCEN =              // Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: The audio sub-block should be configured as asynchronous when SPDIF mode is enabled. (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    static constexpr uint32_t ACR1_MONO = 0x1000;        // Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to Section: Mono/stereo mode for more details.
    static constexpr uint32_t ACR1_OUTDRIV = 0x2000;     // Output drive. This bit is set and cleared by software. Note: This bit has to be set before enabling the audio block and after the audio block configuration.
    static constexpr uint32_t ACR1_SAIXEN = 0x10000;     // Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of SAIx audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: When SAIx block is configured in master mode, the clock must be present on the input of SAIx before setting SAIXEN bit.
    static constexpr uint32_t ACR1_DMAEN = 0x20000;      // DMA enable. This bit is set and cleared by software. Note: Since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode.
    static constexpr uint32_t ACR1_NOMCK = 0x80000;      // No divider
    template<uint32_t X>
    static constexpr uint32_t ACR1_MCKDIV =              // Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula: (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    static constexpr uint32_t ACR1_OSR = 0x4000000;      // Oversampling ratio for master clock
    static const uint32_t ACR1_RESET_VALUE = 0x40;

    template<uint32_t X>
    static constexpr uint32_t ACR2_FTH =                 // FIFO threshold. This bit is set and cleared by software. (3 bits), Read-write
        bit_field_t<0, 0x7>::value<X>();
    static constexpr uint32_t ACR2_FFLUSH = 0x8;         // FIFO flush. This bit is set by software. It is always read as 0. This bit should be configured when the SAI is disabled., Write-only
    static constexpr uint32_t ACR2_TRIS = 0x10;          // Tristate management on data line. This bit is set and cleared by software. It is meaningful only if the audio block is configured as a transmitter. This bit is not used when the audio block is configured in SPDIF mode. It should be configured when SAI is disabled. Refer to Section: Output data line management on an inactive slot for more details., Read-write
    static constexpr uint32_t ACR2_MUTE = 0x20;          // Mute. This bit is set and cleared by software. It is meaningful only when the audio block operates as a transmitter. The MUTE value is linked to value of MUTEVAL if the number of slots is lower or equal to 2, or equal to 0 if it is greater than 2. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks., Read-write
    static constexpr uint32_t ACR2_MUTEVAL = 0x40;       // Mute value. This bit is set and cleared by software.It must be written before enabling the audio block: SAIXEN. This bit is meaningful only when the audio block operates as a transmitter, the number of slots is lower or equal to 2 and the MUTE bit is set. If more slots are declared, the bit value sent during the transmission in mute mode is equal to 0, whatever the value of MUTEVAL. if the number of slot is lower or equal to 2 and MUTEVAL = 1, the MUTE value transmitted for each slot is the one sent during the previous frame. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks., Read-write
    template<uint32_t X>
    static constexpr uint32_t ACR2_MUTECNT =             // Mute counter. These bits are set and cleared by software. They are used only in reception mode. The value set in these bits is compared to the number of consecutive mute frames detected in reception. When the number of mute frames is equal to this value, the flag MUTEDET will be set and an interrupt will be generated if bit MUTEDETIE is set. Refer to Section: Mute mode for more details. (6 bits), Read-write
        bit_field_t<7, 0x3f>::value<X>();
    static constexpr uint32_t ACR2_CPL = 0x2000;         // Complement bit. This bit is set and cleared by software. It defines the type of complement to be used for companding mode Note: This bit has effect only when the companding mode is -Law algorithm or A-Law algorithm., Read-write
    template<uint32_t X>
    static constexpr uint32_t ACR2_COMP =                // Companding mode. These bits are set and cleared by software. The -Law and the A-Law log are a part of the CCITT G.711 recommendation, the type of complement that will be used depends on CPL bit. The data expansion or data compression are determined by the state of bit MODE[0]. The data compression is applied if the audio block is configured as a transmitter. The data expansion is automatically applied when the audio block is configured as a receiver. Refer to Section: Companding mode for more details. Note: Companding mode is applicable only when TDM is selected. (2 bits), Read-write
        bit_field_t<14, 0x3>::value<X>();
    static const uint32_t ACR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRCR_FRL =                 // Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of SAI_xSLOTR register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on MCLK_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. (8 bits), Read-write
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRCR_FSALL =               // Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled. (7 bits), Read-write
        bit_field_t<8, 0x7f>::value<X>();
    static constexpr uint32_t AFRCR_FSDEF = 0x10000;      // Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the SAI_xSLOTR register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or MSB/LSB-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled., Read-only
    static constexpr uint32_t AFRCR_FSPOL = 0x20000;      // Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled., Read-write
    static constexpr uint32_t AFRCR_FSOFF = 0x40000;      // Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled., Read-write
    static const uint32_t AFRCR_RESET_VALUE = 0x7;

    template<uint32_t X>
    static constexpr uint32_t ASLOTR_FBOFF =               // First bit offset These bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ASLOTR_SLOTSZ =              // Slot size This bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to Section: Output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ASLOTR_NBSLOT =              // Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the SAI_xFRCR register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode. (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ASLOTR_SLOTEN =              // Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode. (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t ASLOTR_RESET_VALUE = 0x0;

    static constexpr uint32_t AIM_OVRUDRIE = 0x1;       // Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the SAI_xSR register is set.
    static constexpr uint32_t AIM_MUTEDETIE = 0x2;      // Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the SAI_xSR register is set. This bit has a meaning only if the audio block is configured in receiver mode.
    static constexpr uint32_t AIM_WCKCFGIE = 0x4;       // Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the SAI_xSR register is set. Note: This bit is used only in TDM mode and is meaningless in other modes.
    static constexpr uint32_t AIM_FREQIE = 0x8;         // FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the SAI_xSR register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode,
    static constexpr uint32_t AIM_CNRDYIE = 0x10;       // Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the Codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the SAI_xSR register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver.
    static constexpr uint32_t AIM_AFSDETIE = 0x20;      // Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the SAI_xSR register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
    static constexpr uint32_t AIM_LFSDETIE = 0x40;      // Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the SAI_xSR register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
    static const uint32_t AIM_RESET_VALUE = 0x0;

    static constexpr uint32_t ASR_OVRUDR = 0x1;         // Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in SAI_xIM register. This flag is cleared when the software sets COVRUDR bit in SAI_xCLRFR register.
    static constexpr uint32_t ASR_MUTEDET = 0x2;        // Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the SAI_xCR2 register). It can generate an interrupt if MUTEDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets bit CMUTEDET in the SAI_xCLRFR register.
    static constexpr uint32_t ASR_WCKCFG = 0x4;         // Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in SAI_xIM register. This flag is cleared when the software sets CWCKCFG bit in SAI_xCLRFR register.
    static constexpr uint32_t ASR_FREQ = 0x8;           // FIFO request. This bit is read only. The request depends on the audio block configuration: If the block is configured in transmission mode, the FIFO request is related to a write request operation in the SAI_xDR. If the block configured in reception, the FIFO request related to a read request operation from the SAI_xDR. This flag can generate an interrupt if FREQIE bit is set in SAI_xIM register.
    static constexpr uint32_t ASR_CNRDY = 0x10;         // Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in SAI_xIM register. This flag is cleared when the software sets CCNRDY bit in SAI_xCLRFR register.
    static constexpr uint32_t ASR_AFSDET = 0x20;        // Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets CAFSDET bit in SAI_xCLRFR register.
    static constexpr uint32_t ASR_LFSDET = 0x40;        // Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the SAI_xIM register. This flag is cleared when the software sets bit CLFSDET in SAI_xCLRFR register
    template<uint32_t X>
    static constexpr uint32_t ASR_FLVL =                // FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: If SAI block is configured as receiver: (3 bits)
        bit_field_t<16, 0x7>::value<X>();
    static const uint32_t ASR_RESET_VALUE = 0x8;

    static constexpr uint32_t ACLRFR_COVRUDR = 0x1;        // Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the SAI_xSR register. Reading this bit always returns the value 0.
    static constexpr uint32_t ACLRFR_CMUTEDET = 0x2;       // Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the SAI_xSR register. Reading this bit always returns the value 0.
    static constexpr uint32_t ACLRFR_CWCKCFG = 0x4;        // Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the SAI_xSR register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the SAI_xCR1 register. Reading this bit always returns the value 0.
    static constexpr uint32_t ACLRFR_CCNRDY = 0x10;        // Clear Codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the SAI_xSR register. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register. Reading this bit always returns the value 0.
    static constexpr uint32_t ACLRFR_CAFSDET = 0x20;       // Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the SAI_xSR register. It is not used in AC97or SPDIF mode. Reading this bit always returns the value 0.
    static constexpr uint32_t ACLRFR_CLFSDET = 0x40;       // Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the SAI_xSR register. This bit is not used in AC97or SPDIF mode Reading this bit always returns the value 0.
    static const uint32_t ACLRFR_RESET_VALUE = 0x0;


    static const uint32_t ADR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BCR1_MODE =                // SAIx audio block mode immediately (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BCR1_PRTCFG =              // Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BCR1_DS =                  // Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled. (3 bits)
        bit_field_t<5, 0x7>::value<X>();
    static constexpr uint32_t BCR1_LSBFIRST = 0x100;     // Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first.
    static constexpr uint32_t BCR1_CKSTR = 0x200;        // Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol.
    template<uint32_t X>
    static constexpr uint32_t BCR1_SYNCEN =              // Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: The audio sub-block should be configured as asynchronous when SPDIF mode is enabled. (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    static constexpr uint32_t BCR1_MONO = 0x1000;        // Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to Section: Mono/stereo mode for more details.
    static constexpr uint32_t BCR1_OUTDRIV = 0x2000;     // Output drive. This bit is set and cleared by software. Note: This bit has to be set before enabling the audio block and after the audio block configuration.
    static constexpr uint32_t BCR1_SAIXEN = 0x10000;     // Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of SAIx audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: When SAIx block is configured in master mode, the clock must be present on the input of SAIx before setting SAIXEN bit.
    static constexpr uint32_t BCR1_DMAEN = 0x20000;      // DMA enable. This bit is set and cleared by software. Note: Since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode.
    static constexpr uint32_t BCR1_NOMCK = 0x80000;      // No divider
    template<uint32_t X>
    static constexpr uint32_t BCR1_MCKDIV =              // Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula: (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    static constexpr uint32_t BCR1_OSR = 0x4000000;      // Oversampling ratio for master clock
    static const uint32_t BCR1_RESET_VALUE = 0x40;

    template<uint32_t X>
    static constexpr uint32_t BCR2_FTH =                 // FIFO threshold. This bit is set and cleared by software. (3 bits), Read-write
        bit_field_t<0, 0x7>::value<X>();
    static constexpr uint32_t BCR2_FFLUSH = 0x8;         // FIFO flush. This bit is set by software. It is always read as 0. This bit should be configured when the SAI is disabled., Write-only
    static constexpr uint32_t BCR2_TRIS = 0x10;          // Tristate management on data line. This bit is set and cleared by software. It is meaningful only if the audio block is configured as a transmitter. This bit is not used when the audio block is configured in SPDIF mode. It should be configured when SAI is disabled. Refer to Section: Output data line management on an inactive slot for more details., Read-write
    static constexpr uint32_t BCR2_MUTE = 0x20;          // Mute. This bit is set and cleared by software. It is meaningful only when the audio block operates as a transmitter. The MUTE value is linked to value of MUTEVAL if the number of slots is lower or equal to 2, or equal to 0 if it is greater than 2. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks., Read-write
    static constexpr uint32_t BCR2_MUTEVAL = 0x40;       // Mute value. This bit is set and cleared by software.It must be written before enabling the audio block: SAIXEN. This bit is meaningful only when the audio block operates as a transmitter, the number of slots is lower or equal to 2 and the MUTE bit is set. If more slots are declared, the bit value sent during the transmission in mute mode is equal to 0, whatever the value of MUTEVAL. if the number of slot is lower or equal to 2 and MUTEVAL = 1, the MUTE value transmitted for each slot is the one sent during the previous frame. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks., Read-write
    template<uint32_t X>
    static constexpr uint32_t BCR2_MUTECNT =             // Mute counter. These bits are set and cleared by software. They are used only in reception mode. The value set in these bits is compared to the number of consecutive mute frames detected in reception. When the number of mute frames is equal to this value, the flag MUTEDET will be set and an interrupt will be generated if bit MUTEDETIE is set. Refer to Section: Mute mode for more details. (6 bits), Read-write
        bit_field_t<7, 0x3f>::value<X>();
    static constexpr uint32_t BCR2_CPL = 0x2000;         // Complement bit. This bit is set and cleared by software. It defines the type of complement to be used for companding mode Note: This bit has effect only when the companding mode is -Law algorithm or A-Law algorithm., Read-write
    template<uint32_t X>
    static constexpr uint32_t BCR2_COMP =                // Companding mode. These bits are set and cleared by software. The -Law and the A-Law log are a part of the CCITT G.711 recommendation, the type of complement that will be used depends on CPL bit. The data expansion or data compression are determined by the state of bit MODE[0]. The data compression is applied if the audio block is configured as a transmitter. The data expansion is automatically applied when the audio block is configured as a receiver. Refer to Section: Companding mode for more details. Note: Companding mode is applicable only when TDM is selected. (2 bits), Read-write
        bit_field_t<14, 0x3>::value<X>();
    static const uint32_t BCR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BFRCR_FRL =                 // Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of SAI_xSLOTR register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on MCLK_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. (8 bits), Read-write
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BFRCR_FSALL =               // Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled. (7 bits), Read-write
        bit_field_t<8, 0x7f>::value<X>();
    static constexpr uint32_t BFRCR_FSDEF = 0x10000;      // Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the SAI_xSLOTR register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or MSB/LSB-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled., Read-only
    static constexpr uint32_t BFRCR_FSPOL = 0x20000;      // Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled., Read-write
    static constexpr uint32_t BFRCR_FSOFF = 0x40000;      // Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled., Read-write
    static const uint32_t BFRCR_RESET_VALUE = 0x7;

    template<uint32_t X>
    static constexpr uint32_t BSLOTR_FBOFF =               // First bit offset These bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BSLOTR_SLOTSZ =              // Slot size This bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to Section: Output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BSLOTR_NBSLOT =              // Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the SAI_xFRCR register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode. (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BSLOTR_SLOTEN =              // Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode. (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t BSLOTR_RESET_VALUE = 0x0;

    static constexpr uint32_t BIM_OVRUDRIE = 0x1;       // Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the SAI_xSR register is set.
    static constexpr uint32_t BIM_MUTEDETIE = 0x2;      // Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the SAI_xSR register is set. This bit has a meaning only if the audio block is configured in receiver mode.
    static constexpr uint32_t BIM_WCKCFGIE = 0x4;       // Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the SAI_xSR register is set. Note: This bit is used only in TDM mode and is meaningless in other modes.
    static constexpr uint32_t BIM_FREQIE = 0x8;         // FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the SAI_xSR register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode,
    static constexpr uint32_t BIM_CNRDYIE = 0x10;       // Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the Codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the SAI_xSR register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver.
    static constexpr uint32_t BIM_AFSDETIE = 0x20;      // Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the SAI_xSR register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
    static constexpr uint32_t BIM_LFSDETIE = 0x40;      // Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the SAI_xSR register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
    static const uint32_t BIM_RESET_VALUE = 0x0;

    static constexpr uint32_t BSR_OVRUDR = 0x1;         // Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in SAI_xIM register. This flag is cleared when the software sets COVRUDR bit in SAI_xCLRFR register.
    static constexpr uint32_t BSR_MUTEDET = 0x2;        // Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the SAI_xCR2 register). It can generate an interrupt if MUTEDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets bit CMUTEDET in the SAI_xCLRFR register.
    static constexpr uint32_t BSR_WCKCFG = 0x4;         // Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in SAI_xIM register. This flag is cleared when the software sets CWCKCFG bit in SAI_xCLRFR register.
    static constexpr uint32_t BSR_FREQ = 0x8;           // FIFO request. This bit is read only. The request depends on the audio block configuration: If the block is configured in transmission mode, the FIFO request is related to a write request operation in the SAI_xDR. If the block configured in reception, the FIFO request related to a read request operation from the SAI_xDR. This flag can generate an interrupt if FREQIE bit is set in SAI_xIM register.
    static constexpr uint32_t BSR_CNRDY = 0x10;         // Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in SAI_xIM register. This flag is cleared when the software sets CCNRDY bit in SAI_xCLRFR register.
    static constexpr uint32_t BSR_AFSDET = 0x20;        // Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets CAFSDET bit in SAI_xCLRFR register.
    static constexpr uint32_t BSR_LFSDET = 0x40;        // Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the SAI_xIM register. This flag is cleared when the software sets bit CLFSDET in SAI_xCLRFR register
    template<uint32_t X>
    static constexpr uint32_t BSR_FLVL =                // FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: If SAI block is configured as receiver: (3 bits)
        bit_field_t<16, 0x7>::value<X>();
    static const uint32_t BSR_RESET_VALUE = 0x8;

    static constexpr uint32_t BCLRFR_COVRUDR = 0x1;        // Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the SAI_xSR register. Reading this bit always returns the value 0.
    static constexpr uint32_t BCLRFR_CMUTEDET = 0x2;       // Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the SAI_xSR register. Reading this bit always returns the value 0.
    static constexpr uint32_t BCLRFR_CWCKCFG = 0x4;        // Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the SAI_xSR register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the SAI_xCR1 register. Reading this bit always returns the value 0.
    static constexpr uint32_t BCLRFR_CCNRDY = 0x10;        // Clear Codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the SAI_xSR register. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register. Reading this bit always returns the value 0.
    static constexpr uint32_t BCLRFR_CAFSDET = 0x20;       // Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the SAI_xSR register. It is not used in AC97or SPDIF mode. Reading this bit always returns the value 0.
    static constexpr uint32_t BCLRFR_CLFSDET = 0x40;       // Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the SAI_xSR register. This bit is not used in AC97or SPDIF mode Reading this bit always returns the value 0.
    static const uint32_t BCLRFR_RESET_VALUE = 0x0;


    static const uint32_t BDR_RESET_VALUE = 0x0;

    static constexpr uint32_t PDMCR_PDMEN = 0x1;          // PDM enable
    template<uint32_t X>
    static constexpr uint32_t PDMCR_MICNBR =              // Number of microphones (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static constexpr uint32_t PDMCR_CKEN1 = 0x100;        // Clock enable of bitstream clock number 1
    static constexpr uint32_t PDMCR_CKEN2 = 0x200;        // Clock enable of bitstream clock number 2
    static constexpr uint32_t PDMCR_CKEN3 = 0x400;        // Clock enable of bitstream clock number 3
    static constexpr uint32_t PDMCR_CKEN4 = 0x800;        // Clock enable of bitstream clock number 4
    static const uint32_t PDMCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PDMDLY_DLYM1L =              // Delay line adjust for first microphone of pair 1 (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PDMDLY_DLYM1R =              // Delay line adjust for second microphone of pair 1 (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PDMDLY_DLYM2L =              // Delay line for first microphone of pair 2 (3 bits)
        bit_field_t<8, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PDMDLY_DLYM2R =              // Delay line for second microphone of pair 2 (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PDMDLY_DLYM3L =              // Delay line for first microphone of pair 3 (3 bits)
        bit_field_t<16, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PDMDLY_DLYM3R =              // Delay line for second microphone of pair 3 (3 bits)
        bit_field_t<20, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PDMDLY_DLYM4L =              // Delay line for first microphone of pair 4 (3 bits)
        bit_field_t<24, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PDMDLY_DLYM4R =              // Delay line for second microphone of pair 4 (3 bits)
        bit_field_t<28, 0x7>::value<X>();
    static const uint32_t PDMDLY_RESET_VALUE = 0x0;

    static constexpr uint8_t SAI1 = 87; // SAI1 global interrupt
};

static sai1_t& SAI1 = *reinterpret_cast<sai1_t*>(0x40015800);

#define HAVE_PERIPHERAL_SAI1


////
//
//    SAI
//
////

struct sai2_t
{
    volatile uint32_t    GCR;                  // [Read-write] Global configuration register
    volatile uint32_t    ACR1;                 // [Read-write] Configuration register 1
    volatile uint32_t    ACR2;                 // Configuration register 2
    volatile uint32_t    AFRCR;                // This register has no meaning in AC97 and SPDIF audio protocol
    volatile uint32_t    ASLOTR;               // [Read-write] This register has no meaning in AC97 and SPDIF audio protocol
    volatile uint32_t    AIM;                  // [Read-write] Interrupt mask register 2
    volatile uint32_t    ASR;                  // [Read-only] Status register
    volatile uint32_t    ACLRFR;               // [Write-only] Clear flag register
    volatile uint32_t    ADR;                  // [Read-write] Data register
    volatile uint32_t    BCR1;                 // [Read-write] Configuration register 1
    volatile uint32_t    BCR2;                 // Configuration register 2
    volatile uint32_t    BFRCR;                // This register has no meaning in AC97 and SPDIF audio protocol
    volatile uint32_t    BSLOTR;               // [Read-write] This register has no meaning in AC97 and SPDIF audio protocol
    volatile uint32_t    BIM;                  // [Read-write] Interrupt mask register 2
    volatile uint32_t    BSR;                  // [Read-only] Status register
    volatile uint32_t    BCLRFR;               // [Write-only] Clear flag register
    volatile uint32_t    BDR;                  // [Read-write] Data register
    volatile uint32_t    PDMCR;                // [Read-write] PDM control register
    volatile uint32_t    PDMDLY;               // [Read-write] PDM delay register

    template<uint32_t X>
    static constexpr uint32_t GCR_SYNCOUT =             // Synchronization outputs These bits are set and cleared by software. (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GCR_SYNCIN =              // Synchronization inputs (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t GCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ACR1_MODE =                // SAIx audio block mode immediately (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ACR1_PRTCFG =              // Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ACR1_DS =                  // Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled. (3 bits)
        bit_field_t<5, 0x7>::value<X>();
    static constexpr uint32_t ACR1_LSBFIRST = 0x100;     // Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first.
    static constexpr uint32_t ACR1_CKSTR = 0x200;        // Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol.
    template<uint32_t X>
    static constexpr uint32_t ACR1_SYNCEN =              // Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: The audio sub-block should be configured as asynchronous when SPDIF mode is enabled. (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    static constexpr uint32_t ACR1_MONO = 0x1000;        // Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to Section: Mono/stereo mode for more details.
    static constexpr uint32_t ACR1_OUTDRIV = 0x2000;     // Output drive. This bit is set and cleared by software. Note: This bit has to be set before enabling the audio block and after the audio block configuration.
    static constexpr uint32_t ACR1_SAIXEN = 0x10000;     // Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of SAIx audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: When SAIx block is configured in master mode, the clock must be present on the input of SAIx before setting SAIXEN bit.
    static constexpr uint32_t ACR1_DMAEN = 0x20000;      // DMA enable. This bit is set and cleared by software. Note: Since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode.
    static constexpr uint32_t ACR1_NOMCK = 0x80000;      // No divider
    template<uint32_t X>
    static constexpr uint32_t ACR1_MCKDIV =              // Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula: (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    static constexpr uint32_t ACR1_OSR = 0x4000000;      // Oversampling ratio for master clock
    static const uint32_t ACR1_RESET_VALUE = 0x40;

    template<uint32_t X>
    static constexpr uint32_t ACR2_FTH =                 // FIFO threshold. This bit is set and cleared by software. (3 bits), Read-write
        bit_field_t<0, 0x7>::value<X>();
    static constexpr uint32_t ACR2_FFLUSH = 0x8;         // FIFO flush. This bit is set by software. It is always read as 0. This bit should be configured when the SAI is disabled., Write-only
    static constexpr uint32_t ACR2_TRIS = 0x10;          // Tristate management on data line. This bit is set and cleared by software. It is meaningful only if the audio block is configured as a transmitter. This bit is not used when the audio block is configured in SPDIF mode. It should be configured when SAI is disabled. Refer to Section: Output data line management on an inactive slot for more details., Read-write
    static constexpr uint32_t ACR2_MUTE = 0x20;          // Mute. This bit is set and cleared by software. It is meaningful only when the audio block operates as a transmitter. The MUTE value is linked to value of MUTEVAL if the number of slots is lower or equal to 2, or equal to 0 if it is greater than 2. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks., Read-write
    static constexpr uint32_t ACR2_MUTEVAL = 0x40;       // Mute value. This bit is set and cleared by software.It must be written before enabling the audio block: SAIXEN. This bit is meaningful only when the audio block operates as a transmitter, the number of slots is lower or equal to 2 and the MUTE bit is set. If more slots are declared, the bit value sent during the transmission in mute mode is equal to 0, whatever the value of MUTEVAL. if the number of slot is lower or equal to 2 and MUTEVAL = 1, the MUTE value transmitted for each slot is the one sent during the previous frame. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks., Read-write
    template<uint32_t X>
    static constexpr uint32_t ACR2_MUTECNT =             // Mute counter. These bits are set and cleared by software. They are used only in reception mode. The value set in these bits is compared to the number of consecutive mute frames detected in reception. When the number of mute frames is equal to this value, the flag MUTEDET will be set and an interrupt will be generated if bit MUTEDETIE is set. Refer to Section: Mute mode for more details. (6 bits), Read-write
        bit_field_t<7, 0x3f>::value<X>();
    static constexpr uint32_t ACR2_CPL = 0x2000;         // Complement bit. This bit is set and cleared by software. It defines the type of complement to be used for companding mode Note: This bit has effect only when the companding mode is -Law algorithm or A-Law algorithm., Read-write
    template<uint32_t X>
    static constexpr uint32_t ACR2_COMP =                // Companding mode. These bits are set and cleared by software. The -Law and the A-Law log are a part of the CCITT G.711 recommendation, the type of complement that will be used depends on CPL bit. The data expansion or data compression are determined by the state of bit MODE[0]. The data compression is applied if the audio block is configured as a transmitter. The data expansion is automatically applied when the audio block is configured as a receiver. Refer to Section: Companding mode for more details. Note: Companding mode is applicable only when TDM is selected. (2 bits), Read-write
        bit_field_t<14, 0x3>::value<X>();
    static const uint32_t ACR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRCR_FRL =                 // Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of SAI_xSLOTR register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on MCLK_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. (8 bits), Read-write
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRCR_FSALL =               // Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled. (7 bits), Read-write
        bit_field_t<8, 0x7f>::value<X>();
    static constexpr uint32_t AFRCR_FSDEF = 0x10000;      // Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the SAI_xSLOTR register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or MSB/LSB-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled., Read-only
    static constexpr uint32_t AFRCR_FSPOL = 0x20000;      // Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled., Read-write
    static constexpr uint32_t AFRCR_FSOFF = 0x40000;      // Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled., Read-write
    static const uint32_t AFRCR_RESET_VALUE = 0x7;

    template<uint32_t X>
    static constexpr uint32_t ASLOTR_FBOFF =               // First bit offset These bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ASLOTR_SLOTSZ =              // Slot size This bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to Section: Output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ASLOTR_NBSLOT =              // Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the SAI_xFRCR register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode. (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ASLOTR_SLOTEN =              // Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode. (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t ASLOTR_RESET_VALUE = 0x0;

    static constexpr uint32_t AIM_OVRUDRIE = 0x1;       // Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the SAI_xSR register is set.
    static constexpr uint32_t AIM_MUTEDETIE = 0x2;      // Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the SAI_xSR register is set. This bit has a meaning only if the audio block is configured in receiver mode.
    static constexpr uint32_t AIM_WCKCFGIE = 0x4;       // Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the SAI_xSR register is set. Note: This bit is used only in TDM mode and is meaningless in other modes.
    static constexpr uint32_t AIM_FREQIE = 0x8;         // FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the SAI_xSR register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode,
    static constexpr uint32_t AIM_CNRDYIE = 0x10;       // Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the Codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the SAI_xSR register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver.
    static constexpr uint32_t AIM_AFSDETIE = 0x20;      // Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the SAI_xSR register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
    static constexpr uint32_t AIM_LFSDETIE = 0x40;      // Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the SAI_xSR register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
    static const uint32_t AIM_RESET_VALUE = 0x0;

    static constexpr uint32_t ASR_OVRUDR = 0x1;         // Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in SAI_xIM register. This flag is cleared when the software sets COVRUDR bit in SAI_xCLRFR register.
    static constexpr uint32_t ASR_MUTEDET = 0x2;        // Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the SAI_xCR2 register). It can generate an interrupt if MUTEDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets bit CMUTEDET in the SAI_xCLRFR register.
    static constexpr uint32_t ASR_WCKCFG = 0x4;         // Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in SAI_xIM register. This flag is cleared when the software sets CWCKCFG bit in SAI_xCLRFR register.
    static constexpr uint32_t ASR_FREQ = 0x8;           // FIFO request. This bit is read only. The request depends on the audio block configuration: If the block is configured in transmission mode, the FIFO request is related to a write request operation in the SAI_xDR. If the block configured in reception, the FIFO request related to a read request operation from the SAI_xDR. This flag can generate an interrupt if FREQIE bit is set in SAI_xIM register.
    static constexpr uint32_t ASR_CNRDY = 0x10;         // Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in SAI_xIM register. This flag is cleared when the software sets CCNRDY bit in SAI_xCLRFR register.
    static constexpr uint32_t ASR_AFSDET = 0x20;        // Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets CAFSDET bit in SAI_xCLRFR register.
    static constexpr uint32_t ASR_LFSDET = 0x40;        // Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the SAI_xIM register. This flag is cleared when the software sets bit CLFSDET in SAI_xCLRFR register
    template<uint32_t X>
    static constexpr uint32_t ASR_FLVL =                // FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: If SAI block is configured as receiver: (3 bits)
        bit_field_t<16, 0x7>::value<X>();
    static const uint32_t ASR_RESET_VALUE = 0x8;

    static constexpr uint32_t ACLRFR_COVRUDR = 0x1;        // Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the SAI_xSR register. Reading this bit always returns the value 0.
    static constexpr uint32_t ACLRFR_CMUTEDET = 0x2;       // Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the SAI_xSR register. Reading this bit always returns the value 0.
    static constexpr uint32_t ACLRFR_CWCKCFG = 0x4;        // Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the SAI_xSR register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the SAI_xCR1 register. Reading this bit always returns the value 0.
    static constexpr uint32_t ACLRFR_CCNRDY = 0x10;        // Clear Codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the SAI_xSR register. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register. Reading this bit always returns the value 0.
    static constexpr uint32_t ACLRFR_CAFSDET = 0x20;       // Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the SAI_xSR register. It is not used in AC97or SPDIF mode. Reading this bit always returns the value 0.
    static constexpr uint32_t ACLRFR_CLFSDET = 0x40;       // Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the SAI_xSR register. This bit is not used in AC97or SPDIF mode Reading this bit always returns the value 0.
    static const uint32_t ACLRFR_RESET_VALUE = 0x0;


    static const uint32_t ADR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BCR1_MODE =                // SAIx audio block mode immediately (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BCR1_PRTCFG =              // Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BCR1_DS =                  // Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled. (3 bits)
        bit_field_t<5, 0x7>::value<X>();
    static constexpr uint32_t BCR1_LSBFIRST = 0x100;     // Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first.
    static constexpr uint32_t BCR1_CKSTR = 0x200;        // Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol.
    template<uint32_t X>
    static constexpr uint32_t BCR1_SYNCEN =              // Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: The audio sub-block should be configured as asynchronous when SPDIF mode is enabled. (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    static constexpr uint32_t BCR1_MONO = 0x1000;        // Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to Section: Mono/stereo mode for more details.
    static constexpr uint32_t BCR1_OUTDRIV = 0x2000;     // Output drive. This bit is set and cleared by software. Note: This bit has to be set before enabling the audio block and after the audio block configuration.
    static constexpr uint32_t BCR1_SAIXEN = 0x10000;     // Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of SAIx audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: When SAIx block is configured in master mode, the clock must be present on the input of SAIx before setting SAIXEN bit.
    static constexpr uint32_t BCR1_DMAEN = 0x20000;      // DMA enable. This bit is set and cleared by software. Note: Since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode.
    static constexpr uint32_t BCR1_NOMCK = 0x80000;      // No divider
    template<uint32_t X>
    static constexpr uint32_t BCR1_MCKDIV =              // Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula: (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    static constexpr uint32_t BCR1_OSR = 0x4000000;      // Oversampling ratio for master clock
    static const uint32_t BCR1_RESET_VALUE = 0x40;

    template<uint32_t X>
    static constexpr uint32_t BCR2_FTH =                 // FIFO threshold. This bit is set and cleared by software. (3 bits), Read-write
        bit_field_t<0, 0x7>::value<X>();
    static constexpr uint32_t BCR2_FFLUSH = 0x8;         // FIFO flush. This bit is set by software. It is always read as 0. This bit should be configured when the SAI is disabled., Write-only
    static constexpr uint32_t BCR2_TRIS = 0x10;          // Tristate management on data line. This bit is set and cleared by software. It is meaningful only if the audio block is configured as a transmitter. This bit is not used when the audio block is configured in SPDIF mode. It should be configured when SAI is disabled. Refer to Section: Output data line management on an inactive slot for more details., Read-write
    static constexpr uint32_t BCR2_MUTE = 0x20;          // Mute. This bit is set and cleared by software. It is meaningful only when the audio block operates as a transmitter. The MUTE value is linked to value of MUTEVAL if the number of slots is lower or equal to 2, or equal to 0 if it is greater than 2. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks., Read-write
    static constexpr uint32_t BCR2_MUTEVAL = 0x40;       // Mute value. This bit is set and cleared by software.It must be written before enabling the audio block: SAIXEN. This bit is meaningful only when the audio block operates as a transmitter, the number of slots is lower or equal to 2 and the MUTE bit is set. If more slots are declared, the bit value sent during the transmission in mute mode is equal to 0, whatever the value of MUTEVAL. if the number of slot is lower or equal to 2 and MUTEVAL = 1, the MUTE value transmitted for each slot is the one sent during the previous frame. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks., Read-write
    template<uint32_t X>
    static constexpr uint32_t BCR2_MUTECNT =             // Mute counter. These bits are set and cleared by software. They are used only in reception mode. The value set in these bits is compared to the number of consecutive mute frames detected in reception. When the number of mute frames is equal to this value, the flag MUTEDET will be set and an interrupt will be generated if bit MUTEDETIE is set. Refer to Section: Mute mode for more details. (6 bits), Read-write
        bit_field_t<7, 0x3f>::value<X>();
    static constexpr uint32_t BCR2_CPL = 0x2000;         // Complement bit. This bit is set and cleared by software. It defines the type of complement to be used for companding mode Note: This bit has effect only when the companding mode is -Law algorithm or A-Law algorithm., Read-write
    template<uint32_t X>
    static constexpr uint32_t BCR2_COMP =                // Companding mode. These bits are set and cleared by software. The -Law and the A-Law log are a part of the CCITT G.711 recommendation, the type of complement that will be used depends on CPL bit. The data expansion or data compression are determined by the state of bit MODE[0]. The data compression is applied if the audio block is configured as a transmitter. The data expansion is automatically applied when the audio block is configured as a receiver. Refer to Section: Companding mode for more details. Note: Companding mode is applicable only when TDM is selected. (2 bits), Read-write
        bit_field_t<14, 0x3>::value<X>();
    static const uint32_t BCR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BFRCR_FRL =                 // Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of SAI_xSLOTR register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on MCLK_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. (8 bits), Read-write
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BFRCR_FSALL =               // Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled. (7 bits), Read-write
        bit_field_t<8, 0x7f>::value<X>();
    static constexpr uint32_t BFRCR_FSDEF = 0x10000;      // Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the SAI_xSLOTR register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or MSB/LSB-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled., Read-only
    static constexpr uint32_t BFRCR_FSPOL = 0x20000;      // Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled., Read-write
    static constexpr uint32_t BFRCR_FSOFF = 0x40000;      // Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled., Read-write
    static const uint32_t BFRCR_RESET_VALUE = 0x7;

    template<uint32_t X>
    static constexpr uint32_t BSLOTR_FBOFF =               // First bit offset These bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BSLOTR_SLOTSZ =              // Slot size This bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to Section: Output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BSLOTR_NBSLOT =              // Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the SAI_xFRCR register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode. (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BSLOTR_SLOTEN =              // Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode. (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t BSLOTR_RESET_VALUE = 0x0;

    static constexpr uint32_t BIM_OVRUDRIE = 0x1;       // Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the SAI_xSR register is set.
    static constexpr uint32_t BIM_MUTEDETIE = 0x2;      // Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the SAI_xSR register is set. This bit has a meaning only if the audio block is configured in receiver mode.
    static constexpr uint32_t BIM_WCKCFGIE = 0x4;       // Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the SAI_xSR register is set. Note: This bit is used only in TDM mode and is meaningless in other modes.
    static constexpr uint32_t BIM_FREQIE = 0x8;         // FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the SAI_xSR register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode,
    static constexpr uint32_t BIM_CNRDYIE = 0x10;       // Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the Codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the SAI_xSR register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver.
    static constexpr uint32_t BIM_AFSDETIE = 0x20;      // Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the SAI_xSR register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
    static constexpr uint32_t BIM_LFSDETIE = 0x40;      // Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the SAI_xSR register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
    static const uint32_t BIM_RESET_VALUE = 0x0;

    static constexpr uint32_t BSR_OVRUDR = 0x1;         // Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in SAI_xIM register. This flag is cleared when the software sets COVRUDR bit in SAI_xCLRFR register.
    static constexpr uint32_t BSR_MUTEDET = 0x2;        // Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the SAI_xCR2 register). It can generate an interrupt if MUTEDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets bit CMUTEDET in the SAI_xCLRFR register.
    static constexpr uint32_t BSR_WCKCFG = 0x4;         // Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in SAI_xIM register. This flag is cleared when the software sets CWCKCFG bit in SAI_xCLRFR register.
    static constexpr uint32_t BSR_FREQ = 0x8;           // FIFO request. This bit is read only. The request depends on the audio block configuration: If the block is configured in transmission mode, the FIFO request is related to a write request operation in the SAI_xDR. If the block configured in reception, the FIFO request related to a read request operation from the SAI_xDR. This flag can generate an interrupt if FREQIE bit is set in SAI_xIM register.
    static constexpr uint32_t BSR_CNRDY = 0x10;         // Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in SAI_xIM register. This flag is cleared when the software sets CCNRDY bit in SAI_xCLRFR register.
    static constexpr uint32_t BSR_AFSDET = 0x20;        // Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets CAFSDET bit in SAI_xCLRFR register.
    static constexpr uint32_t BSR_LFSDET = 0x40;        // Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the SAI_xIM register. This flag is cleared when the software sets bit CLFSDET in SAI_xCLRFR register
    template<uint32_t X>
    static constexpr uint32_t BSR_FLVL =                // FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: If SAI block is configured as receiver: (3 bits)
        bit_field_t<16, 0x7>::value<X>();
    static const uint32_t BSR_RESET_VALUE = 0x8;

    static constexpr uint32_t BCLRFR_COVRUDR = 0x1;        // Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the SAI_xSR register. Reading this bit always returns the value 0.
    static constexpr uint32_t BCLRFR_CMUTEDET = 0x2;       // Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the SAI_xSR register. Reading this bit always returns the value 0.
    static constexpr uint32_t BCLRFR_CWCKCFG = 0x4;        // Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the SAI_xSR register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the SAI_xCR1 register. Reading this bit always returns the value 0.
    static constexpr uint32_t BCLRFR_CCNRDY = 0x10;        // Clear Codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the SAI_xSR register. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register. Reading this bit always returns the value 0.
    static constexpr uint32_t BCLRFR_CAFSDET = 0x20;       // Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the SAI_xSR register. It is not used in AC97or SPDIF mode. Reading this bit always returns the value 0.
    static constexpr uint32_t BCLRFR_CLFSDET = 0x40;       // Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the SAI_xSR register. This bit is not used in AC97or SPDIF mode Reading this bit always returns the value 0.
    static const uint32_t BCLRFR_RESET_VALUE = 0x0;


    static const uint32_t BDR_RESET_VALUE = 0x0;

    static constexpr uint32_t PDMCR_PDMEN = 0x1;          // PDM enable
    template<uint32_t X>
    static constexpr uint32_t PDMCR_MICNBR =              // Number of microphones (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static constexpr uint32_t PDMCR_CKEN1 = 0x100;        // Clock enable of bitstream clock number 1
    static constexpr uint32_t PDMCR_CKEN2 = 0x200;        // Clock enable of bitstream clock number 2
    static constexpr uint32_t PDMCR_CKEN3 = 0x400;        // Clock enable of bitstream clock number 3
    static constexpr uint32_t PDMCR_CKEN4 = 0x800;        // Clock enable of bitstream clock number 4
    static const uint32_t PDMCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PDMDLY_DLYM1L =              // Delay line adjust for first microphone of pair 1 (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PDMDLY_DLYM1R =              // Delay line adjust for second microphone of pair 1 (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PDMDLY_DLYM2L =              // Delay line for first microphone of pair 2 (3 bits)
        bit_field_t<8, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PDMDLY_DLYM2R =              // Delay line for second microphone of pair 2 (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PDMDLY_DLYM3L =              // Delay line for first microphone of pair 3 (3 bits)
        bit_field_t<16, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PDMDLY_DLYM3R =              // Delay line for second microphone of pair 3 (3 bits)
        bit_field_t<20, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PDMDLY_DLYM4L =              // Delay line for first microphone of pair 4 (3 bits)
        bit_field_t<24, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PDMDLY_DLYM4R =              // Delay line for second microphone of pair 4 (3 bits)
        bit_field_t<28, 0x7>::value<X>();
    static const uint32_t PDMDLY_RESET_VALUE = 0x0;

    static constexpr uint8_t SAI2 = 91; // SAI2 global interrupt
};

static sai2_t& SAI2 = *reinterpret_cast<sai2_t*>(0x40015c00);

#define HAVE_PERIPHERAL_SAI2


////
//
//    SAI
//
////

struct sai3_t
{
    volatile uint32_t    GCR;                  // [Read-write] Global configuration register
    volatile uint32_t    ACR1;                 // [Read-write] Configuration register 1
    volatile uint32_t    ACR2;                 // Configuration register 2
    volatile uint32_t    AFRCR;                // This register has no meaning in AC97 and SPDIF audio protocol
    volatile uint32_t    ASLOTR;               // [Read-write] This register has no meaning in AC97 and SPDIF audio protocol
    volatile uint32_t    AIM;                  // [Read-write] Interrupt mask register 2
    volatile uint32_t    ASR;                  // [Read-only] Status register
    volatile uint32_t    ACLRFR;               // [Write-only] Clear flag register
    volatile uint32_t    ADR;                  // [Read-write] Data register
    volatile uint32_t    BCR1;                 // [Read-write] Configuration register 1
    volatile uint32_t    BCR2;                 // Configuration register 2
    volatile uint32_t    BFRCR;                // This register has no meaning in AC97 and SPDIF audio protocol
    volatile uint32_t    BSLOTR;               // [Read-write] This register has no meaning in AC97 and SPDIF audio protocol
    volatile uint32_t    BIM;                  // [Read-write] Interrupt mask register 2
    volatile uint32_t    BSR;                  // [Read-only] Status register
    volatile uint32_t    BCLRFR;               // [Write-only] Clear flag register
    volatile uint32_t    BDR;                  // [Read-write] Data register
    volatile uint32_t    PDMCR;                // [Read-write] PDM control register
    volatile uint32_t    PDMDLY;               // [Read-write] PDM delay register

    template<uint32_t X>
    static constexpr uint32_t GCR_SYNCOUT =             // Synchronization outputs These bits are set and cleared by software. (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GCR_SYNCIN =              // Synchronization inputs (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t GCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ACR1_MODE =                // SAIx audio block mode immediately (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ACR1_PRTCFG =              // Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ACR1_DS =                  // Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled. (3 bits)
        bit_field_t<5, 0x7>::value<X>();
    static constexpr uint32_t ACR1_LSBFIRST = 0x100;     // Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first.
    static constexpr uint32_t ACR1_CKSTR = 0x200;        // Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol.
    template<uint32_t X>
    static constexpr uint32_t ACR1_SYNCEN =              // Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: The audio sub-block should be configured as asynchronous when SPDIF mode is enabled. (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    static constexpr uint32_t ACR1_MONO = 0x1000;        // Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to Section: Mono/stereo mode for more details.
    static constexpr uint32_t ACR1_OUTDRIV = 0x2000;     // Output drive. This bit is set and cleared by software. Note: This bit has to be set before enabling the audio block and after the audio block configuration.
    static constexpr uint32_t ACR1_SAIXEN = 0x10000;     // Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of SAIx audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: When SAIx block is configured in master mode, the clock must be present on the input of SAIx before setting SAIXEN bit.
    static constexpr uint32_t ACR1_DMAEN = 0x20000;      // DMA enable. This bit is set and cleared by software. Note: Since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode.
    static constexpr uint32_t ACR1_NOMCK = 0x80000;      // No divider
    template<uint32_t X>
    static constexpr uint32_t ACR1_MCKDIV =              // Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula: (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    static constexpr uint32_t ACR1_OSR = 0x4000000;      // Oversampling ratio for master clock
    static const uint32_t ACR1_RESET_VALUE = 0x40;

    template<uint32_t X>
    static constexpr uint32_t ACR2_FTH =                 // FIFO threshold. This bit is set and cleared by software. (3 bits), Read-write
        bit_field_t<0, 0x7>::value<X>();
    static constexpr uint32_t ACR2_FFLUSH = 0x8;         // FIFO flush. This bit is set by software. It is always read as 0. This bit should be configured when the SAI is disabled., Write-only
    static constexpr uint32_t ACR2_TRIS = 0x10;          // Tristate management on data line. This bit is set and cleared by software. It is meaningful only if the audio block is configured as a transmitter. This bit is not used when the audio block is configured in SPDIF mode. It should be configured when SAI is disabled. Refer to Section: Output data line management on an inactive slot for more details., Read-write
    static constexpr uint32_t ACR2_MUTE = 0x20;          // Mute. This bit is set and cleared by software. It is meaningful only when the audio block operates as a transmitter. The MUTE value is linked to value of MUTEVAL if the number of slots is lower or equal to 2, or equal to 0 if it is greater than 2. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks., Read-write
    static constexpr uint32_t ACR2_MUTEVAL = 0x40;       // Mute value. This bit is set and cleared by software.It must be written before enabling the audio block: SAIXEN. This bit is meaningful only when the audio block operates as a transmitter, the number of slots is lower or equal to 2 and the MUTE bit is set. If more slots are declared, the bit value sent during the transmission in mute mode is equal to 0, whatever the value of MUTEVAL. if the number of slot is lower or equal to 2 and MUTEVAL = 1, the MUTE value transmitted for each slot is the one sent during the previous frame. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks., Read-write
    template<uint32_t X>
    static constexpr uint32_t ACR2_MUTECNT =             // Mute counter. These bits are set and cleared by software. They are used only in reception mode. The value set in these bits is compared to the number of consecutive mute frames detected in reception. When the number of mute frames is equal to this value, the flag MUTEDET will be set and an interrupt will be generated if bit MUTEDETIE is set. Refer to Section: Mute mode for more details. (6 bits), Read-write
        bit_field_t<7, 0x3f>::value<X>();
    static constexpr uint32_t ACR2_CPL = 0x2000;         // Complement bit. This bit is set and cleared by software. It defines the type of complement to be used for companding mode Note: This bit has effect only when the companding mode is -Law algorithm or A-Law algorithm., Read-write
    template<uint32_t X>
    static constexpr uint32_t ACR2_COMP =                // Companding mode. These bits are set and cleared by software. The -Law and the A-Law log are a part of the CCITT G.711 recommendation, the type of complement that will be used depends on CPL bit. The data expansion or data compression are determined by the state of bit MODE[0]. The data compression is applied if the audio block is configured as a transmitter. The data expansion is automatically applied when the audio block is configured as a receiver. Refer to Section: Companding mode for more details. Note: Companding mode is applicable only when TDM is selected. (2 bits), Read-write
        bit_field_t<14, 0x3>::value<X>();
    static const uint32_t ACR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRCR_FRL =                 // Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of SAI_xSLOTR register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on MCLK_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. (8 bits), Read-write
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRCR_FSALL =               // Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled. (7 bits), Read-write
        bit_field_t<8, 0x7f>::value<X>();
    static constexpr uint32_t AFRCR_FSDEF = 0x10000;      // Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the SAI_xSLOTR register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or MSB/LSB-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled., Read-only
    static constexpr uint32_t AFRCR_FSPOL = 0x20000;      // Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled., Read-write
    static constexpr uint32_t AFRCR_FSOFF = 0x40000;      // Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled., Read-write
    static const uint32_t AFRCR_RESET_VALUE = 0x7;

    template<uint32_t X>
    static constexpr uint32_t ASLOTR_FBOFF =               // First bit offset These bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ASLOTR_SLOTSZ =              // Slot size This bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to Section: Output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ASLOTR_NBSLOT =              // Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the SAI_xFRCR register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode. (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ASLOTR_SLOTEN =              // Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode. (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t ASLOTR_RESET_VALUE = 0x0;

    static constexpr uint32_t AIM_OVRUDRIE = 0x1;       // Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the SAI_xSR register is set.
    static constexpr uint32_t AIM_MUTEDETIE = 0x2;      // Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the SAI_xSR register is set. This bit has a meaning only if the audio block is configured in receiver mode.
    static constexpr uint32_t AIM_WCKCFGIE = 0x4;       // Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the SAI_xSR register is set. Note: This bit is used only in TDM mode and is meaningless in other modes.
    static constexpr uint32_t AIM_FREQIE = 0x8;         // FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the SAI_xSR register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode,
    static constexpr uint32_t AIM_CNRDYIE = 0x10;       // Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the Codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the SAI_xSR register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver.
    static constexpr uint32_t AIM_AFSDETIE = 0x20;      // Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the SAI_xSR register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
    static constexpr uint32_t AIM_LFSDETIE = 0x40;      // Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the SAI_xSR register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
    static const uint32_t AIM_RESET_VALUE = 0x0;

    static constexpr uint32_t ASR_OVRUDR = 0x1;         // Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in SAI_xIM register. This flag is cleared when the software sets COVRUDR bit in SAI_xCLRFR register.
    static constexpr uint32_t ASR_MUTEDET = 0x2;        // Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the SAI_xCR2 register). It can generate an interrupt if MUTEDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets bit CMUTEDET in the SAI_xCLRFR register.
    static constexpr uint32_t ASR_WCKCFG = 0x4;         // Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in SAI_xIM register. This flag is cleared when the software sets CWCKCFG bit in SAI_xCLRFR register.
    static constexpr uint32_t ASR_FREQ = 0x8;           // FIFO request. This bit is read only. The request depends on the audio block configuration: If the block is configured in transmission mode, the FIFO request is related to a write request operation in the SAI_xDR. If the block configured in reception, the FIFO request related to a read request operation from the SAI_xDR. This flag can generate an interrupt if FREQIE bit is set in SAI_xIM register.
    static constexpr uint32_t ASR_CNRDY = 0x10;         // Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in SAI_xIM register. This flag is cleared when the software sets CCNRDY bit in SAI_xCLRFR register.
    static constexpr uint32_t ASR_AFSDET = 0x20;        // Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets CAFSDET bit in SAI_xCLRFR register.
    static constexpr uint32_t ASR_LFSDET = 0x40;        // Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the SAI_xIM register. This flag is cleared when the software sets bit CLFSDET in SAI_xCLRFR register
    template<uint32_t X>
    static constexpr uint32_t ASR_FLVL =                // FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: If SAI block is configured as receiver: (3 bits)
        bit_field_t<16, 0x7>::value<X>();
    static const uint32_t ASR_RESET_VALUE = 0x8;

    static constexpr uint32_t ACLRFR_COVRUDR = 0x1;        // Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the SAI_xSR register. Reading this bit always returns the value 0.
    static constexpr uint32_t ACLRFR_CMUTEDET = 0x2;       // Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the SAI_xSR register. Reading this bit always returns the value 0.
    static constexpr uint32_t ACLRFR_CWCKCFG = 0x4;        // Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the SAI_xSR register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the SAI_xCR1 register. Reading this bit always returns the value 0.
    static constexpr uint32_t ACLRFR_CCNRDY = 0x10;        // Clear Codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the SAI_xSR register. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register. Reading this bit always returns the value 0.
    static constexpr uint32_t ACLRFR_CAFSDET = 0x20;       // Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the SAI_xSR register. It is not used in AC97or SPDIF mode. Reading this bit always returns the value 0.
    static constexpr uint32_t ACLRFR_CLFSDET = 0x40;       // Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the SAI_xSR register. This bit is not used in AC97or SPDIF mode Reading this bit always returns the value 0.
    static const uint32_t ACLRFR_RESET_VALUE = 0x0;


    static const uint32_t ADR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BCR1_MODE =                // SAIx audio block mode immediately (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BCR1_PRTCFG =              // Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BCR1_DS =                  // Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled. (3 bits)
        bit_field_t<5, 0x7>::value<X>();
    static constexpr uint32_t BCR1_LSBFIRST = 0x100;     // Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first.
    static constexpr uint32_t BCR1_CKSTR = 0x200;        // Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol.
    template<uint32_t X>
    static constexpr uint32_t BCR1_SYNCEN =              // Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: The audio sub-block should be configured as asynchronous when SPDIF mode is enabled. (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    static constexpr uint32_t BCR1_MONO = 0x1000;        // Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to Section: Mono/stereo mode for more details.
    static constexpr uint32_t BCR1_OUTDRIV = 0x2000;     // Output drive. This bit is set and cleared by software. Note: This bit has to be set before enabling the audio block and after the audio block configuration.
    static constexpr uint32_t BCR1_SAIXEN = 0x10000;     // Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of SAIx audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: When SAIx block is configured in master mode, the clock must be present on the input of SAIx before setting SAIXEN bit.
    static constexpr uint32_t BCR1_DMAEN = 0x20000;      // DMA enable. This bit is set and cleared by software. Note: Since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode.
    static constexpr uint32_t BCR1_NOMCK = 0x80000;      // No divider
    template<uint32_t X>
    static constexpr uint32_t BCR1_MCKDIV =              // Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula: (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    static constexpr uint32_t BCR1_OSR = 0x4000000;      // Oversampling ratio for master clock
    static const uint32_t BCR1_RESET_VALUE = 0x40;

    template<uint32_t X>
    static constexpr uint32_t BCR2_FTH =                 // FIFO threshold. This bit is set and cleared by software. (3 bits), Read-write
        bit_field_t<0, 0x7>::value<X>();
    static constexpr uint32_t BCR2_FFLUSH = 0x8;         // FIFO flush. This bit is set by software. It is always read as 0. This bit should be configured when the SAI is disabled., Write-only
    static constexpr uint32_t BCR2_TRIS = 0x10;          // Tristate management on data line. This bit is set and cleared by software. It is meaningful only if the audio block is configured as a transmitter. This bit is not used when the audio block is configured in SPDIF mode. It should be configured when SAI is disabled. Refer to Section: Output data line management on an inactive slot for more details., Read-write
    static constexpr uint32_t BCR2_MUTE = 0x20;          // Mute. This bit is set and cleared by software. It is meaningful only when the audio block operates as a transmitter. The MUTE value is linked to value of MUTEVAL if the number of slots is lower or equal to 2, or equal to 0 if it is greater than 2. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks., Read-write
    static constexpr uint32_t BCR2_MUTEVAL = 0x40;       // Mute value. This bit is set and cleared by software.It must be written before enabling the audio block: SAIXEN. This bit is meaningful only when the audio block operates as a transmitter, the number of slots is lower or equal to 2 and the MUTE bit is set. If more slots are declared, the bit value sent during the transmission in mute mode is equal to 0, whatever the value of MUTEVAL. if the number of slot is lower or equal to 2 and MUTEVAL = 1, the MUTE value transmitted for each slot is the one sent during the previous frame. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks., Read-write
    template<uint32_t X>
    static constexpr uint32_t BCR2_MUTECNT =             // Mute counter. These bits are set and cleared by software. They are used only in reception mode. The value set in these bits is compared to the number of consecutive mute frames detected in reception. When the number of mute frames is equal to this value, the flag MUTEDET will be set and an interrupt will be generated if bit MUTEDETIE is set. Refer to Section: Mute mode for more details. (6 bits), Read-write
        bit_field_t<7, 0x3f>::value<X>();
    static constexpr uint32_t BCR2_CPL = 0x2000;         // Complement bit. This bit is set and cleared by software. It defines the type of complement to be used for companding mode Note: This bit has effect only when the companding mode is -Law algorithm or A-Law algorithm., Read-write
    template<uint32_t X>
    static constexpr uint32_t BCR2_COMP =                // Companding mode. These bits are set and cleared by software. The -Law and the A-Law log are a part of the CCITT G.711 recommendation, the type of complement that will be used depends on CPL bit. The data expansion or data compression are determined by the state of bit MODE[0]. The data compression is applied if the audio block is configured as a transmitter. The data expansion is automatically applied when the audio block is configured as a receiver. Refer to Section: Companding mode for more details. Note: Companding mode is applicable only when TDM is selected. (2 bits), Read-write
        bit_field_t<14, 0x3>::value<X>();
    static const uint32_t BCR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BFRCR_FRL =                 // Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of SAI_xSLOTR register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on MCLK_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. (8 bits), Read-write
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BFRCR_FSALL =               // Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled. (7 bits), Read-write
        bit_field_t<8, 0x7f>::value<X>();
    static constexpr uint32_t BFRCR_FSDEF = 0x10000;      // Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the SAI_xSLOTR register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or MSB/LSB-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled., Read-only
    static constexpr uint32_t BFRCR_FSPOL = 0x20000;      // Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled., Read-write
    static constexpr uint32_t BFRCR_FSOFF = 0x40000;      // Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled., Read-write
    static const uint32_t BFRCR_RESET_VALUE = 0x7;

    template<uint32_t X>
    static constexpr uint32_t BSLOTR_FBOFF =               // First bit offset These bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BSLOTR_SLOTSZ =              // Slot size This bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to Section: Output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BSLOTR_NBSLOT =              // Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the SAI_xFRCR register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode. (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BSLOTR_SLOTEN =              // Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode. (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t BSLOTR_RESET_VALUE = 0x0;

    static constexpr uint32_t BIM_OVRUDRIE = 0x1;       // Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the SAI_xSR register is set.
    static constexpr uint32_t BIM_MUTEDETIE = 0x2;      // Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the SAI_xSR register is set. This bit has a meaning only if the audio block is configured in receiver mode.
    static constexpr uint32_t BIM_WCKCFGIE = 0x4;       // Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the SAI_xSR register is set. Note: This bit is used only in TDM mode and is meaningless in other modes.
    static constexpr uint32_t BIM_FREQIE = 0x8;         // FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the SAI_xSR register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode,
    static constexpr uint32_t BIM_CNRDYIE = 0x10;       // Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the Codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the SAI_xSR register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver.
    static constexpr uint32_t BIM_AFSDETIE = 0x20;      // Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the SAI_xSR register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
    static constexpr uint32_t BIM_LFSDETIE = 0x40;      // Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the SAI_xSR register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
    static const uint32_t BIM_RESET_VALUE = 0x0;

    static constexpr uint32_t BSR_OVRUDR = 0x1;         // Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in SAI_xIM register. This flag is cleared when the software sets COVRUDR bit in SAI_xCLRFR register.
    static constexpr uint32_t BSR_MUTEDET = 0x2;        // Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the SAI_xCR2 register). It can generate an interrupt if MUTEDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets bit CMUTEDET in the SAI_xCLRFR register.
    static constexpr uint32_t BSR_WCKCFG = 0x4;         // Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in SAI_xIM register. This flag is cleared when the software sets CWCKCFG bit in SAI_xCLRFR register.
    static constexpr uint32_t BSR_FREQ = 0x8;           // FIFO request. This bit is read only. The request depends on the audio block configuration: If the block is configured in transmission mode, the FIFO request is related to a write request operation in the SAI_xDR. If the block configured in reception, the FIFO request related to a read request operation from the SAI_xDR. This flag can generate an interrupt if FREQIE bit is set in SAI_xIM register.
    static constexpr uint32_t BSR_CNRDY = 0x10;         // Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in SAI_xIM register. This flag is cleared when the software sets CCNRDY bit in SAI_xCLRFR register.
    static constexpr uint32_t BSR_AFSDET = 0x20;        // Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets CAFSDET bit in SAI_xCLRFR register.
    static constexpr uint32_t BSR_LFSDET = 0x40;        // Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the SAI_xIM register. This flag is cleared when the software sets bit CLFSDET in SAI_xCLRFR register
    template<uint32_t X>
    static constexpr uint32_t BSR_FLVL =                // FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: If SAI block is configured as receiver: (3 bits)
        bit_field_t<16, 0x7>::value<X>();
    static const uint32_t BSR_RESET_VALUE = 0x8;

    static constexpr uint32_t BCLRFR_COVRUDR = 0x1;        // Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the SAI_xSR register. Reading this bit always returns the value 0.
    static constexpr uint32_t BCLRFR_CMUTEDET = 0x2;       // Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the SAI_xSR register. Reading this bit always returns the value 0.
    static constexpr uint32_t BCLRFR_CWCKCFG = 0x4;        // Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the SAI_xSR register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the SAI_xCR1 register. Reading this bit always returns the value 0.
    static constexpr uint32_t BCLRFR_CCNRDY = 0x10;        // Clear Codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the SAI_xSR register. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register. Reading this bit always returns the value 0.
    static constexpr uint32_t BCLRFR_CAFSDET = 0x20;       // Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the SAI_xSR register. It is not used in AC97or SPDIF mode. Reading this bit always returns the value 0.
    static constexpr uint32_t BCLRFR_CLFSDET = 0x40;       // Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the SAI_xSR register. This bit is not used in AC97or SPDIF mode Reading this bit always returns the value 0.
    static const uint32_t BCLRFR_RESET_VALUE = 0x0;


    static const uint32_t BDR_RESET_VALUE = 0x0;

    static constexpr uint32_t PDMCR_PDMEN = 0x1;          // PDM enable
    template<uint32_t X>
    static constexpr uint32_t PDMCR_MICNBR =              // Number of microphones (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static constexpr uint32_t PDMCR_CKEN1 = 0x100;        // Clock enable of bitstream clock number 1
    static constexpr uint32_t PDMCR_CKEN2 = 0x200;        // Clock enable of bitstream clock number 2
    static constexpr uint32_t PDMCR_CKEN3 = 0x400;        // Clock enable of bitstream clock number 3
    static constexpr uint32_t PDMCR_CKEN4 = 0x800;        // Clock enable of bitstream clock number 4
    static const uint32_t PDMCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PDMDLY_DLYM1L =              // Delay line adjust for first microphone of pair 1 (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PDMDLY_DLYM1R =              // Delay line adjust for second microphone of pair 1 (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PDMDLY_DLYM2L =              // Delay line for first microphone of pair 2 (3 bits)
        bit_field_t<8, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PDMDLY_DLYM2R =              // Delay line for second microphone of pair 2 (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PDMDLY_DLYM3L =              // Delay line for first microphone of pair 3 (3 bits)
        bit_field_t<16, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PDMDLY_DLYM3R =              // Delay line for second microphone of pair 3 (3 bits)
        bit_field_t<20, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PDMDLY_DLYM4L =              // Delay line for first microphone of pair 4 (3 bits)
        bit_field_t<24, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PDMDLY_DLYM4R =              // Delay line for second microphone of pair 4 (3 bits)
        bit_field_t<28, 0x7>::value<X>();
    static const uint32_t PDMDLY_RESET_VALUE = 0x0;

    static constexpr uint8_t SAI3 = 114; // SAI3 global interrupt
};

static sai3_t& SAI3 = *reinterpret_cast<sai3_t*>(0x40016000);

#define HAVE_PERIPHERAL_SAI3


////
//
//    SDMMC1
//
////

struct sdmmc1_t
{
    volatile uint32_t    POWER;                // [Read-write] SDMMC power control register
    volatile uint32_t    CLKCR;                // [Read-write] The SDMMC_CLKCR register controls the SDMMC_CK output clock, the SDMMC_RX_CLK receive clock, and the bus width.
    volatile uint32_t    ARGR;                 // [Read-write] The SDMMC_ARGR register contains a 32-bit command argument, which is sent to a card as part of a command message.
    volatile uint32_t    CMDR;                 // [Read-write] The SDMMC_CMDR register contains the command index and command type bits. The command index is sent to a card as part of a command message. The command type bits control the command path state machine (CPSM).
    volatile uint32_t    RESPCMDR;             // [Read-only] SDMMC command response register
    volatile uint32_t    RESP1R;               // [Read-only] The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
    volatile uint32_t    RESP2R;               // [Read-only] The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
    volatile uint32_t    RESP3R;               // [Read-only] The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
    volatile uint32_t    RESP4R;               // [Read-only] The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
    volatile uint32_t    DTIMER;               // [Read-write] The SDMMC_DTIMER register contains the data timeout period, in card bus clock periods. A counter loads the value from the SDMMC_DTIMER register, and starts decrementing when the data path state machine (DPSM) enters the Wait_R or Busy state. If the timer reaches 0 while the DPSM is in either of these states, the timeout status flag is set.
    volatile uint32_t    DLENR;                // [Read-write] The SDMMC_DLENR register contains the number of data bytes to be transferred. The value is loaded into the data counter when data transfer starts.
    volatile uint32_t    DCTRL;                // [Read-write] The SDMMC_DCTRL register control the data path state machine (DPSM).
    volatile uint32_t    DCNTR;                // [Read-only] The SDMMC_DCNTR register loads the value from the data length register (see SDMMC_DLENR) when the DPSM moves from the Idle state to the Wait_R or Wait_S state. As data is transferred, the counter decrements the value until it reaches 0. The DPSM then moves to the Idle state and when there has been no error, the data status end flag (DATAEND) is set.
    volatile uint32_t    STAR;                 // [Read-only] The SDMMC_STAR register is a read-only register. It contains two types of flag:Static flags (bits [29,21,11:0]): these bits remain asserted until they are cleared by writing to the SDMMC interrupt Clear register (see SDMMC_ICR)Dynamic flags (bits [20:12]): these bits change state depending on the state of the underlying logic (for example, FIFO full and empty flags are asserted and de-asserted as data while written to the FIFO)
    volatile uint32_t    ICR;                  // [Read-write] The SDMMC_ICR register is a write-only register. Writing a bit with 1 clears the corresponding bit in the SDMMC_STAR status register.
    volatile uint32_t    MASKR;                // [Read-write] The interrupt mask register determines which status flags generate an interrupt request by setting the corresponding bit to 1.
    volatile uint32_t    ACKTIMER;             // [Read-write] The SDMMC_ACKTIMER register contains the acknowledgment timeout period, in SDMMC_CK bus clock periods. A counter loads the value from the SDMMC_ACKTIMER register, and starts decrementing when the data path state machine (DPSM) enters the Wait_Ack state. If the timer reaches 0 while the DPSM is in this states, the acknowledgment timeout status flag is set.
    reserved_t<3>        _0;
    volatile uint32_t    IDMACTRLR;            // [Read-write] The receive and transmit FIFOs can be read or written as 32-bit wide registers. The FIFOs contain 32 entries on 32 sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO.
    volatile uint32_t    IDMABSIZER;           // [Read-write] The SDMMC_IDMABSIZER register contains the buffers size when in double buffer configuration.
    volatile uint32_t    IDMABASE0R;           // [Read-write] The SDMMC_IDMABASE0R register contains the memory buffer base address in single buffer configuration and the buffer 0 base address in double buffer configuration.
    volatile uint32_t    IDMABASE1R;           // [Read-write] The SDMMC_IDMABASE1R register contains the double buffer configuration second buffer memory base address.
    reserved_t<8>        _1;
    volatile uint32_t    FIFOR;                // [Read-write] The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO.When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
    reserved_t<220>      _2;
    volatile uint32_t    VER;                  // [Read-only] SDMMC IP version register
    volatile uint32_t    ID;                   // [Read-only] SDMMC IP identification register

    template<uint32_t X>
    static constexpr uint32_t POWER_PWRCTRL =             // SDMMC state control bits. These bits can only be written when the SDMMC is not in the power-on state (PWRCTRL?11). These bits are used to define the functional state of the SDMMC signals: Any further write will be ignored, PWRCTRL value will keep 11. (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static constexpr uint32_t POWER_VSWITCH = 0x4;        // Voltage switch sequence start. This bit is used to start the timing critical section of the voltage switch sequence:
    static constexpr uint32_t POWER_VSWITCHEN = 0x8;      // Voltage switch procedure enable. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). This bit is used to stop the SDMMC_CK after the voltage switch command response:
    static constexpr uint32_t POWER_DIRPOL = 0x10;        // Data and command direction signals polarity selection. This bit can only be written when the SDMMC is in the power-off state (PWRCTRL = 00).
    static const uint32_t POWER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CLKCR_CLKDIV =              // Clock divide factor This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). This field defines the divide factor between the input clock (SDMMCCLK) and the output clock (SDMMC_CK): SDMMC_CK frequency = SDMMCCLK / [2 * CLKDIV]. 0xx: etc.. xxx: etc.. (10 bits)
        bit_field_t<0, 0x3ff>::value<X>();
    static constexpr uint32_t CLKCR_PWRSAV = 0x1000;      // Power saving configuration bit This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) For power saving, the SDMMC_CK clock output can be disabled when the bus is idle by setting PWRSAV:
    template<uint32_t X>
    static constexpr uint32_t CLKCR_WIDBUS =              // Wide bus mode enable bit This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t CLKCR_NEGEDGE = 0x10000;    // SDMMC_CK dephasing selection bit for data and Command. This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). When clock division = 1 (CLKDIV = 0), this bit has no effect. Data and Command change on SDMMC_CK falling edge. When clock division &amp;gt;1 (CLKDIV &amp;gt; 0) &amp;amp; DDR = 0: - SDMMC_CK edge occurs on SDMMCCLK rising edge. When clock division &gt;1 (CLKDIV &gt; 0) &amp; DDR = 1: - Data changed on the SDMMCCLK falling edge succeeding a SDMMC_CK edge. - SDMMC_CK edge occurs on SDMMCCLK rising edge. - Data changed on the SDMMC_CK falling edge succeeding a SDMMC_CK edge. - SDMMC_CK edge occurs on SDMMCCLK rising edge.
    static constexpr uint32_t CLKCR_HWFC_EN = 0x20000;    // Hardware flow control enable This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) When Hardware flow control is enabled, the meaning of the TXFIFOE and RXFIFOF flags change, please see SDMMC status register definition in Section56.8.11.
    static constexpr uint32_t CLKCR_DDR = 0x40000;        // Data rate signaling selection This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) DDR rate shall only be selected with 4-bit or 8-bit wide bus mode. (WIDBUS &amp;gt; 00). DDR = 1 has no effect when WIDBUS = 00 (1-bit wide bus). DDR rate shall only be selected with clock division &amp;gt;1. (CLKDIV &amp;gt; 0)
    static constexpr uint32_t CLKCR_BUSSPEED = 0x80000;   // Bus speed mode selection between DS, HS, SDR12, SDR25 and SDR50, DDR50, SDR104. This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0)
    template<uint32_t X>
    static constexpr uint32_t CLKCR_SELCLKRX =            // Receive clock selection. These bits can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    static const uint32_t CLKCR_RESET_VALUE = 0x0;


    static const uint32_t ARGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CMDR_CMDINDEX =            // Command index. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). The command index is sent to the card as part of a command message. (6 bits)
        bit_field_t<0, 0x3f>::value<X>();
    static constexpr uint32_t CMDR_CMDTRANS = 0x40;      // The CPSM treats the command as a data transfer command, stops the interrupt period, and signals DataEnable to the DPSM This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). If this bit is set, the CPSM issues an end of interrupt period and issues DataEnable signal to the DPSM when the command is sent.
    static constexpr uint32_t CMDR_CMDSTOP = 0x80;       // The CPSM treats the command as a Stop Transmission command and signals Abort to the DPSM. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). If this bit is set, the CPSM issues the Abort signal to the DPSM when the command is sent.
    template<uint32_t X>
    static constexpr uint32_t CMDR_WAITRESP =            // Wait for response bits. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). They are used to configure whether the CPSM is to wait for a response, and if yes, which kind of response. (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t CMDR_WAITINT = 0x400;      // CPSM waits for interrupt request. If this bit is set, the CPSM disables command timeout and waits for an card interrupt request (Response). If this bit is cleared in the CPSM Wait state, will cause the abort of the interrupt mode.
    static constexpr uint32_t CMDR_WAITPEND = 0x800;     // CPSM Waits for end of data transfer (CmdPend internal signal) from DPSM. This bit when set, the CPSM waits for the end of data transfer trigger before it starts sending a command. WAITPEND is only taken into account when DTMODE = MMC stream data transfer, WIDBUS = 1-bit wide bus mode, DPSMACT = 1 and DTDIR = from host to card.
    static constexpr uint32_t CMDR_CPSMEN = 0x1000;      // Command path state machine (CPSM) Enable bit This bit is written 1 by firmware, and cleared by hardware when the CPSM enters the Idle state. If this bit is set, the CPSM is enabled. When DTEN = 1, no command will be transfered nor boot procedure will be started. CPSMEN is cleared to 0.
    static constexpr uint32_t CMDR_DTHOLD = 0x2000;      // Hold new data block transmission and reception in the DPSM. If this bit is set, the DPSM will not move from the Wait_S state to the Send state or from the Wait_R state to the Receive state.
    static constexpr uint32_t CMDR_BOOTMODE = 0x4000;    // Select the boot mode procedure to be used. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0)
    static constexpr uint32_t CMDR_BOOTEN = 0x8000;      // Enable boot mode procedure.
    static constexpr uint32_t CMDR_CMDSUSPEND = 0x10000; // The CPSM treats the command as a Suspend or Resume command and signals interrupt period start/end. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). CMDSUSPEND = 1 and CMDTRANS = 0 Suspend command, start interrupt period when response bit BS=0. CMDSUSPEND = 1 and CMDTRANS = 1 Resume command with data, end interrupt period when response bit DF=1.
    static const uint32_t CMDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RESPCMDR_RESPCMD =             // Response command index (6 bits)
        bit_field_t<0, 0x3f>::value<X>();
    static const uint32_t RESPCMDR_RESET_VALUE = 0xa3c5dd01;


    static const uint32_t RESP1R_RESET_VALUE = 0x0;


    static const uint32_t RESP2R_RESET_VALUE = 0x0;


    static const uint32_t RESP3R_RESET_VALUE = 0x0;


    static const uint32_t RESP4R_RESET_VALUE = 0x0;


    static const uint32_t DTIMER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DLENR_DATALENGTH =          // Data length value This register can only be written by firmware when DPSM is inactive (DPSMACT = 0). Number of data bytes to be transferred. When DDR = 1 DATALENGTH is truncated to a multiple of 2. (The last odd byte is not transfered) When DATALENGTH = 0 no data will be transfered, when requested by a CPSMEN and CMDTRANS = 1 also no command will be transfered. DTEN and CPSMEN are cleared to 0. (25 bits)
        bit_field_t<0, 0x1ffffff>::value<X>();
    static const uint32_t DLENR_RESET_VALUE = 0x0;

    static constexpr uint32_t DCTRL_DTEN = 0x1;           // Data transfer enable bit This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). This bit is cleared by Hardware when data transfer completes. This bit shall only be used to transfer data when no associated data transfer command is used, i.e. shall not be used with SD or eMMC cards.
    static constexpr uint32_t DCTRL_DTDIR = 0x2;          // Data transfer direction selection This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
    template<uint32_t X>
    static constexpr uint32_t DCTRL_DTMODE =              // Data transfer mode selection. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DCTRL_DBLOCKSIZE =          // Data block size This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). Define the data block length when the block data transfer mode is selected: When DATALENGTH is not a multiple of DBLOCKSIZE, the transfered data is truncated at a multiple of DBLOCKSIZE. (Any remain data will not be transfered.) When DDR = 1, DBLOCKSIZE = 0000 shall not be used. (No data will be transfered) (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    static constexpr uint32_t DCTRL_RWSTART = 0x100;      // Read wait start. If this bit is set, read wait operation starts.
    static constexpr uint32_t DCTRL_RWSTOP = 0x200;       // Read wait stop This bit is written by firmware and auto cleared by hardware when the DPSM moves from the READ_WAIT state to the WAIT_R or IDLE state.
    static constexpr uint32_t DCTRL_RWMOD = 0x400;        // Read wait mode. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
    static constexpr uint32_t DCTRL_SDIOEN = 0x800;       // SD I/O interrupt enable functions This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). If this bit is set, the DPSM enables the SD I/O card specific interrupt operation.
    static constexpr uint32_t DCTRL_BOOTACKEN = 0x1000;   // Enable the reception of the boot acknowledgment. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
    static constexpr uint32_t DCTRL_FIFORST = 0x2000;     // FIFO reset, will flush any remaining data. This bit can only be written by firmware when IDMAEN= 0 and DPSM is active (DPSMACT = 1). This bit will only take effect when a transfer error or transfer hold occurs.
    static const uint32_t DCTRL_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DCNTR_DATACOUNT =           // Data count value When read, the number of remaining data bytes to be transferred is returned. Write has no effect. (25 bits)
        bit_field_t<0, 0x1ffffff>::value<X>();
    static const uint32_t DCNTR_RESET_VALUE = 0x0;

    static constexpr uint32_t STAR_CCRCFAIL = 0x1;       // Command response received (CRC check failed). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    static constexpr uint32_t STAR_DCRCFAIL = 0x2;       // Data block sent/received (CRC check failed). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    static constexpr uint32_t STAR_CTIMEOUT = 0x4;       // Command response timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. The Command Timeout period has a fixed value of 64 SDMMC_CK clock periods.
    static constexpr uint32_t STAR_DTIMEOUT = 0x8;       // Data timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    static constexpr uint32_t STAR_TXUNDERR = 0x10;      // Transmit FIFO underrun error or IDMA read transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    static constexpr uint32_t STAR_RXOVERR = 0x20;       // Received FIFO overrun error or IDMA write transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    static constexpr uint32_t STAR_CMDREND = 0x40;       // Command response received (CRC check passed, or no CRC). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    static constexpr uint32_t STAR_CMDSENT = 0x80;       // Command sent (no response required). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    static constexpr uint32_t STAR_DATAEND = 0x100;      // Data transfer ended correctly. (data counter, DATACOUNT is zero and no errors occur). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    static constexpr uint32_t STAR_DHOLD = 0x200;        // Data transfer Hold. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    static constexpr uint32_t STAR_DBCKEND = 0x400;      // Data block sent/received. (CRC check passed) and DPSM moves to the READWAIT state. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    static constexpr uint32_t STAR_DABORT = 0x800;       // Data transfer aborted by CMD12. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    static constexpr uint32_t STAR_DPSMACT = 0x1000;     // Data path state machine active, i.e. not in Idle state. This is a hardware status flag only, does not generate an interrupt.
    static constexpr uint32_t STAR_CPSMACT = 0x2000;     // Command path state machine active, i.e. not in Idle state. This is a hardware status flag only, does not generate an interrupt.
    static constexpr uint32_t STAR_TXFIFOHE = 0x4000;    // Transmit FIFO half empty At least half the number of words can be written into the FIFO. This bit is cleared when the FIFO becomes half+1 full.
    static constexpr uint32_t STAR_RXFIFOHF = 0x8000;    // Receive FIFO half full There are at least half the number of words in the FIFO. This bit is cleared when the FIFO becomes half+1 empty.
    static constexpr uint32_t STAR_TXFIFOF = 0x10000;    // Transmit FIFO full This is a hardware status flag only, does not generate an interrupt. This bit is cleared when one FIFO location becomes empty.
    static constexpr uint32_t STAR_RXFIFOF = 0x20000;    // Receive FIFO full This bit is cleared when one FIFO location becomes empty.
    static constexpr uint32_t STAR_TXFIFOE = 0x40000;    // Transmit FIFO empty This bit is cleared when one FIFO location becomes full.
    static constexpr uint32_t STAR_RXFIFOE = 0x80000;    // Receive FIFO empty This is a hardware status flag only, does not generate an interrupt. This bit is cleared when one FIFO location becomes full.
    static constexpr uint32_t STAR_BUSYD0 = 0x100000;    // Inverted value of SDMMC_D0 line (Busy), sampled at the end of a CMD response and a second time 2 SDMMC_CK cycles after the CMD response. This bit is reset to not busy when the SDMMCD0 line changes from busy to not busy. This bit does not signal busy due to data transfer. This is a hardware status flag only, it does not generate an interrupt.
    static constexpr uint32_t STAR_BUSYD0END = 0x200000; // end of SDMMC_D0 Busy following a CMD response detected. This indicates only end of busy following a CMD response. This bit does not signal busy due to data transfer. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    static constexpr uint32_t STAR_SDIOIT = 0x400000;    // SDIO interrupt received. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    static constexpr uint32_t STAR_ACKFAIL = 0x800000;   // Boot acknowledgment received (boot acknowledgment check fail). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    static constexpr uint32_t STAR_ACKTIMEOUT = 0x1000000;// Boot acknowledgment timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    static constexpr uint32_t STAR_VSWEND = 0x2000000;   // Voltage switch critical timing section completion. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    static constexpr uint32_t STAR_CKSTOP = 0x4000000;   // SDMMC_CK stopped in Voltage switch procedure. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    static constexpr uint32_t STAR_IDMATE = 0x8000000;   // IDMA transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    static constexpr uint32_t STAR_IDMABTC = 0x10000000; // IDMA buffer transfer complete. interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    static const uint32_t STAR_RESET_VALUE = 0x0;

    static constexpr uint32_t ICR_CCRCFAILC = 0x1;      // CCRCFAIL flag clear bit Set by software to clear the CCRCFAIL flag.
    static constexpr uint32_t ICR_DCRCFAILC = 0x2;      // DCRCFAIL flag clear bit Set by software to clear the DCRCFAIL flag.
    static constexpr uint32_t ICR_CTIMEOUTC = 0x4;      // CTIMEOUT flag clear bit Set by software to clear the CTIMEOUT flag.
    static constexpr uint32_t ICR_DTIMEOUTC = 0x8;      // DTIMEOUT flag clear bit Set by software to clear the DTIMEOUT flag.
    static constexpr uint32_t ICR_TXUNDERRC = 0x10;     // TXUNDERR flag clear bit Set by software to clear TXUNDERR flag.
    static constexpr uint32_t ICR_RXOVERRC = 0x20;      // RXOVERR flag clear bit Set by software to clear the RXOVERR flag.
    static constexpr uint32_t ICR_CMDRENDC = 0x40;      // CMDREND flag clear bit Set by software to clear the CMDREND flag.
    static constexpr uint32_t ICR_CMDSENTC = 0x80;      // CMDSENT flag clear bit Set by software to clear the CMDSENT flag.
    static constexpr uint32_t ICR_DATAENDC = 0x100;     // DATAEND flag clear bit Set by software to clear the DATAEND flag.
    static constexpr uint32_t ICR_DHOLDC = 0x200;       // DHOLD flag clear bit Set by software to clear the DHOLD flag.
    static constexpr uint32_t ICR_DBCKENDC = 0x400;     // DBCKEND flag clear bit Set by software to clear the DBCKEND flag.
    static constexpr uint32_t ICR_DABORTC = 0x800;      // DABORT flag clear bit Set by software to clear the DABORT flag.
    static constexpr uint32_t ICR_BUSYD0ENDC = 0x200000;// BUSYD0END flag clear bit Set by software to clear the BUSYD0END flag.
    static constexpr uint32_t ICR_SDIOITC = 0x400000;   // SDIOIT flag clear bit Set by software to clear the SDIOIT flag.
    static constexpr uint32_t ICR_ACKFAILC = 0x800000;  // ACKFAIL flag clear bit Set by software to clear the ACKFAIL flag.
    static constexpr uint32_t ICR_ACKTIMEOUTC = 0x1000000;// ACKTIMEOUT flag clear bit Set by software to clear the ACKTIMEOUT flag.
    static constexpr uint32_t ICR_VSWENDC = 0x2000000;  // VSWEND flag clear bit Set by software to clear the VSWEND flag.
    static constexpr uint32_t ICR_CKSTOPC = 0x4000000;  // CKSTOP flag clear bit Set by software to clear the CKSTOP flag.
    static constexpr uint32_t ICR_IDMATEC = 0x8000000;  // IDMA transfer error clear bit Set by software to clear the IDMATE flag.
    static constexpr uint32_t ICR_IDMABTCC = 0x10000000;// IDMA buffer transfer complete clear bit Set by software to clear the IDMABTC flag.
    static const uint32_t ICR_RESET_VALUE = 0x0;

    static constexpr uint32_t MASKR_CCRCFAILIE = 0x1;     // Command CRC fail interrupt enable Set and cleared by software to enable/disable interrupt caused by command CRC failure.
    static constexpr uint32_t MASKR_DCRCFAILIE = 0x2;     // Data CRC fail interrupt enable Set and cleared by software to enable/disable interrupt caused by data CRC failure.
    static constexpr uint32_t MASKR_CTIMEOUTIE = 0x4;     // Command timeout interrupt enable Set and cleared by software to enable/disable interrupt caused by command timeout.
    static constexpr uint32_t MASKR_DTIMEOUTIE = 0x8;     // Data timeout interrupt enable Set and cleared by software to enable/disable interrupt caused by data timeout.
    static constexpr uint32_t MASKR_TXUNDERRIE = 0x10;    // Tx FIFO underrun error interrupt enable Set and cleared by software to enable/disable interrupt caused by Tx FIFO underrun error.
    static constexpr uint32_t MASKR_RXOVERRIE = 0x20;     // Rx FIFO overrun error interrupt enable Set and cleared by software to enable/disable interrupt caused by Rx FIFO overrun error.
    static constexpr uint32_t MASKR_CMDRENDIE = 0x40;     // Command response received interrupt enable Set and cleared by software to enable/disable interrupt caused by receiving command response.
    static constexpr uint32_t MASKR_CMDSENTIE = 0x80;     // Command sent interrupt enable Set and cleared by software to enable/disable interrupt caused by sending command.
    static constexpr uint32_t MASKR_DATAENDIE = 0x100;    // Data end interrupt enable Set and cleared by software to enable/disable interrupt caused by data end.
    static constexpr uint32_t MASKR_DHOLDIE = 0x200;      // Data hold interrupt enable Set and cleared by software to enable/disable the interrupt generated when sending new data is hold in the DPSM Wait_S state.
    static constexpr uint32_t MASKR_DBCKENDIE = 0x400;    // Data block end interrupt enable Set and cleared by software to enable/disable interrupt caused by data block end.
    static constexpr uint32_t MASKR_DABORTIE = 0x800;     // Data transfer aborted interrupt enable Set and cleared by software to enable/disable interrupt caused by a data transfer being aborted.
    static constexpr uint32_t MASKR_TXFIFOHEIE = 0x4000;  // Tx FIFO half empty interrupt enable Set and cleared by software to enable/disable interrupt caused by Tx FIFO half empty.
    static constexpr uint32_t MASKR_RXFIFOHFIE = 0x8000;  // Rx FIFO half full interrupt enable Set and cleared by software to enable/disable interrupt caused by Rx FIFO half full.
    static constexpr uint32_t MASKR_RXFIFOFIE = 0x20000;  // Rx FIFO full interrupt enable Set and cleared by software to enable/disable interrupt caused by Rx FIFO full.
    static constexpr uint32_t MASKR_TXFIFOEIE = 0x40000;  // Tx FIFO empty interrupt enable Set and cleared by software to enable/disable interrupt caused by Tx FIFO empty.
    static constexpr uint32_t MASKR_BUSYD0ENDIE = 0x200000;// BUSYD0END interrupt enable Set and cleared by software to enable/disable the interrupt generated when SDMMC_D0 signal changes from busy to NOT busy following a CMD response.
    static constexpr uint32_t MASKR_SDIOITIE = 0x400000;  // SDIO mode interrupt received interrupt enable Set and cleared by software to enable/disable the interrupt generated when receiving the SDIO mode interrupt.
    static constexpr uint32_t MASKR_ACKFAILIE = 0x800000; // Acknowledgment Fail interrupt enable Set and cleared by software to enable/disable interrupt caused by acknowledgment Fail.
    static constexpr uint32_t MASKR_ACKTIMEOUTIE = 0x1000000;// Acknowledgment timeout interrupt enable Set and cleared by software to enable/disable interrupt caused by acknowledgment timeout.
    static constexpr uint32_t MASKR_VSWENDIE = 0x2000000; // Voltage switch critical timing section completion interrupt enable Set and cleared by software to enable/disable the interrupt generated when voltage switch critical timing section completion.
    static constexpr uint32_t MASKR_CKSTOPIE = 0x4000000; // Voltage Switch clock stopped interrupt enable Set and cleared by software to enable/disable interrupt caused by Voltage Switch clock stopped.
    static constexpr uint32_t MASKR_IDMABTCIE = 0x10000000;// IDMA buffer transfer complete interrupt enable Set and cleared by software to enable/disable the interrupt generated when the IDMA has transferred all data belonging to a memory buffer.
    static const uint32_t MASKR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ACKTIMER_ACKTIME =             // Boot acknowledgment timeout period This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). Boot acknowledgment timeout period expressed in card bus clock periods. (25 bits)
        bit_field_t<0, 0x1ffffff>::value<X>();
    static const uint32_t ACKTIMER_RESET_VALUE = 0x0;

    static constexpr uint32_t IDMACTRLR_IDMAEN = 0x1;         // IDMA enable This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
    static constexpr uint32_t IDMACTRLR_IDMABMODE = 0x2;      // Buffer mode selection. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
    static constexpr uint32_t IDMACTRLR_IDMABACT = 0x4;       // Double buffer mode active buffer indication This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). When IDMA is enabled this bit is toggled by hardware.
    static const uint32_t IDMACTRLR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IDMABSIZER_IDMABNDT =            // Number of transfers per buffer. This 8-bit value shall be multiplied by 8 to get the size of the buffer in 32-bit words and by 32 to get the size of the buffer in bytes. Example: IDMABNDT = 0x01: buffer size = 8 words = 32 bytes. These bits can only be written by firmware when DPSM is inactive (DPSMACT = 0). (8 bits)
        bit_field_t<5, 0xff>::value<X>();
    static const uint32_t IDMABSIZER_RESET_VALUE = 0x0;


    static const uint32_t IDMABASE0R_RESET_VALUE = 0x0;


    static const uint32_t IDMABASE1R_RESET_VALUE = 0x0;


    static const uint32_t FIFOR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t VER_MINREV =              // IP minor revision number. (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t VER_MAJREV =              // IP major revision number. (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    static const uint32_t VER_RESET_VALUE = 0x10;


    static const uint32_t ID_RESET_VALUE = 0x140022;

    static constexpr uint8_t SDMMC = 124; // SDMMC global interrupt
    static constexpr uint8_t SDMMC1 = 49; // SDMMC global interrupt
};

static sdmmc1_t& SDMMC1 = *reinterpret_cast<sdmmc1_t*>(0x52007000);

#define HAVE_PERIPHERAL_SDMMC1


////
//
//    SDMMC1
//
////

struct sdmmc2_t
{
    volatile uint32_t    POWER;                // [Read-write] SDMMC power control register
    volatile uint32_t    CLKCR;                // [Read-write] The SDMMC_CLKCR register controls the SDMMC_CK output clock, the SDMMC_RX_CLK receive clock, and the bus width.
    volatile uint32_t    ARGR;                 // [Read-write] The SDMMC_ARGR register contains a 32-bit command argument, which is sent to a card as part of a command message.
    volatile uint32_t    CMDR;                 // [Read-write] The SDMMC_CMDR register contains the command index and command type bits. The command index is sent to a card as part of a command message. The command type bits control the command path state machine (CPSM).
    volatile uint32_t    RESPCMDR;             // [Read-only] SDMMC command response register
    volatile uint32_t    RESP1R;               // [Read-only] The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
    volatile uint32_t    RESP2R;               // [Read-only] The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
    volatile uint32_t    RESP3R;               // [Read-only] The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
    volatile uint32_t    RESP4R;               // [Read-only] The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
    volatile uint32_t    DTIMER;               // [Read-write] The SDMMC_DTIMER register contains the data timeout period, in card bus clock periods. A counter loads the value from the SDMMC_DTIMER register, and starts decrementing when the data path state machine (DPSM) enters the Wait_R or Busy state. If the timer reaches 0 while the DPSM is in either of these states, the timeout status flag is set.
    volatile uint32_t    DLENR;                // [Read-write] The SDMMC_DLENR register contains the number of data bytes to be transferred. The value is loaded into the data counter when data transfer starts.
    volatile uint32_t    DCTRL;                // [Read-write] The SDMMC_DCTRL register control the data path state machine (DPSM).
    volatile uint32_t    DCNTR;                // [Read-only] The SDMMC_DCNTR register loads the value from the data length register (see SDMMC_DLENR) when the DPSM moves from the Idle state to the Wait_R or Wait_S state. As data is transferred, the counter decrements the value until it reaches 0. The DPSM then moves to the Idle state and when there has been no error, the data status end flag (DATAEND) is set.
    volatile uint32_t    STAR;                 // [Read-only] The SDMMC_STAR register is a read-only register. It contains two types of flag:Static flags (bits [29,21,11:0]): these bits remain asserted until they are cleared by writing to the SDMMC interrupt Clear register (see SDMMC_ICR)Dynamic flags (bits [20:12]): these bits change state depending on the state of the underlying logic (for example, FIFO full and empty flags are asserted and de-asserted as data while written to the FIFO)
    volatile uint32_t    ICR;                  // [Read-write] The SDMMC_ICR register is a write-only register. Writing a bit with 1 clears the corresponding bit in the SDMMC_STAR status register.
    volatile uint32_t    MASKR;                // [Read-write] The interrupt mask register determines which status flags generate an interrupt request by setting the corresponding bit to 1.
    volatile uint32_t    ACKTIMER;             // [Read-write] The SDMMC_ACKTIMER register contains the acknowledgment timeout period, in SDMMC_CK bus clock periods. A counter loads the value from the SDMMC_ACKTIMER register, and starts decrementing when the data path state machine (DPSM) enters the Wait_Ack state. If the timer reaches 0 while the DPSM is in this states, the acknowledgment timeout status flag is set.
    reserved_t<3>        _0;
    volatile uint32_t    IDMACTRLR;            // [Read-write] The receive and transmit FIFOs can be read or written as 32-bit wide registers. The FIFOs contain 32 entries on 32 sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO.
    volatile uint32_t    IDMABSIZER;           // [Read-write] The SDMMC_IDMABSIZER register contains the buffers size when in double buffer configuration.
    volatile uint32_t    IDMABASE0R;           // [Read-write] The SDMMC_IDMABASE0R register contains the memory buffer base address in single buffer configuration and the buffer 0 base address in double buffer configuration.
    volatile uint32_t    IDMABASE1R;           // [Read-write] The SDMMC_IDMABASE1R register contains the double buffer configuration second buffer memory base address.
    reserved_t<8>        _1;
    volatile uint32_t    FIFOR;                // [Read-write] The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO.When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
    reserved_t<220>      _2;
    volatile uint32_t    VER;                  // [Read-only] SDMMC IP version register
    volatile uint32_t    ID;                   // [Read-only] SDMMC IP identification register

    template<uint32_t X>
    static constexpr uint32_t POWER_PWRCTRL =             // SDMMC state control bits. These bits can only be written when the SDMMC is not in the power-on state (PWRCTRL?11). These bits are used to define the functional state of the SDMMC signals: Any further write will be ignored, PWRCTRL value will keep 11. (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static constexpr uint32_t POWER_VSWITCH = 0x4;        // Voltage switch sequence start. This bit is used to start the timing critical section of the voltage switch sequence:
    static constexpr uint32_t POWER_VSWITCHEN = 0x8;      // Voltage switch procedure enable. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). This bit is used to stop the SDMMC_CK after the voltage switch command response:
    static constexpr uint32_t POWER_DIRPOL = 0x10;        // Data and command direction signals polarity selection. This bit can only be written when the SDMMC is in the power-off state (PWRCTRL = 00).
    static const uint32_t POWER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CLKCR_CLKDIV =              // Clock divide factor This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). This field defines the divide factor between the input clock (SDMMCCLK) and the output clock (SDMMC_CK): SDMMC_CK frequency = SDMMCCLK / [2 * CLKDIV]. 0xx: etc.. xxx: etc.. (10 bits)
        bit_field_t<0, 0x3ff>::value<X>();
    static constexpr uint32_t CLKCR_PWRSAV = 0x1000;      // Power saving configuration bit This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) For power saving, the SDMMC_CK clock output can be disabled when the bus is idle by setting PWRSAV:
    template<uint32_t X>
    static constexpr uint32_t CLKCR_WIDBUS =              // Wide bus mode enable bit This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t CLKCR_NEGEDGE = 0x10000;    // SDMMC_CK dephasing selection bit for data and Command. This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). When clock division = 1 (CLKDIV = 0), this bit has no effect. Data and Command change on SDMMC_CK falling edge. When clock division &amp;gt;1 (CLKDIV &amp;gt; 0) &amp;amp; DDR = 0: - SDMMC_CK edge occurs on SDMMCCLK rising edge. When clock division &gt;1 (CLKDIV &gt; 0) &amp; DDR = 1: - Data changed on the SDMMCCLK falling edge succeeding a SDMMC_CK edge. - SDMMC_CK edge occurs on SDMMCCLK rising edge. - Data changed on the SDMMC_CK falling edge succeeding a SDMMC_CK edge. - SDMMC_CK edge occurs on SDMMCCLK rising edge.
    static constexpr uint32_t CLKCR_HWFC_EN = 0x20000;    // Hardware flow control enable This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) When Hardware flow control is enabled, the meaning of the TXFIFOE and RXFIFOF flags change, please see SDMMC status register definition in Section56.8.11.
    static constexpr uint32_t CLKCR_DDR = 0x40000;        // Data rate signaling selection This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) DDR rate shall only be selected with 4-bit or 8-bit wide bus mode. (WIDBUS &amp;gt; 00). DDR = 1 has no effect when WIDBUS = 00 (1-bit wide bus). DDR rate shall only be selected with clock division &amp;gt;1. (CLKDIV &amp;gt; 0)
    static constexpr uint32_t CLKCR_BUSSPEED = 0x80000;   // Bus speed mode selection between DS, HS, SDR12, SDR25 and SDR50, DDR50, SDR104. This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0)
    template<uint32_t X>
    static constexpr uint32_t CLKCR_SELCLKRX =            // Receive clock selection. These bits can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    static const uint32_t CLKCR_RESET_VALUE = 0x0;


    static const uint32_t ARGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CMDR_CMDINDEX =            // Command index. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). The command index is sent to the card as part of a command message. (6 bits)
        bit_field_t<0, 0x3f>::value<X>();
    static constexpr uint32_t CMDR_CMDTRANS = 0x40;      // The CPSM treats the command as a data transfer command, stops the interrupt period, and signals DataEnable to the DPSM This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). If this bit is set, the CPSM issues an end of interrupt period and issues DataEnable signal to the DPSM when the command is sent.
    static constexpr uint32_t CMDR_CMDSTOP = 0x80;       // The CPSM treats the command as a Stop Transmission command and signals Abort to the DPSM. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). If this bit is set, the CPSM issues the Abort signal to the DPSM when the command is sent.
    template<uint32_t X>
    static constexpr uint32_t CMDR_WAITRESP =            // Wait for response bits. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). They are used to configure whether the CPSM is to wait for a response, and if yes, which kind of response. (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t CMDR_WAITINT = 0x400;      // CPSM waits for interrupt request. If this bit is set, the CPSM disables command timeout and waits for an card interrupt request (Response). If this bit is cleared in the CPSM Wait state, will cause the abort of the interrupt mode.
    static constexpr uint32_t CMDR_WAITPEND = 0x800;     // CPSM Waits for end of data transfer (CmdPend internal signal) from DPSM. This bit when set, the CPSM waits for the end of data transfer trigger before it starts sending a command. WAITPEND is only taken into account when DTMODE = MMC stream data transfer, WIDBUS = 1-bit wide bus mode, DPSMACT = 1 and DTDIR = from host to card.
    static constexpr uint32_t CMDR_CPSMEN = 0x1000;      // Command path state machine (CPSM) Enable bit This bit is written 1 by firmware, and cleared by hardware when the CPSM enters the Idle state. If this bit is set, the CPSM is enabled. When DTEN = 1, no command will be transfered nor boot procedure will be started. CPSMEN is cleared to 0.
    static constexpr uint32_t CMDR_DTHOLD = 0x2000;      // Hold new data block transmission and reception in the DPSM. If this bit is set, the DPSM will not move from the Wait_S state to the Send state or from the Wait_R state to the Receive state.
    static constexpr uint32_t CMDR_BOOTMODE = 0x4000;    // Select the boot mode procedure to be used. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0)
    static constexpr uint32_t CMDR_BOOTEN = 0x8000;      // Enable boot mode procedure.
    static constexpr uint32_t CMDR_CMDSUSPEND = 0x10000; // The CPSM treats the command as a Suspend or Resume command and signals interrupt period start/end. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). CMDSUSPEND = 1 and CMDTRANS = 0 Suspend command, start interrupt period when response bit BS=0. CMDSUSPEND = 1 and CMDTRANS = 1 Resume command with data, end interrupt period when response bit DF=1.
    static const uint32_t CMDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RESPCMDR_RESPCMD =             // Response command index (6 bits)
        bit_field_t<0, 0x3f>::value<X>();
    static const uint32_t RESPCMDR_RESET_VALUE = 0xa3c5dd01;


    static const uint32_t RESP1R_RESET_VALUE = 0x0;


    static const uint32_t RESP2R_RESET_VALUE = 0x0;


    static const uint32_t RESP3R_RESET_VALUE = 0x0;


    static const uint32_t RESP4R_RESET_VALUE = 0x0;


    static const uint32_t DTIMER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DLENR_DATALENGTH =          // Data length value This register can only be written by firmware when DPSM is inactive (DPSMACT = 0). Number of data bytes to be transferred. When DDR = 1 DATALENGTH is truncated to a multiple of 2. (The last odd byte is not transfered) When DATALENGTH = 0 no data will be transfered, when requested by a CPSMEN and CMDTRANS = 1 also no command will be transfered. DTEN and CPSMEN are cleared to 0. (25 bits)
        bit_field_t<0, 0x1ffffff>::value<X>();
    static const uint32_t DLENR_RESET_VALUE = 0x0;

    static constexpr uint32_t DCTRL_DTEN = 0x1;           // Data transfer enable bit This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). This bit is cleared by Hardware when data transfer completes. This bit shall only be used to transfer data when no associated data transfer command is used, i.e. shall not be used with SD or eMMC cards.
    static constexpr uint32_t DCTRL_DTDIR = 0x2;          // Data transfer direction selection This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
    template<uint32_t X>
    static constexpr uint32_t DCTRL_DTMODE =              // Data transfer mode selection. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DCTRL_DBLOCKSIZE =          // Data block size This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). Define the data block length when the block data transfer mode is selected: When DATALENGTH is not a multiple of DBLOCKSIZE, the transfered data is truncated at a multiple of DBLOCKSIZE. (Any remain data will not be transfered.) When DDR = 1, DBLOCKSIZE = 0000 shall not be used. (No data will be transfered) (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    static constexpr uint32_t DCTRL_RWSTART = 0x100;      // Read wait start. If this bit is set, read wait operation starts.
    static constexpr uint32_t DCTRL_RWSTOP = 0x200;       // Read wait stop This bit is written by firmware and auto cleared by hardware when the DPSM moves from the READ_WAIT state to the WAIT_R or IDLE state.
    static constexpr uint32_t DCTRL_RWMOD = 0x400;        // Read wait mode. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
    static constexpr uint32_t DCTRL_SDIOEN = 0x800;       // SD I/O interrupt enable functions This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). If this bit is set, the DPSM enables the SD I/O card specific interrupt operation.
    static constexpr uint32_t DCTRL_BOOTACKEN = 0x1000;   // Enable the reception of the boot acknowledgment. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
    static constexpr uint32_t DCTRL_FIFORST = 0x2000;     // FIFO reset, will flush any remaining data. This bit can only be written by firmware when IDMAEN= 0 and DPSM is active (DPSMACT = 1). This bit will only take effect when a transfer error or transfer hold occurs.
    static const uint32_t DCTRL_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DCNTR_DATACOUNT =           // Data count value When read, the number of remaining data bytes to be transferred is returned. Write has no effect. (25 bits)
        bit_field_t<0, 0x1ffffff>::value<X>();
    static const uint32_t DCNTR_RESET_VALUE = 0x0;

    static constexpr uint32_t STAR_CCRCFAIL = 0x1;       // Command response received (CRC check failed). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    static constexpr uint32_t STAR_DCRCFAIL = 0x2;       // Data block sent/received (CRC check failed). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    static constexpr uint32_t STAR_CTIMEOUT = 0x4;       // Command response timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. The Command Timeout period has a fixed value of 64 SDMMC_CK clock periods.
    static constexpr uint32_t STAR_DTIMEOUT = 0x8;       // Data timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    static constexpr uint32_t STAR_TXUNDERR = 0x10;      // Transmit FIFO underrun error or IDMA read transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    static constexpr uint32_t STAR_RXOVERR = 0x20;       // Received FIFO overrun error or IDMA write transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    static constexpr uint32_t STAR_CMDREND = 0x40;       // Command response received (CRC check passed, or no CRC). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    static constexpr uint32_t STAR_CMDSENT = 0x80;       // Command sent (no response required). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    static constexpr uint32_t STAR_DATAEND = 0x100;      // Data transfer ended correctly. (data counter, DATACOUNT is zero and no errors occur). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    static constexpr uint32_t STAR_DHOLD = 0x200;        // Data transfer Hold. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    static constexpr uint32_t STAR_DBCKEND = 0x400;      // Data block sent/received. (CRC check passed) and DPSM moves to the READWAIT state. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    static constexpr uint32_t STAR_DABORT = 0x800;       // Data transfer aborted by CMD12. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    static constexpr uint32_t STAR_DPSMACT = 0x1000;     // Data path state machine active, i.e. not in Idle state. This is a hardware status flag only, does not generate an interrupt.
    static constexpr uint32_t STAR_CPSMACT = 0x2000;     // Command path state machine active, i.e. not in Idle state. This is a hardware status flag only, does not generate an interrupt.
    static constexpr uint32_t STAR_TXFIFOHE = 0x4000;    // Transmit FIFO half empty At least half the number of words can be written into the FIFO. This bit is cleared when the FIFO becomes half+1 full.
    static constexpr uint32_t STAR_RXFIFOHF = 0x8000;    // Receive FIFO half full There are at least half the number of words in the FIFO. This bit is cleared when the FIFO becomes half+1 empty.
    static constexpr uint32_t STAR_TXFIFOF = 0x10000;    // Transmit FIFO full This is a hardware status flag only, does not generate an interrupt. This bit is cleared when one FIFO location becomes empty.
    static constexpr uint32_t STAR_RXFIFOF = 0x20000;    // Receive FIFO full This bit is cleared when one FIFO location becomes empty.
    static constexpr uint32_t STAR_TXFIFOE = 0x40000;    // Transmit FIFO empty This bit is cleared when one FIFO location becomes full.
    static constexpr uint32_t STAR_RXFIFOE = 0x80000;    // Receive FIFO empty This is a hardware status flag only, does not generate an interrupt. This bit is cleared when one FIFO location becomes full.
    static constexpr uint32_t STAR_BUSYD0 = 0x100000;    // Inverted value of SDMMC_D0 line (Busy), sampled at the end of a CMD response and a second time 2 SDMMC_CK cycles after the CMD response. This bit is reset to not busy when the SDMMCD0 line changes from busy to not busy. This bit does not signal busy due to data transfer. This is a hardware status flag only, it does not generate an interrupt.
    static constexpr uint32_t STAR_BUSYD0END = 0x200000; // end of SDMMC_D0 Busy following a CMD response detected. This indicates only end of busy following a CMD response. This bit does not signal busy due to data transfer. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    static constexpr uint32_t STAR_SDIOIT = 0x400000;    // SDIO interrupt received. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    static constexpr uint32_t STAR_ACKFAIL = 0x800000;   // Boot acknowledgment received (boot acknowledgment check fail). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    static constexpr uint32_t STAR_ACKTIMEOUT = 0x1000000;// Boot acknowledgment timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    static constexpr uint32_t STAR_VSWEND = 0x2000000;   // Voltage switch critical timing section completion. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    static constexpr uint32_t STAR_CKSTOP = 0x4000000;   // SDMMC_CK stopped in Voltage switch procedure. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    static constexpr uint32_t STAR_IDMATE = 0x8000000;   // IDMA transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    static constexpr uint32_t STAR_IDMABTC = 0x10000000; // IDMA buffer transfer complete. interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    static const uint32_t STAR_RESET_VALUE = 0x0;

    static constexpr uint32_t ICR_CCRCFAILC = 0x1;      // CCRCFAIL flag clear bit Set by software to clear the CCRCFAIL flag.
    static constexpr uint32_t ICR_DCRCFAILC = 0x2;      // DCRCFAIL flag clear bit Set by software to clear the DCRCFAIL flag.
    static constexpr uint32_t ICR_CTIMEOUTC = 0x4;      // CTIMEOUT flag clear bit Set by software to clear the CTIMEOUT flag.
    static constexpr uint32_t ICR_DTIMEOUTC = 0x8;      // DTIMEOUT flag clear bit Set by software to clear the DTIMEOUT flag.
    static constexpr uint32_t ICR_TXUNDERRC = 0x10;     // TXUNDERR flag clear bit Set by software to clear TXUNDERR flag.
    static constexpr uint32_t ICR_RXOVERRC = 0x20;      // RXOVERR flag clear bit Set by software to clear the RXOVERR flag.
    static constexpr uint32_t ICR_CMDRENDC = 0x40;      // CMDREND flag clear bit Set by software to clear the CMDREND flag.
    static constexpr uint32_t ICR_CMDSENTC = 0x80;      // CMDSENT flag clear bit Set by software to clear the CMDSENT flag.
    static constexpr uint32_t ICR_DATAENDC = 0x100;     // DATAEND flag clear bit Set by software to clear the DATAEND flag.
    static constexpr uint32_t ICR_DHOLDC = 0x200;       // DHOLD flag clear bit Set by software to clear the DHOLD flag.
    static constexpr uint32_t ICR_DBCKENDC = 0x400;     // DBCKEND flag clear bit Set by software to clear the DBCKEND flag.
    static constexpr uint32_t ICR_DABORTC = 0x800;      // DABORT flag clear bit Set by software to clear the DABORT flag.
    static constexpr uint32_t ICR_BUSYD0ENDC = 0x200000;// BUSYD0END flag clear bit Set by software to clear the BUSYD0END flag.
    static constexpr uint32_t ICR_SDIOITC = 0x400000;   // SDIOIT flag clear bit Set by software to clear the SDIOIT flag.
    static constexpr uint32_t ICR_ACKFAILC = 0x800000;  // ACKFAIL flag clear bit Set by software to clear the ACKFAIL flag.
    static constexpr uint32_t ICR_ACKTIMEOUTC = 0x1000000;// ACKTIMEOUT flag clear bit Set by software to clear the ACKTIMEOUT flag.
    static constexpr uint32_t ICR_VSWENDC = 0x2000000;  // VSWEND flag clear bit Set by software to clear the VSWEND flag.
    static constexpr uint32_t ICR_CKSTOPC = 0x4000000;  // CKSTOP flag clear bit Set by software to clear the CKSTOP flag.
    static constexpr uint32_t ICR_IDMATEC = 0x8000000;  // IDMA transfer error clear bit Set by software to clear the IDMATE flag.
    static constexpr uint32_t ICR_IDMABTCC = 0x10000000;// IDMA buffer transfer complete clear bit Set by software to clear the IDMABTC flag.
    static const uint32_t ICR_RESET_VALUE = 0x0;

    static constexpr uint32_t MASKR_CCRCFAILIE = 0x1;     // Command CRC fail interrupt enable Set and cleared by software to enable/disable interrupt caused by command CRC failure.
    static constexpr uint32_t MASKR_DCRCFAILIE = 0x2;     // Data CRC fail interrupt enable Set and cleared by software to enable/disable interrupt caused by data CRC failure.
    static constexpr uint32_t MASKR_CTIMEOUTIE = 0x4;     // Command timeout interrupt enable Set and cleared by software to enable/disable interrupt caused by command timeout.
    static constexpr uint32_t MASKR_DTIMEOUTIE = 0x8;     // Data timeout interrupt enable Set and cleared by software to enable/disable interrupt caused by data timeout.
    static constexpr uint32_t MASKR_TXUNDERRIE = 0x10;    // Tx FIFO underrun error interrupt enable Set and cleared by software to enable/disable interrupt caused by Tx FIFO underrun error.
    static constexpr uint32_t MASKR_RXOVERRIE = 0x20;     // Rx FIFO overrun error interrupt enable Set and cleared by software to enable/disable interrupt caused by Rx FIFO overrun error.
    static constexpr uint32_t MASKR_CMDRENDIE = 0x40;     // Command response received interrupt enable Set and cleared by software to enable/disable interrupt caused by receiving command response.
    static constexpr uint32_t MASKR_CMDSENTIE = 0x80;     // Command sent interrupt enable Set and cleared by software to enable/disable interrupt caused by sending command.
    static constexpr uint32_t MASKR_DATAENDIE = 0x100;    // Data end interrupt enable Set and cleared by software to enable/disable interrupt caused by data end.
    static constexpr uint32_t MASKR_DHOLDIE = 0x200;      // Data hold interrupt enable Set and cleared by software to enable/disable the interrupt generated when sending new data is hold in the DPSM Wait_S state.
    static constexpr uint32_t MASKR_DBCKENDIE = 0x400;    // Data block end interrupt enable Set and cleared by software to enable/disable interrupt caused by data block end.
    static constexpr uint32_t MASKR_DABORTIE = 0x800;     // Data transfer aborted interrupt enable Set and cleared by software to enable/disable interrupt caused by a data transfer being aborted.
    static constexpr uint32_t MASKR_TXFIFOHEIE = 0x4000;  // Tx FIFO half empty interrupt enable Set and cleared by software to enable/disable interrupt caused by Tx FIFO half empty.
    static constexpr uint32_t MASKR_RXFIFOHFIE = 0x8000;  // Rx FIFO half full interrupt enable Set and cleared by software to enable/disable interrupt caused by Rx FIFO half full.
    static constexpr uint32_t MASKR_RXFIFOFIE = 0x20000;  // Rx FIFO full interrupt enable Set and cleared by software to enable/disable interrupt caused by Rx FIFO full.
    static constexpr uint32_t MASKR_TXFIFOEIE = 0x40000;  // Tx FIFO empty interrupt enable Set and cleared by software to enable/disable interrupt caused by Tx FIFO empty.
    static constexpr uint32_t MASKR_BUSYD0ENDIE = 0x200000;// BUSYD0END interrupt enable Set and cleared by software to enable/disable the interrupt generated when SDMMC_D0 signal changes from busy to NOT busy following a CMD response.
    static constexpr uint32_t MASKR_SDIOITIE = 0x400000;  // SDIO mode interrupt received interrupt enable Set and cleared by software to enable/disable the interrupt generated when receiving the SDIO mode interrupt.
    static constexpr uint32_t MASKR_ACKFAILIE = 0x800000; // Acknowledgment Fail interrupt enable Set and cleared by software to enable/disable interrupt caused by acknowledgment Fail.
    static constexpr uint32_t MASKR_ACKTIMEOUTIE = 0x1000000;// Acknowledgment timeout interrupt enable Set and cleared by software to enable/disable interrupt caused by acknowledgment timeout.
    static constexpr uint32_t MASKR_VSWENDIE = 0x2000000; // Voltage switch critical timing section completion interrupt enable Set and cleared by software to enable/disable the interrupt generated when voltage switch critical timing section completion.
    static constexpr uint32_t MASKR_CKSTOPIE = 0x4000000; // Voltage Switch clock stopped interrupt enable Set and cleared by software to enable/disable interrupt caused by Voltage Switch clock stopped.
    static constexpr uint32_t MASKR_IDMABTCIE = 0x10000000;// IDMA buffer transfer complete interrupt enable Set and cleared by software to enable/disable the interrupt generated when the IDMA has transferred all data belonging to a memory buffer.
    static const uint32_t MASKR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ACKTIMER_ACKTIME =             // Boot acknowledgment timeout period This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). Boot acknowledgment timeout period expressed in card bus clock periods. (25 bits)
        bit_field_t<0, 0x1ffffff>::value<X>();
    static const uint32_t ACKTIMER_RESET_VALUE = 0x0;

    static constexpr uint32_t IDMACTRLR_IDMAEN = 0x1;         // IDMA enable This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
    static constexpr uint32_t IDMACTRLR_IDMABMODE = 0x2;      // Buffer mode selection. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
    static constexpr uint32_t IDMACTRLR_IDMABACT = 0x4;       // Double buffer mode active buffer indication This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). When IDMA is enabled this bit is toggled by hardware.
    static const uint32_t IDMACTRLR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IDMABSIZER_IDMABNDT =            // Number of transfers per buffer. This 8-bit value shall be multiplied by 8 to get the size of the buffer in 32-bit words and by 32 to get the size of the buffer in bytes. Example: IDMABNDT = 0x01: buffer size = 8 words = 32 bytes. These bits can only be written by firmware when DPSM is inactive (DPSMACT = 0). (8 bits)
        bit_field_t<5, 0xff>::value<X>();
    static const uint32_t IDMABSIZER_RESET_VALUE = 0x0;


    static const uint32_t IDMABASE0R_RESET_VALUE = 0x0;


    static const uint32_t IDMABASE1R_RESET_VALUE = 0x0;


    static const uint32_t FIFOR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t VER_MINREV =              // IP minor revision number. (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t VER_MAJREV =              // IP major revision number. (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    static const uint32_t VER_RESET_VALUE = 0x10;


    static const uint32_t ID_RESET_VALUE = 0x140022;
};

static sdmmc2_t& SDMMC2 = *reinterpret_cast<sdmmc2_t*>(0x48022400);

#define HAVE_PERIPHERAL_SDMMC2


////
//
//    VREFBUF
//
////

struct vrefbuf_t
{
    volatile uint32_t    CSR;                  // VREFBUF control and status register
    volatile uint32_t    CCR;                  // [Read-write] VREFBUF calibration control register

    static constexpr uint32_t CSR_ENVR = 0x1;           // Voltage reference buffer mode enable This bit is used to enable the voltage reference buffer mode., Read-write
    static constexpr uint32_t CSR_HIZ = 0x2;            // High impedance mode This bit controls the analog switch to connect or not the VREF+ pin. Refer to Table196: VREF buffer modes for the mode descriptions depending on ENVR bit configuration., Read-write
    static constexpr uint32_t CSR_VRR = 0x8;            // Voltage reference buffer ready, Read-only
    template<uint32_t X>
    static constexpr uint32_t CSR_VRS =                 // Voltage reference scale These bits select the value generated by the voltage reference buffer. Other: Reserved (3 bits), Read-write
        bit_field_t<4, 0x7>::value<X>();
    static const uint32_t CSR_RESET_VALUE = 0x2;

    template<uint32_t X>
    static constexpr uint32_t CCR_TRIM =                // Trimming code These bits are automatically initialized after reset with the trimming value stored in the Flash memory during the production test. Writing into these bits allows to tune the internal reference buffer voltage. (6 bits)
        bit_field_t<0, 0x3f>::value<X>();
    static const uint32_t CCR_RESET_VALUE = 0x0;
};

static vrefbuf_t& VREFBUF = *reinterpret_cast<vrefbuf_t*>(0x58003c00);

#define HAVE_PERIPHERAL_VREFBUF


////
//
//    IWDG
//
////

struct iwdg_t
{
    volatile uint32_t    KR;                   // [Write-only] Key register
    volatile uint32_t    PR;                   // [Read-write] Prescaler register
    volatile uint32_t    RLR;                  // [Read-write] Reload register
    volatile uint32_t    SR;                   // [Read-only] Status register
    volatile uint32_t    WINR;                 // [Read-write] Window register

    template<uint32_t X>
    static constexpr uint32_t KR_KEY =                 // Key value (write only, read 0x0000) These bits must be written by software at regular intervals with the key value 0xAAAA, otherwise the watchdog generates a reset when the counter reaches 0. Writing the key value 0x5555 to enable access to the IWDG_PR, IWDG_RLR and IWDG_WINR registers (see Section23.3.6: Register access protection) Writing the key value CCCCh starts the watchdog (except if the hardware watchdog option is selected) (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t KR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PR_PR =                  // Prescaler divider These bits are write access protected see Section23.3.6: Register access protection. They are written by software to select the prescaler divider feeding the counter clock. PVU bit of IWDG_SR must be reset in order to be able to change the prescaler divider. Note: Reading this register returns the prescaler value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the PVU bit in the IWDG_SR register is reset. (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t PR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RLR_RL =                  // Watchdog counter reload value These bits are write access protected see Section23.3.6. They are written by software to define the value to be loaded in the watchdog counter each time the value 0xAAAA is written in the IWDG_KR register. The watchdog counter counts down from this value. The timeout period is a function of this value and the clock prescaler. Refer to the datasheet for the timeout information. The RVU bit in the IWDG_SR register must be reset in order to be able to change the reload value. Note: Reading this register returns the reload value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing on this register. For this reason the value read from this register is valid only when the RVU bit in the IWDG_SR register is reset. (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t RLR_RESET_VALUE = 0xfff;

    static constexpr uint32_t SR_PVU = 0x1;            // Watchdog prescaler value update This bit is set by hardware to indicate that an update of the prescaler value is ongoing. It is reset by hardware when the prescaler update operation is completed in the VDD voltage domain (takes up to 5 RC 40 kHz cycles). Prescaler value can be updated only when PVU bit is reset.
    static constexpr uint32_t SR_RVU = 0x2;            // Watchdog counter reload value update This bit is set by hardware to indicate that an update of the reload value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to 5 RC 40 kHz cycles). Reload value can be updated only when RVU bit is reset.
    static constexpr uint32_t SR_WVU = 0x4;            // Watchdog counter window value update This bit is set by hardware to indicate that an update of the window value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to 5 RC 40 kHz cycles). Window value can be updated only when WVU bit is reset. This bit is generated only if generic window = 1
    static const uint32_t SR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t WINR_WIN =                 // Watchdog counter window value These bits are write access protected see Section23.3.6. These bits contain the high limit of the window value to be compared to the downcounter. To prevent a reset, the downcounter must be reloaded when its value is lower than the window register value and greater than 0x0 The WVU bit in the IWDG_SR register must be reset in order to be able to change the reload value. Note: Reading this register returns the reload value from the VDD voltage domain. This value may not be valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the WVU bit in the IWDG_SR register is reset. (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t WINR_RESET_VALUE = 0xfff;
};

static iwdg_t& IWDG = *reinterpret_cast<iwdg_t*>(0x58004800);

#define HAVE_PERIPHERAL_IWDG


////
//
//    WWDG
//
////

struct wwdg_t
{
    volatile uint32_t    CR;                   // [Read-write] Control register
    volatile uint32_t    CFR;                  // [Read-write] Configuration register
    volatile uint32_t    SR;                   // [Read-write] Status register

    template<uint32_t X>
    static constexpr uint32_t CR_T =                   // 7-bit counter (MSB to LSB) These bits contain the value of the watchdog counter. It is decremented every (4096 x 2WDGTB[1:0]) PCLK cycles. A reset is produced when it is decremented from 0x40 to 0x3F (T6 becomes cleared). (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    static constexpr uint32_t CR_WDGA = 0x80;          // Activation bit This bit is set by software and only cleared by hardware after a reset. When WDGA=1, the watchdog can generate a reset.
    static const uint32_t CR_RESET_VALUE = 0x7f;

    template<uint32_t X>
    static constexpr uint32_t CFR_W =                   // 7-bit window value These bits contain the window value to be compared to the downcounter. (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFR_WDGTB =               // Timer base The time base of the prescaler can be modified as follows: (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    static constexpr uint32_t CFR_EWI = 0x200;          // Early wakeup interrupt When set, an interrupt occurs whenever the counter reaches the value 0x40. This interrupt is only cleared by hardware after a reset.
    static const uint32_t CFR_RESET_VALUE = 0x7f;

    static constexpr uint32_t SR_EWIF = 0x1;           // Early wakeup interrupt flag This bit is set by hardware when the counter has reached the value 0x40. It must be cleared by software by writing 0. A write of 1 has no effect. This bit is also set if the interrupt is not enabled.
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint8_t WWDG1 = 0; // Window Watchdog interrupt
    static constexpr uint8_t WWDG1_RST = 143; // Window Watchdog interrupt
};

static wwdg_t& WWDG = *reinterpret_cast<wwdg_t*>(0x50003000);

#define HAVE_PERIPHERAL_WWDG


////
//
//    PWR
//
////

struct pwr_t
{
    volatile uint32_t    CR1;                  // [Read-write] PWR control register 1
    volatile uint32_t    CSR1;                 // [Read-only] PWR control status register 1
    volatile uint32_t    CR2;                  // This register is not reset by wakeup from Standby mode, RESET signal and VDD POR. It is only reset by VSW POR and VSWRST reset. This register shall not be accessed when VSWRST bit in RCC_BDCR register resets the VSW domain.After reset, PWR_CR2 register is write-protected. Prior to modifying its content, the DBP bit in PWR_CR1 register must be set to disable the write protection.
    volatile uint32_t    CR3;                  // Reset only by POR only, not reset by wakeup from Standby mode and RESET pad. The lower byte of this register is written once after POR and shall be written before changing VOS level or ck_sys clock frequency. No limitation applies to the upper bytes.Programming data corresponding to an invalid combination of SDLEVEL, SDEXTHP, SDEN, LDOEN and BYPASS bits (see Table9) will be ignored: data will not be written, the written-once mechanism will lock the register and any further write access will be ignored. The default supply configuration will be kept and the ACTVOSRDY bit in PWR control status register 1 (PWR_CSR1) will go on indicating invalid voltage levels. The system shall be power cycled before writing a new value.
    volatile uint32_t    CPUCR;                // This register allows controlling CPU1 power.
    reserved_t<1>        _0;
    volatile uint32_t    D3CR;                 // This register allows controlling D3 domain power.Following reset VOSRDY will be read 1 by software
    reserved_t<1>        _1;
    volatile uint32_t    WKUPCR;               // [Read-write] reset only by system reset, not reset by wakeup from Standby mode5 wait states are required when writing this register (when clearing a WKUPF bit in PWR_WKUPFR, the AHB write access will complete after the WKUPF has been cleared).
    volatile uint32_t    WKUPFR;               // [Read-write] reset only by system reset, not reset by wakeup from Standby mode
    volatile uint32_t    WKUPEPR;              // [Read-write] Reset only by system reset, not reset by wakeup from Standby mode

    static constexpr uint32_t CR1_LPDS = 0x1;           // Low-power Deepsleep with SVOS3 (SVOS4 and SVOS5 always use low-power, regardless of the setting of this bit)
    static constexpr uint32_t CR1_PVDE = 0x10;          // Programmable voltage detector enable
    template<uint32_t X>
    static constexpr uint32_t CR1_PLS =                 // Programmable voltage detector level selection These bits select the voltage threshold detected by the PVD. Note: Refer to Section Electrical characteristics of the product datasheet for more details. (3 bits)
        bit_field_t<5, 0x7>::value<X>();
    static constexpr uint32_t CR1_DBP = 0x100;          // Disable backup domain write protection In reset state, the RCC_BDCR register, the RTC registers (including the backup registers), BREN and MOEN bits in PWR_CR2 register, are protected against parasitic write access. This bit must be set to enable write access to these registers.
    static constexpr uint32_t CR1_FLPS = 0x200;         // Flash low-power mode in DStop mode This bit allows to obtain the best trade-off between low-power consumption and restart time when exiting from DStop mode. When it is set, the Flash memory enters low-power mode when D1 domain is in DStop mode.
    template<uint32_t X>
    static constexpr uint32_t CR1_SVOS =                // System Stop mode voltage scaling selection These bits control the VCORE voltage level in system Stop mode, to obtain the best trade-off between power consumption and performance. (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t CR1_AVDEN = 0x10000;      // Peripheral voltage monitor on VDDA enable
    template<uint32_t X>
    static constexpr uint32_t CR1_ALS =                 // Analog voltage detector level selection These bits select the voltage threshold detected by the AVD. (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    static const uint32_t CR1_RESET_VALUE = 0xf000c000;

    static constexpr uint32_t CSR1_PVDO = 0x10;          // Programmable voltage detect output This bit is set and cleared by hardware. It is valid only if the PVD has been enabled by the PVDE bit. Note: since the PVD is disabled in Standby mode, this bit is equal to 0 after Standby or reset until the PVDE bit is set.
    static constexpr uint32_t CSR1_ACTVOSRDY = 0x2000;   // Voltage levels ready bit for currently used VOS and SDLEVEL This bit is set to 1 by hardware when the voltage regulator and the SD converter are both disabled and Bypass mode is selected in PWR control register 3 (PWR_CR3).
    template<uint32_t X>
    static constexpr uint32_t CSR1_ACTVOS =              // VOS currently applied for VCORE voltage scaling selection. These bits reflect the last VOS value applied to the PMU. (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t CSR1_AVDO = 0x10000;       // Analog voltage detector output on VDDA This bit is set and cleared by hardware. It is valid only if AVD on VDDA is enabled by the AVDEN bit. Note: Since the AVD is disabled in Standby mode, this bit is equal to 0 after Standby or reset until the AVDEN bit is set.
    static const uint32_t CSR1_RESET_VALUE = 0x4000;

    static constexpr uint32_t CR2_BREN = 0x1;           // Backup regulator enable When set, the Backup regulator (used to maintain the backup RAM content in Standby and VBAT modes) is enabled. If BREN is reset, the backup regulator is switched off. The backup RAM can still be used in Run and Stop modes. However, its content will be lost in Standby and VBAT modes. If BREN is set, the application must wait till the Backup Regulator Ready flag (BRRDY) is set to indicate that the data written into the SRAM will be maintained in Standby and VBAT modes., Read-write
    static constexpr uint32_t CR2_MONEN = 0x10;         // VBAT and temperature monitoring enable When set, the VBAT supply and temperature monitoring is enabled., Read-write
    static constexpr uint32_t CR2_BRRDY = 0x10000;      // Backup regulator ready This bit is set by hardware to indicate that the Backup regulator is ready., Read-only
    static constexpr uint32_t CR2_VBATL = 0x100000;     // VBAT level monitoring versus low threshold, Read-only
    static constexpr uint32_t CR2_VBATH = 0x200000;     // VBAT level monitoring versus high threshold, Read-only
    static constexpr uint32_t CR2_TEMPL = 0x400000;     // Temperature level monitoring versus low threshold, Read-only
    static constexpr uint32_t CR2_TEMPH = 0x800000;     // Temperature level monitoring versus high threshold, Read-only
    static const uint32_t CR2_RESET_VALUE = 0x0;

    static constexpr uint32_t CR3_BYPASS = 0x1;         // Power management unit bypass, Read-write
    static constexpr uint32_t CR3_LDOEN = 0x2;          // Low drop-out regulator enable, Read-write
    static constexpr uint32_t CR3_SCUEN = 0x4;          // SD converter Enable, Read-write
    static constexpr uint32_t CR3_VBE = 0x100;          // VBAT charging enable, Read-write
    static constexpr uint32_t CR3_VBRS = 0x200;         // VBAT charging resistor selection, Read-write
    static constexpr uint32_t CR3_USB33DEN = 0x1000000; // VDD33USB voltage level detector enable., Read-write
    static constexpr uint32_t CR3_USBREGEN = 0x2000000; // USB regulator enable., Read-write
    static constexpr uint32_t CR3_USB33RDY = 0x4000000; // USB supply ready., Read-only
    static const uint32_t CR3_RESET_VALUE = 0x6;

    static constexpr uint32_t CPUCR_PDDS_D1 = 0x1;        // D1 domain Power Down Deepsleep selection. This bit allows CPU1 to define the Deepsleep mode for D1 domain., Read-write
    static constexpr uint32_t CPUCR_PDDS_D2 = 0x2;        // D2 domain Power Down Deepsleep. This bit allows CPU1 to define the Deepsleep mode for D2 domain., Read-write
    static constexpr uint32_t CPUCR_PDDS_D3 = 0x4;        // System D3 domain Power Down Deepsleep. This bit allows CPU1 to define the Deepsleep mode for System D3 domain., Read-write
    static constexpr uint32_t CPUCR_STOPF = 0x20;         // STOP flag This bit is set by hardware and cleared only by any reset or by setting the CPU1 CSSF bit., Read-only
    static constexpr uint32_t CPUCR_SBF = 0x40;           // System Standby flag This bit is set by hardware and cleared only by a POR (Power-on Reset) or by setting the CPU1 CSSF bit, Read-only
    static constexpr uint32_t CPUCR_SBF_D1 = 0x80;        // D1 domain DStandby flag This bit is set by hardware and cleared by any system reset or by setting the CPU1 CSSF bit. Once set, this bit can be cleared only when the D1 domain is no longer in DStandby mode., Read-only
    static constexpr uint32_t CPUCR_SBF_D2 = 0x100;       // D2 domain DStandby flag This bit is set by hardware and cleared by any system reset or by setting the CPU1 CSSF bit. Once set, this bit can be cleared only when the D2 domain is no longer in DStandby mode., Read-only
    static constexpr uint32_t CPUCR_CSSF = 0x200;         // Clear D1 domain CPU1 Standby, Stop and HOLD flags (always read as 0) This bit is cleared to 0 by hardware., Read-write
    static constexpr uint32_t CPUCR_RUN_D3 = 0x800;       // Keep system D3 domain in Run mode regardless of the CPU sub-systems modes, Read-write
    static const uint32_t CPUCR_RESET_VALUE = 0x0;

    static constexpr uint32_t D3CR_VOSRDY = 0x2000;      // VOS Ready bit for VCORE voltage scaling output selection. This bit is set to 1 by hardware when Bypass mode is selected in PWR control register 3 (PWR_CR3)., Read-only
    template<uint32_t X>
    static constexpr uint32_t D3CR_VOS =                 // Voltage scaling selection according to performance These bits control the VCORE voltage level and allow to obtains the best trade-off between power consumption and performance: When increasing the performance, the voltage scaling shall be changed before increasing the system frequency. When decreasing performance, the system frequency shall first be decreased before changing the voltage scaling. (2 bits), Read-write
        bit_field_t<14, 0x3>::value<X>();
    static const uint32_t D3CR_RESET_VALUE = 0x4000;

    template<uint32_t X>
    static constexpr uint32_t WKUPCR_WKUPC =               // Clear Wakeup pin flag for WKUP. These bits are always read as 0. (6 bits)
        bit_field_t<0, 0x3f>::value<X>();
    static const uint32_t WKUPCR_RESET_VALUE = 0x0;

    static constexpr uint32_t WKUPFR_WKUPF1 = 0x1;         // Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a Reset pin or by setting the WKUPCn+1 bit in the PWR wakeup clear register (PWR_WKUPCR).
    static constexpr uint32_t WKUPFR_WKUPF2 = 0x2;         // Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a Reset pin or by setting the WKUPCn+1 bit in the PWR wakeup clear register (PWR_WKUPCR).
    static constexpr uint32_t WKUPFR_WKUPF3 = 0x4;         // Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a Reset pin or by setting the WKUPCn+1 bit in the PWR wakeup clear register (PWR_WKUPCR).
    static constexpr uint32_t WKUPFR_WKUPF4 = 0x8;         // Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a Reset pin or by setting the WKUPCn+1 bit in the PWR wakeup clear register (PWR_WKUPCR).
    static constexpr uint32_t WKUPFR_WKUPF5 = 0x10;        // Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a Reset pin or by setting the WKUPCn+1 bit in the PWR wakeup clear register (PWR_WKUPCR).
    static constexpr uint32_t WKUPFR_WKUPF6 = 0x20;        // Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a Reset pin or by setting the WKUPCn+1 bit in the PWR wakeup clear register (PWR_WKUPCR).
    static const uint32_t WKUPFR_RESET_VALUE = 0x0;

    static constexpr uint32_t WKUPEPR_WKUPEN1 = 0x1;        // Enable Wakeup Pin WKUPn+1 Each bit is set and cleared by software. Note: An additional wakeup event is detected if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit) when WKUPn+1 pin level is already high when WKUPPn+1 selects rising edge, or low when WKUPPn+1 selects falling edge.
    static constexpr uint32_t WKUPEPR_WKUPEN2 = 0x2;        // Enable Wakeup Pin WKUPn+1 Each bit is set and cleared by software. Note: An additional wakeup event is detected if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit) when WKUPn+1 pin level is already high when WKUPPn+1 selects rising edge, or low when WKUPPn+1 selects falling edge.
    static constexpr uint32_t WKUPEPR_WKUPEN3 = 0x4;        // Enable Wakeup Pin WKUPn+1 Each bit is set and cleared by software. Note: An additional wakeup event is detected if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit) when WKUPn+1 pin level is already high when WKUPPn+1 selects rising edge, or low when WKUPPn+1 selects falling edge.
    static constexpr uint32_t WKUPEPR_WKUPEN4 = 0x8;        // Enable Wakeup Pin WKUPn+1 Each bit is set and cleared by software. Note: An additional wakeup event is detected if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit) when WKUPn+1 pin level is already high when WKUPPn+1 selects rising edge, or low when WKUPPn+1 selects falling edge.
    static constexpr uint32_t WKUPEPR_WKUPEN5 = 0x10;       // Enable Wakeup Pin WKUPn+1 Each bit is set and cleared by software. Note: An additional wakeup event is detected if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit) when WKUPn+1 pin level is already high when WKUPPn+1 selects rising edge, or low when WKUPPn+1 selects falling edge.
    static constexpr uint32_t WKUPEPR_WKUPEN6 = 0x20;       // Enable Wakeup Pin WKUPn+1 Each bit is set and cleared by software. Note: An additional wakeup event is detected if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit) when WKUPn+1 pin level is already high when WKUPPn+1 selects rising edge, or low when WKUPPn+1 selects falling edge.
    static constexpr uint32_t WKUPEPR_WKUPP1 = 0x100;       // Wakeup pin polarity bit for WKUPn-7 These bits define the polarity used for event detection on WKUPn-7 external wakeup pin.
    static constexpr uint32_t WKUPEPR_WKUPP2 = 0x200;       // Wakeup pin polarity bit for WKUPn-7 These bits define the polarity used for event detection on WKUPn-7 external wakeup pin.
    static constexpr uint32_t WKUPEPR_WKUPP3 = 0x400;       // Wakeup pin polarity bit for WKUPn-7 These bits define the polarity used for event detection on WKUPn-7 external wakeup pin.
    static constexpr uint32_t WKUPEPR_WKUPP4 = 0x800;       // Wakeup pin polarity bit for WKUPn-7 These bits define the polarity used for event detection on WKUPn-7 external wakeup pin.
    static constexpr uint32_t WKUPEPR_WKUPP5 = 0x1000;      // Wakeup pin polarity bit for WKUPn-7 These bits define the polarity used for event detection on WKUPn-7 external wakeup pin.
    static constexpr uint32_t WKUPEPR_WKUPP6 = 0x2000;      // Wakeup pin polarity bit for WKUPn-7 These bits define the polarity used for event detection on WKUPn-7 external wakeup pin.
    template<uint32_t X>
    static constexpr uint32_t WKUPEPR_WKUPPUPD1 =           // Wakeup pin pull configuration (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t WKUPEPR_WKUPPUPD2 =           // Wakeup pin pull configuration (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t WKUPEPR_WKUPPUPD3 =           // Wakeup pin pull configuration (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t WKUPEPR_WKUPPUPD4 =           // Wakeup pin pull configuration (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t WKUPEPR_WKUPPUPD5 =           // Wakeup pin pull configuration (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t WKUPEPR_WKUPPUPD6 =           // Wakeup pin pull configuration for WKUP(truncate(n/2)-7) These bits define the I/O pad pull configuration used when WKUPEN(truncate(n/2)-7) = 1. The associated GPIO port pull configuration shall be set to the same value or to 00. The Wakeup pin pull configuration is kept in Standby mode. (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    static const uint32_t WKUPEPR_RESET_VALUE = 0x0;
};

static pwr_t& PWR = *reinterpret_cast<pwr_t*>(0x58024800);

#define HAVE_PERIPHERAL_PWR


////
//
//    Serial peripheral interface
//
////

struct spi1_t
{
    volatile uint32_t    CR1;                  // control register 1
    volatile uint32_t    CR2;                  // control register 2
    volatile uint32_t    CFG1;                 // [Read-write] configuration register 1
    volatile uint32_t    CFG2;                 // [Read-write] configuration register 2
    volatile uint32_t    IER;                  // Interrupt Enable Register
    volatile uint32_t    SR;                   // [Read-only] Status Register
    volatile uint32_t    IFCR;                 // [Write-only] Interrupt/Status Flags Clear Register
    reserved_t<1>        _0;
    volatile uint32_t    TXDR;                 // [Write-only] Transmit Data Register
    reserved_t<3>        _1;
    volatile uint32_t    RXDR;                 // [Read-only] Receive Data Register
    reserved_t<3>        _2;
    volatile uint32_t    CRCPOLY;              // [Read-write] Polynomial Register
    volatile uint32_t    TXCRC;                // [Read-write] Transmitter CRC Register
    volatile uint32_t    RXCRC;                // [Read-write] Receiver CRC Register
    volatile uint32_t    UDRDR;                // [Read-write] Underrun Data Register
    volatile uint32_t    CGFR;                 // [Read-write] configuration register

    static constexpr uint32_t CR1_IOLOCK = 0x10000;     // Locking the AF configuration of associated IOs, Read-only
    static constexpr uint32_t CR1_TCRCI = 0x8000;       // CRC calculation initialization pattern control for transmitter, Read-write
    static constexpr uint32_t CR1_RCRCI = 0x4000;       // CRC calculation initialization pattern control for receiver, Read-write
    static constexpr uint32_t CR1_CRC33_17 = 0x2000;    // 32-bit CRC polynomial configuration, Read-write
    static constexpr uint32_t CR1_SSI = 0x1000;         // Internal SS signal input level, Read-write
    static constexpr uint32_t CR1_HDDIR = 0x800;        // Rx/Tx direction at Half-duplex mode, Read-write
    static constexpr uint32_t CR1_CSUSP = 0x400;        // Master SUSPend request, Write-only
    static constexpr uint32_t CR1_CSTART = 0x200;       // Master transfer start, Read-only
    static constexpr uint32_t CR1_MASRX = 0x100;        // Master automatic SUSP in Receive mode, Read-write
    static constexpr uint32_t CR1_SPE = 0x1;            // Serial Peripheral Enable, Read-write
    static const uint32_t CR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CR2_TSER =                // Number of data transfer extension to be reload into TSIZE just when a previous (16 bits), Read-only
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR2_TSIZE =               // Number of data at current transfer (16 bits), Read-write
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CFG1_MBR =                 // Master baud rate (3 bits)
        bit_field_t<28, 0x7>::value<X>();
    static constexpr uint32_t CFG1_CRCEN = 0x400000;     // Hardware CRC computation enable
    template<uint32_t X>
    static constexpr uint32_t CFG1_CRCSIZE =             // Length of CRC frame to be transacted and compared (5 bits)
        bit_field_t<16, 0x1f>::value<X>();
    static constexpr uint32_t CFG1_TXDMAEN = 0x8000;     // Tx DMA stream enable
    static constexpr uint32_t CFG1_RXDMAEN = 0x4000;     // Rx DMA stream enable
    template<uint32_t X>
    static constexpr uint32_t CFG1_UDRDET =              // Detection of underrun condition at slave transmitter (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFG1_UDRCFG =              // Behavior of slave transmitter at underrun condition (2 bits)
        bit_field_t<9, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFG1_FTHVL =               // threshold level (4 bits)
        bit_field_t<5, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFG1_DSIZE =               // Number of bits in at single SPI data frame (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t CFG1_RESET_VALUE = 0x70007;

    static constexpr uint32_t CFG2_AFCNTR = 0x80000000;  // Alternate function GPIOs control
    static constexpr uint32_t CFG2_SSOM = 0x40000000;    // SS output management in master mode
    static constexpr uint32_t CFG2_SSOE = 0x20000000;    // SS output enable
    static constexpr uint32_t CFG2_SSIOP = 0x10000000;   // SS input/output polarity
    static constexpr uint32_t CFG2_SSM = 0x4000000;      // Software management of SS signal input
    static constexpr uint32_t CFG2_CPOL = 0x2000000;     // Clock polarity
    static constexpr uint32_t CFG2_CPHA = 0x1000000;     // Clock phase
    static constexpr uint32_t CFG2_LSBFRST = 0x800000;   // Data frame format
    static constexpr uint32_t CFG2_MASTER = 0x400000;    // SPI Master
    template<uint32_t X>
    static constexpr uint32_t CFG2_SP =                  // Serial Protocol (3 bits)
        bit_field_t<19, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFG2_COMM =                // SPI Communication Mode (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    static constexpr uint32_t CFG2_IOSWP = 0x8000;       // Swap functionality of MISO and MOSI pins
    template<uint32_t X>
    static constexpr uint32_t CFG2_MIDI =                // Master Inter-Data Idleness (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFG2_MSSI =                // Master SS Idleness (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t CFG2_RESET_VALUE = 0x0;

    static constexpr uint32_t IER_TSERFIE = 0x400;      // Additional number of transactions reload interrupt enable, Read-write
    static constexpr uint32_t IER_MODFIE = 0x200;       // Mode Fault interrupt enable, Read-write
    static constexpr uint32_t IER_TIFREIE = 0x100;      // TIFRE interrupt enable, Read-write
    static constexpr uint32_t IER_CRCEIE = 0x80;        // CRC Interrupt enable, Read-write
    static constexpr uint32_t IER_OVRIE = 0x40;         // OVR interrupt enable, Read-write
    static constexpr uint32_t IER_UDRIE = 0x20;         // UDR interrupt enable, Read-write
    static constexpr uint32_t IER_TXTFIE = 0x10;        // TXTFIE interrupt enable, Read-write
    static constexpr uint32_t IER_EOTIE = 0x8;          // EOT, SUSP and TXC interrupt enable, Read-write
    static constexpr uint32_t IER_DPXPIE = 0x4;         // DXP interrupt enabled, Read-only
    static constexpr uint32_t IER_TXPIE = 0x2;          // TXP interrupt enable, Read-only
    static constexpr uint32_t IER_RXPIE = 0x1;          // RXP Interrupt Enable, Read-write
    static const uint32_t IER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SR_CTSIZE =              // Number of data frames remaining in current TSIZE session (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static constexpr uint32_t SR_RXWNE = 0x8000;       // RxFIFO Word Not Empty
    template<uint32_t X>
    static constexpr uint32_t SR_RXPLVL =              // RxFIFO Packing LeVeL (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    static constexpr uint32_t SR_TXC = 0x1000;         // TxFIFO transmission complete
    static constexpr uint32_t SR_SUSP = 0x800;         // SUSPend
    static constexpr uint32_t SR_TSERF = 0x400;        // Additional number of SPI data to be transacted was reload
    static constexpr uint32_t SR_MODF = 0x200;         // Mode Fault
    static constexpr uint32_t SR_TIFRE = 0x100;        // TI frame format error
    static constexpr uint32_t SR_CRCE = 0x80;          // CRC Error
    static constexpr uint32_t SR_OVR = 0x40;           // Overrun
    static constexpr uint32_t SR_UDR = 0x20;           // Underrun at slave transmission mode
    static constexpr uint32_t SR_TXTF = 0x10;          // Transmission Transfer Filled
    static constexpr uint32_t SR_EOT = 0x8;            // End Of Transfer
    static constexpr uint32_t SR_DXP = 0x4;            // Duplex Packet
    static constexpr uint32_t SR_TXP = 0x2;            // Tx-Packet space available
    static constexpr uint32_t SR_RXP = 0x1;            // Rx-Packet available
    static const uint32_t SR_RESET_VALUE = 0x1002;

    static constexpr uint32_t IFCR_SUSPC = 0x800;        // SUSPend flag clear
    static constexpr uint32_t IFCR_TSERFC = 0x400;       // TSERFC flag clear
    static constexpr uint32_t IFCR_MODFC = 0x200;        // Mode Fault flag clear
    static constexpr uint32_t IFCR_TIFREC = 0x100;       // TI frame format error flag clear
    static constexpr uint32_t IFCR_CRCEC = 0x80;         // CRC Error flag clear
    static constexpr uint32_t IFCR_OVRC = 0x40;          // Overrun flag clear
    static constexpr uint32_t IFCR_UDRC = 0x20;          // Underrun flag clear
    static constexpr uint32_t IFCR_TXTFC = 0x10;         // Transmission Transfer Filled flag clear
    static constexpr uint32_t IFCR_EOTC = 0x8;           // End Of Transfer flag clear
    static const uint32_t IFCR_RESET_VALUE = 0x0;


    static const uint32_t TXDR_RESET_VALUE = 0x0;


    static const uint32_t RXDR_RESET_VALUE = 0x0;


    static const uint32_t CRCPOLY_RESET_VALUE = 0x107;


    static const uint32_t TXCRC_RESET_VALUE = 0x0;


    static const uint32_t RXCRC_RESET_VALUE = 0x0;


    static const uint32_t UDRDR_RESET_VALUE = 0x0;

    static constexpr uint32_t CGFR_MCKOE = 0x2000000;    // Master clock output enable
    static constexpr uint32_t CGFR_ODD = 0x1000000;      // Odd factor for the prescaler
    template<uint32_t X>
    static constexpr uint32_t CGFR_I2SDIV =              // I2S linear prescaler (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static constexpr uint32_t CGFR_DATFMT = 0x4000;      // Data format
    static constexpr uint32_t CGFR_WSINV = 0x2000;       // Fixed channel length in SLAVE
    static constexpr uint32_t CGFR_FIXCH = 0x1000;       // Word select inversion
    static constexpr uint32_t CGFR_CKPOL = 0x800;        // Serial audio clock polarity
    static constexpr uint32_t CGFR_CHLEN = 0x400;        // Channel length (number of bits per audio channel)
    template<uint32_t X>
    static constexpr uint32_t CGFR_DATLEN =              // Data length to be transferred (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t CGFR_PCMSYNC = 0x80;       // PCM frame synchronization
    template<uint32_t X>
    static constexpr uint32_t CGFR_I2SSTD =              // I2S standard selection (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CGFR_I2SCFG =              // I2S configuration mode (3 bits)
        bit_field_t<1, 0x7>::value<X>();
    static constexpr uint32_t CGFR_I2SMOD = 0x1;         // I2S mode selection
    static const uint32_t CGFR_RESET_VALUE = 0x0;

    static constexpr uint8_t SPI1 = 35; // SPI1 global interrupt
};

static spi1_t& SPI1 = *reinterpret_cast<spi1_t*>(0x40013000);

#define HAVE_PERIPHERAL_SPI1


////
//
//    Serial peripheral interface
//
////

struct spi2_t
{
    volatile uint32_t    CR1;                  // control register 1
    volatile uint32_t    CR2;                  // control register 2
    volatile uint32_t    CFG1;                 // [Read-write] configuration register 1
    volatile uint32_t    CFG2;                 // [Read-write] configuration register 2
    volatile uint32_t    IER;                  // Interrupt Enable Register
    volatile uint32_t    SR;                   // [Read-only] Status Register
    volatile uint32_t    IFCR;                 // [Write-only] Interrupt/Status Flags Clear Register
    reserved_t<1>        _0;
    volatile uint32_t    TXDR;                 // [Write-only] Transmit Data Register
    reserved_t<3>        _1;
    volatile uint32_t    RXDR;                 // [Read-only] Receive Data Register
    reserved_t<3>        _2;
    volatile uint32_t    CRCPOLY;              // [Read-write] Polynomial Register
    volatile uint32_t    TXCRC;                // [Read-write] Transmitter CRC Register
    volatile uint32_t    RXCRC;                // [Read-write] Receiver CRC Register
    volatile uint32_t    UDRDR;                // [Read-write] Underrun Data Register
    volatile uint32_t    CGFR;                 // [Read-write] configuration register

    static constexpr uint32_t CR1_IOLOCK = 0x10000;     // Locking the AF configuration of associated IOs, Read-only
    static constexpr uint32_t CR1_TCRCI = 0x8000;       // CRC calculation initialization pattern control for transmitter, Read-write
    static constexpr uint32_t CR1_RCRCI = 0x4000;       // CRC calculation initialization pattern control for receiver, Read-write
    static constexpr uint32_t CR1_CRC33_17 = 0x2000;    // 32-bit CRC polynomial configuration, Read-write
    static constexpr uint32_t CR1_SSI = 0x1000;         // Internal SS signal input level, Read-write
    static constexpr uint32_t CR1_HDDIR = 0x800;        // Rx/Tx direction at Half-duplex mode, Read-write
    static constexpr uint32_t CR1_CSUSP = 0x400;        // Master SUSPend request, Write-only
    static constexpr uint32_t CR1_CSTART = 0x200;       // Master transfer start, Read-only
    static constexpr uint32_t CR1_MASRX = 0x100;        // Master automatic SUSP in Receive mode, Read-write
    static constexpr uint32_t CR1_SPE = 0x1;            // Serial Peripheral Enable, Read-write
    static const uint32_t CR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CR2_TSER =                // Number of data transfer extension to be reload into TSIZE just when a previous (16 bits), Read-only
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR2_TSIZE =               // Number of data at current transfer (16 bits), Read-write
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CFG1_MBR =                 // Master baud rate (3 bits)
        bit_field_t<28, 0x7>::value<X>();
    static constexpr uint32_t CFG1_CRCEN = 0x400000;     // Hardware CRC computation enable
    template<uint32_t X>
    static constexpr uint32_t CFG1_CRCSIZE =             // Length of CRC frame to be transacted and compared (5 bits)
        bit_field_t<16, 0x1f>::value<X>();
    static constexpr uint32_t CFG1_TXDMAEN = 0x8000;     // Tx DMA stream enable
    static constexpr uint32_t CFG1_RXDMAEN = 0x4000;     // Rx DMA stream enable
    template<uint32_t X>
    static constexpr uint32_t CFG1_UDRDET =              // Detection of underrun condition at slave transmitter (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFG1_UDRCFG =              // Behavior of slave transmitter at underrun condition (2 bits)
        bit_field_t<9, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFG1_FTHVL =               // threshold level (4 bits)
        bit_field_t<5, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFG1_DSIZE =               // Number of bits in at single SPI data frame (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t CFG1_RESET_VALUE = 0x70007;

    static constexpr uint32_t CFG2_AFCNTR = 0x80000000;  // Alternate function GPIOs control
    static constexpr uint32_t CFG2_SSOM = 0x40000000;    // SS output management in master mode
    static constexpr uint32_t CFG2_SSOE = 0x20000000;    // SS output enable
    static constexpr uint32_t CFG2_SSIOP = 0x10000000;   // SS input/output polarity
    static constexpr uint32_t CFG2_SSM = 0x4000000;      // Software management of SS signal input
    static constexpr uint32_t CFG2_CPOL = 0x2000000;     // Clock polarity
    static constexpr uint32_t CFG2_CPHA = 0x1000000;     // Clock phase
    static constexpr uint32_t CFG2_LSBFRST = 0x800000;   // Data frame format
    static constexpr uint32_t CFG2_MASTER = 0x400000;    // SPI Master
    template<uint32_t X>
    static constexpr uint32_t CFG2_SP =                  // Serial Protocol (3 bits)
        bit_field_t<19, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFG2_COMM =                // SPI Communication Mode (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    static constexpr uint32_t CFG2_IOSWP = 0x8000;       // Swap functionality of MISO and MOSI pins
    template<uint32_t X>
    static constexpr uint32_t CFG2_MIDI =                // Master Inter-Data Idleness (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFG2_MSSI =                // Master SS Idleness (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t CFG2_RESET_VALUE = 0x0;

    static constexpr uint32_t IER_TSERFIE = 0x400;      // Additional number of transactions reload interrupt enable, Read-write
    static constexpr uint32_t IER_MODFIE = 0x200;       // Mode Fault interrupt enable, Read-write
    static constexpr uint32_t IER_TIFREIE = 0x100;      // TIFRE interrupt enable, Read-write
    static constexpr uint32_t IER_CRCEIE = 0x80;        // CRC Interrupt enable, Read-write
    static constexpr uint32_t IER_OVRIE = 0x40;         // OVR interrupt enable, Read-write
    static constexpr uint32_t IER_UDRIE = 0x20;         // UDR interrupt enable, Read-write
    static constexpr uint32_t IER_TXTFIE = 0x10;        // TXTFIE interrupt enable, Read-write
    static constexpr uint32_t IER_EOTIE = 0x8;          // EOT, SUSP and TXC interrupt enable, Read-write
    static constexpr uint32_t IER_DPXPIE = 0x4;         // DXP interrupt enabled, Read-only
    static constexpr uint32_t IER_TXPIE = 0x2;          // TXP interrupt enable, Read-only
    static constexpr uint32_t IER_RXPIE = 0x1;          // RXP Interrupt Enable, Read-write
    static const uint32_t IER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SR_CTSIZE =              // Number of data frames remaining in current TSIZE session (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static constexpr uint32_t SR_RXWNE = 0x8000;       // RxFIFO Word Not Empty
    template<uint32_t X>
    static constexpr uint32_t SR_RXPLVL =              // RxFIFO Packing LeVeL (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    static constexpr uint32_t SR_TXC = 0x1000;         // TxFIFO transmission complete
    static constexpr uint32_t SR_SUSP = 0x800;         // SUSPend
    static constexpr uint32_t SR_TSERF = 0x400;        // Additional number of SPI data to be transacted was reload
    static constexpr uint32_t SR_MODF = 0x200;         // Mode Fault
    static constexpr uint32_t SR_TIFRE = 0x100;        // TI frame format error
    static constexpr uint32_t SR_CRCE = 0x80;          // CRC Error
    static constexpr uint32_t SR_OVR = 0x40;           // Overrun
    static constexpr uint32_t SR_UDR = 0x20;           // Underrun at slave transmission mode
    static constexpr uint32_t SR_TXTF = 0x10;          // Transmission Transfer Filled
    static constexpr uint32_t SR_EOT = 0x8;            // End Of Transfer
    static constexpr uint32_t SR_DXP = 0x4;            // Duplex Packet
    static constexpr uint32_t SR_TXP = 0x2;            // Tx-Packet space available
    static constexpr uint32_t SR_RXP = 0x1;            // Rx-Packet available
    static const uint32_t SR_RESET_VALUE = 0x1002;

    static constexpr uint32_t IFCR_SUSPC = 0x800;        // SUSPend flag clear
    static constexpr uint32_t IFCR_TSERFC = 0x400;       // TSERFC flag clear
    static constexpr uint32_t IFCR_MODFC = 0x200;        // Mode Fault flag clear
    static constexpr uint32_t IFCR_TIFREC = 0x100;       // TI frame format error flag clear
    static constexpr uint32_t IFCR_CRCEC = 0x80;         // CRC Error flag clear
    static constexpr uint32_t IFCR_OVRC = 0x40;          // Overrun flag clear
    static constexpr uint32_t IFCR_UDRC = 0x20;          // Underrun flag clear
    static constexpr uint32_t IFCR_TXTFC = 0x10;         // Transmission Transfer Filled flag clear
    static constexpr uint32_t IFCR_EOTC = 0x8;           // End Of Transfer flag clear
    static const uint32_t IFCR_RESET_VALUE = 0x0;


    static const uint32_t TXDR_RESET_VALUE = 0x0;


    static const uint32_t RXDR_RESET_VALUE = 0x0;


    static const uint32_t CRCPOLY_RESET_VALUE = 0x107;


    static const uint32_t TXCRC_RESET_VALUE = 0x0;


    static const uint32_t RXCRC_RESET_VALUE = 0x0;


    static const uint32_t UDRDR_RESET_VALUE = 0x0;

    static constexpr uint32_t CGFR_MCKOE = 0x2000000;    // Master clock output enable
    static constexpr uint32_t CGFR_ODD = 0x1000000;      // Odd factor for the prescaler
    template<uint32_t X>
    static constexpr uint32_t CGFR_I2SDIV =              // I2S linear prescaler (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static constexpr uint32_t CGFR_DATFMT = 0x4000;      // Data format
    static constexpr uint32_t CGFR_WSINV = 0x2000;       // Fixed channel length in SLAVE
    static constexpr uint32_t CGFR_FIXCH = 0x1000;       // Word select inversion
    static constexpr uint32_t CGFR_CKPOL = 0x800;        // Serial audio clock polarity
    static constexpr uint32_t CGFR_CHLEN = 0x400;        // Channel length (number of bits per audio channel)
    template<uint32_t X>
    static constexpr uint32_t CGFR_DATLEN =              // Data length to be transferred (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t CGFR_PCMSYNC = 0x80;       // PCM frame synchronization
    template<uint32_t X>
    static constexpr uint32_t CGFR_I2SSTD =              // I2S standard selection (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CGFR_I2SCFG =              // I2S configuration mode (3 bits)
        bit_field_t<1, 0x7>::value<X>();
    static constexpr uint32_t CGFR_I2SMOD = 0x1;         // I2S mode selection
    static const uint32_t CGFR_RESET_VALUE = 0x0;

    static constexpr uint8_t SPI2 = 36; // SPI2 global interrupt
};

static spi2_t& SPI2 = *reinterpret_cast<spi2_t*>(0x40003800);

#define HAVE_PERIPHERAL_SPI2


////
//
//    Serial peripheral interface
//
////

struct spi3_t
{
    volatile uint32_t    CR1;                  // control register 1
    volatile uint32_t    CR2;                  // control register 2
    volatile uint32_t    CFG1;                 // [Read-write] configuration register 1
    volatile uint32_t    CFG2;                 // [Read-write] configuration register 2
    volatile uint32_t    IER;                  // Interrupt Enable Register
    volatile uint32_t    SR;                   // [Read-only] Status Register
    volatile uint32_t    IFCR;                 // [Write-only] Interrupt/Status Flags Clear Register
    reserved_t<1>        _0;
    volatile uint32_t    TXDR;                 // [Write-only] Transmit Data Register
    reserved_t<3>        _1;
    volatile uint32_t    RXDR;                 // [Read-only] Receive Data Register
    reserved_t<3>        _2;
    volatile uint32_t    CRCPOLY;              // [Read-write] Polynomial Register
    volatile uint32_t    TXCRC;                // [Read-write] Transmitter CRC Register
    volatile uint32_t    RXCRC;                // [Read-write] Receiver CRC Register
    volatile uint32_t    UDRDR;                // [Read-write] Underrun Data Register
    volatile uint32_t    CGFR;                 // [Read-write] configuration register

    static constexpr uint32_t CR1_IOLOCK = 0x10000;     // Locking the AF configuration of associated IOs, Read-only
    static constexpr uint32_t CR1_TCRCI = 0x8000;       // CRC calculation initialization pattern control for transmitter, Read-write
    static constexpr uint32_t CR1_RCRCI = 0x4000;       // CRC calculation initialization pattern control for receiver, Read-write
    static constexpr uint32_t CR1_CRC33_17 = 0x2000;    // 32-bit CRC polynomial configuration, Read-write
    static constexpr uint32_t CR1_SSI = 0x1000;         // Internal SS signal input level, Read-write
    static constexpr uint32_t CR1_HDDIR = 0x800;        // Rx/Tx direction at Half-duplex mode, Read-write
    static constexpr uint32_t CR1_CSUSP = 0x400;        // Master SUSPend request, Write-only
    static constexpr uint32_t CR1_CSTART = 0x200;       // Master transfer start, Read-only
    static constexpr uint32_t CR1_MASRX = 0x100;        // Master automatic SUSP in Receive mode, Read-write
    static constexpr uint32_t CR1_SPE = 0x1;            // Serial Peripheral Enable, Read-write
    static const uint32_t CR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CR2_TSER =                // Number of data transfer extension to be reload into TSIZE just when a previous (16 bits), Read-only
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR2_TSIZE =               // Number of data at current transfer (16 bits), Read-write
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CFG1_MBR =                 // Master baud rate (3 bits)
        bit_field_t<28, 0x7>::value<X>();
    static constexpr uint32_t CFG1_CRCEN = 0x400000;     // Hardware CRC computation enable
    template<uint32_t X>
    static constexpr uint32_t CFG1_CRCSIZE =             // Length of CRC frame to be transacted and compared (5 bits)
        bit_field_t<16, 0x1f>::value<X>();
    static constexpr uint32_t CFG1_TXDMAEN = 0x8000;     // Tx DMA stream enable
    static constexpr uint32_t CFG1_RXDMAEN = 0x4000;     // Rx DMA stream enable
    template<uint32_t X>
    static constexpr uint32_t CFG1_UDRDET =              // Detection of underrun condition at slave transmitter (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFG1_UDRCFG =              // Behavior of slave transmitter at underrun condition (2 bits)
        bit_field_t<9, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFG1_FTHVL =               // threshold level (4 bits)
        bit_field_t<5, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFG1_DSIZE =               // Number of bits in at single SPI data frame (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t CFG1_RESET_VALUE = 0x70007;

    static constexpr uint32_t CFG2_AFCNTR = 0x80000000;  // Alternate function GPIOs control
    static constexpr uint32_t CFG2_SSOM = 0x40000000;    // SS output management in master mode
    static constexpr uint32_t CFG2_SSOE = 0x20000000;    // SS output enable
    static constexpr uint32_t CFG2_SSIOP = 0x10000000;   // SS input/output polarity
    static constexpr uint32_t CFG2_SSM = 0x4000000;      // Software management of SS signal input
    static constexpr uint32_t CFG2_CPOL = 0x2000000;     // Clock polarity
    static constexpr uint32_t CFG2_CPHA = 0x1000000;     // Clock phase
    static constexpr uint32_t CFG2_LSBFRST = 0x800000;   // Data frame format
    static constexpr uint32_t CFG2_MASTER = 0x400000;    // SPI Master
    template<uint32_t X>
    static constexpr uint32_t CFG2_SP =                  // Serial Protocol (3 bits)
        bit_field_t<19, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFG2_COMM =                // SPI Communication Mode (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    static constexpr uint32_t CFG2_IOSWP = 0x8000;       // Swap functionality of MISO and MOSI pins
    template<uint32_t X>
    static constexpr uint32_t CFG2_MIDI =                // Master Inter-Data Idleness (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFG2_MSSI =                // Master SS Idleness (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t CFG2_RESET_VALUE = 0x0;

    static constexpr uint32_t IER_TSERFIE = 0x400;      // Additional number of transactions reload interrupt enable, Read-write
    static constexpr uint32_t IER_MODFIE = 0x200;       // Mode Fault interrupt enable, Read-write
    static constexpr uint32_t IER_TIFREIE = 0x100;      // TIFRE interrupt enable, Read-write
    static constexpr uint32_t IER_CRCEIE = 0x80;        // CRC Interrupt enable, Read-write
    static constexpr uint32_t IER_OVRIE = 0x40;         // OVR interrupt enable, Read-write
    static constexpr uint32_t IER_UDRIE = 0x20;         // UDR interrupt enable, Read-write
    static constexpr uint32_t IER_TXTFIE = 0x10;        // TXTFIE interrupt enable, Read-write
    static constexpr uint32_t IER_EOTIE = 0x8;          // EOT, SUSP and TXC interrupt enable, Read-write
    static constexpr uint32_t IER_DPXPIE = 0x4;         // DXP interrupt enabled, Read-only
    static constexpr uint32_t IER_TXPIE = 0x2;          // TXP interrupt enable, Read-only
    static constexpr uint32_t IER_RXPIE = 0x1;          // RXP Interrupt Enable, Read-write
    static const uint32_t IER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SR_CTSIZE =              // Number of data frames remaining in current TSIZE session (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static constexpr uint32_t SR_RXWNE = 0x8000;       // RxFIFO Word Not Empty
    template<uint32_t X>
    static constexpr uint32_t SR_RXPLVL =              // RxFIFO Packing LeVeL (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    static constexpr uint32_t SR_TXC = 0x1000;         // TxFIFO transmission complete
    static constexpr uint32_t SR_SUSP = 0x800;         // SUSPend
    static constexpr uint32_t SR_TSERF = 0x400;        // Additional number of SPI data to be transacted was reload
    static constexpr uint32_t SR_MODF = 0x200;         // Mode Fault
    static constexpr uint32_t SR_TIFRE = 0x100;        // TI frame format error
    static constexpr uint32_t SR_CRCE = 0x80;          // CRC Error
    static constexpr uint32_t SR_OVR = 0x40;           // Overrun
    static constexpr uint32_t SR_UDR = 0x20;           // Underrun at slave transmission mode
    static constexpr uint32_t SR_TXTF = 0x10;          // Transmission Transfer Filled
    static constexpr uint32_t SR_EOT = 0x8;            // End Of Transfer
    static constexpr uint32_t SR_DXP = 0x4;            // Duplex Packet
    static constexpr uint32_t SR_TXP = 0x2;            // Tx-Packet space available
    static constexpr uint32_t SR_RXP = 0x1;            // Rx-Packet available
    static const uint32_t SR_RESET_VALUE = 0x1002;

    static constexpr uint32_t IFCR_SUSPC = 0x800;        // SUSPend flag clear
    static constexpr uint32_t IFCR_TSERFC = 0x400;       // TSERFC flag clear
    static constexpr uint32_t IFCR_MODFC = 0x200;        // Mode Fault flag clear
    static constexpr uint32_t IFCR_TIFREC = 0x100;       // TI frame format error flag clear
    static constexpr uint32_t IFCR_CRCEC = 0x80;         // CRC Error flag clear
    static constexpr uint32_t IFCR_OVRC = 0x40;          // Overrun flag clear
    static constexpr uint32_t IFCR_UDRC = 0x20;          // Underrun flag clear
    static constexpr uint32_t IFCR_TXTFC = 0x10;         // Transmission Transfer Filled flag clear
    static constexpr uint32_t IFCR_EOTC = 0x8;           // End Of Transfer flag clear
    static const uint32_t IFCR_RESET_VALUE = 0x0;


    static const uint32_t TXDR_RESET_VALUE = 0x0;


    static const uint32_t RXDR_RESET_VALUE = 0x0;


    static const uint32_t CRCPOLY_RESET_VALUE = 0x107;


    static const uint32_t TXCRC_RESET_VALUE = 0x0;


    static const uint32_t RXCRC_RESET_VALUE = 0x0;


    static const uint32_t UDRDR_RESET_VALUE = 0x0;

    static constexpr uint32_t CGFR_MCKOE = 0x2000000;    // Master clock output enable
    static constexpr uint32_t CGFR_ODD = 0x1000000;      // Odd factor for the prescaler
    template<uint32_t X>
    static constexpr uint32_t CGFR_I2SDIV =              // I2S linear prescaler (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static constexpr uint32_t CGFR_DATFMT = 0x4000;      // Data format
    static constexpr uint32_t CGFR_WSINV = 0x2000;       // Fixed channel length in SLAVE
    static constexpr uint32_t CGFR_FIXCH = 0x1000;       // Word select inversion
    static constexpr uint32_t CGFR_CKPOL = 0x800;        // Serial audio clock polarity
    static constexpr uint32_t CGFR_CHLEN = 0x400;        // Channel length (number of bits per audio channel)
    template<uint32_t X>
    static constexpr uint32_t CGFR_DATLEN =              // Data length to be transferred (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t CGFR_PCMSYNC = 0x80;       // PCM frame synchronization
    template<uint32_t X>
    static constexpr uint32_t CGFR_I2SSTD =              // I2S standard selection (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CGFR_I2SCFG =              // I2S configuration mode (3 bits)
        bit_field_t<1, 0x7>::value<X>();
    static constexpr uint32_t CGFR_I2SMOD = 0x1;         // I2S mode selection
    static const uint32_t CGFR_RESET_VALUE = 0x0;

    static constexpr uint8_t SPI3 = 51; // SPI3 global interrupt
};

static spi3_t& SPI3 = *reinterpret_cast<spi3_t*>(0x40003c00);

#define HAVE_PERIPHERAL_SPI3


////
//
//    Serial peripheral interface
//
////

struct spi4_t
{
    volatile uint32_t    CR1;                  // control register 1
    volatile uint32_t    CR2;                  // control register 2
    volatile uint32_t    CFG1;                 // [Read-write] configuration register 1
    volatile uint32_t    CFG2;                 // [Read-write] configuration register 2
    volatile uint32_t    IER;                  // Interrupt Enable Register
    volatile uint32_t    SR;                   // [Read-only] Status Register
    volatile uint32_t    IFCR;                 // [Write-only] Interrupt/Status Flags Clear Register
    reserved_t<1>        _0;
    volatile uint32_t    TXDR;                 // [Write-only] Transmit Data Register
    reserved_t<3>        _1;
    volatile uint32_t    RXDR;                 // [Read-only] Receive Data Register
    reserved_t<3>        _2;
    volatile uint32_t    CRCPOLY;              // [Read-write] Polynomial Register
    volatile uint32_t    TXCRC;                // [Read-write] Transmitter CRC Register
    volatile uint32_t    RXCRC;                // [Read-write] Receiver CRC Register
    volatile uint32_t    UDRDR;                // [Read-write] Underrun Data Register
    volatile uint32_t    CGFR;                 // [Read-write] configuration register

    static constexpr uint32_t CR1_IOLOCK = 0x10000;     // Locking the AF configuration of associated IOs, Read-only
    static constexpr uint32_t CR1_TCRCI = 0x8000;       // CRC calculation initialization pattern control for transmitter, Read-write
    static constexpr uint32_t CR1_RCRCI = 0x4000;       // CRC calculation initialization pattern control for receiver, Read-write
    static constexpr uint32_t CR1_CRC33_17 = 0x2000;    // 32-bit CRC polynomial configuration, Read-write
    static constexpr uint32_t CR1_SSI = 0x1000;         // Internal SS signal input level, Read-write
    static constexpr uint32_t CR1_HDDIR = 0x800;        // Rx/Tx direction at Half-duplex mode, Read-write
    static constexpr uint32_t CR1_CSUSP = 0x400;        // Master SUSPend request, Write-only
    static constexpr uint32_t CR1_CSTART = 0x200;       // Master transfer start, Read-only
    static constexpr uint32_t CR1_MASRX = 0x100;        // Master automatic SUSP in Receive mode, Read-write
    static constexpr uint32_t CR1_SPE = 0x1;            // Serial Peripheral Enable, Read-write
    static const uint32_t CR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CR2_TSER =                // Number of data transfer extension to be reload into TSIZE just when a previous (16 bits), Read-only
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR2_TSIZE =               // Number of data at current transfer (16 bits), Read-write
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CFG1_MBR =                 // Master baud rate (3 bits)
        bit_field_t<28, 0x7>::value<X>();
    static constexpr uint32_t CFG1_CRCEN = 0x400000;     // Hardware CRC computation enable
    template<uint32_t X>
    static constexpr uint32_t CFG1_CRCSIZE =             // Length of CRC frame to be transacted and compared (5 bits)
        bit_field_t<16, 0x1f>::value<X>();
    static constexpr uint32_t CFG1_TXDMAEN = 0x8000;     // Tx DMA stream enable
    static constexpr uint32_t CFG1_RXDMAEN = 0x4000;     // Rx DMA stream enable
    template<uint32_t X>
    static constexpr uint32_t CFG1_UDRDET =              // Detection of underrun condition at slave transmitter (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFG1_UDRCFG =              // Behavior of slave transmitter at underrun condition (2 bits)
        bit_field_t<9, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFG1_FTHVL =               // threshold level (4 bits)
        bit_field_t<5, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFG1_DSIZE =               // Number of bits in at single SPI data frame (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t CFG1_RESET_VALUE = 0x70007;

    static constexpr uint32_t CFG2_AFCNTR = 0x80000000;  // Alternate function GPIOs control
    static constexpr uint32_t CFG2_SSOM = 0x40000000;    // SS output management in master mode
    static constexpr uint32_t CFG2_SSOE = 0x20000000;    // SS output enable
    static constexpr uint32_t CFG2_SSIOP = 0x10000000;   // SS input/output polarity
    static constexpr uint32_t CFG2_SSM = 0x4000000;      // Software management of SS signal input
    static constexpr uint32_t CFG2_CPOL = 0x2000000;     // Clock polarity
    static constexpr uint32_t CFG2_CPHA = 0x1000000;     // Clock phase
    static constexpr uint32_t CFG2_LSBFRST = 0x800000;   // Data frame format
    static constexpr uint32_t CFG2_MASTER = 0x400000;    // SPI Master
    template<uint32_t X>
    static constexpr uint32_t CFG2_SP =                  // Serial Protocol (3 bits)
        bit_field_t<19, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFG2_COMM =                // SPI Communication Mode (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    static constexpr uint32_t CFG2_IOSWP = 0x8000;       // Swap functionality of MISO and MOSI pins
    template<uint32_t X>
    static constexpr uint32_t CFG2_MIDI =                // Master Inter-Data Idleness (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFG2_MSSI =                // Master SS Idleness (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t CFG2_RESET_VALUE = 0x0;

    static constexpr uint32_t IER_TSERFIE = 0x400;      // Additional number of transactions reload interrupt enable, Read-write
    static constexpr uint32_t IER_MODFIE = 0x200;       // Mode Fault interrupt enable, Read-write
    static constexpr uint32_t IER_TIFREIE = 0x100;      // TIFRE interrupt enable, Read-write
    static constexpr uint32_t IER_CRCEIE = 0x80;        // CRC Interrupt enable, Read-write
    static constexpr uint32_t IER_OVRIE = 0x40;         // OVR interrupt enable, Read-write
    static constexpr uint32_t IER_UDRIE = 0x20;         // UDR interrupt enable, Read-write
    static constexpr uint32_t IER_TXTFIE = 0x10;        // TXTFIE interrupt enable, Read-write
    static constexpr uint32_t IER_EOTIE = 0x8;          // EOT, SUSP and TXC interrupt enable, Read-write
    static constexpr uint32_t IER_DPXPIE = 0x4;         // DXP interrupt enabled, Read-only
    static constexpr uint32_t IER_TXPIE = 0x2;          // TXP interrupt enable, Read-only
    static constexpr uint32_t IER_RXPIE = 0x1;          // RXP Interrupt Enable, Read-write
    static const uint32_t IER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SR_CTSIZE =              // Number of data frames remaining in current TSIZE session (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static constexpr uint32_t SR_RXWNE = 0x8000;       // RxFIFO Word Not Empty
    template<uint32_t X>
    static constexpr uint32_t SR_RXPLVL =              // RxFIFO Packing LeVeL (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    static constexpr uint32_t SR_TXC = 0x1000;         // TxFIFO transmission complete
    static constexpr uint32_t SR_SUSP = 0x800;         // SUSPend
    static constexpr uint32_t SR_TSERF = 0x400;        // Additional number of SPI data to be transacted was reload
    static constexpr uint32_t SR_MODF = 0x200;         // Mode Fault
    static constexpr uint32_t SR_TIFRE = 0x100;        // TI frame format error
    static constexpr uint32_t SR_CRCE = 0x80;          // CRC Error
    static constexpr uint32_t SR_OVR = 0x40;           // Overrun
    static constexpr uint32_t SR_UDR = 0x20;           // Underrun at slave transmission mode
    static constexpr uint32_t SR_TXTF = 0x10;          // Transmission Transfer Filled
    static constexpr uint32_t SR_EOT = 0x8;            // End Of Transfer
    static constexpr uint32_t SR_DXP = 0x4;            // Duplex Packet
    static constexpr uint32_t SR_TXP = 0x2;            // Tx-Packet space available
    static constexpr uint32_t SR_RXP = 0x1;            // Rx-Packet available
    static const uint32_t SR_RESET_VALUE = 0x1002;

    static constexpr uint32_t IFCR_SUSPC = 0x800;        // SUSPend flag clear
    static constexpr uint32_t IFCR_TSERFC = 0x400;       // TSERFC flag clear
    static constexpr uint32_t IFCR_MODFC = 0x200;        // Mode Fault flag clear
    static constexpr uint32_t IFCR_TIFREC = 0x100;       // TI frame format error flag clear
    static constexpr uint32_t IFCR_CRCEC = 0x80;         // CRC Error flag clear
    static constexpr uint32_t IFCR_OVRC = 0x40;          // Overrun flag clear
    static constexpr uint32_t IFCR_UDRC = 0x20;          // Underrun flag clear
    static constexpr uint32_t IFCR_TXTFC = 0x10;         // Transmission Transfer Filled flag clear
    static constexpr uint32_t IFCR_EOTC = 0x8;           // End Of Transfer flag clear
    static const uint32_t IFCR_RESET_VALUE = 0x0;


    static const uint32_t TXDR_RESET_VALUE = 0x0;


    static const uint32_t RXDR_RESET_VALUE = 0x0;


    static const uint32_t CRCPOLY_RESET_VALUE = 0x107;


    static const uint32_t TXCRC_RESET_VALUE = 0x0;


    static const uint32_t RXCRC_RESET_VALUE = 0x0;


    static const uint32_t UDRDR_RESET_VALUE = 0x0;

    static constexpr uint32_t CGFR_MCKOE = 0x2000000;    // Master clock output enable
    static constexpr uint32_t CGFR_ODD = 0x1000000;      // Odd factor for the prescaler
    template<uint32_t X>
    static constexpr uint32_t CGFR_I2SDIV =              // I2S linear prescaler (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static constexpr uint32_t CGFR_DATFMT = 0x4000;      // Data format
    static constexpr uint32_t CGFR_WSINV = 0x2000;       // Fixed channel length in SLAVE
    static constexpr uint32_t CGFR_FIXCH = 0x1000;       // Word select inversion
    static constexpr uint32_t CGFR_CKPOL = 0x800;        // Serial audio clock polarity
    static constexpr uint32_t CGFR_CHLEN = 0x400;        // Channel length (number of bits per audio channel)
    template<uint32_t X>
    static constexpr uint32_t CGFR_DATLEN =              // Data length to be transferred (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t CGFR_PCMSYNC = 0x80;       // PCM frame synchronization
    template<uint32_t X>
    static constexpr uint32_t CGFR_I2SSTD =              // I2S standard selection (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CGFR_I2SCFG =              // I2S configuration mode (3 bits)
        bit_field_t<1, 0x7>::value<X>();
    static constexpr uint32_t CGFR_I2SMOD = 0x1;         // I2S mode selection
    static const uint32_t CGFR_RESET_VALUE = 0x0;

    static constexpr uint8_t SPI4 = 84; // SPI4 global interrupt
};

static spi4_t& SPI4 = *reinterpret_cast<spi4_t*>(0x40013400);

#define HAVE_PERIPHERAL_SPI4


////
//
//    Serial peripheral interface
//
////

struct spi5_t
{
    volatile uint32_t    CR1;                  // control register 1
    volatile uint32_t    CR2;                  // control register 2
    volatile uint32_t    CFG1;                 // [Read-write] configuration register 1
    volatile uint32_t    CFG2;                 // [Read-write] configuration register 2
    volatile uint32_t    IER;                  // Interrupt Enable Register
    volatile uint32_t    SR;                   // [Read-only] Status Register
    volatile uint32_t    IFCR;                 // [Write-only] Interrupt/Status Flags Clear Register
    reserved_t<1>        _0;
    volatile uint32_t    TXDR;                 // [Write-only] Transmit Data Register
    reserved_t<3>        _1;
    volatile uint32_t    RXDR;                 // [Read-only] Receive Data Register
    reserved_t<3>        _2;
    volatile uint32_t    CRCPOLY;              // [Read-write] Polynomial Register
    volatile uint32_t    TXCRC;                // [Read-write] Transmitter CRC Register
    volatile uint32_t    RXCRC;                // [Read-write] Receiver CRC Register
    volatile uint32_t    UDRDR;                // [Read-write] Underrun Data Register
    volatile uint32_t    CGFR;                 // [Read-write] configuration register

    static constexpr uint32_t CR1_IOLOCK = 0x10000;     // Locking the AF configuration of associated IOs, Read-only
    static constexpr uint32_t CR1_TCRCI = 0x8000;       // CRC calculation initialization pattern control for transmitter, Read-write
    static constexpr uint32_t CR1_RCRCI = 0x4000;       // CRC calculation initialization pattern control for receiver, Read-write
    static constexpr uint32_t CR1_CRC33_17 = 0x2000;    // 32-bit CRC polynomial configuration, Read-write
    static constexpr uint32_t CR1_SSI = 0x1000;         // Internal SS signal input level, Read-write
    static constexpr uint32_t CR1_HDDIR = 0x800;        // Rx/Tx direction at Half-duplex mode, Read-write
    static constexpr uint32_t CR1_CSUSP = 0x400;        // Master SUSPend request, Write-only
    static constexpr uint32_t CR1_CSTART = 0x200;       // Master transfer start, Read-only
    static constexpr uint32_t CR1_MASRX = 0x100;        // Master automatic SUSP in Receive mode, Read-write
    static constexpr uint32_t CR1_SPE = 0x1;            // Serial Peripheral Enable, Read-write
    static const uint32_t CR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CR2_TSER =                // Number of data transfer extension to be reload into TSIZE just when a previous (16 bits), Read-only
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR2_TSIZE =               // Number of data at current transfer (16 bits), Read-write
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CFG1_MBR =                 // Master baud rate (3 bits)
        bit_field_t<28, 0x7>::value<X>();
    static constexpr uint32_t CFG1_CRCEN = 0x400000;     // Hardware CRC computation enable
    template<uint32_t X>
    static constexpr uint32_t CFG1_CRCSIZE =             // Length of CRC frame to be transacted and compared (5 bits)
        bit_field_t<16, 0x1f>::value<X>();
    static constexpr uint32_t CFG1_TXDMAEN = 0x8000;     // Tx DMA stream enable
    static constexpr uint32_t CFG1_RXDMAEN = 0x4000;     // Rx DMA stream enable
    template<uint32_t X>
    static constexpr uint32_t CFG1_UDRDET =              // Detection of underrun condition at slave transmitter (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFG1_UDRCFG =              // Behavior of slave transmitter at underrun condition (2 bits)
        bit_field_t<9, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFG1_FTHVL =               // threshold level (4 bits)
        bit_field_t<5, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFG1_DSIZE =               // Number of bits in at single SPI data frame (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t CFG1_RESET_VALUE = 0x70007;

    static constexpr uint32_t CFG2_AFCNTR = 0x80000000;  // Alternate function GPIOs control
    static constexpr uint32_t CFG2_SSOM = 0x40000000;    // SS output management in master mode
    static constexpr uint32_t CFG2_SSOE = 0x20000000;    // SS output enable
    static constexpr uint32_t CFG2_SSIOP = 0x10000000;   // SS input/output polarity
    static constexpr uint32_t CFG2_SSM = 0x4000000;      // Software management of SS signal input
    static constexpr uint32_t CFG2_CPOL = 0x2000000;     // Clock polarity
    static constexpr uint32_t CFG2_CPHA = 0x1000000;     // Clock phase
    static constexpr uint32_t CFG2_LSBFRST = 0x800000;   // Data frame format
    static constexpr uint32_t CFG2_MASTER = 0x400000;    // SPI Master
    template<uint32_t X>
    static constexpr uint32_t CFG2_SP =                  // Serial Protocol (3 bits)
        bit_field_t<19, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFG2_COMM =                // SPI Communication Mode (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    static constexpr uint32_t CFG2_IOSWP = 0x8000;       // Swap functionality of MISO and MOSI pins
    template<uint32_t X>
    static constexpr uint32_t CFG2_MIDI =                // Master Inter-Data Idleness (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFG2_MSSI =                // Master SS Idleness (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t CFG2_RESET_VALUE = 0x0;

    static constexpr uint32_t IER_TSERFIE = 0x400;      // Additional number of transactions reload interrupt enable, Read-write
    static constexpr uint32_t IER_MODFIE = 0x200;       // Mode Fault interrupt enable, Read-write
    static constexpr uint32_t IER_TIFREIE = 0x100;      // TIFRE interrupt enable, Read-write
    static constexpr uint32_t IER_CRCEIE = 0x80;        // CRC Interrupt enable, Read-write
    static constexpr uint32_t IER_OVRIE = 0x40;         // OVR interrupt enable, Read-write
    static constexpr uint32_t IER_UDRIE = 0x20;         // UDR interrupt enable, Read-write
    static constexpr uint32_t IER_TXTFIE = 0x10;        // TXTFIE interrupt enable, Read-write
    static constexpr uint32_t IER_EOTIE = 0x8;          // EOT, SUSP and TXC interrupt enable, Read-write
    static constexpr uint32_t IER_DPXPIE = 0x4;         // DXP interrupt enabled, Read-only
    static constexpr uint32_t IER_TXPIE = 0x2;          // TXP interrupt enable, Read-only
    static constexpr uint32_t IER_RXPIE = 0x1;          // RXP Interrupt Enable, Read-write
    static const uint32_t IER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SR_CTSIZE =              // Number of data frames remaining in current TSIZE session (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static constexpr uint32_t SR_RXWNE = 0x8000;       // RxFIFO Word Not Empty
    template<uint32_t X>
    static constexpr uint32_t SR_RXPLVL =              // RxFIFO Packing LeVeL (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    static constexpr uint32_t SR_TXC = 0x1000;         // TxFIFO transmission complete
    static constexpr uint32_t SR_SUSP = 0x800;         // SUSPend
    static constexpr uint32_t SR_TSERF = 0x400;        // Additional number of SPI data to be transacted was reload
    static constexpr uint32_t SR_MODF = 0x200;         // Mode Fault
    static constexpr uint32_t SR_TIFRE = 0x100;        // TI frame format error
    static constexpr uint32_t SR_CRCE = 0x80;          // CRC Error
    static constexpr uint32_t SR_OVR = 0x40;           // Overrun
    static constexpr uint32_t SR_UDR = 0x20;           // Underrun at slave transmission mode
    static constexpr uint32_t SR_TXTF = 0x10;          // Transmission Transfer Filled
    static constexpr uint32_t SR_EOT = 0x8;            // End Of Transfer
    static constexpr uint32_t SR_DXP = 0x4;            // Duplex Packet
    static constexpr uint32_t SR_TXP = 0x2;            // Tx-Packet space available
    static constexpr uint32_t SR_RXP = 0x1;            // Rx-Packet available
    static const uint32_t SR_RESET_VALUE = 0x1002;

    static constexpr uint32_t IFCR_SUSPC = 0x800;        // SUSPend flag clear
    static constexpr uint32_t IFCR_TSERFC = 0x400;       // TSERFC flag clear
    static constexpr uint32_t IFCR_MODFC = 0x200;        // Mode Fault flag clear
    static constexpr uint32_t IFCR_TIFREC = 0x100;       // TI frame format error flag clear
    static constexpr uint32_t IFCR_CRCEC = 0x80;         // CRC Error flag clear
    static constexpr uint32_t IFCR_OVRC = 0x40;          // Overrun flag clear
    static constexpr uint32_t IFCR_UDRC = 0x20;          // Underrun flag clear
    static constexpr uint32_t IFCR_TXTFC = 0x10;         // Transmission Transfer Filled flag clear
    static constexpr uint32_t IFCR_EOTC = 0x8;           // End Of Transfer flag clear
    static const uint32_t IFCR_RESET_VALUE = 0x0;


    static const uint32_t TXDR_RESET_VALUE = 0x0;


    static const uint32_t RXDR_RESET_VALUE = 0x0;


    static const uint32_t CRCPOLY_RESET_VALUE = 0x107;


    static const uint32_t TXCRC_RESET_VALUE = 0x0;


    static const uint32_t RXCRC_RESET_VALUE = 0x0;


    static const uint32_t UDRDR_RESET_VALUE = 0x0;

    static constexpr uint32_t CGFR_MCKOE = 0x2000000;    // Master clock output enable
    static constexpr uint32_t CGFR_ODD = 0x1000000;      // Odd factor for the prescaler
    template<uint32_t X>
    static constexpr uint32_t CGFR_I2SDIV =              // I2S linear prescaler (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static constexpr uint32_t CGFR_DATFMT = 0x4000;      // Data format
    static constexpr uint32_t CGFR_WSINV = 0x2000;       // Fixed channel length in SLAVE
    static constexpr uint32_t CGFR_FIXCH = 0x1000;       // Word select inversion
    static constexpr uint32_t CGFR_CKPOL = 0x800;        // Serial audio clock polarity
    static constexpr uint32_t CGFR_CHLEN = 0x400;        // Channel length (number of bits per audio channel)
    template<uint32_t X>
    static constexpr uint32_t CGFR_DATLEN =              // Data length to be transferred (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t CGFR_PCMSYNC = 0x80;       // PCM frame synchronization
    template<uint32_t X>
    static constexpr uint32_t CGFR_I2SSTD =              // I2S standard selection (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CGFR_I2SCFG =              // I2S configuration mode (3 bits)
        bit_field_t<1, 0x7>::value<X>();
    static constexpr uint32_t CGFR_I2SMOD = 0x1;         // I2S mode selection
    static const uint32_t CGFR_RESET_VALUE = 0x0;

    static constexpr uint8_t SPI5 = 85; // SPI5 global interrupt
};

static spi5_t& SPI5 = *reinterpret_cast<spi5_t*>(0x40015000);

#define HAVE_PERIPHERAL_SPI5


////
//
//    Serial peripheral interface
//
////

struct spi6_t
{
    volatile uint32_t    CR1;                  // control register 1
    volatile uint32_t    CR2;                  // control register 2
    volatile uint32_t    CFG1;                 // [Read-write] configuration register 1
    volatile uint32_t    CFG2;                 // [Read-write] configuration register 2
    volatile uint32_t    IER;                  // Interrupt Enable Register
    volatile uint32_t    SR;                   // [Read-only] Status Register
    volatile uint32_t    IFCR;                 // [Write-only] Interrupt/Status Flags Clear Register
    reserved_t<1>        _0;
    volatile uint32_t    TXDR;                 // [Write-only] Transmit Data Register
    reserved_t<3>        _1;
    volatile uint32_t    RXDR;                 // [Read-only] Receive Data Register
    reserved_t<3>        _2;
    volatile uint32_t    CRCPOLY;              // [Read-write] Polynomial Register
    volatile uint32_t    TXCRC;                // [Read-write] Transmitter CRC Register
    volatile uint32_t    RXCRC;                // [Read-write] Receiver CRC Register
    volatile uint32_t    UDRDR;                // [Read-write] Underrun Data Register
    volatile uint32_t    CGFR;                 // [Read-write] configuration register

    static constexpr uint32_t CR1_IOLOCK = 0x10000;     // Locking the AF configuration of associated IOs, Read-only
    static constexpr uint32_t CR1_TCRCI = 0x8000;       // CRC calculation initialization pattern control for transmitter, Read-write
    static constexpr uint32_t CR1_RCRCI = 0x4000;       // CRC calculation initialization pattern control for receiver, Read-write
    static constexpr uint32_t CR1_CRC33_17 = 0x2000;    // 32-bit CRC polynomial configuration, Read-write
    static constexpr uint32_t CR1_SSI = 0x1000;         // Internal SS signal input level, Read-write
    static constexpr uint32_t CR1_HDDIR = 0x800;        // Rx/Tx direction at Half-duplex mode, Read-write
    static constexpr uint32_t CR1_CSUSP = 0x400;        // Master SUSPend request, Write-only
    static constexpr uint32_t CR1_CSTART = 0x200;       // Master transfer start, Read-only
    static constexpr uint32_t CR1_MASRX = 0x100;        // Master automatic SUSP in Receive mode, Read-write
    static constexpr uint32_t CR1_SPE = 0x1;            // Serial Peripheral Enable, Read-write
    static const uint32_t CR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CR2_TSER =                // Number of data transfer extension to be reload into TSIZE just when a previous (16 bits), Read-only
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR2_TSIZE =               // Number of data at current transfer (16 bits), Read-write
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CFG1_MBR =                 // Master baud rate (3 bits)
        bit_field_t<28, 0x7>::value<X>();
    static constexpr uint32_t CFG1_CRCEN = 0x400000;     // Hardware CRC computation enable
    template<uint32_t X>
    static constexpr uint32_t CFG1_CRCSIZE =             // Length of CRC frame to be transacted and compared (5 bits)
        bit_field_t<16, 0x1f>::value<X>();
    static constexpr uint32_t CFG1_TXDMAEN = 0x8000;     // Tx DMA stream enable
    static constexpr uint32_t CFG1_RXDMAEN = 0x4000;     // Rx DMA stream enable
    template<uint32_t X>
    static constexpr uint32_t CFG1_UDRDET =              // Detection of underrun condition at slave transmitter (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFG1_UDRCFG =              // Behavior of slave transmitter at underrun condition (2 bits)
        bit_field_t<9, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFG1_FTHVL =               // threshold level (4 bits)
        bit_field_t<5, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFG1_DSIZE =               // Number of bits in at single SPI data frame (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t CFG1_RESET_VALUE = 0x70007;

    static constexpr uint32_t CFG2_AFCNTR = 0x80000000;  // Alternate function GPIOs control
    static constexpr uint32_t CFG2_SSOM = 0x40000000;    // SS output management in master mode
    static constexpr uint32_t CFG2_SSOE = 0x20000000;    // SS output enable
    static constexpr uint32_t CFG2_SSIOP = 0x10000000;   // SS input/output polarity
    static constexpr uint32_t CFG2_SSM = 0x4000000;      // Software management of SS signal input
    static constexpr uint32_t CFG2_CPOL = 0x2000000;     // Clock polarity
    static constexpr uint32_t CFG2_CPHA = 0x1000000;     // Clock phase
    static constexpr uint32_t CFG2_LSBFRST = 0x800000;   // Data frame format
    static constexpr uint32_t CFG2_MASTER = 0x400000;    // SPI Master
    template<uint32_t X>
    static constexpr uint32_t CFG2_SP =                  // Serial Protocol (3 bits)
        bit_field_t<19, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFG2_COMM =                // SPI Communication Mode (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    static constexpr uint32_t CFG2_IOSWP = 0x8000;       // Swap functionality of MISO and MOSI pins
    template<uint32_t X>
    static constexpr uint32_t CFG2_MIDI =                // Master Inter-Data Idleness (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFG2_MSSI =                // Master SS Idleness (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t CFG2_RESET_VALUE = 0x0;

    static constexpr uint32_t IER_TSERFIE = 0x400;      // Additional number of transactions reload interrupt enable, Read-write
    static constexpr uint32_t IER_MODFIE = 0x200;       // Mode Fault interrupt enable, Read-write
    static constexpr uint32_t IER_TIFREIE = 0x100;      // TIFRE interrupt enable, Read-write
    static constexpr uint32_t IER_CRCEIE = 0x80;        // CRC Interrupt enable, Read-write
    static constexpr uint32_t IER_OVRIE = 0x40;         // OVR interrupt enable, Read-write
    static constexpr uint32_t IER_UDRIE = 0x20;         // UDR interrupt enable, Read-write
    static constexpr uint32_t IER_TXTFIE = 0x10;        // TXTFIE interrupt enable, Read-write
    static constexpr uint32_t IER_EOTIE = 0x8;          // EOT, SUSP and TXC interrupt enable, Read-write
    static constexpr uint32_t IER_DPXPIE = 0x4;         // DXP interrupt enabled, Read-only
    static constexpr uint32_t IER_TXPIE = 0x2;          // TXP interrupt enable, Read-only
    static constexpr uint32_t IER_RXPIE = 0x1;          // RXP Interrupt Enable, Read-write
    static const uint32_t IER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SR_CTSIZE =              // Number of data frames remaining in current TSIZE session (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static constexpr uint32_t SR_RXWNE = 0x8000;       // RxFIFO Word Not Empty
    template<uint32_t X>
    static constexpr uint32_t SR_RXPLVL =              // RxFIFO Packing LeVeL (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    static constexpr uint32_t SR_TXC = 0x1000;         // TxFIFO transmission complete
    static constexpr uint32_t SR_SUSP = 0x800;         // SUSPend
    static constexpr uint32_t SR_TSERF = 0x400;        // Additional number of SPI data to be transacted was reload
    static constexpr uint32_t SR_MODF = 0x200;         // Mode Fault
    static constexpr uint32_t SR_TIFRE = 0x100;        // TI frame format error
    static constexpr uint32_t SR_CRCE = 0x80;          // CRC Error
    static constexpr uint32_t SR_OVR = 0x40;           // Overrun
    static constexpr uint32_t SR_UDR = 0x20;           // Underrun at slave transmission mode
    static constexpr uint32_t SR_TXTF = 0x10;          // Transmission Transfer Filled
    static constexpr uint32_t SR_EOT = 0x8;            // End Of Transfer
    static constexpr uint32_t SR_DXP = 0x4;            // Duplex Packet
    static constexpr uint32_t SR_TXP = 0x2;            // Tx-Packet space available
    static constexpr uint32_t SR_RXP = 0x1;            // Rx-Packet available
    static const uint32_t SR_RESET_VALUE = 0x1002;

    static constexpr uint32_t IFCR_SUSPC = 0x800;        // SUSPend flag clear
    static constexpr uint32_t IFCR_TSERFC = 0x400;       // TSERFC flag clear
    static constexpr uint32_t IFCR_MODFC = 0x200;        // Mode Fault flag clear
    static constexpr uint32_t IFCR_TIFREC = 0x100;       // TI frame format error flag clear
    static constexpr uint32_t IFCR_CRCEC = 0x80;         // CRC Error flag clear
    static constexpr uint32_t IFCR_OVRC = 0x40;          // Overrun flag clear
    static constexpr uint32_t IFCR_UDRC = 0x20;          // Underrun flag clear
    static constexpr uint32_t IFCR_TXTFC = 0x10;         // Transmission Transfer Filled flag clear
    static constexpr uint32_t IFCR_EOTC = 0x8;           // End Of Transfer flag clear
    static const uint32_t IFCR_RESET_VALUE = 0x0;


    static const uint32_t TXDR_RESET_VALUE = 0x0;


    static const uint32_t RXDR_RESET_VALUE = 0x0;


    static const uint32_t CRCPOLY_RESET_VALUE = 0x107;


    static const uint32_t TXCRC_RESET_VALUE = 0x0;


    static const uint32_t RXCRC_RESET_VALUE = 0x0;


    static const uint32_t UDRDR_RESET_VALUE = 0x0;

    static constexpr uint32_t CGFR_MCKOE = 0x2000000;    // Master clock output enable
    static constexpr uint32_t CGFR_ODD = 0x1000000;      // Odd factor for the prescaler
    template<uint32_t X>
    static constexpr uint32_t CGFR_I2SDIV =              // I2S linear prescaler (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static constexpr uint32_t CGFR_DATFMT = 0x4000;      // Data format
    static constexpr uint32_t CGFR_WSINV = 0x2000;       // Fixed channel length in SLAVE
    static constexpr uint32_t CGFR_FIXCH = 0x1000;       // Word select inversion
    static constexpr uint32_t CGFR_CKPOL = 0x800;        // Serial audio clock polarity
    static constexpr uint32_t CGFR_CHLEN = 0x400;        // Channel length (number of bits per audio channel)
    template<uint32_t X>
    static constexpr uint32_t CGFR_DATLEN =              // Data length to be transferred (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t CGFR_PCMSYNC = 0x80;       // PCM frame synchronization
    template<uint32_t X>
    static constexpr uint32_t CGFR_I2SSTD =              // I2S standard selection (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CGFR_I2SCFG =              // I2S configuration mode (3 bits)
        bit_field_t<1, 0x7>::value<X>();
    static constexpr uint32_t CGFR_I2SMOD = 0x1;         // I2S mode selection
    static const uint32_t CGFR_RESET_VALUE = 0x0;

    static constexpr uint8_t SPI6 = 86; // SPI6 global interrupt
};

static spi6_t& SPI6 = *reinterpret_cast<spi6_t*>(0x58001400);

#define HAVE_PERIPHERAL_SPI6


////
//
//    LCD-TFT Controller
//
////

struct ltdc_t
{
    volatile uint32_t    SSCR;                 // [Read-write] Synchronization Size Configuration Register
    volatile uint32_t    BPCR;                 // [Read-write] Back Porch Configuration Register
    volatile uint32_t    AWCR;                 // [Read-write] Active Width Configuration Register
    volatile uint32_t    TWCR;                 // [Read-write] Total Width Configuration Register
    volatile uint32_t    GCR;                  // Global Control Register
    reserved_t<2>        _0;
    volatile uint32_t    SRCR;                 // [Read-write] Shadow Reload Configuration Register
    reserved_t<1>        _1;
    volatile uint32_t    BCCR;                 // [Read-write] Background Color Configuration Register
    reserved_t<1>        _2;
    volatile uint32_t    IER;                  // [Read-write] Interrupt Enable Register
    volatile uint32_t    ISR;                  // [Read-only] Interrupt Status Register
    volatile uint32_t    ICR;                  // [Write-only] Interrupt Clear Register
    volatile uint32_t    LIPCR;                // [Read-write] Line Interrupt Position Configuration Register
    volatile uint32_t    CPSR;                 // [Read-only] Current Position Status Register
    volatile uint32_t    CDSR;                 // [Read-only] Current Display Status Register
    reserved_t<14>       _3;
    volatile uint32_t    L1CR;                 // [Read-write] Layerx Control Register
    volatile uint32_t    L1WHPCR;              // [Read-write] Layerx Window Horizontal Position Configuration Register
    volatile uint32_t    L1WVPCR;              // [Read-write] Layerx Window Vertical Position Configuration Register
    volatile uint32_t    L1CKCR;               // [Read-write] Layerx Color Keying Configuration Register
    volatile uint32_t    L1PFCR;               // [Read-write] Layerx Pixel Format Configuration Register
    volatile uint32_t    L1CACR;               // [Read-write] Layerx Constant Alpha Configuration Register
    volatile uint32_t    L1DCCR;               // [Read-write] Layerx Default Color Configuration Register
    volatile uint32_t    L1BFCR;               // [Read-write] Layerx Blending Factors Configuration Register
    reserved_t<2>        _4;
    volatile uint32_t    L1CFBAR;              // [Read-write] Layerx Color Frame Buffer Address Register
    volatile uint32_t    L1CFBLR;              // [Read-write] Layerx Color Frame Buffer Length Register
    volatile uint32_t    L1CFBLNR;             // [Read-write] Layerx ColorFrame Buffer Line Number Register
    reserved_t<3>        _5;
    volatile uint32_t    L1CLUTWR;             // [Write-only] Layerx CLUT Write Register
    reserved_t<15>       _6;
    volatile uint32_t    L2CR;                 // [Read-write] Layerx Control Register
    volatile uint32_t    L2WHPCR;              // [Read-write] Layerx Window Horizontal Position Configuration Register
    volatile uint32_t    L2WVPCR;              // [Read-write] Layerx Window Vertical Position Configuration Register
    volatile uint32_t    L2CKCR;               // [Read-write] Layerx Color Keying Configuration Register
    volatile uint32_t    L2PFCR;               // [Read-write] Layerx Pixel Format Configuration Register
    volatile uint32_t    L2CACR;               // [Read-write] Layerx Constant Alpha Configuration Register
    volatile uint32_t    L2DCCR;               // [Read-write] Layerx Default Color Configuration Register
    volatile uint32_t    L2BFCR;               // [Read-write] Layerx Blending Factors Configuration Register
    reserved_t<2>        _7;
    volatile uint32_t    L2CFBAR;              // [Read-write] Layerx Color Frame Buffer Address Register
    volatile uint32_t    L2CFBLR;              // [Read-write] Layerx Color Frame Buffer Length Register
    volatile uint32_t    L2CFBLNR;             // [Read-write] Layerx ColorFrame Buffer Line Number Register
    reserved_t<3>        _8;
    volatile uint32_t    L2CLUTWR;             // [Write-only] Layerx CLUT Write Register

    template<uint32_t X>
    static constexpr uint32_t SSCR_HSW =                 // Horizontal Synchronization Width (in units of pixel clock period) (10 bits)
        bit_field_t<16, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SSCR_VSH =                 // Vertical Synchronization Height (in units of horizontal scan line) (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    static const uint32_t SSCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BPCR_AHBP =                // Accumulated Horizontal back porch (in units of pixel clock period) (12 bits)
        bit_field_t<16, 0xfff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BPCR_AVBP =                // Accumulated Vertical back porch (in units of horizontal scan line) (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    static const uint32_t BPCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AWCR_AAV =                 // AAV (12 bits)
        bit_field_t<16, 0xfff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWCR_AAH =                 // Accumulated Active Height (in units of horizontal scan line) (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    static const uint32_t AWCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TWCR_TOTALW =              // Total Width (in units of pixel clock period) (12 bits)
        bit_field_t<16, 0xfff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TWCR_TOTALH =              // Total Height (in units of horizontal scan line) (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    static const uint32_t TWCR_RESET_VALUE = 0x0;

    static constexpr uint32_t GCR_HSPOL = 0x80000000;   // Horizontal Synchronization Polarity, Read-write
    static constexpr uint32_t GCR_VSPOL = 0x40000000;   // Vertical Synchronization Polarity, Read-write
    static constexpr uint32_t GCR_DEPOL = 0x20000000;   // Data Enable Polarity, Read-write
    static constexpr uint32_t GCR_PCPOL = 0x10000000;   // Pixel Clock Polarity, Read-write
    static constexpr uint32_t GCR_DEN = 0x10000;        // Dither Enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t GCR_DRW =                 // Dither Red Width (3 bits), Read-only
        bit_field_t<12, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GCR_DGW =                 // Dither Green Width (3 bits), Read-only
        bit_field_t<8, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GCR_DBW =                 // Dither Blue Width (3 bits), Read-only
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t GCR_LTDCEN = 0x1;         // LCD-TFT controller enable bit, Read-write
    static const uint32_t GCR_RESET_VALUE = 0x2220;

    static constexpr uint32_t SRCR_VBR = 0x2;            // Vertical Blanking Reload
    static constexpr uint32_t SRCR_IMR = 0x1;            // Immediate Reload
    static const uint32_t SRCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BCCR_BCBLUE =              // Background Color Blue value (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BCCR_BCGREEN =             // Background Color Green value (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BCCR_BCRED =               // Background Color Red value (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static const uint32_t BCCR_RESET_VALUE = 0x0;

    static constexpr uint32_t IER_RRIE = 0x8;           // Register Reload interrupt enable
    static constexpr uint32_t IER_TERRIE = 0x4;         // Transfer Error Interrupt Enable
    static constexpr uint32_t IER_FUIE = 0x2;           // FIFO Underrun Interrupt Enable
    static constexpr uint32_t IER_LIE = 0x1;            // Line Interrupt Enable
    static const uint32_t IER_RESET_VALUE = 0x0;

    static constexpr uint32_t ISR_RRIF = 0x8;           // Register Reload Interrupt Flag
    static constexpr uint32_t ISR_TERRIF = 0x4;         // Transfer Error interrupt flag
    static constexpr uint32_t ISR_FUIF = 0x2;           // FIFO Underrun Interrupt flag
    static constexpr uint32_t ISR_LIF = 0x1;            // Line Interrupt flag
    static const uint32_t ISR_RESET_VALUE = 0x0;

    static constexpr uint32_t ICR_CRRIF = 0x8;          // Clears Register Reload Interrupt Flag
    static constexpr uint32_t ICR_CTERRIF = 0x4;        // Clears the Transfer Error Interrupt Flag
    static constexpr uint32_t ICR_CFUIF = 0x2;          // Clears the FIFO Underrun Interrupt flag
    static constexpr uint32_t ICR_CLIF = 0x1;           // Clears the Line Interrupt Flag
    static const uint32_t ICR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t LIPCR_LIPOS =               // Line Interrupt Position (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    static const uint32_t LIPCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CPSR_CXPOS =               // Current X Position (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CPSR_CYPOS =               // Current Y Position (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CPSR_RESET_VALUE = 0x0;

    static constexpr uint32_t CDSR_HSYNCS = 0x8;         // Horizontal Synchronization display Status
    static constexpr uint32_t CDSR_VSYNCS = 0x4;         // Vertical Synchronization display Status
    static constexpr uint32_t CDSR_HDES = 0x2;           // Horizontal Data Enable display Status
    static constexpr uint32_t CDSR_VDES = 0x1;           // Vertical Data Enable display Status
    static const uint32_t CDSR_RESET_VALUE = 0xf;

    static constexpr uint32_t L1CR_CLUTEN = 0x10;        // Color Look-Up Table Enable
    static constexpr uint32_t L1CR_COLKEN = 0x2;         // Color Keying Enable
    static constexpr uint32_t L1CR_LEN = 0x1;            // Layer Enable
    static const uint32_t L1CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t L1WHPCR_WHSPPOS =             // Window Horizontal Stop Position (12 bits)
        bit_field_t<16, 0xfff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L1WHPCR_WHSTPOS =             // Window Horizontal Start Position (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t L1WHPCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t L1WVPCR_WVSPPOS =             // Window Vertical Stop Position (11 bits)
        bit_field_t<16, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L1WVPCR_WVSTPOS =             // Window Vertical Start Position (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    static const uint32_t L1WVPCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t L1CKCR_CKRED =               // Color Key Red value (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L1CKCR_CKGREEN =             // Color Key Green value (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L1CKCR_CKBLUE =              // Color Key Blue value (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t L1CKCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t L1PFCR_PF =                  // Pixel Format (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t L1PFCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t L1CACR_CONSTA =              // Constant Alpha (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t L1CACR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t L1DCCR_DCALPHA =             // Default Color Alpha (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L1DCCR_DCRED =               // Default Color Red (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L1DCCR_DCGREEN =             // Default Color Green (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L1DCCR_DCBLUE =              // Default Color Blue (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t L1DCCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t L1BFCR_BF1 =                 // Blending Factor 1 (3 bits)
        bit_field_t<8, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L1BFCR_BF2 =                 // Blending Factor 2 (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t L1BFCR_RESET_VALUE = 0x607;


    static const uint32_t L1CFBAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t L1CFBLR_CFBP =                // Color Frame Buffer Pitch in bytes (13 bits)
        bit_field_t<16, 0x1fff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L1CFBLR_CFBLL =               // Color Frame Buffer Line Length (13 bits)
        bit_field_t<0, 0x1fff>::value<X>();
    static const uint32_t L1CFBLR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t L1CFBLNR_CFBLNBR =             // Frame Buffer Line Number (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    static const uint32_t L1CFBLNR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t L1CLUTWR_CLUTADD =             // CLUT Address (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L1CLUTWR_RED =                 // Red value (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L1CLUTWR_GREEN =               // Green value (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L1CLUTWR_BLUE =                // Blue value (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t L1CLUTWR_RESET_VALUE = 0x0;

    static constexpr uint32_t L2CR_CLUTEN = 0x10;        // Color Look-Up Table Enable
    static constexpr uint32_t L2CR_COLKEN = 0x2;         // Color Keying Enable
    static constexpr uint32_t L2CR_LEN = 0x1;            // Layer Enable
    static const uint32_t L2CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t L2WHPCR_WHSPPOS =             // Window Horizontal Stop Position (12 bits)
        bit_field_t<16, 0xfff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L2WHPCR_WHSTPOS =             // Window Horizontal Start Position (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t L2WHPCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t L2WVPCR_WVSPPOS =             // Window Vertical Stop Position (11 bits)
        bit_field_t<16, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L2WVPCR_WVSTPOS =             // Window Vertical Start Position (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    static const uint32_t L2WVPCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t L2CKCR_CKRED =               // Color Key Red value (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L2CKCR_CKGREEN =             // Color Key Green value (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L2CKCR_CKBLUE =              // Color Key Blue value (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t L2CKCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t L2PFCR_PF =                  // Pixel Format (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t L2PFCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t L2CACR_CONSTA =              // Constant Alpha (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t L2CACR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t L2DCCR_DCALPHA =             // Default Color Alpha (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L2DCCR_DCRED =               // Default Color Red (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L2DCCR_DCGREEN =             // Default Color Green (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L2DCCR_DCBLUE =              // Default Color Blue (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t L2DCCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t L2BFCR_BF1 =                 // Blending Factor 1 (3 bits)
        bit_field_t<8, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L2BFCR_BF2 =                 // Blending Factor 2 (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t L2BFCR_RESET_VALUE = 0x607;


    static const uint32_t L2CFBAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t L2CFBLR_CFBP =                // Color Frame Buffer Pitch in bytes (13 bits)
        bit_field_t<16, 0x1fff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L2CFBLR_CFBLL =               // Color Frame Buffer Line Length (13 bits)
        bit_field_t<0, 0x1fff>::value<X>();
    static const uint32_t L2CFBLR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t L2CFBLNR_CFBLNBR =             // Frame Buffer Line Number (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    static const uint32_t L2CFBLNR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t L2CLUTWR_CLUTADD =             // CLUT Address (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L2CLUTWR_RED =                 // Red value (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L2CLUTWR_GREEN =               // Green value (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L2CLUTWR_BLUE =                // Blue value (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t L2CLUTWR_RESET_VALUE = 0x0;

    static constexpr uint8_t LTDC = 88; // LCD-TFT global interrupt
    static constexpr uint8_t LTDC_ER = 89; // LCD-TFT error interrupt
};

static ltdc_t& LTDC = *reinterpret_cast<ltdc_t*>(0x50001000);

#define HAVE_PERIPHERAL_LTDC


////
//
//    Receiver Interface
//
////

struct spdifrx_t
{
    volatile uint32_t    CR;                   // [Read-write] Control register
    volatile uint32_t    IMR;                  // [Read-write] Interrupt mask register
    volatile uint32_t    SR;                   // [Read-only] Status register
    volatile uint32_t    IFCR;                 // [Write-only] Interrupt Flag Clear register
    volatile uint32_t    DR_00;                // [Read-only] Data input register
    volatile uint32_t    CSR;                  // [Read-only] Channel Status register
    volatile uint32_t    DIR;                  // [Read-only] Debug Information register
    reserved_t<246>      _0;
    volatile uint32_t    VERR;                 // [Read-only] SPDIFRX version register
    volatile uint32_t    IDR;                  // [Read-only] SPDIFRX identification register
    volatile uint32_t    SIDR;                 // [Read-only] SPDIFRX size identification register

    template<uint32_t X>
    static constexpr uint32_t CR_SPDIFRXEN =           // Peripheral Block Enable (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static constexpr uint32_t CR_RXDMAEN = 0x4;        // Receiver DMA ENable for data flow
    static constexpr uint32_t CR_RXSTEO = 0x8;         // STerEO Mode
    template<uint32_t X>
    static constexpr uint32_t CR_DRFMT =               // RX Data format (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static constexpr uint32_t CR_PMSK = 0x40;          // Mask Parity error bit
    static constexpr uint32_t CR_VMSK = 0x80;          // Mask of Validity bit
    static constexpr uint32_t CR_CUMSK = 0x100;        // Mask of channel status and user bits
    static constexpr uint32_t CR_PTMSK = 0x200;        // Mask of Preamble Type bits
    static constexpr uint32_t CR_CBDMAEN = 0x400;      // Control Buffer DMA ENable for control flow
    static constexpr uint32_t CR_CHSEL = 0x800;        // Channel Selection
    template<uint32_t X>
    static constexpr uint32_t CR_NBTR =                // Maximum allowed re-tries during synchronization phase (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    static constexpr uint32_t CR_WFA = 0x4000;         // Wait For Activity
    template<uint32_t X>
    static constexpr uint32_t CR_INSEL =               // input selection (3 bits)
        bit_field_t<16, 0x7>::value<X>();
    static constexpr uint32_t CR_CKSEN = 0x100000;     // Symbol Clock Enable
    static constexpr uint32_t CR_CKSBKPEN = 0x200000;  // Backup Symbol Clock Enable
    static const uint32_t CR_RESET_VALUE = 0x0;

    static constexpr uint32_t IMR_RXNEIE = 0x1;         // RXNE interrupt enable
    static constexpr uint32_t IMR_CSRNEIE = 0x2;        // Control Buffer Ready Interrupt Enable
    static constexpr uint32_t IMR_PERRIE = 0x4;         // Parity error interrupt enable
    static constexpr uint32_t IMR_OVRIE = 0x8;          // Overrun error Interrupt Enable
    static constexpr uint32_t IMR_SBLKIE = 0x10;        // Synchronization Block Detected Interrupt Enable
    static constexpr uint32_t IMR_SYNCDIE = 0x20;       // Synchronization Done
    static constexpr uint32_t IMR_IFEIE = 0x40;         // Serial Interface Error Interrupt Enable
    static const uint32_t IMR_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_RXNE = 0x1;           // Read data register not empty
    static constexpr uint32_t SR_CSRNE = 0x2;          // Control Buffer register is not empty
    static constexpr uint32_t SR_PERR = 0x4;           // Parity error
    static constexpr uint32_t SR_OVR = 0x8;            // Overrun error
    static constexpr uint32_t SR_SBD = 0x10;           // Synchronization Block Detected
    static constexpr uint32_t SR_SYNCD = 0x20;         // Synchronization Done
    static constexpr uint32_t SR_FERR = 0x40;          // Framing error
    static constexpr uint32_t SR_SERR = 0x80;          // Synchronization error
    static constexpr uint32_t SR_TERR = 0x100;         // Time-out error
    template<uint32_t X>
    static constexpr uint32_t SR_WIDTH5 =              // Duration of 5 symbols counted with SPDIF_CLK (15 bits)
        bit_field_t<16, 0x7fff>::value<X>();
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint32_t IFCR_PERRCF = 0x4;         // Clears the Parity error flag
    static constexpr uint32_t IFCR_OVRCF = 0x8;          // Clears the Overrun error flag
    static constexpr uint32_t IFCR_SBDCF = 0x10;         // Clears the Synchronization Block Detected flag
    static constexpr uint32_t IFCR_SYNCDCF = 0x20;       // Clears the Synchronization Done flag
    static const uint32_t IFCR_RESET_VALUE = 0x0;

    static constexpr uint32_t DR_00_C = 0x8000000;        // Channel Status bit
    template<uint32_t X>
    static constexpr uint32_t DR_00_DR =                  // Parity Error bit (24 bits)
        bit_field_t<0, 0xffffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DR_00_DRNL1 =               // Data value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DR_00_DRNL2 =               // Data value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static constexpr uint32_t DR_00_PE = 0x1000000;       // Parity Error bit
    template<uint32_t X>
    static constexpr uint32_t DR_00_PT =                  // Preamble Type (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    static constexpr uint32_t DR_00_U = 0x4000000;        // User bit
    static constexpr uint32_t DR_00_V = 0x2000000;        // Validity bit
    static const uint32_t DR_00_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CSR_USR =                 // User data information (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CSR_CS =                  // Channel A status information (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static constexpr uint32_t CSR_SOB = 0x1000000;      // Start Of Block
    static const uint32_t CSR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DIR_THI =                 // Threshold HIGH (13 bits)
        bit_field_t<0, 0x1fff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DIR_TLO =                 // Threshold LOW (13 bits)
        bit_field_t<16, 0x1fff>::value<X>();
    static const uint32_t DIR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t VERR_MINREV =              // Minor revision (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t VERR_MAJREV =              // Major revision (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    static const uint32_t VERR_RESET_VALUE = 0x12;


    static const uint32_t IDR_RESET_VALUE = 0x130041;


    static const uint32_t SIDR_RESET_VALUE = 0xa3c5dd01;

    static constexpr uint8_t SPDIF = 97; // SPDIFRX global interrupt
};

static spdifrx_t& SPDIFRX = *reinterpret_cast<spdifrx_t*>(0x40004000);

#define HAVE_PERIPHERAL_SPDIFRX


////
//
//    Analog to Digital Converter
//
////

struct adc3_t
{
    volatile uint32_t    ISR;                  // [Read-write] ADC interrupt and status register
    volatile uint32_t    IER;                  // [Read-write] ADC interrupt enable register
    volatile uint32_t    CR;                   // [Read-write] ADC control register
    volatile uint32_t    CFGR;                 // [Read-write] ADC configuration register 1
    volatile uint32_t    CFGR2;                // [Read-write] ADC configuration register 2
    volatile uint32_t    SMPR1;                // [Read-write] ADC sampling time register 1
    volatile uint32_t    SMPR2;                // [Read-write] ADC sampling time register 2
    volatile uint32_t    PCSEL;                // [Read-write] ADC pre channel selection register
    volatile uint32_t    LTR1;                 // [Read-write] ADC analog watchdog 1 threshold register
    volatile uint32_t    LHTR1;                // [Read-write] ADC analog watchdog 2 threshold register
    reserved_t<2>        _0;
    volatile uint32_t    SQR1;                 // [Read-write] ADC group regular sequencer ranks register 1
    volatile uint32_t    SQR2;                 // [Read-write] ADC group regular sequencer ranks register 2
    volatile uint32_t    SQR3;                 // [Read-write] ADC group regular sequencer ranks register 3
    volatile uint32_t    SQR4;                 // [Read-write] ADC group regular sequencer ranks register 4
    volatile uint32_t    DR;                   // [Read-only] ADC group regular conversion data register
    reserved_t<2>        _1;
    volatile uint32_t    JSQR;                 // [Read-write] ADC group injected sequencer register
    reserved_t<4>        _2;
    volatile uint32_t    OFR1;                 // [Read-write] ADC offset number 1 register
    volatile uint32_t    OFR2;                 // [Read-write] ADC offset number 2 register
    volatile uint32_t    OFR3;                 // [Read-write] ADC offset number 3 register
    volatile uint32_t    OFR4;                 // [Read-write] ADC offset number 4 register
    reserved_t<4>        _3;
    volatile uint32_t    JDR1;                 // [Read-only] ADC group injected sequencer rank 1 register
    volatile uint32_t    JDR2;                 // [Read-only] ADC group injected sequencer rank 2 register
    volatile uint32_t    JDR3;                 // [Read-only] ADC group injected sequencer rank 3 register
    volatile uint32_t    JDR4;                 // [Read-only] ADC group injected sequencer rank 4 register
    reserved_t<4>        _4;
    volatile uint32_t    AWD2CR;               // [Read-write] ADC analog watchdog 2 configuration register
    volatile uint32_t    AWD3CR;               // [Read-write] ADC analog watchdog 3 configuration register
    reserved_t<2>        _5;
    volatile uint32_t    LTR2;                 // [Read-write] ADC watchdog lower threshold register 2
    volatile uint32_t    HTR2;                 // [Read-write] ADC watchdog higher threshold register 2
    volatile uint32_t    LTR3;                 // [Read-write] ADC watchdog lower threshold register 3
    volatile uint32_t    HTR3;                 // [Read-write] ADC watchdog higher threshold register 3
    volatile uint32_t    DIFSEL;               // [Read-write] ADC channel differential or single-ended mode selection register
    volatile uint32_t    CALFACT;              // [Read-write] ADC calibration factors register
    volatile uint32_t    CALFACT2;             // [Read-write] ADC Calibration Factor register 2

    static constexpr uint32_t ISR_JQOVF = 0x400;        // ADC group injected contexts queue overflow flag
    static constexpr uint32_t ISR_AWD3 = 0x200;         // ADC analog watchdog 3 flag
    static constexpr uint32_t ISR_AWD2 = 0x100;         // ADC analog watchdog 2 flag
    static constexpr uint32_t ISR_AWD1 = 0x80;          // ADC analog watchdog 1 flag
    static constexpr uint32_t ISR_JEOS = 0x40;          // ADC group injected end of sequence conversions flag
    static constexpr uint32_t ISR_JEOC = 0x20;          // ADC group injected end of unitary conversion flag
    static constexpr uint32_t ISR_OVR = 0x10;           // ADC group regular overrun flag
    static constexpr uint32_t ISR_EOS = 0x8;            // ADC group regular end of sequence conversions flag
    static constexpr uint32_t ISR_EOC = 0x4;            // ADC group regular end of unitary conversion flag
    static constexpr uint32_t ISR_EOSMP = 0x2;          // ADC group regular end of sampling flag
    static constexpr uint32_t ISR_ADRDY = 0x1;          // ADC ready flag
    static const uint32_t ISR_RESET_VALUE = 0x0;

    static constexpr uint32_t IER_JQOVFIE = 0x400;      // ADC group injected contexts queue overflow interrupt
    static constexpr uint32_t IER_AWD3IE = 0x200;       // ADC analog watchdog 3 interrupt
    static constexpr uint32_t IER_AWD2IE = 0x100;       // ADC analog watchdog 2 interrupt
    static constexpr uint32_t IER_AWD1IE = 0x80;        // ADC analog watchdog 1 interrupt
    static constexpr uint32_t IER_JEOSIE = 0x40;        // ADC group injected end of sequence conversions interrupt
    static constexpr uint32_t IER_JEOCIE = 0x20;        // ADC group injected end of unitary conversion interrupt
    static constexpr uint32_t IER_OVRIE = 0x10;         // ADC group regular overrun interrupt
    static constexpr uint32_t IER_EOSIE = 0x8;          // ADC group regular end of sequence conversions interrupt
    static constexpr uint32_t IER_EOCIE = 0x4;          // ADC group regular end of unitary conversion interrupt
    static constexpr uint32_t IER_EOSMPIE = 0x2;        // ADC group regular end of sampling interrupt
    static constexpr uint32_t IER_ADRDYIE = 0x1;        // ADC ready interrupt
    static const uint32_t IER_RESET_VALUE = 0x0;

    static constexpr uint32_t CR_ADCAL = 0x80000000;   // ADC calibration
    static constexpr uint32_t CR_ADCALDIF = 0x40000000;// ADC differential mode for calibration
    static constexpr uint32_t CR_DEEPPWD = 0x20000000; // ADC deep power down enable
    static constexpr uint32_t CR_ADVREGEN = 0x10000000;// ADC voltage regulator enable
    static constexpr uint32_t CR_LINCALRDYW6 = 0x8000000;// Linearity calibration ready Word 6
    static constexpr uint32_t CR_LINCALRDYW5 = 0x4000000;// Linearity calibration ready Word 5
    static constexpr uint32_t CR_LINCALRDYW4 = 0x2000000;// Linearity calibration ready Word 4
    static constexpr uint32_t CR_LINCALRDYW3 = 0x1000000;// Linearity calibration ready Word 3
    static constexpr uint32_t CR_LINCALRDYW2 = 0x800000;// Linearity calibration ready Word 2
    static constexpr uint32_t CR_LINCALRDYW1 = 0x400000;// Linearity calibration ready Word 1
    static constexpr uint32_t CR_ADCALLIN = 0x10000;   // Linearity calibration
    static constexpr uint32_t CR_BOOST = 0x100;        // Boost mode control
    static constexpr uint32_t CR_JADSTP = 0x20;        // ADC group injected conversion stop
    static constexpr uint32_t CR_ADSTP = 0x10;         // ADC group regular conversion stop
    static constexpr uint32_t CR_JADSTART = 0x8;       // ADC group injected conversion start
    static constexpr uint32_t CR_ADSTART = 0x4;        // ADC group regular conversion start
    static constexpr uint32_t CR_ADDIS = 0x2;          // ADC disable
    static constexpr uint32_t CR_ADEN = 0x1;           // ADC enable
    static const uint32_t CR_RESET_VALUE = 0x0;

    static constexpr uint32_t CFGR_JQDIS = 0x80000000;   // ADC group injected contexts queue disable
    template<uint32_t X>
    static constexpr uint32_t CFGR_AWDCH1CH =            // ADC analog watchdog 1 monitored channel selection (5 bits)
        bit_field_t<26, 0x1f>::value<X>();
    static constexpr uint32_t CFGR_JAUTO = 0x2000000;    // ADC group injected automatic trigger mode
    static constexpr uint32_t CFGR_JAWD1EN = 0x1000000;  // ADC analog watchdog 1 enable on scope ADC group injected
    static constexpr uint32_t CFGR_AWD1EN = 0x800000;    // ADC analog watchdog 1 enable on scope ADC group regular
    static constexpr uint32_t CFGR_AWD1SGL = 0x400000;   // ADC analog watchdog 1 monitoring a single channel or all channels
    static constexpr uint32_t CFGR_JQM = 0x200000;       // ADC group injected contexts queue mode
    static constexpr uint32_t CFGR_JDISCEN = 0x100000;   // ADC group injected sequencer discontinuous mode
    template<uint32_t X>
    static constexpr uint32_t CFGR_DISCNUM =             // ADC group regular sequencer discontinuous number of ranks (3 bits)
        bit_field_t<17, 0x7>::value<X>();
    static constexpr uint32_t CFGR_DISCEN = 0x10000;     // ADC group regular sequencer discontinuous mode
    static constexpr uint32_t CFGR_AUTDLY = 0x4000;      // ADC low power auto wait
    static constexpr uint32_t CFGR_CONT = 0x2000;        // ADC group regular continuous conversion mode
    static constexpr uint32_t CFGR_OVRMOD = 0x1000;      // ADC group regular overrun configuration
    template<uint32_t X>
    static constexpr uint32_t CFGR_EXTEN =               // ADC group regular external trigger polarity (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_EXTSEL =              // ADC group regular external trigger source (5 bits)
        bit_field_t<5, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_RES =                 // ADC data resolution (3 bits)
        bit_field_t<2, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_DMNGT =               // ADC DMA transfer enable (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t CFGR_RESET_VALUE = 0x0;

    static constexpr uint32_t CFGR2_ROVSE = 0x1;          // ADC oversampler enable on scope ADC group regular
    static constexpr uint32_t CFGR2_JOVSE = 0x2;          // ADC oversampler enable on scope ADC group injected
    template<uint32_t X>
    static constexpr uint32_t CFGR2_OVSS =                // ADC oversampling shift (4 bits)
        bit_field_t<5, 0xf>::value<X>();
    static constexpr uint32_t CFGR2_TROVS = 0x200;        // ADC oversampling discontinuous mode (triggered mode) for ADC group regular
    static constexpr uint32_t CFGR2_ROVSM = 0x400;        // Regular Oversampling mode
    static constexpr uint32_t CFGR2_RSHIFT1 = 0x800;      // Right-shift data after Offset 1 correction
    static constexpr uint32_t CFGR2_RSHIFT2 = 0x1000;     // Right-shift data after Offset 2 correction
    static constexpr uint32_t CFGR2_RSHIFT3 = 0x2000;     // Right-shift data after Offset 3 correction
    static constexpr uint32_t CFGR2_RSHIFT4 = 0x4000;     // Right-shift data after Offset 4 correction
    template<uint32_t X>
    static constexpr uint32_t CFGR2_OSR =                 // Oversampling ratio (10 bits)
        bit_field_t<16, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR2_LSHIFT =              // Left shift factor (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    static const uint32_t CFGR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SMPR1_SMP9 =                // ADC channel 9 sampling time selection (3 bits)
        bit_field_t<27, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR1_SMP8 =                // ADC channel 8 sampling time selection (3 bits)
        bit_field_t<24, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR1_SMP7 =                // ADC channel 7 sampling time selection (3 bits)
        bit_field_t<21, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR1_SMP6 =                // ADC channel 6 sampling time selection (3 bits)
        bit_field_t<18, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR1_SMP5 =                // ADC channel 5 sampling time selection (3 bits)
        bit_field_t<15, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR1_SMP4 =                // ADC channel 4 sampling time selection (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR1_SMP3 =                // ADC channel 3 sampling time selection (3 bits)
        bit_field_t<9, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR1_SMP2 =                // ADC channel 2 sampling time selection (3 bits)
        bit_field_t<6, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR1_SMP1 =                // ADC channel 1 sampling time selection (3 bits)
        bit_field_t<3, 0x7>::value<X>();
    static const uint32_t SMPR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SMPR2_SMP19 =               // ADC channel 18 sampling time selection (3 bits)
        bit_field_t<27, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR2_SMP18 =               // ADC channel 18 sampling time selection (3 bits)
        bit_field_t<24, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR2_SMP17 =               // ADC channel 17 sampling time selection (3 bits)
        bit_field_t<21, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR2_SMP16 =               // ADC channel 16 sampling time selection (3 bits)
        bit_field_t<18, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR2_SMP15 =               // ADC channel 15 sampling time selection (3 bits)
        bit_field_t<15, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR2_SMP14 =               // ADC channel 14 sampling time selection (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR2_SMP13 =               // ADC channel 13 sampling time selection (3 bits)
        bit_field_t<9, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR2_SMP12 =               // ADC channel 12 sampling time selection (3 bits)
        bit_field_t<6, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR2_SMP11 =               // ADC channel 11 sampling time selection (3 bits)
        bit_field_t<3, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR2_SMP10 =               // ADC channel 10 sampling time selection (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t SMPR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PCSEL_PCSEL =               // Channel x (VINP[i]) pre selection (20 bits)
        bit_field_t<0, 0xfffff>::value<X>();
    static const uint32_t PCSEL_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t LTR1_LTR1 =                // ADC analog watchdog 1 threshold low (26 bits)
        bit_field_t<0, 0x3ffffff>::value<X>();
    static const uint32_t LTR1_RESET_VALUE = 0xfff0000;

    template<uint32_t X>
    static constexpr uint32_t LHTR1_LHTR1 =               // ADC analog watchdog 2 threshold low (26 bits)
        bit_field_t<0, 0x3ffffff>::value<X>();
    static const uint32_t LHTR1_RESET_VALUE = 0xfff0000;

    template<uint32_t X>
    static constexpr uint32_t SQR1_SQ4 =                 // ADC group regular sequencer rank 4 (5 bits)
        bit_field_t<24, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR1_SQ3 =                 // ADC group regular sequencer rank 3 (5 bits)
        bit_field_t<18, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR1_SQ2 =                 // ADC group regular sequencer rank 2 (5 bits)
        bit_field_t<12, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR1_SQ1 =                 // ADC group regular sequencer rank 1 (5 bits)
        bit_field_t<6, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR1_L3 =                  // L3 (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t SQR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SQR2_SQ9 =                 // ADC group regular sequencer rank 9 (5 bits)
        bit_field_t<24, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR2_SQ8 =                 // ADC group regular sequencer rank 8 (5 bits)
        bit_field_t<18, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR2_SQ7 =                 // ADC group regular sequencer rank 7 (5 bits)
        bit_field_t<12, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR2_SQ6 =                 // ADC group regular sequencer rank 6 (5 bits)
        bit_field_t<6, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR2_SQ5 =                 // ADC group regular sequencer rank 5 (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t SQR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SQR3_SQ14 =                // ADC group regular sequencer rank 14 (5 bits)
        bit_field_t<24, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR3_SQ13 =                // ADC group regular sequencer rank 13 (5 bits)
        bit_field_t<18, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR3_SQ12 =                // ADC group regular sequencer rank 12 (5 bits)
        bit_field_t<12, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR3_SQ11 =                // ADC group regular sequencer rank 11 (5 bits)
        bit_field_t<6, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR3_SQ10 =                // ADC group regular sequencer rank 10 (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t SQR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SQR4_SQ16 =                // ADC group regular sequencer rank 16 (5 bits)
        bit_field_t<6, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR4_SQ15 =                // ADC group regular sequencer rank 15 (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t SQR4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DR_RDATA =               // ADC group regular conversion data (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t JSQR_JSQ4 =                // ADC group injected sequencer rank 4 (5 bits)
        bit_field_t<27, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t JSQR_JSQ3 =                // ADC group injected sequencer rank 3 (5 bits)
        bit_field_t<21, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t JSQR_JSQ2 =                // ADC group injected sequencer rank 2 (5 bits)
        bit_field_t<15, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t JSQR_JSQ1 =                // ADC group injected sequencer rank 1 (5 bits)
        bit_field_t<9, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t JSQR_JEXTEN =              // ADC group injected external trigger polarity (2 bits)
        bit_field_t<7, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t JSQR_JEXTSEL =             // ADC group injected external trigger source (5 bits)
        bit_field_t<2, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t JSQR_JL =                  // ADC group injected sequencer scan length (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t JSQR_RESET_VALUE = 0x0;

    static constexpr uint32_t OFR1_SSATE = 0x80000000;   // ADC offset number 1 enable
    template<uint32_t X>
    static constexpr uint32_t OFR1_OFFSET1_CH =          // ADC offset number 1 channel selection (5 bits)
        bit_field_t<26, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OFR1_OFFSET1 =             // ADC offset number 1 offset level (26 bits)
        bit_field_t<0, 0x3ffffff>::value<X>();
    static const uint32_t OFR1_RESET_VALUE = 0x0;

    static constexpr uint32_t OFR2_SSATE = 0x80000000;   // ADC offset number 1 enable
    template<uint32_t X>
    static constexpr uint32_t OFR2_OFFSET1_CH =          // ADC offset number 1 channel selection (5 bits)
        bit_field_t<26, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OFR2_OFFSET1 =             // ADC offset number 1 offset level (26 bits)
        bit_field_t<0, 0x3ffffff>::value<X>();
    static const uint32_t OFR2_RESET_VALUE = 0x0;

    static constexpr uint32_t OFR3_SSATE = 0x80000000;   // ADC offset number 1 enable
    template<uint32_t X>
    static constexpr uint32_t OFR3_OFFSET1_CH =          // ADC offset number 1 channel selection (5 bits)
        bit_field_t<26, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OFR3_OFFSET1 =             // ADC offset number 1 offset level (26 bits)
        bit_field_t<0, 0x3ffffff>::value<X>();
    static const uint32_t OFR3_RESET_VALUE = 0x0;

    static constexpr uint32_t OFR4_SSATE = 0x80000000;   // ADC offset number 1 enable
    template<uint32_t X>
    static constexpr uint32_t OFR4_OFFSET1_CH =          // ADC offset number 1 channel selection (5 bits)
        bit_field_t<26, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OFR4_OFFSET1 =             // ADC offset number 1 offset level (26 bits)
        bit_field_t<0, 0x3ffffff>::value<X>();
    static const uint32_t OFR4_RESET_VALUE = 0x0;


    static const uint32_t JDR1_RESET_VALUE = 0x0;


    static const uint32_t JDR2_RESET_VALUE = 0x0;


    static const uint32_t JDR3_RESET_VALUE = 0x0;


    static const uint32_t JDR4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AWD2CR_AWD2CH =              // ADC analog watchdog 2 monitored channel selection (20 bits)
        bit_field_t<0, 0xfffff>::value<X>();
    static const uint32_t AWD2CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AWD3CR_AWD3CH =              // ADC analog watchdog 3 monitored channel selection (20 bits)
        bit_field_t<1, 0xfffff>::value<X>();
    static const uint32_t AWD3CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t LTR2_LTR2 =                // Analog watchdog 2 lower threshold (26 bits)
        bit_field_t<0, 0x3ffffff>::value<X>();
    static const uint32_t LTR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HTR2_HTR2 =                // Analog watchdog 2 higher threshold (26 bits)
        bit_field_t<0, 0x3ffffff>::value<X>();
    static const uint32_t HTR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t LTR3_LTR3 =                // Analog watchdog 3 lower threshold (26 bits)
        bit_field_t<0, 0x3ffffff>::value<X>();
    static const uint32_t LTR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HTR3_HTR3 =                // Analog watchdog 3 higher threshold (26 bits)
        bit_field_t<0, 0x3ffffff>::value<X>();
    static const uint32_t HTR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DIFSEL_DIFSEL =              // ADC channel differential or single-ended mode for channel (20 bits)
        bit_field_t<0, 0xfffff>::value<X>();
    static const uint32_t DIFSEL_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CALFACT_CALFACT_D =           // ADC calibration factor in differential mode (11 bits)
        bit_field_t<16, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CALFACT_CALFACT_S =           // ADC calibration factor in single-ended mode (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    static const uint32_t CALFACT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CALFACT2_LINCALFACT =          // Linearity Calibration Factor (30 bits)
        bit_field_t<0, 0x3fffffff>::value<X>();
    static const uint32_t CALFACT2_RESET_VALUE = 0x0;

    static constexpr uint8_t ADC3 = 127; // ADC3 global interrupt
};

static adc3_t& ADC3 = *reinterpret_cast<adc3_t*>(0x58026000);

#define HAVE_PERIPHERAL_ADC3


////
//
//    Analog to Digital Converter
//
////

struct adc1_t
{
    volatile uint32_t    ISR;                  // [Read-write] ADC interrupt and status register
    volatile uint32_t    IER;                  // [Read-write] ADC interrupt enable register
    volatile uint32_t    CR;                   // [Read-write] ADC control register
    volatile uint32_t    CFGR;                 // [Read-write] ADC configuration register 1
    volatile uint32_t    CFGR2;                // [Read-write] ADC configuration register 2
    volatile uint32_t    SMPR1;                // [Read-write] ADC sampling time register 1
    volatile uint32_t    SMPR2;                // [Read-write] ADC sampling time register 2
    volatile uint32_t    PCSEL;                // [Read-write] ADC pre channel selection register
    volatile uint32_t    LTR1;                 // [Read-write] ADC analog watchdog 1 threshold register
    volatile uint32_t    LHTR1;                // [Read-write] ADC analog watchdog 2 threshold register
    reserved_t<2>        _0;
    volatile uint32_t    SQR1;                 // [Read-write] ADC group regular sequencer ranks register 1
    volatile uint32_t    SQR2;                 // [Read-write] ADC group regular sequencer ranks register 2
    volatile uint32_t    SQR3;                 // [Read-write] ADC group regular sequencer ranks register 3
    volatile uint32_t    SQR4;                 // [Read-write] ADC group regular sequencer ranks register 4
    volatile uint32_t    DR;                   // [Read-only] ADC group regular conversion data register
    reserved_t<2>        _1;
    volatile uint32_t    JSQR;                 // [Read-write] ADC group injected sequencer register
    reserved_t<4>        _2;
    volatile uint32_t    OFR1;                 // [Read-write] ADC offset number 1 register
    volatile uint32_t    OFR2;                 // [Read-write] ADC offset number 2 register
    volatile uint32_t    OFR3;                 // [Read-write] ADC offset number 3 register
    volatile uint32_t    OFR4;                 // [Read-write] ADC offset number 4 register
    reserved_t<4>        _3;
    volatile uint32_t    JDR1;                 // [Read-only] ADC group injected sequencer rank 1 register
    volatile uint32_t    JDR2;                 // [Read-only] ADC group injected sequencer rank 2 register
    volatile uint32_t    JDR3;                 // [Read-only] ADC group injected sequencer rank 3 register
    volatile uint32_t    JDR4;                 // [Read-only] ADC group injected sequencer rank 4 register
    reserved_t<4>        _4;
    volatile uint32_t    AWD2CR;               // [Read-write] ADC analog watchdog 2 configuration register
    volatile uint32_t    AWD3CR;               // [Read-write] ADC analog watchdog 3 configuration register
    reserved_t<2>        _5;
    volatile uint32_t    LTR2;                 // [Read-write] ADC watchdog lower threshold register 2
    volatile uint32_t    HTR2;                 // [Read-write] ADC watchdog higher threshold register 2
    volatile uint32_t    LTR3;                 // [Read-write] ADC watchdog lower threshold register 3
    volatile uint32_t    HTR3;                 // [Read-write] ADC watchdog higher threshold register 3
    volatile uint32_t    DIFSEL;               // [Read-write] ADC channel differential or single-ended mode selection register
    volatile uint32_t    CALFACT;              // [Read-write] ADC calibration factors register
    volatile uint32_t    CALFACT2;             // [Read-write] ADC Calibration Factor register 2

    static constexpr uint32_t ISR_JQOVF = 0x400;        // ADC group injected contexts queue overflow flag
    static constexpr uint32_t ISR_AWD3 = 0x200;         // ADC analog watchdog 3 flag
    static constexpr uint32_t ISR_AWD2 = 0x100;         // ADC analog watchdog 2 flag
    static constexpr uint32_t ISR_AWD1 = 0x80;          // ADC analog watchdog 1 flag
    static constexpr uint32_t ISR_JEOS = 0x40;          // ADC group injected end of sequence conversions flag
    static constexpr uint32_t ISR_JEOC = 0x20;          // ADC group injected end of unitary conversion flag
    static constexpr uint32_t ISR_OVR = 0x10;           // ADC group regular overrun flag
    static constexpr uint32_t ISR_EOS = 0x8;            // ADC group regular end of sequence conversions flag
    static constexpr uint32_t ISR_EOC = 0x4;            // ADC group regular end of unitary conversion flag
    static constexpr uint32_t ISR_EOSMP = 0x2;          // ADC group regular end of sampling flag
    static constexpr uint32_t ISR_ADRDY = 0x1;          // ADC ready flag
    static const uint32_t ISR_RESET_VALUE = 0x0;

    static constexpr uint32_t IER_JQOVFIE = 0x400;      // ADC group injected contexts queue overflow interrupt
    static constexpr uint32_t IER_AWD3IE = 0x200;       // ADC analog watchdog 3 interrupt
    static constexpr uint32_t IER_AWD2IE = 0x100;       // ADC analog watchdog 2 interrupt
    static constexpr uint32_t IER_AWD1IE = 0x80;        // ADC analog watchdog 1 interrupt
    static constexpr uint32_t IER_JEOSIE = 0x40;        // ADC group injected end of sequence conversions interrupt
    static constexpr uint32_t IER_JEOCIE = 0x20;        // ADC group injected end of unitary conversion interrupt
    static constexpr uint32_t IER_OVRIE = 0x10;         // ADC group regular overrun interrupt
    static constexpr uint32_t IER_EOSIE = 0x8;          // ADC group regular end of sequence conversions interrupt
    static constexpr uint32_t IER_EOCIE = 0x4;          // ADC group regular end of unitary conversion interrupt
    static constexpr uint32_t IER_EOSMPIE = 0x2;        // ADC group regular end of sampling interrupt
    static constexpr uint32_t IER_ADRDYIE = 0x1;        // ADC ready interrupt
    static const uint32_t IER_RESET_VALUE = 0x0;

    static constexpr uint32_t CR_ADCAL = 0x80000000;   // ADC calibration
    static constexpr uint32_t CR_ADCALDIF = 0x40000000;// ADC differential mode for calibration
    static constexpr uint32_t CR_DEEPPWD = 0x20000000; // ADC deep power down enable
    static constexpr uint32_t CR_ADVREGEN = 0x10000000;// ADC voltage regulator enable
    static constexpr uint32_t CR_LINCALRDYW6 = 0x8000000;// Linearity calibration ready Word 6
    static constexpr uint32_t CR_LINCALRDYW5 = 0x4000000;// Linearity calibration ready Word 5
    static constexpr uint32_t CR_LINCALRDYW4 = 0x2000000;// Linearity calibration ready Word 4
    static constexpr uint32_t CR_LINCALRDYW3 = 0x1000000;// Linearity calibration ready Word 3
    static constexpr uint32_t CR_LINCALRDYW2 = 0x800000;// Linearity calibration ready Word 2
    static constexpr uint32_t CR_LINCALRDYW1 = 0x400000;// Linearity calibration ready Word 1
    static constexpr uint32_t CR_ADCALLIN = 0x10000;   // Linearity calibration
    static constexpr uint32_t CR_BOOST = 0x100;        // Boost mode control
    static constexpr uint32_t CR_JADSTP = 0x20;        // ADC group injected conversion stop
    static constexpr uint32_t CR_ADSTP = 0x10;         // ADC group regular conversion stop
    static constexpr uint32_t CR_JADSTART = 0x8;       // ADC group injected conversion start
    static constexpr uint32_t CR_ADSTART = 0x4;        // ADC group regular conversion start
    static constexpr uint32_t CR_ADDIS = 0x2;          // ADC disable
    static constexpr uint32_t CR_ADEN = 0x1;           // ADC enable
    static const uint32_t CR_RESET_VALUE = 0x0;

    static constexpr uint32_t CFGR_JQDIS = 0x80000000;   // ADC group injected contexts queue disable
    template<uint32_t X>
    static constexpr uint32_t CFGR_AWDCH1CH =            // ADC analog watchdog 1 monitored channel selection (5 bits)
        bit_field_t<26, 0x1f>::value<X>();
    static constexpr uint32_t CFGR_JAUTO = 0x2000000;    // ADC group injected automatic trigger mode
    static constexpr uint32_t CFGR_JAWD1EN = 0x1000000;  // ADC analog watchdog 1 enable on scope ADC group injected
    static constexpr uint32_t CFGR_AWD1EN = 0x800000;    // ADC analog watchdog 1 enable on scope ADC group regular
    static constexpr uint32_t CFGR_AWD1SGL = 0x400000;   // ADC analog watchdog 1 monitoring a single channel or all channels
    static constexpr uint32_t CFGR_JQM = 0x200000;       // ADC group injected contexts queue mode
    static constexpr uint32_t CFGR_JDISCEN = 0x100000;   // ADC group injected sequencer discontinuous mode
    template<uint32_t X>
    static constexpr uint32_t CFGR_DISCNUM =             // ADC group regular sequencer discontinuous number of ranks (3 bits)
        bit_field_t<17, 0x7>::value<X>();
    static constexpr uint32_t CFGR_DISCEN = 0x10000;     // ADC group regular sequencer discontinuous mode
    static constexpr uint32_t CFGR_AUTDLY = 0x4000;      // ADC low power auto wait
    static constexpr uint32_t CFGR_CONT = 0x2000;        // ADC group regular continuous conversion mode
    static constexpr uint32_t CFGR_OVRMOD = 0x1000;      // ADC group regular overrun configuration
    template<uint32_t X>
    static constexpr uint32_t CFGR_EXTEN =               // ADC group regular external trigger polarity (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_EXTSEL =              // ADC group regular external trigger source (5 bits)
        bit_field_t<5, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_RES =                 // ADC data resolution (3 bits)
        bit_field_t<2, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_DMNGT =               // ADC DMA transfer enable (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t CFGR_RESET_VALUE = 0x0;

    static constexpr uint32_t CFGR2_ROVSE = 0x1;          // ADC oversampler enable on scope ADC group regular
    static constexpr uint32_t CFGR2_JOVSE = 0x2;          // ADC oversampler enable on scope ADC group injected
    template<uint32_t X>
    static constexpr uint32_t CFGR2_OVSS =                // ADC oversampling shift (4 bits)
        bit_field_t<5, 0xf>::value<X>();
    static constexpr uint32_t CFGR2_TROVS = 0x200;        // ADC oversampling discontinuous mode (triggered mode) for ADC group regular
    static constexpr uint32_t CFGR2_ROVSM = 0x400;        // Regular Oversampling mode
    static constexpr uint32_t CFGR2_RSHIFT1 = 0x800;      // Right-shift data after Offset 1 correction
    static constexpr uint32_t CFGR2_RSHIFT2 = 0x1000;     // Right-shift data after Offset 2 correction
    static constexpr uint32_t CFGR2_RSHIFT3 = 0x2000;     // Right-shift data after Offset 3 correction
    static constexpr uint32_t CFGR2_RSHIFT4 = 0x4000;     // Right-shift data after Offset 4 correction
    template<uint32_t X>
    static constexpr uint32_t CFGR2_OSR =                 // Oversampling ratio (10 bits)
        bit_field_t<16, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR2_LSHIFT =              // Left shift factor (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    static const uint32_t CFGR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SMPR1_SMP9 =                // ADC channel 9 sampling time selection (3 bits)
        bit_field_t<27, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR1_SMP8 =                // ADC channel 8 sampling time selection (3 bits)
        bit_field_t<24, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR1_SMP7 =                // ADC channel 7 sampling time selection (3 bits)
        bit_field_t<21, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR1_SMP6 =                // ADC channel 6 sampling time selection (3 bits)
        bit_field_t<18, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR1_SMP5 =                // ADC channel 5 sampling time selection (3 bits)
        bit_field_t<15, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR1_SMP4 =                // ADC channel 4 sampling time selection (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR1_SMP3 =                // ADC channel 3 sampling time selection (3 bits)
        bit_field_t<9, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR1_SMP2 =                // ADC channel 2 sampling time selection (3 bits)
        bit_field_t<6, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR1_SMP1 =                // ADC channel 1 sampling time selection (3 bits)
        bit_field_t<3, 0x7>::value<X>();
    static const uint32_t SMPR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SMPR2_SMP19 =               // ADC channel 18 sampling time selection (3 bits)
        bit_field_t<27, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR2_SMP18 =               // ADC channel 18 sampling time selection (3 bits)
        bit_field_t<24, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR2_SMP17 =               // ADC channel 17 sampling time selection (3 bits)
        bit_field_t<21, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR2_SMP16 =               // ADC channel 16 sampling time selection (3 bits)
        bit_field_t<18, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR2_SMP15 =               // ADC channel 15 sampling time selection (3 bits)
        bit_field_t<15, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR2_SMP14 =               // ADC channel 14 sampling time selection (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR2_SMP13 =               // ADC channel 13 sampling time selection (3 bits)
        bit_field_t<9, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR2_SMP12 =               // ADC channel 12 sampling time selection (3 bits)
        bit_field_t<6, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR2_SMP11 =               // ADC channel 11 sampling time selection (3 bits)
        bit_field_t<3, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR2_SMP10 =               // ADC channel 10 sampling time selection (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t SMPR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PCSEL_PCSEL =               // Channel x (VINP[i]) pre selection (20 bits)
        bit_field_t<0, 0xfffff>::value<X>();
    static const uint32_t PCSEL_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t LTR1_LTR1 =                // ADC analog watchdog 1 threshold low (26 bits)
        bit_field_t<0, 0x3ffffff>::value<X>();
    static const uint32_t LTR1_RESET_VALUE = 0xfff0000;

    template<uint32_t X>
    static constexpr uint32_t LHTR1_LHTR1 =               // ADC analog watchdog 2 threshold low (26 bits)
        bit_field_t<0, 0x3ffffff>::value<X>();
    static const uint32_t LHTR1_RESET_VALUE = 0xfff0000;

    template<uint32_t X>
    static constexpr uint32_t SQR1_SQ4 =                 // ADC group regular sequencer rank 4 (5 bits)
        bit_field_t<24, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR1_SQ3 =                 // ADC group regular sequencer rank 3 (5 bits)
        bit_field_t<18, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR1_SQ2 =                 // ADC group regular sequencer rank 2 (5 bits)
        bit_field_t<12, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR1_SQ1 =                 // ADC group regular sequencer rank 1 (5 bits)
        bit_field_t<6, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR1_L3 =                  // L3 (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t SQR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SQR2_SQ9 =                 // ADC group regular sequencer rank 9 (5 bits)
        bit_field_t<24, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR2_SQ8 =                 // ADC group regular sequencer rank 8 (5 bits)
        bit_field_t<18, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR2_SQ7 =                 // ADC group regular sequencer rank 7 (5 bits)
        bit_field_t<12, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR2_SQ6 =                 // ADC group regular sequencer rank 6 (5 bits)
        bit_field_t<6, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR2_SQ5 =                 // ADC group regular sequencer rank 5 (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t SQR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SQR3_SQ14 =                // ADC group regular sequencer rank 14 (5 bits)
        bit_field_t<24, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR3_SQ13 =                // ADC group regular sequencer rank 13 (5 bits)
        bit_field_t<18, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR3_SQ12 =                // ADC group regular sequencer rank 12 (5 bits)
        bit_field_t<12, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR3_SQ11 =                // ADC group regular sequencer rank 11 (5 bits)
        bit_field_t<6, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR3_SQ10 =                // ADC group regular sequencer rank 10 (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t SQR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SQR4_SQ16 =                // ADC group regular sequencer rank 16 (5 bits)
        bit_field_t<6, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR4_SQ15 =                // ADC group regular sequencer rank 15 (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t SQR4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DR_RDATA =               // ADC group regular conversion data (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t JSQR_JSQ4 =                // ADC group injected sequencer rank 4 (5 bits)
        bit_field_t<27, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t JSQR_JSQ3 =                // ADC group injected sequencer rank 3 (5 bits)
        bit_field_t<21, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t JSQR_JSQ2 =                // ADC group injected sequencer rank 2 (5 bits)
        bit_field_t<15, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t JSQR_JSQ1 =                // ADC group injected sequencer rank 1 (5 bits)
        bit_field_t<9, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t JSQR_JEXTEN =              // ADC group injected external trigger polarity (2 bits)
        bit_field_t<7, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t JSQR_JEXTSEL =             // ADC group injected external trigger source (5 bits)
        bit_field_t<2, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t JSQR_JL =                  // ADC group injected sequencer scan length (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t JSQR_RESET_VALUE = 0x0;

    static constexpr uint32_t OFR1_SSATE = 0x80000000;   // ADC offset number 1 enable
    template<uint32_t X>
    static constexpr uint32_t OFR1_OFFSET1_CH =          // ADC offset number 1 channel selection (5 bits)
        bit_field_t<26, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OFR1_OFFSET1 =             // ADC offset number 1 offset level (26 bits)
        bit_field_t<0, 0x3ffffff>::value<X>();
    static const uint32_t OFR1_RESET_VALUE = 0x0;

    static constexpr uint32_t OFR2_SSATE = 0x80000000;   // ADC offset number 1 enable
    template<uint32_t X>
    static constexpr uint32_t OFR2_OFFSET1_CH =          // ADC offset number 1 channel selection (5 bits)
        bit_field_t<26, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OFR2_OFFSET1 =             // ADC offset number 1 offset level (26 bits)
        bit_field_t<0, 0x3ffffff>::value<X>();
    static const uint32_t OFR2_RESET_VALUE = 0x0;

    static constexpr uint32_t OFR3_SSATE = 0x80000000;   // ADC offset number 1 enable
    template<uint32_t X>
    static constexpr uint32_t OFR3_OFFSET1_CH =          // ADC offset number 1 channel selection (5 bits)
        bit_field_t<26, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OFR3_OFFSET1 =             // ADC offset number 1 offset level (26 bits)
        bit_field_t<0, 0x3ffffff>::value<X>();
    static const uint32_t OFR3_RESET_VALUE = 0x0;

    static constexpr uint32_t OFR4_SSATE = 0x80000000;   // ADC offset number 1 enable
    template<uint32_t X>
    static constexpr uint32_t OFR4_OFFSET1_CH =          // ADC offset number 1 channel selection (5 bits)
        bit_field_t<26, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OFR4_OFFSET1 =             // ADC offset number 1 offset level (26 bits)
        bit_field_t<0, 0x3ffffff>::value<X>();
    static const uint32_t OFR4_RESET_VALUE = 0x0;


    static const uint32_t JDR1_RESET_VALUE = 0x0;


    static const uint32_t JDR2_RESET_VALUE = 0x0;


    static const uint32_t JDR3_RESET_VALUE = 0x0;


    static const uint32_t JDR4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AWD2CR_AWD2CH =              // ADC analog watchdog 2 monitored channel selection (20 bits)
        bit_field_t<0, 0xfffff>::value<X>();
    static const uint32_t AWD2CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AWD3CR_AWD3CH =              // ADC analog watchdog 3 monitored channel selection (20 bits)
        bit_field_t<1, 0xfffff>::value<X>();
    static const uint32_t AWD3CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t LTR2_LTR2 =                // Analog watchdog 2 lower threshold (26 bits)
        bit_field_t<0, 0x3ffffff>::value<X>();
    static const uint32_t LTR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HTR2_HTR2 =                // Analog watchdog 2 higher threshold (26 bits)
        bit_field_t<0, 0x3ffffff>::value<X>();
    static const uint32_t HTR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t LTR3_LTR3 =                // Analog watchdog 3 lower threshold (26 bits)
        bit_field_t<0, 0x3ffffff>::value<X>();
    static const uint32_t LTR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HTR3_HTR3 =                // Analog watchdog 3 higher threshold (26 bits)
        bit_field_t<0, 0x3ffffff>::value<X>();
    static const uint32_t HTR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DIFSEL_DIFSEL =              // ADC channel differential or single-ended mode for channel (20 bits)
        bit_field_t<0, 0xfffff>::value<X>();
    static const uint32_t DIFSEL_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CALFACT_CALFACT_D =           // ADC calibration factor in differential mode (11 bits)
        bit_field_t<16, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CALFACT_CALFACT_S =           // ADC calibration factor in single-ended mode (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    static const uint32_t CALFACT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CALFACT2_LINCALFACT =          // Linearity Calibration Factor (30 bits)
        bit_field_t<0, 0x3fffffff>::value<X>();
    static const uint32_t CALFACT2_RESET_VALUE = 0x0;
};

static adc1_t& ADC1 = *reinterpret_cast<adc1_t*>(0x40022000);

#define HAVE_PERIPHERAL_ADC1


////
//
//    Analog to Digital Converter
//
////

struct adc2_t
{
    volatile uint32_t    ISR;                  // [Read-write] ADC interrupt and status register
    volatile uint32_t    IER;                  // [Read-write] ADC interrupt enable register
    volatile uint32_t    CR;                   // [Read-write] ADC control register
    volatile uint32_t    CFGR;                 // [Read-write] ADC configuration register 1
    volatile uint32_t    CFGR2;                // [Read-write] ADC configuration register 2
    volatile uint32_t    SMPR1;                // [Read-write] ADC sampling time register 1
    volatile uint32_t    SMPR2;                // [Read-write] ADC sampling time register 2
    volatile uint32_t    PCSEL;                // [Read-write] ADC pre channel selection register
    volatile uint32_t    LTR1;                 // [Read-write] ADC analog watchdog 1 threshold register
    volatile uint32_t    LHTR1;                // [Read-write] ADC analog watchdog 2 threshold register
    reserved_t<2>        _0;
    volatile uint32_t    SQR1;                 // [Read-write] ADC group regular sequencer ranks register 1
    volatile uint32_t    SQR2;                 // [Read-write] ADC group regular sequencer ranks register 2
    volatile uint32_t    SQR3;                 // [Read-write] ADC group regular sequencer ranks register 3
    volatile uint32_t    SQR4;                 // [Read-write] ADC group regular sequencer ranks register 4
    volatile uint32_t    DR;                   // [Read-only] ADC group regular conversion data register
    reserved_t<2>        _1;
    volatile uint32_t    JSQR;                 // [Read-write] ADC group injected sequencer register
    reserved_t<4>        _2;
    volatile uint32_t    OFR1;                 // [Read-write] ADC offset number 1 register
    volatile uint32_t    OFR2;                 // [Read-write] ADC offset number 2 register
    volatile uint32_t    OFR3;                 // [Read-write] ADC offset number 3 register
    volatile uint32_t    OFR4;                 // [Read-write] ADC offset number 4 register
    reserved_t<4>        _3;
    volatile uint32_t    JDR1;                 // [Read-only] ADC group injected sequencer rank 1 register
    volatile uint32_t    JDR2;                 // [Read-only] ADC group injected sequencer rank 2 register
    volatile uint32_t    JDR3;                 // [Read-only] ADC group injected sequencer rank 3 register
    volatile uint32_t    JDR4;                 // [Read-only] ADC group injected sequencer rank 4 register
    reserved_t<4>        _4;
    volatile uint32_t    AWD2CR;               // [Read-write] ADC analog watchdog 2 configuration register
    volatile uint32_t    AWD3CR;               // [Read-write] ADC analog watchdog 3 configuration register
    reserved_t<2>        _5;
    volatile uint32_t    LTR2;                 // [Read-write] ADC watchdog lower threshold register 2
    volatile uint32_t    HTR2;                 // [Read-write] ADC watchdog higher threshold register 2
    volatile uint32_t    LTR3;                 // [Read-write] ADC watchdog lower threshold register 3
    volatile uint32_t    HTR3;                 // [Read-write] ADC watchdog higher threshold register 3
    volatile uint32_t    DIFSEL;               // [Read-write] ADC channel differential or single-ended mode selection register
    volatile uint32_t    CALFACT;              // [Read-write] ADC calibration factors register
    volatile uint32_t    CALFACT2;             // [Read-write] ADC Calibration Factor register 2

    static constexpr uint32_t ISR_JQOVF = 0x400;        // ADC group injected contexts queue overflow flag
    static constexpr uint32_t ISR_AWD3 = 0x200;         // ADC analog watchdog 3 flag
    static constexpr uint32_t ISR_AWD2 = 0x100;         // ADC analog watchdog 2 flag
    static constexpr uint32_t ISR_AWD1 = 0x80;          // ADC analog watchdog 1 flag
    static constexpr uint32_t ISR_JEOS = 0x40;          // ADC group injected end of sequence conversions flag
    static constexpr uint32_t ISR_JEOC = 0x20;          // ADC group injected end of unitary conversion flag
    static constexpr uint32_t ISR_OVR = 0x10;           // ADC group regular overrun flag
    static constexpr uint32_t ISR_EOS = 0x8;            // ADC group regular end of sequence conversions flag
    static constexpr uint32_t ISR_EOC = 0x4;            // ADC group regular end of unitary conversion flag
    static constexpr uint32_t ISR_EOSMP = 0x2;          // ADC group regular end of sampling flag
    static constexpr uint32_t ISR_ADRDY = 0x1;          // ADC ready flag
    static const uint32_t ISR_RESET_VALUE = 0x0;

    static constexpr uint32_t IER_JQOVFIE = 0x400;      // ADC group injected contexts queue overflow interrupt
    static constexpr uint32_t IER_AWD3IE = 0x200;       // ADC analog watchdog 3 interrupt
    static constexpr uint32_t IER_AWD2IE = 0x100;       // ADC analog watchdog 2 interrupt
    static constexpr uint32_t IER_AWD1IE = 0x80;        // ADC analog watchdog 1 interrupt
    static constexpr uint32_t IER_JEOSIE = 0x40;        // ADC group injected end of sequence conversions interrupt
    static constexpr uint32_t IER_JEOCIE = 0x20;        // ADC group injected end of unitary conversion interrupt
    static constexpr uint32_t IER_OVRIE = 0x10;         // ADC group regular overrun interrupt
    static constexpr uint32_t IER_EOSIE = 0x8;          // ADC group regular end of sequence conversions interrupt
    static constexpr uint32_t IER_EOCIE = 0x4;          // ADC group regular end of unitary conversion interrupt
    static constexpr uint32_t IER_EOSMPIE = 0x2;        // ADC group regular end of sampling interrupt
    static constexpr uint32_t IER_ADRDYIE = 0x1;        // ADC ready interrupt
    static const uint32_t IER_RESET_VALUE = 0x0;

    static constexpr uint32_t CR_ADCAL = 0x80000000;   // ADC calibration
    static constexpr uint32_t CR_ADCALDIF = 0x40000000;// ADC differential mode for calibration
    static constexpr uint32_t CR_DEEPPWD = 0x20000000; // ADC deep power down enable
    static constexpr uint32_t CR_ADVREGEN = 0x10000000;// ADC voltage regulator enable
    static constexpr uint32_t CR_LINCALRDYW6 = 0x8000000;// Linearity calibration ready Word 6
    static constexpr uint32_t CR_LINCALRDYW5 = 0x4000000;// Linearity calibration ready Word 5
    static constexpr uint32_t CR_LINCALRDYW4 = 0x2000000;// Linearity calibration ready Word 4
    static constexpr uint32_t CR_LINCALRDYW3 = 0x1000000;// Linearity calibration ready Word 3
    static constexpr uint32_t CR_LINCALRDYW2 = 0x800000;// Linearity calibration ready Word 2
    static constexpr uint32_t CR_LINCALRDYW1 = 0x400000;// Linearity calibration ready Word 1
    static constexpr uint32_t CR_ADCALLIN = 0x10000;   // Linearity calibration
    static constexpr uint32_t CR_BOOST = 0x100;        // Boost mode control
    static constexpr uint32_t CR_JADSTP = 0x20;        // ADC group injected conversion stop
    static constexpr uint32_t CR_ADSTP = 0x10;         // ADC group regular conversion stop
    static constexpr uint32_t CR_JADSTART = 0x8;       // ADC group injected conversion start
    static constexpr uint32_t CR_ADSTART = 0x4;        // ADC group regular conversion start
    static constexpr uint32_t CR_ADDIS = 0x2;          // ADC disable
    static constexpr uint32_t CR_ADEN = 0x1;           // ADC enable
    static const uint32_t CR_RESET_VALUE = 0x0;

    static constexpr uint32_t CFGR_JQDIS = 0x80000000;   // ADC group injected contexts queue disable
    template<uint32_t X>
    static constexpr uint32_t CFGR_AWDCH1CH =            // ADC analog watchdog 1 monitored channel selection (5 bits)
        bit_field_t<26, 0x1f>::value<X>();
    static constexpr uint32_t CFGR_JAUTO = 0x2000000;    // ADC group injected automatic trigger mode
    static constexpr uint32_t CFGR_JAWD1EN = 0x1000000;  // ADC analog watchdog 1 enable on scope ADC group injected
    static constexpr uint32_t CFGR_AWD1EN = 0x800000;    // ADC analog watchdog 1 enable on scope ADC group regular
    static constexpr uint32_t CFGR_AWD1SGL = 0x400000;   // ADC analog watchdog 1 monitoring a single channel or all channels
    static constexpr uint32_t CFGR_JQM = 0x200000;       // ADC group injected contexts queue mode
    static constexpr uint32_t CFGR_JDISCEN = 0x100000;   // ADC group injected sequencer discontinuous mode
    template<uint32_t X>
    static constexpr uint32_t CFGR_DISCNUM =             // ADC group regular sequencer discontinuous number of ranks (3 bits)
        bit_field_t<17, 0x7>::value<X>();
    static constexpr uint32_t CFGR_DISCEN = 0x10000;     // ADC group regular sequencer discontinuous mode
    static constexpr uint32_t CFGR_AUTDLY = 0x4000;      // ADC low power auto wait
    static constexpr uint32_t CFGR_CONT = 0x2000;        // ADC group regular continuous conversion mode
    static constexpr uint32_t CFGR_OVRMOD = 0x1000;      // ADC group regular overrun configuration
    template<uint32_t X>
    static constexpr uint32_t CFGR_EXTEN =               // ADC group regular external trigger polarity (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_EXTSEL =              // ADC group regular external trigger source (5 bits)
        bit_field_t<5, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_RES =                 // ADC data resolution (3 bits)
        bit_field_t<2, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_DMNGT =               // ADC DMA transfer enable (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t CFGR_RESET_VALUE = 0x0;

    static constexpr uint32_t CFGR2_ROVSE = 0x1;          // ADC oversampler enable on scope ADC group regular
    static constexpr uint32_t CFGR2_JOVSE = 0x2;          // ADC oversampler enable on scope ADC group injected
    template<uint32_t X>
    static constexpr uint32_t CFGR2_OVSS =                // ADC oversampling shift (4 bits)
        bit_field_t<5, 0xf>::value<X>();
    static constexpr uint32_t CFGR2_TROVS = 0x200;        // ADC oversampling discontinuous mode (triggered mode) for ADC group regular
    static constexpr uint32_t CFGR2_ROVSM = 0x400;        // Regular Oversampling mode
    static constexpr uint32_t CFGR2_RSHIFT1 = 0x800;      // Right-shift data after Offset 1 correction
    static constexpr uint32_t CFGR2_RSHIFT2 = 0x1000;     // Right-shift data after Offset 2 correction
    static constexpr uint32_t CFGR2_RSHIFT3 = 0x2000;     // Right-shift data after Offset 3 correction
    static constexpr uint32_t CFGR2_RSHIFT4 = 0x4000;     // Right-shift data after Offset 4 correction
    template<uint32_t X>
    static constexpr uint32_t CFGR2_OSR =                 // Oversampling ratio (10 bits)
        bit_field_t<16, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR2_LSHIFT =              // Left shift factor (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    static const uint32_t CFGR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SMPR1_SMP9 =                // ADC channel 9 sampling time selection (3 bits)
        bit_field_t<27, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR1_SMP8 =                // ADC channel 8 sampling time selection (3 bits)
        bit_field_t<24, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR1_SMP7 =                // ADC channel 7 sampling time selection (3 bits)
        bit_field_t<21, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR1_SMP6 =                // ADC channel 6 sampling time selection (3 bits)
        bit_field_t<18, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR1_SMP5 =                // ADC channel 5 sampling time selection (3 bits)
        bit_field_t<15, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR1_SMP4 =                // ADC channel 4 sampling time selection (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR1_SMP3 =                // ADC channel 3 sampling time selection (3 bits)
        bit_field_t<9, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR1_SMP2 =                // ADC channel 2 sampling time selection (3 bits)
        bit_field_t<6, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR1_SMP1 =                // ADC channel 1 sampling time selection (3 bits)
        bit_field_t<3, 0x7>::value<X>();
    static const uint32_t SMPR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SMPR2_SMP19 =               // ADC channel 18 sampling time selection (3 bits)
        bit_field_t<27, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR2_SMP18 =               // ADC channel 18 sampling time selection (3 bits)
        bit_field_t<24, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR2_SMP17 =               // ADC channel 17 sampling time selection (3 bits)
        bit_field_t<21, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR2_SMP16 =               // ADC channel 16 sampling time selection (3 bits)
        bit_field_t<18, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR2_SMP15 =               // ADC channel 15 sampling time selection (3 bits)
        bit_field_t<15, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR2_SMP14 =               // ADC channel 14 sampling time selection (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR2_SMP13 =               // ADC channel 13 sampling time selection (3 bits)
        bit_field_t<9, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR2_SMP12 =               // ADC channel 12 sampling time selection (3 bits)
        bit_field_t<6, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR2_SMP11 =               // ADC channel 11 sampling time selection (3 bits)
        bit_field_t<3, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMPR2_SMP10 =               // ADC channel 10 sampling time selection (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t SMPR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PCSEL_PCSEL =               // Channel x (VINP[i]) pre selection (20 bits)
        bit_field_t<0, 0xfffff>::value<X>();
    static const uint32_t PCSEL_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t LTR1_LTR1 =                // ADC analog watchdog 1 threshold low (26 bits)
        bit_field_t<0, 0x3ffffff>::value<X>();
    static const uint32_t LTR1_RESET_VALUE = 0xfff0000;

    template<uint32_t X>
    static constexpr uint32_t LHTR1_LHTR1 =               // ADC analog watchdog 2 threshold low (26 bits)
        bit_field_t<0, 0x3ffffff>::value<X>();
    static const uint32_t LHTR1_RESET_VALUE = 0xfff0000;

    template<uint32_t X>
    static constexpr uint32_t SQR1_SQ4 =                 // ADC group regular sequencer rank 4 (5 bits)
        bit_field_t<24, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR1_SQ3 =                 // ADC group regular sequencer rank 3 (5 bits)
        bit_field_t<18, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR1_SQ2 =                 // ADC group regular sequencer rank 2 (5 bits)
        bit_field_t<12, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR1_SQ1 =                 // ADC group regular sequencer rank 1 (5 bits)
        bit_field_t<6, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR1_L3 =                  // L3 (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t SQR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SQR2_SQ9 =                 // ADC group regular sequencer rank 9 (5 bits)
        bit_field_t<24, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR2_SQ8 =                 // ADC group regular sequencer rank 8 (5 bits)
        bit_field_t<18, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR2_SQ7 =                 // ADC group regular sequencer rank 7 (5 bits)
        bit_field_t<12, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR2_SQ6 =                 // ADC group regular sequencer rank 6 (5 bits)
        bit_field_t<6, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR2_SQ5 =                 // ADC group regular sequencer rank 5 (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t SQR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SQR3_SQ14 =                // ADC group regular sequencer rank 14 (5 bits)
        bit_field_t<24, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR3_SQ13 =                // ADC group regular sequencer rank 13 (5 bits)
        bit_field_t<18, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR3_SQ12 =                // ADC group regular sequencer rank 12 (5 bits)
        bit_field_t<12, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR3_SQ11 =                // ADC group regular sequencer rank 11 (5 bits)
        bit_field_t<6, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR3_SQ10 =                // ADC group regular sequencer rank 10 (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t SQR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SQR4_SQ16 =                // ADC group regular sequencer rank 16 (5 bits)
        bit_field_t<6, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR4_SQ15 =                // ADC group regular sequencer rank 15 (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t SQR4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DR_RDATA =               // ADC group regular conversion data (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t JSQR_JSQ4 =                // ADC group injected sequencer rank 4 (5 bits)
        bit_field_t<27, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t JSQR_JSQ3 =                // ADC group injected sequencer rank 3 (5 bits)
        bit_field_t<21, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t JSQR_JSQ2 =                // ADC group injected sequencer rank 2 (5 bits)
        bit_field_t<15, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t JSQR_JSQ1 =                // ADC group injected sequencer rank 1 (5 bits)
        bit_field_t<9, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t JSQR_JEXTEN =              // ADC group injected external trigger polarity (2 bits)
        bit_field_t<7, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t JSQR_JEXTSEL =             // ADC group injected external trigger source (5 bits)
        bit_field_t<2, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t JSQR_JL =                  // ADC group injected sequencer scan length (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t JSQR_RESET_VALUE = 0x0;

    static constexpr uint32_t OFR1_SSATE = 0x80000000;   // ADC offset number 1 enable
    template<uint32_t X>
    static constexpr uint32_t OFR1_OFFSET1_CH =          // ADC offset number 1 channel selection (5 bits)
        bit_field_t<26, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OFR1_OFFSET1 =             // ADC offset number 1 offset level (26 bits)
        bit_field_t<0, 0x3ffffff>::value<X>();
    static const uint32_t OFR1_RESET_VALUE = 0x0;

    static constexpr uint32_t OFR2_SSATE = 0x80000000;   // ADC offset number 1 enable
    template<uint32_t X>
    static constexpr uint32_t OFR2_OFFSET1_CH =          // ADC offset number 1 channel selection (5 bits)
        bit_field_t<26, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OFR2_OFFSET1 =             // ADC offset number 1 offset level (26 bits)
        bit_field_t<0, 0x3ffffff>::value<X>();
    static const uint32_t OFR2_RESET_VALUE = 0x0;

    static constexpr uint32_t OFR3_SSATE = 0x80000000;   // ADC offset number 1 enable
    template<uint32_t X>
    static constexpr uint32_t OFR3_OFFSET1_CH =          // ADC offset number 1 channel selection (5 bits)
        bit_field_t<26, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OFR3_OFFSET1 =             // ADC offset number 1 offset level (26 bits)
        bit_field_t<0, 0x3ffffff>::value<X>();
    static const uint32_t OFR3_RESET_VALUE = 0x0;

    static constexpr uint32_t OFR4_SSATE = 0x80000000;   // ADC offset number 1 enable
    template<uint32_t X>
    static constexpr uint32_t OFR4_OFFSET1_CH =          // ADC offset number 1 channel selection (5 bits)
        bit_field_t<26, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OFR4_OFFSET1 =             // ADC offset number 1 offset level (26 bits)
        bit_field_t<0, 0x3ffffff>::value<X>();
    static const uint32_t OFR4_RESET_VALUE = 0x0;


    static const uint32_t JDR1_RESET_VALUE = 0x0;


    static const uint32_t JDR2_RESET_VALUE = 0x0;


    static const uint32_t JDR3_RESET_VALUE = 0x0;


    static const uint32_t JDR4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AWD2CR_AWD2CH =              // ADC analog watchdog 2 monitored channel selection (20 bits)
        bit_field_t<0, 0xfffff>::value<X>();
    static const uint32_t AWD2CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AWD3CR_AWD3CH =              // ADC analog watchdog 3 monitored channel selection (20 bits)
        bit_field_t<1, 0xfffff>::value<X>();
    static const uint32_t AWD3CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t LTR2_LTR2 =                // Analog watchdog 2 lower threshold (26 bits)
        bit_field_t<0, 0x3ffffff>::value<X>();
    static const uint32_t LTR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HTR2_HTR2 =                // Analog watchdog 2 higher threshold (26 bits)
        bit_field_t<0, 0x3ffffff>::value<X>();
    static const uint32_t HTR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t LTR3_LTR3 =                // Analog watchdog 3 lower threshold (26 bits)
        bit_field_t<0, 0x3ffffff>::value<X>();
    static const uint32_t LTR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HTR3_HTR3 =                // Analog watchdog 3 higher threshold (26 bits)
        bit_field_t<0, 0x3ffffff>::value<X>();
    static const uint32_t HTR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DIFSEL_DIFSEL =              // ADC channel differential or single-ended mode for channel (20 bits)
        bit_field_t<0, 0xfffff>::value<X>();
    static const uint32_t DIFSEL_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CALFACT_CALFACT_D =           // ADC calibration factor in differential mode (11 bits)
        bit_field_t<16, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CALFACT_CALFACT_S =           // ADC calibration factor in single-ended mode (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    static const uint32_t CALFACT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CALFACT2_LINCALFACT =          // Linearity Calibration Factor (30 bits)
        bit_field_t<0, 0x3fffffff>::value<X>();
    static const uint32_t CALFACT2_RESET_VALUE = 0x0;
};

static adc2_t& ADC2 = *reinterpret_cast<adc2_t*>(0x40022100);

#define HAVE_PERIPHERAL_ADC2


////
//
//    Analog-to-Digital Converter
//
////

struct adc3_common_t
{
    volatile uint32_t    CSR;                  // [Read-only] ADC Common status register
    reserved_t<1>        _0;
    volatile uint32_t    CCR;                  // [Read-write] ADC common control register
    volatile uint32_t    CDR;                  // [Read-only] ADC common regular data register for dual and triple modes
    volatile uint32_t    CDR2;                 // [Read-only] ADC x common regular data register for 32-bit dual mode

    static constexpr uint32_t CSR_ADRDY_MST = 0x1;      // Master ADC ready
    static constexpr uint32_t CSR_EOSMP_MST = 0x2;      // End of Sampling phase flag of the master ADC
    static constexpr uint32_t CSR_EOC_MST = 0x4;        // End of regular conversion of the master ADC
    static constexpr uint32_t CSR_EOS_MST = 0x8;        // End of regular sequence flag of the master ADC
    static constexpr uint32_t CSR_OVR_MST = 0x10;       // Overrun flag of the master ADC
    static constexpr uint32_t CSR_JEOC_MST = 0x20;      // End of injected conversion flag of the master ADC
    static constexpr uint32_t CSR_JEOS_MST = 0x40;      // End of injected sequence flag of the master ADC
    static constexpr uint32_t CSR_AWD1_MST = 0x80;      // Analog watchdog 1 flag of the master ADC
    static constexpr uint32_t CSR_AWD2_MST = 0x100;     // Analog watchdog 2 flag of the master ADC
    static constexpr uint32_t CSR_AWD3_MST = 0x200;     // Analog watchdog 3 flag of the master ADC
    static constexpr uint32_t CSR_JQOVF_MST = 0x400;    // Injected Context Queue Overflow flag of the master ADC
    static constexpr uint32_t CSR_ADRDY_SLV = 0x10000;  // Slave ADC ready
    static constexpr uint32_t CSR_EOSMP_SLV = 0x20000;  // End of Sampling phase flag of the slave ADC
    static constexpr uint32_t CSR_EOC_SLV = 0x40000;    // End of regular conversion of the slave ADC
    static constexpr uint32_t CSR_EOS_SLV = 0x80000;    // End of regular sequence flag of the slave ADC
    static constexpr uint32_t CSR_OVR_SLV = 0x100000;   // Overrun flag of the slave ADC
    static constexpr uint32_t CSR_JEOC_SLV = 0x200000;  // End of injected conversion flag of the slave ADC
    static constexpr uint32_t CSR_JEOS_SLV = 0x400000;  // End of injected sequence flag of the slave ADC
    static constexpr uint32_t CSR_AWD1_SLV = 0x800000;  // Analog watchdog 1 flag of the slave ADC
    static constexpr uint32_t CSR_AWD2_SLV = 0x1000000; // Analog watchdog 2 flag of the slave ADC
    static constexpr uint32_t CSR_AWD3_SLV = 0x2000000; // Analog watchdog 3 flag of the slave ADC
    static constexpr uint32_t CSR_JQOVF_SLV = 0x4000000;// Injected Context Queue Overflow flag of the slave ADC
    static const uint32_t CSR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR_DUAL =                // Dual ADC mode selection (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR_DELAY =               // Delay between 2 sampling phases (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR_DAMDF =               // Dual ADC Mode Data Format (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR_CKMODE =              // ADC clock mode (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR_PRESC =               // ADC prescaler (4 bits)
        bit_field_t<18, 0xf>::value<X>();
    static constexpr uint32_t CCR_VREFEN = 0x400000;    // VREFINT enable
    static constexpr uint32_t CCR_TSEN = 0x800000;      // Temperature sensor enable
    static constexpr uint32_t CCR_VBATEN = 0x1000000;   // VBAT enable
    static const uint32_t CCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CDR_RDATA_SLV =           // Regular data of the slave ADC (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CDR_RDATA_MST =           // Regular data of the master ADC (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CDR_RESET_VALUE = 0x0;


    static const uint32_t CDR2_RESET_VALUE = 0x0;
};

static adc3_common_t& ADC3_COMMON = *reinterpret_cast<adc3_common_t*>(0x58026300);

#define HAVE_PERIPHERAL_ADC3_COMMON


////
//
//    Analog-to-Digital Converter
//
////

struct adc12_common_t
{
    volatile uint32_t    CSR;                  // [Read-only] ADC Common status register
    reserved_t<1>        _0;
    volatile uint32_t    CCR;                  // [Read-write] ADC common control register
    volatile uint32_t    CDR;                  // [Read-only] ADC common regular data register for dual and triple modes
    volatile uint32_t    CDR2;                 // [Read-only] ADC x common regular data register for 32-bit dual mode

    static constexpr uint32_t CSR_ADRDY_MST = 0x1;      // Master ADC ready
    static constexpr uint32_t CSR_EOSMP_MST = 0x2;      // End of Sampling phase flag of the master ADC
    static constexpr uint32_t CSR_EOC_MST = 0x4;        // End of regular conversion of the master ADC
    static constexpr uint32_t CSR_EOS_MST = 0x8;        // End of regular sequence flag of the master ADC
    static constexpr uint32_t CSR_OVR_MST = 0x10;       // Overrun flag of the master ADC
    static constexpr uint32_t CSR_JEOC_MST = 0x20;      // End of injected conversion flag of the master ADC
    static constexpr uint32_t CSR_JEOS_MST = 0x40;      // End of injected sequence flag of the master ADC
    static constexpr uint32_t CSR_AWD1_MST = 0x80;      // Analog watchdog 1 flag of the master ADC
    static constexpr uint32_t CSR_AWD2_MST = 0x100;     // Analog watchdog 2 flag of the master ADC
    static constexpr uint32_t CSR_AWD3_MST = 0x200;     // Analog watchdog 3 flag of the master ADC
    static constexpr uint32_t CSR_JQOVF_MST = 0x400;    // Injected Context Queue Overflow flag of the master ADC
    static constexpr uint32_t CSR_ADRDY_SLV = 0x10000;  // Slave ADC ready
    static constexpr uint32_t CSR_EOSMP_SLV = 0x20000;  // End of Sampling phase flag of the slave ADC
    static constexpr uint32_t CSR_EOC_SLV = 0x40000;    // End of regular conversion of the slave ADC
    static constexpr uint32_t CSR_EOS_SLV = 0x80000;    // End of regular sequence flag of the slave ADC
    static constexpr uint32_t CSR_OVR_SLV = 0x100000;   // Overrun flag of the slave ADC
    static constexpr uint32_t CSR_JEOC_SLV = 0x200000;  // End of injected conversion flag of the slave ADC
    static constexpr uint32_t CSR_JEOS_SLV = 0x400000;  // End of injected sequence flag of the slave ADC
    static constexpr uint32_t CSR_AWD1_SLV = 0x800000;  // Analog watchdog 1 flag of the slave ADC
    static constexpr uint32_t CSR_AWD2_SLV = 0x1000000; // Analog watchdog 2 flag of the slave ADC
    static constexpr uint32_t CSR_AWD3_SLV = 0x2000000; // Analog watchdog 3 flag of the slave ADC
    static constexpr uint32_t CSR_JQOVF_SLV = 0x4000000;// Injected Context Queue Overflow flag of the slave ADC
    static const uint32_t CSR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR_DUAL =                // Dual ADC mode selection (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR_DELAY =               // Delay between 2 sampling phases (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR_DAMDF =               // Dual ADC Mode Data Format (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR_CKMODE =              // ADC clock mode (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR_PRESC =               // ADC prescaler (4 bits)
        bit_field_t<18, 0xf>::value<X>();
    static constexpr uint32_t CCR_VREFEN = 0x400000;    // VREFINT enable
    static constexpr uint32_t CCR_TSEN = 0x800000;      // Temperature sensor enable
    static constexpr uint32_t CCR_VBATEN = 0x1000000;   // VBAT enable
    static const uint32_t CCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CDR_RDATA_SLV =           // Regular data of the slave ADC (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CDR_RDATA_MST =           // Regular data of the master ADC (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CDR_RESET_VALUE = 0x0;


    static const uint32_t CDR2_RESET_VALUE = 0x0;

    static constexpr uint8_t ADC1_2 = 18; // ADC1 and ADC2
};

static adc12_common_t& ADC12_COMMON = *reinterpret_cast<adc12_common_t*>(0x40022300);

#define HAVE_PERIPHERAL_ADC12_COMMON


////
//
//    DMAMUX
//
////

struct dmamux1_t
{
    volatile uint32_t    C0CR;                 // [Read-write] DMAMux - DMA request line multiplexer channel x control register
    volatile uint32_t    C1CR;                 // [Read-write] DMAMux - DMA request line multiplexer channel x control register
    volatile uint32_t    C2CR;                 // [Read-write] DMAMux - DMA request line multiplexer channel x control register
    volatile uint32_t    C3CR;                 // [Read-write] DMAMux - DMA request line multiplexer channel x control register
    volatile uint32_t    C4CR;                 // [Read-write] DMAMux - DMA request line multiplexer channel x control register
    volatile uint32_t    C5CR;                 // [Read-write] DMAMux - DMA request line multiplexer channel x control register
    volatile uint32_t    C6CR;                 // [Read-write] DMAMux - DMA request line multiplexer channel x control register
    volatile uint32_t    C7CR;                 // [Read-write] DMAMux - DMA request line multiplexer channel x control register
    volatile uint32_t    C8CR;                 // [Read-write] DMAMux - DMA request line multiplexer channel x control register
    volatile uint32_t    C9CR;                 // [Read-write] DMAMux - DMA request line multiplexer channel x control register
    volatile uint32_t    C10CR;                // [Read-write] DMAMux - DMA request line multiplexer channel x control register
    volatile uint32_t    C11CR;                // [Read-write] DMAMux - DMA request line multiplexer channel x control register
    volatile uint32_t    C12CR;                // [Read-write] DMAMux - DMA request line multiplexer channel x control register
    volatile uint32_t    C13CR;                // [Read-write] DMAMux - DMA request line multiplexer channel x control register
    volatile uint32_t    C14CR;                // [Read-write] DMAMux - DMA request line multiplexer channel x control register
    volatile uint32_t    C15CR;                // [Read-write] DMAMux - DMA request line multiplexer channel x control register
    reserved_t<16>       _0;
    volatile uint32_t    CSR;                  // [Read-only] DMAMUX request line multiplexer interrupt channel status register
    volatile uint32_t    CFR;                  // [Write-only] DMAMUX request line multiplexer interrupt clear flag register
    reserved_t<30>       _1;
    volatile uint32_t    RG0CR;                // [Read-write] DMAMux - DMA request generator channel x control register
    volatile uint32_t    RG1CR;                // [Read-write] DMAMux - DMA request generator channel x control register
    volatile uint32_t    RG2CR;                // [Read-write] DMAMux - DMA request generator channel x control register
    volatile uint32_t    RG3CR;                // [Read-write] DMAMux - DMA request generator channel x control register
    volatile uint32_t    RG4CR;                // [Read-write] DMAMux - DMA request generator channel x control register
    volatile uint32_t    RG5CR;                // [Read-write] DMAMux - DMA request generator channel x control register
    volatile uint32_t    RG6CR;                // [Read-write] DMAMux - DMA request generator channel x control register
    volatile uint32_t    RG7CR;                // [Read-write] DMAMux - DMA request generator channel x control register
    reserved_t<8>        _2;
    volatile uint32_t    RGSR;                 // [Read-only] DMAMux - DMA request generator status register
    volatile uint32_t    RGCFR;                // [Write-only] DMAMux - DMA request generator clear flag register

    template<uint32_t X>
    static constexpr uint32_t C0CR_DMAREQ_ID =           // Input DMA request line selected (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static constexpr uint32_t C0CR_SOIE = 0x100;         // Interrupt enable at synchronization event overrun
    static constexpr uint32_t C0CR_EGE = 0x200;          // Event generation enable/disable
    static constexpr uint32_t C0CR_SE = 0x10000;         // Synchronous operating mode enable/disable
    template<uint32_t X>
    static constexpr uint32_t C0CR_SPOL =                // Synchronization event type selector Defines the synchronization event on the selected synchronization input: (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C0CR_NBREQ =               // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset. (5 bits)
        bit_field_t<19, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C0CR_SYNC_ID =             // Synchronization input selected (5 bits)
        bit_field_t<24, 0x1f>::value<X>();
    static const uint32_t C0CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C1CR_DMAREQ_ID =           // Input DMA request line selected (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static constexpr uint32_t C1CR_SOIE = 0x100;         // Interrupt enable at synchronization event overrun
    static constexpr uint32_t C1CR_EGE = 0x200;          // Event generation enable/disable
    static constexpr uint32_t C1CR_SE = 0x10000;         // Synchronous operating mode enable/disable
    template<uint32_t X>
    static constexpr uint32_t C1CR_SPOL =                // Synchronization event type selector Defines the synchronization event on the selected synchronization input: (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C1CR_NBREQ =               // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset. (5 bits)
        bit_field_t<19, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C1CR_SYNC_ID =             // Synchronization input selected (5 bits)
        bit_field_t<24, 0x1f>::value<X>();
    static const uint32_t C1CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C2CR_DMAREQ_ID =           // Input DMA request line selected (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static constexpr uint32_t C2CR_SOIE = 0x100;         // Interrupt enable at synchronization event overrun
    static constexpr uint32_t C2CR_EGE = 0x200;          // Event generation enable/disable
    static constexpr uint32_t C2CR_SE = 0x10000;         // Synchronous operating mode enable/disable
    template<uint32_t X>
    static constexpr uint32_t C2CR_SPOL =                // Synchronization event type selector Defines the synchronization event on the selected synchronization input: (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C2CR_NBREQ =               // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset. (5 bits)
        bit_field_t<19, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C2CR_SYNC_ID =             // Synchronization input selected (5 bits)
        bit_field_t<24, 0x1f>::value<X>();
    static const uint32_t C2CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C3CR_DMAREQ_ID =           // Input DMA request line selected (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static constexpr uint32_t C3CR_SOIE = 0x100;         // Interrupt enable at synchronization event overrun
    static constexpr uint32_t C3CR_EGE = 0x200;          // Event generation enable/disable
    static constexpr uint32_t C3CR_SE = 0x10000;         // Synchronous operating mode enable/disable
    template<uint32_t X>
    static constexpr uint32_t C3CR_SPOL =                // Synchronization event type selector Defines the synchronization event on the selected synchronization input: (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C3CR_NBREQ =               // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset. (5 bits)
        bit_field_t<19, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C3CR_SYNC_ID =             // Synchronization input selected (5 bits)
        bit_field_t<24, 0x1f>::value<X>();
    static const uint32_t C3CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C4CR_DMAREQ_ID =           // Input DMA request line selected (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static constexpr uint32_t C4CR_SOIE = 0x100;         // Interrupt enable at synchronization event overrun
    static constexpr uint32_t C4CR_EGE = 0x200;          // Event generation enable/disable
    static constexpr uint32_t C4CR_SE = 0x10000;         // Synchronous operating mode enable/disable
    template<uint32_t X>
    static constexpr uint32_t C4CR_SPOL =                // Synchronization event type selector Defines the synchronization event on the selected synchronization input: (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C4CR_NBREQ =               // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset. (5 bits)
        bit_field_t<19, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C4CR_SYNC_ID =             // Synchronization input selected (5 bits)
        bit_field_t<24, 0x1f>::value<X>();
    static const uint32_t C4CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C5CR_DMAREQ_ID =           // Input DMA request line selected (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static constexpr uint32_t C5CR_SOIE = 0x100;         // Interrupt enable at synchronization event overrun
    static constexpr uint32_t C5CR_EGE = 0x200;          // Event generation enable/disable
    static constexpr uint32_t C5CR_SE = 0x10000;         // Synchronous operating mode enable/disable
    template<uint32_t X>
    static constexpr uint32_t C5CR_SPOL =                // Synchronization event type selector Defines the synchronization event on the selected synchronization input: (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C5CR_NBREQ =               // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset. (5 bits)
        bit_field_t<19, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C5CR_SYNC_ID =             // Synchronization input selected (5 bits)
        bit_field_t<24, 0x1f>::value<X>();
    static const uint32_t C5CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C6CR_DMAREQ_ID =           // Input DMA request line selected (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static constexpr uint32_t C6CR_SOIE = 0x100;         // Interrupt enable at synchronization event overrun
    static constexpr uint32_t C6CR_EGE = 0x200;          // Event generation enable/disable
    static constexpr uint32_t C6CR_SE = 0x10000;         // Synchronous operating mode enable/disable
    template<uint32_t X>
    static constexpr uint32_t C6CR_SPOL =                // Synchronization event type selector Defines the synchronization event on the selected synchronization input: (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C6CR_NBREQ =               // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset. (5 bits)
        bit_field_t<19, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C6CR_SYNC_ID =             // Synchronization input selected (5 bits)
        bit_field_t<24, 0x1f>::value<X>();
    static const uint32_t C6CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C7CR_DMAREQ_ID =           // Input DMA request line selected (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static constexpr uint32_t C7CR_SOIE = 0x100;         // Interrupt enable at synchronization event overrun
    static constexpr uint32_t C7CR_EGE = 0x200;          // Event generation enable/disable
    static constexpr uint32_t C7CR_SE = 0x10000;         // Synchronous operating mode enable/disable
    template<uint32_t X>
    static constexpr uint32_t C7CR_SPOL =                // Synchronization event type selector Defines the synchronization event on the selected synchronization input: (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C7CR_NBREQ =               // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset. (5 bits)
        bit_field_t<19, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C7CR_SYNC_ID =             // Synchronization input selected (5 bits)
        bit_field_t<24, 0x1f>::value<X>();
    static const uint32_t C7CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C8CR_DMAREQ_ID =           // Input DMA request line selected (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static constexpr uint32_t C8CR_SOIE = 0x100;         // Interrupt enable at synchronization event overrun
    static constexpr uint32_t C8CR_EGE = 0x200;          // Event generation enable/disable
    static constexpr uint32_t C8CR_SE = 0x10000;         // Synchronous operating mode enable/disable
    template<uint32_t X>
    static constexpr uint32_t C8CR_SPOL =                // Synchronization event type selector Defines the synchronization event on the selected synchronization input: (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C8CR_NBREQ =               // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset. (5 bits)
        bit_field_t<19, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C8CR_SYNC_ID =             // Synchronization input selected (5 bits)
        bit_field_t<24, 0x1f>::value<X>();
    static const uint32_t C8CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C9CR_DMAREQ_ID =           // Input DMA request line selected (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static constexpr uint32_t C9CR_SOIE = 0x100;         // Interrupt enable at synchronization event overrun
    static constexpr uint32_t C9CR_EGE = 0x200;          // Event generation enable/disable
    static constexpr uint32_t C9CR_SE = 0x10000;         // Synchronous operating mode enable/disable
    template<uint32_t X>
    static constexpr uint32_t C9CR_SPOL =                // Synchronization event type selector Defines the synchronization event on the selected synchronization input: (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C9CR_NBREQ =               // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset. (5 bits)
        bit_field_t<19, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C9CR_SYNC_ID =             // Synchronization input selected (5 bits)
        bit_field_t<24, 0x1f>::value<X>();
    static const uint32_t C9CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C10CR_DMAREQ_ID =           // Input DMA request line selected (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static constexpr uint32_t C10CR_SOIE = 0x100;         // Interrupt enable at synchronization event overrun
    static constexpr uint32_t C10CR_EGE = 0x200;          // Event generation enable/disable
    static constexpr uint32_t C10CR_SE = 0x10000;         // Synchronous operating mode enable/disable
    template<uint32_t X>
    static constexpr uint32_t C10CR_SPOL =                // Synchronization event type selector Defines the synchronization event on the selected synchronization input: (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C10CR_NBREQ =               // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset. (5 bits)
        bit_field_t<19, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C10CR_SYNC_ID =             // Synchronization input selected (5 bits)
        bit_field_t<24, 0x1f>::value<X>();
    static const uint32_t C10CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C11CR_DMAREQ_ID =           // Input DMA request line selected (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static constexpr uint32_t C11CR_SOIE = 0x100;         // Interrupt enable at synchronization event overrun
    static constexpr uint32_t C11CR_EGE = 0x200;          // Event generation enable/disable
    static constexpr uint32_t C11CR_SE = 0x10000;         // Synchronous operating mode enable/disable
    template<uint32_t X>
    static constexpr uint32_t C11CR_SPOL =                // Synchronization event type selector Defines the synchronization event on the selected synchronization input: (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C11CR_NBREQ =               // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset. (5 bits)
        bit_field_t<19, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C11CR_SYNC_ID =             // Synchronization input selected (5 bits)
        bit_field_t<24, 0x1f>::value<X>();
    static const uint32_t C11CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C12CR_DMAREQ_ID =           // Input DMA request line selected (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static constexpr uint32_t C12CR_SOIE = 0x100;         // Interrupt enable at synchronization event overrun
    static constexpr uint32_t C12CR_EGE = 0x200;          // Event generation enable/disable
    static constexpr uint32_t C12CR_SE = 0x10000;         // Synchronous operating mode enable/disable
    template<uint32_t X>
    static constexpr uint32_t C12CR_SPOL =                // Synchronization event type selector Defines the synchronization event on the selected synchronization input: (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C12CR_NBREQ =               // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset. (5 bits)
        bit_field_t<19, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C12CR_SYNC_ID =             // Synchronization input selected (5 bits)
        bit_field_t<24, 0x1f>::value<X>();
    static const uint32_t C12CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C13CR_DMAREQ_ID =           // Input DMA request line selected (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static constexpr uint32_t C13CR_SOIE = 0x100;         // Interrupt enable at synchronization event overrun
    static constexpr uint32_t C13CR_EGE = 0x200;          // Event generation enable/disable
    static constexpr uint32_t C13CR_SE = 0x10000;         // Synchronous operating mode enable/disable
    template<uint32_t X>
    static constexpr uint32_t C13CR_SPOL =                // Synchronization event type selector Defines the synchronization event on the selected synchronization input: (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C13CR_NBREQ =               // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset. (5 bits)
        bit_field_t<19, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C13CR_SYNC_ID =             // Synchronization input selected (5 bits)
        bit_field_t<24, 0x1f>::value<X>();
    static const uint32_t C13CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C14CR_DMAREQ_ID =           // Input DMA request line selected (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static constexpr uint32_t C14CR_SOIE = 0x100;         // Interrupt enable at synchronization event overrun
    static constexpr uint32_t C14CR_EGE = 0x200;          // Event generation enable/disable
    static constexpr uint32_t C14CR_SE = 0x10000;         // Synchronous operating mode enable/disable
    template<uint32_t X>
    static constexpr uint32_t C14CR_SPOL =                // Synchronization event type selector Defines the synchronization event on the selected synchronization input: (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C14CR_NBREQ =               // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset. (5 bits)
        bit_field_t<19, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C14CR_SYNC_ID =             // Synchronization input selected (5 bits)
        bit_field_t<24, 0x1f>::value<X>();
    static const uint32_t C14CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t C15CR_DMAREQ_ID =           // Input DMA request line selected (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static constexpr uint32_t C15CR_SOIE = 0x100;         // Interrupt enable at synchronization event overrun
    static constexpr uint32_t C15CR_EGE = 0x200;          // Event generation enable/disable
    static constexpr uint32_t C15CR_SE = 0x10000;         // Synchronous operating mode enable/disable
    template<uint32_t X>
    static constexpr uint32_t C15CR_SPOL =                // Synchronization event type selector Defines the synchronization event on the selected synchronization input: (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C15CR_NBREQ =               // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset. (5 bits)
        bit_field_t<19, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t C15CR_SYNC_ID =             // Synchronization input selected (5 bits)
        bit_field_t<24, 0x1f>::value<X>();
    static const uint32_t C15CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CSR_SOF =                 // Synchronization overrun event flag (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CSR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CFR_CSOF =                // Clear synchronization overrun event flag (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CFR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RG0CR_SIG_ID =              // DMA request trigger input selected (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static constexpr uint32_t RG0CR_OIE = 0x100;          // Interrupt enable at trigger event overrun
    static constexpr uint32_t RG0CR_GE = 0x10000;         // DMA request generator channel enable/disable
    template<uint32_t X>
    static constexpr uint32_t RG0CR_GPOL =                // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RG0CR_GNBREQ =              // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset. (5 bits)
        bit_field_t<19, 0x1f>::value<X>();
    static const uint32_t RG0CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RG1CR_SIG_ID =              // DMA request trigger input selected (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static constexpr uint32_t RG1CR_OIE = 0x100;          // Interrupt enable at trigger event overrun
    static constexpr uint32_t RG1CR_GE = 0x10000;         // DMA request generator channel enable/disable
    template<uint32_t X>
    static constexpr uint32_t RG1CR_GPOL =                // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RG1CR_GNBREQ =              // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset. (5 bits)
        bit_field_t<19, 0x1f>::value<X>();
    static const uint32_t RG1CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RG2CR_SIG_ID =              // DMA request trigger input selected (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static constexpr uint32_t RG2CR_OIE = 0x100;          // Interrupt enable at trigger event overrun
    static constexpr uint32_t RG2CR_GE = 0x10000;         // DMA request generator channel enable/disable
    template<uint32_t X>
    static constexpr uint32_t RG2CR_GPOL =                // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RG2CR_GNBREQ =              // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset. (5 bits)
        bit_field_t<19, 0x1f>::value<X>();
    static const uint32_t RG2CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RG3CR_SIG_ID =              // DMA request trigger input selected (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static constexpr uint32_t RG3CR_OIE = 0x100;          // Interrupt enable at trigger event overrun
    static constexpr uint32_t RG3CR_GE = 0x10000;         // DMA request generator channel enable/disable
    template<uint32_t X>
    static constexpr uint32_t RG3CR_GPOL =                // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RG3CR_GNBREQ =              // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset. (5 bits)
        bit_field_t<19, 0x1f>::value<X>();
    static const uint32_t RG3CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RG4CR_SIG_ID =              // DMA request trigger input selected (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static constexpr uint32_t RG4CR_OIE = 0x100;          // Interrupt enable at trigger event overrun
    static constexpr uint32_t RG4CR_GE = 0x10000;         // DMA request generator channel enable/disable
    template<uint32_t X>
    static constexpr uint32_t RG4CR_GPOL =                // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RG4CR_GNBREQ =              // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset. (5 bits)
        bit_field_t<19, 0x1f>::value<X>();
    static const uint32_t RG4CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RG5CR_SIG_ID =              // DMA request trigger input selected (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static constexpr uint32_t RG5CR_OIE = 0x100;          // Interrupt enable at trigger event overrun
    static constexpr uint32_t RG5CR_GE = 0x10000;         // DMA request generator channel enable/disable
    template<uint32_t X>
    static constexpr uint32_t RG5CR_GPOL =                // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RG5CR_GNBREQ =              // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset. (5 bits)
        bit_field_t<19, 0x1f>::value<X>();
    static const uint32_t RG5CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RG6CR_SIG_ID =              // DMA request trigger input selected (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static constexpr uint32_t RG6CR_OIE = 0x100;          // Interrupt enable at trigger event overrun
    static constexpr uint32_t RG6CR_GE = 0x10000;         // DMA request generator channel enable/disable
    template<uint32_t X>
    static constexpr uint32_t RG6CR_GPOL =                // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RG6CR_GNBREQ =              // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset. (5 bits)
        bit_field_t<19, 0x1f>::value<X>();
    static const uint32_t RG6CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RG7CR_SIG_ID =              // DMA request trigger input selected (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static constexpr uint32_t RG7CR_OIE = 0x100;          // Interrupt enable at trigger event overrun
    static constexpr uint32_t RG7CR_GE = 0x10000;         // DMA request generator channel enable/disable
    template<uint32_t X>
    static constexpr uint32_t RG7CR_GPOL =                // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RG7CR_GNBREQ =              // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset. (5 bits)
        bit_field_t<19, 0x1f>::value<X>();
    static const uint32_t RG7CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RGSR_OF =                  // Trigger event overrun flag The flag is set when a trigger event occurs on DMA request generator channel x, while the DMA request generator counter value is lower than GNBREQ. The flag is cleared by writing 1 to the corresponding COFx bit in DMAMUX_RGCFR register. (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t RGSR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RGCFR_COF =                 // Clear trigger event overrun flag Upon setting, this bit clears the corresponding overrun flag OFx in the DMAMUX_RGCSR register. (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t RGCFR_RESET_VALUE = 0x0;

    static constexpr uint8_t DMAMUX1_OV = 102; // DMAMUX1 overrun interrupt
};

static dmamux1_t& DMAMUX1 = *reinterpret_cast<dmamux1_t*>(0x40020800);

#define HAVE_PERIPHERAL_DMAMUX1


////
//
//    Cryptographic processor
//
////

struct crc_t
{
    volatile uint32_t    DR;                   // [Read-write] Data register
    volatile uint32_t    IDR;                  // [Read-write] Independent Data register
    volatile uint32_t    CR;                   // Control register
    volatile uint32_t    INIT;                 // [Read-write] Initial CRC value
    volatile uint32_t    POL;                  // [Read-write] CRC polynomial


    static const uint32_t DR_RESET_VALUE = 0xffffffff;


    static const uint32_t IDR_RESET_VALUE = 0x0;

    static constexpr uint32_t CR_RESET = 0x1;          // RESET bit, Write-only
    template<uint32_t X>
    static constexpr uint32_t CR_POLYSIZE =            // Polynomial size (2 bits), Read-write
        bit_field_t<3, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR_REV_IN =              // Reverse input data (2 bits), Read-write
        bit_field_t<5, 0x3>::value<X>();
    static constexpr uint32_t CR_REV_OUT = 0x80;       // Reverse output data, Read-write
    static const uint32_t CR_RESET_VALUE = 0x0;


    static const uint32_t INIT_RESET_VALUE = 0x0;


    static const uint32_t POL_RESET_VALUE = 0x0;
};

static crc_t& CRC = *reinterpret_cast<crc_t*>(0x58024c00);

#define HAVE_PERIPHERAL_CRC


////
//
//    Reset and clock control
//
////

struct rcc_t
{
    volatile uint32_t    CR;                   // [Read-write] clock control register
    volatile uint32_t    ICSCR;                // RCC Internal Clock Source Calibration Register
    volatile uint32_t    CRRCR;                // [Read-only] RCC Clock Recovery RC Register
    reserved_t<1>        _0;
    volatile uint32_t    CFGR;                 // [Read-write] RCC Clock Configuration Register
    reserved_t<1>        _1;
    volatile uint32_t    D1CFGR;               // [Read-write] RCC Domain 1 Clock Configuration Register
    volatile uint32_t    D2CFGR;               // [Read-write] RCC Domain 2 Clock Configuration Register
    volatile uint32_t    D3CFGR;               // [Read-write] RCC Domain 3 Clock Configuration Register
    reserved_t<1>        _2;
    volatile uint32_t    PLLCKSELR;            // [Read-write] RCC PLLs Clock Source Selection Register
    volatile uint32_t    PLLCFGR;              // [Read-write] RCC PLLs Configuration Register
    volatile uint32_t    PLL1DIVR;             // [Read-write] RCC PLL1 Dividers Configuration Register
    volatile uint32_t    PLL1FRACR;            // [Read-write] RCC PLL1 Fractional Divider Register
    volatile uint32_t    PLL2DIVR;             // [Read-write] RCC PLL2 Dividers Configuration Register
    volatile uint32_t    PLL2FRACR;            // [Read-write] RCC PLL2 Fractional Divider Register
    volatile uint32_t    PLL3DIVR;             // [Read-write] RCC PLL3 Dividers Configuration Register
    volatile uint32_t    PLL3FRACR;            // [Read-write] RCC PLL3 Fractional Divider Register
    reserved_t<1>        _3;
    volatile uint32_t    D1CCIPR;              // [Read-write] RCC Domain 1 Kernel Clock Configuration Register
    volatile uint32_t    D2CCIP1R;             // [Read-write] RCC Domain 2 Kernel Clock Configuration Register
    volatile uint32_t    D2CCIP2R;             // [Read-write] RCC Domain 2 Kernel Clock Configuration Register
    volatile uint32_t    D3CCIPR;              // [Read-write] RCC Domain 3 Kernel Clock Configuration Register
    reserved_t<1>        _4;
    volatile uint32_t    CIER;                 // [Read-write] RCC Clock Source Interrupt Enable Register
    volatile uint32_t    CIFR;                 // [Read-write] RCC Clock Source Interrupt Flag Register
    volatile uint32_t    CICR;                 // [Read-write] RCC Clock Source Interrupt Clear Register
    reserved_t<1>        _5;
    volatile uint32_t    BDCR;                 // [Read-write] RCC Backup Domain Control Register
    volatile uint32_t    CSR;                  // [Read-write] RCC Clock Control and Status Register
    reserved_t<1>        _6;
    volatile uint32_t    AHB3RSTR;             // [Read-write] RCC AHB3 Reset Register
    volatile uint32_t    AHB1RSTR;             // [Read-write] RCC AHB1 Peripheral Reset Register
    volatile uint32_t    AHB2RSTR;             // [Read-write] RCC AHB2 Peripheral Reset Register
    volatile uint32_t    AHB4RSTR;             // [Read-write] RCC AHB4 Peripheral Reset Register
    volatile uint32_t    APB3RSTR;             // [Read-write] RCC APB3 Peripheral Reset Register
    volatile uint32_t    APB1LRSTR;            // [Read-write] RCC APB1 Peripheral Reset Register
    volatile uint32_t    APB1HRSTR;            // [Read-write] RCC APB1 Peripheral Reset Register
    volatile uint32_t    APB2RSTR;             // [Read-write] RCC APB2 Peripheral Reset Register
    volatile uint32_t    APB4RSTR;             // [Read-write] RCC APB4 Peripheral Reset Register
    volatile uint32_t    GCR;                  // [Read-write] RCC Global Control Register
    reserved_t<1>        _7;
    volatile uint32_t    D3AMR;                // [Read-write] RCC D3 Autonomous mode Register
    reserved_t<9>        _8;
    volatile uint32_t    RSR;                  // [Read-write] RCC Reset Status Register
    volatile uint32_t    AHB3ENR;              // [Read-write] RCC AHB3 Clock Register
    volatile uint32_t    AHB1ENR;              // [Read-write] RCC AHB1 Clock Register
    volatile uint32_t    AHB2ENR;              // [Read-write] RCC AHB2 Clock Register
    volatile uint32_t    AHB4ENR;              // [Read-write] RCC AHB4 Clock Register
    volatile uint32_t    APB3ENR;              // [Read-write] RCC APB3 Clock Register
    volatile uint32_t    APB1LENR;             // [Read-write] RCC APB1 Clock Register
    volatile uint32_t    APB1HENR;             // [Read-write] RCC APB1 Clock Register
    volatile uint32_t    APB2ENR;              // [Read-write] RCC APB2 Clock Register
    volatile uint32_t    APB4ENR;              // [Read-write] RCC APB4 Clock Register
    reserved_t<1>        _9;
    volatile uint32_t    AHB3LPENR;            // [Read-write] RCC AHB3 Sleep Clock Register
    volatile uint32_t    AHB1LPENR;            // [Read-write] RCC AHB1 Sleep Clock Register
    volatile uint32_t    AHB2LPENR;            // [Read-write] RCC AHB2 Sleep Clock Register
    volatile uint32_t    AHB4LPENR;            // [Read-write] RCC AHB4 Sleep Clock Register
    volatile uint32_t    APB3LPENR;            // [Read-write] RCC APB3 Sleep Clock Register
    volatile uint32_t    APB1LLPENR;           // [Read-write] RCC APB1 Low Sleep Clock Register
    volatile uint32_t    APB1HLPENR;           // [Read-write] RCC APB1 High Sleep Clock Register
    volatile uint32_t    APB2LPENR;            // [Read-write] RCC APB2 Sleep Clock Register
    volatile uint32_t    APB4LPENR;            // [Read-write] RCC APB4 Sleep Clock Register
    reserved_t<4>        _10;
    volatile uint32_t    C1_RSR;               // [Read-write] RCC Reset Status Register
    volatile uint32_t    C1_AHB3ENR;           // [Read-write] RCC AHB3 Clock Register
    volatile uint32_t    C1_AHB1ENR;           // [Read-write] RCC AHB1 Clock Register
    volatile uint32_t    C1_AHB2ENR;           // [Read-write] RCC AHB2 Clock Register
    volatile uint32_t    C1_AHB4ENR;           // [Read-write] RCC AHB4 Clock Register
    volatile uint32_t    C1_APB3ENR;           // [Read-write] RCC APB3 Clock Register
    volatile uint32_t    C1_APB1LENR;          // [Read-write] RCC APB1 Clock Register
    volatile uint32_t    C1_APB1HENR;          // [Read-write] RCC APB1 Clock Register
    volatile uint32_t    C1_APB2ENR;           // [Read-write] RCC APB2 Clock Register
    volatile uint32_t    C1_APB4ENR;           // [Read-write] RCC APB4 Clock Register
    reserved_t<1>        _11;
    volatile uint32_t    C1_AHB3LPENR;         // [Read-write] RCC AHB3 Sleep Clock Register
    volatile uint32_t    C1_AHB1LPENR;         // [Read-write] RCC AHB1 Sleep Clock Register
    volatile uint32_t    C1_AHB2LPENR;         // [Read-write] RCC AHB2 Sleep Clock Register
    volatile uint32_t    C1_AHB4LPENR;         // [Read-write] RCC AHB4 Sleep Clock Register
    volatile uint32_t    C1_APB3LPENR;         // [Read-write] RCC APB3 Sleep Clock Register
    volatile uint32_t    C1_APB1LLPENR;        // [Read-write] RCC APB1 Low Sleep Clock Register
    volatile uint32_t    C1_APB1HLPENR;        // [Read-write] RCC APB1 High Sleep Clock Register
    volatile uint32_t    C1_APB2LPENR;         // [Read-write] RCC APB2 Sleep Clock Register
    volatile uint32_t    C1_APB4LPENR;         // [Read-write] RCC APB4 Sleep Clock Register

    static constexpr uint32_t CR_HSION = 0x1;          // Internal high-speed clock enable
    static constexpr uint32_t CR_HSIKERON = 0x2;       // High Speed Internal clock enable in Stop mode
    static constexpr uint32_t CR_HSIRDY = 0x4;         // HSI clock ready flag
    template<uint32_t X>
    static constexpr uint32_t CR_HSIDIV =              // HSI clock divider (2 bits)
        bit_field_t<3, 0x3>::value<X>();
    static constexpr uint32_t CR_HSIDIVF = 0x20;       // HSI divider flag
    static constexpr uint32_t CR_CSION = 0x80;         // CSI clock enable
    static constexpr uint32_t CR_CSIRDY = 0x100;       // CSI clock ready flag
    static constexpr uint32_t CR_CSIKERON = 0x200;     // CSI clock enable in Stop mode
    static constexpr uint32_t CR_RC48ON = 0x1000;      // RC48 clock enable
    static constexpr uint32_t CR_RC48RDY = 0x2000;     // RC48 clock ready flag
    static constexpr uint32_t CR_D1CKRDY = 0x4000;     // D1 domain clocks ready flag
    static constexpr uint32_t CR_D2CKRDY = 0x8000;     // D2 domain clocks ready flag
    static constexpr uint32_t CR_HSEON = 0x10000;      // HSE clock enable
    static constexpr uint32_t CR_HSERDY = 0x20000;     // HSE clock ready flag
    static constexpr uint32_t CR_HSEBYP = 0x40000;     // HSE clock bypass
    static constexpr uint32_t CR_HSECSSON = 0x80000;   // HSE Clock Security System enable
    static constexpr uint32_t CR_PLL1ON = 0x1000000;   // PLL1 enable
    static constexpr uint32_t CR_PLL1RDY = 0x2000000;  // PLL1 clock ready flag
    static constexpr uint32_t CR_PLL2ON = 0x4000000;   // PLL2 enable
    static constexpr uint32_t CR_PLL2RDY = 0x8000000;  // PLL2 clock ready flag
    static constexpr uint32_t CR_PLL3ON = 0x10000000;  // PLL3 enable
    static constexpr uint32_t CR_PLL3RDY = 0x20000000; // PLL3 clock ready flag
    static const uint32_t CR_RESET_VALUE = 0x83;

    template<uint32_t X>
    static constexpr uint32_t ICSCR_HSICAL =              // HSI clock calibration (12 bits), Read-only
        bit_field_t<0, 0xfff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ICSCR_HSITRIM =             // HSI clock trimming (6 bits), Read-write
        bit_field_t<12, 0x3f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ICSCR_CSICAL =              // CSI clock calibration (8 bits), Read-only
        bit_field_t<18, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ICSCR_CSITRIM =             // CSI clock trimming (5 bits), Read-write
        bit_field_t<26, 0x1f>::value<X>();
    static const uint32_t ICSCR_RESET_VALUE = 0x40000000;

    template<uint32_t X>
    static constexpr uint32_t CRRCR_RC48CAL =             // Internal RC 48 MHz clock calibration (10 bits)
        bit_field_t<0, 0x3ff>::value<X>();
    static const uint32_t CRRCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CFGR_SW =                  // System clock switch (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_SWS =                 // System clock switch status (3 bits)
        bit_field_t<3, 0x7>::value<X>();
    static constexpr uint32_t CFGR_STOPWUCK = 0x40;      // System clock selection after a wake up from system Stop
    static constexpr uint32_t CFGR_STOPKERWUCK = 0x80;   // Kernel clock selection after a wake up from system Stop
    template<uint32_t X>
    static constexpr uint32_t CFGR_RTCPRE =              // HSE division factor for RTC clock (6 bits)
        bit_field_t<8, 0x3f>::value<X>();
    static constexpr uint32_t CFGR_HRTIMSEL = 0x4000;    // High Resolution Timer clock prescaler selection
    static constexpr uint32_t CFGR_TIMPRE = 0x8000;      // Timers clocks prescaler selection
    template<uint32_t X>
    static constexpr uint32_t CFGR_MCO1PRE =             // MCO1 prescaler (4 bits)
        bit_field_t<18, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_MCO1SEL =             // Micro-controller clock output 1 (3 bits)
        bit_field_t<22, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_MCO2PRE =             // MCO2 prescaler (4 bits)
        bit_field_t<25, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_MCO2SEL =             // Micro-controller clock output 2 (3 bits)
        bit_field_t<29, 0x7>::value<X>();
    static const uint32_t CFGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t D1CFGR_HPRE =                // D1 domain AHB prescaler (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D1CFGR_D1PPRE =              // D1 domain APB3 prescaler (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D1CFGR_D1CPRE =              // D1 domain Core prescaler (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    static const uint32_t D1CFGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t D2CFGR_D2PPRE1 =             // D2 domain APB1 prescaler (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D2CFGR_D2PPRE2 =             // D2 domain APB2 prescaler (3 bits)
        bit_field_t<8, 0x7>::value<X>();
    static const uint32_t D2CFGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t D3CFGR_D3PPRE =              // D3 domain APB4 prescaler (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static const uint32_t D3CFGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PLLCKSELR_PLLSRC =              // DIVMx and PLLs clock source selection (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PLLCKSELR_DIVM1 =               // Prescaler for PLL1 (6 bits)
        bit_field_t<4, 0x3f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PLLCKSELR_DIVM2 =               // Prescaler for PLL2 (6 bits)
        bit_field_t<12, 0x3f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PLLCKSELR_DIVM3 =               // Prescaler for PLL3 (6 bits)
        bit_field_t<20, 0x3f>::value<X>();
    static const uint32_t PLLCKSELR_RESET_VALUE = 0x2020200;

    static constexpr uint32_t PLLCFGR_PLL1FRACEN = 0x1;     // PLL1 fractional latch enable
    static constexpr uint32_t PLLCFGR_PLL1VCOSEL = 0x2;     // PLL1 VCO selection
    template<uint32_t X>
    static constexpr uint32_t PLLCFGR_PLL1RGE =             // PLL1 input frequency range (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t PLLCFGR_PLL2FRACEN = 0x10;    // PLL2 fractional latch enable
    static constexpr uint32_t PLLCFGR_PLL2VCOSEL = 0x20;    // PLL2 VCO selection
    template<uint32_t X>
    static constexpr uint32_t PLLCFGR_PLL2RGE =             // PLL2 input frequency range (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t PLLCFGR_PLL3FRACEN = 0x100;   // PLL3 fractional latch enable
    static constexpr uint32_t PLLCFGR_PLL3VCOSEL = 0x200;   // PLL3 VCO selection
    template<uint32_t X>
    static constexpr uint32_t PLLCFGR_PLL3RGE =             // PLL3 input frequency range (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    static constexpr uint32_t PLLCFGR_DIVP1EN = 0x10000;    // PLL1 DIVP divider output enable
    static constexpr uint32_t PLLCFGR_DIVQ1EN = 0x20000;    // PLL1 DIVQ divider output enable
    static constexpr uint32_t PLLCFGR_DIVR1EN = 0x40000;    // PLL1 DIVR divider output enable
    static constexpr uint32_t PLLCFGR_DIVP2EN = 0x80000;    // PLL2 DIVP divider output enable
    static constexpr uint32_t PLLCFGR_DIVQ2EN = 0x100000;   // PLL2 DIVQ divider output enable
    static constexpr uint32_t PLLCFGR_DIVR2EN = 0x200000;   // PLL2 DIVR divider output enable
    static constexpr uint32_t PLLCFGR_DIVP3EN = 0x400000;   // PLL3 DIVP divider output enable
    static constexpr uint32_t PLLCFGR_DIVQ3EN = 0x800000;   // PLL3 DIVQ divider output enable
    static constexpr uint32_t PLLCFGR_DIVR3EN = 0x1000000;  // PLL3 DIVR divider output enable
    static const uint32_t PLLCFGR_RESET_VALUE = 0x1ff0000;

    template<uint32_t X>
    static constexpr uint32_t PLL1DIVR_DIVN1 =               // Multiplication factor for PLL1 VCO (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PLL1DIVR_DIVP1 =               // PLL1 DIVP division factor (7 bits)
        bit_field_t<9, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PLL1DIVR_DIVQ1 =               // PLL1 DIVQ division factor (7 bits)
        bit_field_t<16, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PLL1DIVR_DIVR1 =               // PLL1 DIVR division factor (7 bits)
        bit_field_t<24, 0x7f>::value<X>();
    static const uint32_t PLL1DIVR_RESET_VALUE = 0x1010280;

    template<uint32_t X>
    static constexpr uint32_t PLL1FRACR_FRACN1 =              // Fractional part of the multiplication factor for PLL1 VCO (13 bits)
        bit_field_t<3, 0x1fff>::value<X>();
    static const uint32_t PLL1FRACR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PLL2DIVR_DIVN1 =               // Multiplication factor for PLL1 VCO (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PLL2DIVR_DIVP1 =               // PLL1 DIVP division factor (7 bits)
        bit_field_t<9, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PLL2DIVR_DIVQ1 =               // PLL1 DIVQ division factor (7 bits)
        bit_field_t<16, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PLL2DIVR_DIVR1 =               // PLL1 DIVR division factor (7 bits)
        bit_field_t<24, 0x7f>::value<X>();
    static const uint32_t PLL2DIVR_RESET_VALUE = 0x1010280;

    template<uint32_t X>
    static constexpr uint32_t PLL2FRACR_FRACN2 =              // Fractional part of the multiplication factor for PLL VCO (13 bits)
        bit_field_t<3, 0x1fff>::value<X>();
    static const uint32_t PLL2FRACR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PLL3DIVR_DIVN3 =               // Multiplication factor for PLL1 VCO (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PLL3DIVR_DIVP3 =               // PLL DIVP division factor (7 bits)
        bit_field_t<9, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PLL3DIVR_DIVQ3 =               // PLL DIVQ division factor (7 bits)
        bit_field_t<16, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PLL3DIVR_DIVR3 =               // PLL DIVR division factor (7 bits)
        bit_field_t<24, 0x7f>::value<X>();
    static const uint32_t PLL3DIVR_RESET_VALUE = 0x1010280;

    template<uint32_t X>
    static constexpr uint32_t PLL3FRACR_FRACN3 =              // Fractional part of the multiplication factor for PLL3 VCO (13 bits)
        bit_field_t<3, 0x1fff>::value<X>();
    static const uint32_t PLL3FRACR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t D1CCIPR_FMCSRC =              // FMC kernel clock source selection (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D1CCIPR_QSPISRC =             // QUADSPI kernel clock source selection (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static constexpr uint32_t D1CCIPR_SDMMCSRC = 0x10000;   // SDMMC kernel clock source selection
    template<uint32_t X>
    static constexpr uint32_t D1CCIPR_CKPERSRC =            // per_ck clock source selection (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    static const uint32_t D1CCIPR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t D2CCIP1R_SAI1SRC =             // SAI1 and DFSDM1 kernel Aclk clock source selection (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D2CCIP1R_SAI23SRC =            // SAI2 and SAI3 kernel clock source selection (3 bits)
        bit_field_t<6, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D2CCIP1R_SPI123SRC =           // SPI/I2S1,2 and 3 kernel clock source selection (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D2CCIP1R_SPI45SRC =            // SPI4 and 5 kernel clock source selection (3 bits)
        bit_field_t<16, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D2CCIP1R_SPDIFSRC =            // SPDIFRX kernel clock source selection (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    static constexpr uint32_t D2CCIP1R_DFSDM1SRC = 0x1000000;// DFSDM1 kernel Clk clock source selection
    template<uint32_t X>
    static constexpr uint32_t D2CCIP1R_FDCANSRC =            // FDCAN kernel clock source selection (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    static constexpr uint32_t D2CCIP1R_SWPSRC = 0x80000000;  // SWPMI kernel clock source selection
    static const uint32_t D2CCIP1R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t D2CCIP2R_USART234578SRC =      // USART2/3, UART4,5, 7/8 (APB1) kernel clock source selection (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D2CCIP2R_USART16SRC =          // USART1 and 6 kernel clock source selection (3 bits)
        bit_field_t<3, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D2CCIP2R_RNGSRC =              // RNG kernel clock source selection (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D2CCIP2R_I2C123SRC =           // I2C1,2,3 kernel clock source selection (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D2CCIP2R_USBSRC =              // USBOTG 1 and 2 kernel clock source selection (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D2CCIP2R_CECSRC =              // HDMI-CEC kernel clock source selection (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D2CCIP2R_LPTIM1SRC =           // LPTIM1 kernel clock source selection (3 bits)
        bit_field_t<28, 0x7>::value<X>();
    static const uint32_t D2CCIP2R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t D3CCIPR_LPUART1SRC =          // LPUART1 kernel clock source selection (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D3CCIPR_I2C4SRC =             // I2C4 kernel clock source selection (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D3CCIPR_LPTIM2SRC =           // LPTIM2 kernel clock source selection (3 bits)
        bit_field_t<10, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D3CCIPR_LPTIM345SRC =         // LPTIM3,4,5 kernel clock source selection (3 bits)
        bit_field_t<13, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D3CCIPR_ADCSRC =              // SAR ADC kernel clock source selection (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D3CCIPR_SAI4ASRC =            // Sub-Block A of SAI4 kernel clock source selection (3 bits)
        bit_field_t<21, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D3CCIPR_SAI4BSRC =            // Sub-Block B of SAI4 kernel clock source selection (3 bits)
        bit_field_t<24, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D3CCIPR_SPI6SRC =             // SPI6 kernel clock source selection (3 bits)
        bit_field_t<28, 0x7>::value<X>();
    static const uint32_t D3CCIPR_RESET_VALUE = 0x0;

    static constexpr uint32_t CIER_LSIRDYIE = 0x1;       // LSI ready Interrupt Enable
    static constexpr uint32_t CIER_LSERDYIE = 0x2;       // LSE ready Interrupt Enable
    static constexpr uint32_t CIER_HSIRDYIE = 0x4;       // HSI ready Interrupt Enable
    static constexpr uint32_t CIER_HSERDYIE = 0x8;       // HSE ready Interrupt Enable
    static constexpr uint32_t CIER_CSIRDYIE = 0x10;      // CSI ready Interrupt Enable
    static constexpr uint32_t CIER_RC48RDYIE = 0x20;     // RC48 ready Interrupt Enable
    static constexpr uint32_t CIER_PLL1RDYIE = 0x40;     // PLL1 ready Interrupt Enable
    static constexpr uint32_t CIER_PLL2RDYIE = 0x80;     // PLL2 ready Interrupt Enable
    static constexpr uint32_t CIER_PLL3RDYIE = 0x100;    // PLL3 ready Interrupt Enable
    static constexpr uint32_t CIER_LSECSSIE = 0x200;     // LSE clock security system Interrupt Enable
    static const uint32_t CIER_RESET_VALUE = 0x0;

    static constexpr uint32_t CIFR_LSIRDYF = 0x1;        // LSI ready Interrupt Flag
    static constexpr uint32_t CIFR_LSERDYF = 0x2;        // LSE ready Interrupt Flag
    static constexpr uint32_t CIFR_HSIRDYF = 0x4;        // HSI ready Interrupt Flag
    static constexpr uint32_t CIFR_HSERDYF = 0x8;        // HSE ready Interrupt Flag
    static constexpr uint32_t CIFR_CSIRDY = 0x10;        // CSI ready Interrupt Flag
    static constexpr uint32_t CIFR_RC48RDYF = 0x20;      // RC48 ready Interrupt Flag
    static constexpr uint32_t CIFR_PLL1RDYF = 0x40;      // PLL1 ready Interrupt Flag
    static constexpr uint32_t CIFR_PLL2RDYF = 0x80;      // PLL2 ready Interrupt Flag
    static constexpr uint32_t CIFR_PLL3RDYF = 0x100;     // PLL3 ready Interrupt Flag
    static constexpr uint32_t CIFR_LSECSSF = 0x200;      // LSE clock security system Interrupt Flag
    static constexpr uint32_t CIFR_HSECSSF = 0x400;      // HSE clock security system Interrupt Flag
    static const uint32_t CIFR_RESET_VALUE = 0x0;

    static constexpr uint32_t CICR_LSIRDYC = 0x1;        // LSI ready Interrupt Clear
    static constexpr uint32_t CICR_LSERDYC = 0x2;        // LSE ready Interrupt Clear
    static constexpr uint32_t CICR_HSIRDYC = 0x4;        // HSI ready Interrupt Clear
    static constexpr uint32_t CICR_HSERDYC = 0x8;        // HSE ready Interrupt Clear
    static constexpr uint32_t CICR_HSE_ready_Interrupt_Clear = 0x10;// CSI ready Interrupt Clear
    static constexpr uint32_t CICR_RC48RDYC = 0x20;      // RC48 ready Interrupt Clear
    static constexpr uint32_t CICR_PLL1RDYC = 0x40;      // PLL1 ready Interrupt Clear
    static constexpr uint32_t CICR_PLL2RDYC = 0x80;      // PLL2 ready Interrupt Clear
    static constexpr uint32_t CICR_PLL3RDYC = 0x100;     // PLL3 ready Interrupt Clear
    static constexpr uint32_t CICR_LSECSSC = 0x200;      // LSE clock security system Interrupt Clear
    static constexpr uint32_t CICR_HSECSSC = 0x400;      // HSE clock security system Interrupt Clear
    static const uint32_t CICR_RESET_VALUE = 0x0;

    static constexpr uint32_t BDCR_LSEON = 0x1;          // LSE oscillator enabled
    static constexpr uint32_t BDCR_LSERDY = 0x2;         // LSE oscillator ready
    static constexpr uint32_t BDCR_LSEBYP = 0x4;         // LSE oscillator bypass
    template<uint32_t X>
    static constexpr uint32_t BDCR_LSEDRV =              // LSE oscillator driving capability (2 bits)
        bit_field_t<3, 0x3>::value<X>();
    static constexpr uint32_t BDCR_LSECSSON = 0x20;      // LSE clock security system enable
    static constexpr uint32_t BDCR_LSECSSD = 0x40;       // LSE clock security system failure detection
    template<uint32_t X>
    static constexpr uint32_t BDCR_RTCSRC =              // RTC clock source selection (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t BDCR_RTCEN = 0x8000;       // RTC clock enable
    static constexpr uint32_t BDCR_VSWRST = 0x10000;     // VSwitch domain software reset
    static const uint32_t BDCR_RESET_VALUE = 0x0;

    static constexpr uint32_t CSR_LSION = 0x1;          // LSI oscillator enable
    static constexpr uint32_t CSR_LSIRDY = 0x2;         // LSI oscillator ready
    static const uint32_t CSR_RESET_VALUE = 0x0;

    static constexpr uint32_t AHB3RSTR_MDMARST = 0x1;        // MDMA block reset
    static constexpr uint32_t AHB3RSTR_DMA2DRST = 0x10;      // DMA2D block reset
    static constexpr uint32_t AHB3RSTR_JPGDECRST = 0x20;     // JPGDEC block reset
    static constexpr uint32_t AHB3RSTR_FMCRST = 0x1000;      // FMC block reset
    static constexpr uint32_t AHB3RSTR_QSPIRST = 0x4000;     // QUADSPI and QUADSPI delay block reset
    static constexpr uint32_t AHB3RSTR_SDMMC1RST = 0x10000;  // SDMMC1 and SDMMC1 delay block reset
    static constexpr uint32_t AHB3RSTR_CPURST = 0x80000000;  // CPU reset
    static const uint32_t AHB3RSTR_RESET_VALUE = 0x0;

    static constexpr uint32_t AHB1RSTR_DMA1RST = 0x1;        // DMA1 block reset
    static constexpr uint32_t AHB1RSTR_DMA2RST = 0x2;        // DMA2 block reset
    static constexpr uint32_t AHB1RSTR_ADC12RST = 0x20;      // ADC1&amp;2 block reset
    static constexpr uint32_t AHB1RSTR_ETH1MACRST = 0x8000;  // ETH1MAC block reset
    static constexpr uint32_t AHB1RSTR_USB1OTGRST = 0x2000000;// USB1OTG block reset
    static constexpr uint32_t AHB1RSTR_USB2OTGRST = 0x8000000;// USB2OTG block reset
    static const uint32_t AHB1RSTR_RESET_VALUE = 0x0;

    static constexpr uint32_t AHB2RSTR_CAMITFRST = 0x1;      // CAMITF block reset
    static constexpr uint32_t AHB2RSTR_CRYPTRST = 0x10;      // Cryptography block reset
    static constexpr uint32_t AHB2RSTR_HASHRST = 0x20;       // Hash block reset
    static constexpr uint32_t AHB2RSTR_RNGRST = 0x40;        // Random Number Generator block reset
    static constexpr uint32_t AHB2RSTR_SDMMC2RST = 0x200;    // SDMMC2 and SDMMC2 Delay block reset
    static const uint32_t AHB2RSTR_RESET_VALUE = 0x0;

    static constexpr uint32_t AHB4RSTR_GPIOARST = 0x1;       // GPIO block reset
    static constexpr uint32_t AHB4RSTR_GPIOBRST = 0x2;       // GPIO block reset
    static constexpr uint32_t AHB4RSTR_GPIOCRST = 0x4;       // GPIO block reset
    static constexpr uint32_t AHB4RSTR_GPIODRST = 0x8;       // GPIO block reset
    static constexpr uint32_t AHB4RSTR_GPIOERST = 0x10;      // GPIO block reset
    static constexpr uint32_t AHB4RSTR_GPIOFRST = 0x20;      // GPIO block reset
    static constexpr uint32_t AHB4RSTR_GPIOGRST = 0x40;      // GPIO block reset
    static constexpr uint32_t AHB4RSTR_GPIOHRST = 0x80;      // GPIO block reset
    static constexpr uint32_t AHB4RSTR_GPIOIRST = 0x100;     // GPIO block reset
    static constexpr uint32_t AHB4RSTR_GPIOJRST = 0x200;     // GPIO block reset
    static constexpr uint32_t AHB4RSTR_GPIOKRST = 0x400;     // GPIO block reset
    static constexpr uint32_t AHB4RSTR_CRCRST = 0x80000;     // CRC block reset
    static constexpr uint32_t AHB4RSTR_BDMARST = 0x200000;   // BDMA block reset
    static constexpr uint32_t AHB4RSTR_ADC3RST = 0x1000000;  // ADC3 block reset
    static constexpr uint32_t AHB4RSTR_HSEMRST = 0x2000000;  // HSEM block reset
    static const uint32_t AHB4RSTR_RESET_VALUE = 0x0;

    static constexpr uint32_t APB3RSTR_LTDCRST = 0x8;        // LTDC block reset
    static const uint32_t APB3RSTR_RESET_VALUE = 0x0;

    static constexpr uint32_t APB1LRSTR_TIM2RST = 0x1;        // TIM block reset
    static constexpr uint32_t APB1LRSTR_TIM3RST = 0x2;        // TIM block reset
    static constexpr uint32_t APB1LRSTR_TIM4RST = 0x4;        // TIM block reset
    static constexpr uint32_t APB1LRSTR_TIM5RST = 0x8;        // TIM block reset
    static constexpr uint32_t APB1LRSTR_TIM6RST = 0x10;       // TIM block reset
    static constexpr uint32_t APB1LRSTR_TIM7RST = 0x20;       // TIM block reset
    static constexpr uint32_t APB1LRSTR_TIM12RST = 0x40;      // TIM block reset
    static constexpr uint32_t APB1LRSTR_TIM13RST = 0x80;      // TIM block reset
    static constexpr uint32_t APB1LRSTR_TIM14RST = 0x100;     // TIM block reset
    static constexpr uint32_t APB1LRSTR_LPTIM1RST = 0x200;    // TIM block reset
    static constexpr uint32_t APB1LRSTR_SPI2RST = 0x4000;     // SPI2 block reset
    static constexpr uint32_t APB1LRSTR_SPI3RST = 0x8000;     // SPI3 block reset
    static constexpr uint32_t APB1LRSTR_SPDIFRXRST = 0x10000; // SPDIFRX block reset
    static constexpr uint32_t APB1LRSTR_USART2RST = 0x20000;  // USART2 block reset
    static constexpr uint32_t APB1LRSTR_USART3RST = 0x40000;  // USART3 block reset
    static constexpr uint32_t APB1LRSTR_UART4RST = 0x80000;   // UART4 block reset
    static constexpr uint32_t APB1LRSTR_UART5RST = 0x100000;  // UART5 block reset
    static constexpr uint32_t APB1LRSTR_I2C1RST = 0x200000;   // I2C1 block reset
    static constexpr uint32_t APB1LRSTR_I2C2RST = 0x400000;   // I2C2 block reset
    static constexpr uint32_t APB1LRSTR_I2C3RST = 0x800000;   // I2C3 block reset
    static constexpr uint32_t APB1LRSTR_CECRST = 0x8000000;   // HDMI-CEC block reset
    static constexpr uint32_t APB1LRSTR_DAC12RST = 0x20000000;// DAC1 and 2 Blocks Reset
    static constexpr uint32_t APB1LRSTR_USART7RST = 0x40000000;// USART7 block reset
    static constexpr uint32_t APB1LRSTR_USART8RST = 0x80000000;// USART8 block reset
    static const uint32_t APB1LRSTR_RESET_VALUE = 0x0;

    static constexpr uint32_t APB1HRSTR_CRSRST = 0x2;         // Clock Recovery System reset
    static constexpr uint32_t APB1HRSTR_SWPRST = 0x4;         // SWPMI block reset
    static constexpr uint32_t APB1HRSTR_OPAMPRST = 0x10;      // OPAMP block reset
    static constexpr uint32_t APB1HRSTR_MDIOSRST = 0x20;      // MDIOS block reset
    static constexpr uint32_t APB1HRSTR_FDCANRST = 0x100;     // FDCAN block reset
    static const uint32_t APB1HRSTR_RESET_VALUE = 0x0;

    static constexpr uint32_t APB2RSTR_TIM1RST = 0x1;        // TIM1 block reset
    static constexpr uint32_t APB2RSTR_TIM8RST = 0x2;        // TIM8 block reset
    static constexpr uint32_t APB2RSTR_USART1RST = 0x10;     // USART1 block reset
    static constexpr uint32_t APB2RSTR_USART6RST = 0x20;     // USART6 block reset
    static constexpr uint32_t APB2RSTR_SPI1RST = 0x1000;     // SPI1 block reset
    static constexpr uint32_t APB2RSTR_SPI4RST = 0x2000;     // SPI4 block reset
    static constexpr uint32_t APB2RSTR_TIM15RST = 0x10000;   // TIM15 block reset
    static constexpr uint32_t APB2RSTR_TIM16RST = 0x20000;   // TIM16 block reset
    static constexpr uint32_t APB2RSTR_TIM17RST = 0x40000;   // TIM17 block reset
    static constexpr uint32_t APB2RSTR_SPI5RST = 0x100000;   // SPI5 block reset
    static constexpr uint32_t APB2RSTR_SAI1RST = 0x400000;   // SAI1 block reset
    static constexpr uint32_t APB2RSTR_SAI2RST = 0x800000;   // SAI2 block reset
    static constexpr uint32_t APB2RSTR_SAI3RST = 0x1000000;  // SAI3 block reset
    static constexpr uint32_t APB2RSTR_DFSDM1RST = 0x10000000;// DFSDM1 block reset
    static constexpr uint32_t APB2RSTR_HRTIMRST = 0x20000000;// HRTIM block reset
    static const uint32_t APB2RSTR_RESET_VALUE = 0x0;

    static constexpr uint32_t APB4RSTR_SYSCFGRST = 0x2;      // SYSCFG block reset
    static constexpr uint32_t APB4RSTR_LPUART1RST = 0x8;     // LPUART1 block reset
    static constexpr uint32_t APB4RSTR_SPI6RST = 0x20;       // SPI6 block reset
    static constexpr uint32_t APB4RSTR_I2C4RST = 0x80;       // I2C4 block reset
    static constexpr uint32_t APB4RSTR_LPTIM2RST = 0x200;    // LPTIM2 block reset
    static constexpr uint32_t APB4RSTR_LPTIM3RST = 0x400;    // LPTIM3 block reset
    static constexpr uint32_t APB4RSTR_LPTIM4RST = 0x800;    // LPTIM4 block reset
    static constexpr uint32_t APB4RSTR_LPTIM5RST = 0x1000;   // LPTIM5 block reset
    static constexpr uint32_t APB4RSTR_COMP12RST = 0x4000;   // COMP12 Blocks Reset
    static constexpr uint32_t APB4RSTR_VREFRST = 0x8000;     // VREF block reset
    static constexpr uint32_t APB4RSTR_SAI4RST = 0x200000;   // SAI4 block reset
    static const uint32_t APB4RSTR_RESET_VALUE = 0x0;

    static constexpr uint32_t GCR_WW1RSC = 0x1;         // WWDG1 reset scope control
    static const uint32_t GCR_RESET_VALUE = 0x0;

    static constexpr uint32_t D3AMR_BDMAAMEN = 0x1;       // BDMA and DMAMUX Autonomous mode enable
    static constexpr uint32_t D3AMR_LPUART1AMEN = 0x8;    // LPUART1 Autonomous mode enable
    static constexpr uint32_t D3AMR_SPI6AMEN = 0x20;      // SPI6 Autonomous mode enable
    static constexpr uint32_t D3AMR_I2C4AMEN = 0x80;      // I2C4 Autonomous mode enable
    static constexpr uint32_t D3AMR_LPTIM2AMEN = 0x200;   // LPTIM2 Autonomous mode enable
    static constexpr uint32_t D3AMR_LPTIM3AMEN = 0x400;   // LPTIM3 Autonomous mode enable
    static constexpr uint32_t D3AMR_LPTIM4AMEN = 0x800;   // LPTIM4 Autonomous mode enable
    static constexpr uint32_t D3AMR_LPTIM5AMEN = 0x1000;  // LPTIM5 Autonomous mode enable
    static constexpr uint32_t D3AMR_COMP12AMEN = 0x4000;  // COMP12 Autonomous mode enable
    static constexpr uint32_t D3AMR_VREFAMEN = 0x8000;    // VREF Autonomous mode enable
    static constexpr uint32_t D3AMR_RTCAMEN = 0x10000;    // RTC Autonomous mode enable
    static constexpr uint32_t D3AMR_CRCAMEN = 0x80000;    // CRC Autonomous mode enable
    static constexpr uint32_t D3AMR_SAI4AMEN = 0x200000;  // SAI4 Autonomous mode enable
    static constexpr uint32_t D3AMR_ADC3AMEN = 0x1000000; // ADC3 Autonomous mode enable
    static constexpr uint32_t D3AMR_BKPRAMAMEN = 0x10000000;// Backup RAM Autonomous mode enable
    static constexpr uint32_t D3AMR_SRAM4AMEN = 0x20000000;// SRAM4 Autonomous mode enable
    static const uint32_t D3AMR_RESET_VALUE = 0x0;

    static constexpr uint32_t RSR_RMVF = 0x10000;       // Remove reset flag
    static constexpr uint32_t RSR_CPURSTF = 0x20000;    // CPU reset flag
    static constexpr uint32_t RSR_D1RSTF = 0x80000;     // D1 domain power switch reset flag
    static constexpr uint32_t RSR_D2RSTF = 0x100000;    // D2 domain power switch reset flag
    static constexpr uint32_t RSR_BORRSTF = 0x200000;   // BOR reset flag
    static constexpr uint32_t RSR_PINRSTF = 0x400000;   // Pin reset flag (NRST)
    static constexpr uint32_t RSR_PORRSTF = 0x800000;   // POR/PDR reset flag
    static constexpr uint32_t RSR_SFTRSTF = 0x1000000;  // System reset from CPU reset flag
    static constexpr uint32_t RSR_IWDG1RSTF = 0x4000000;// Independent Watchdog reset flag
    static constexpr uint32_t RSR_WWDG1RSTF = 0x10000000;// Window Watchdog reset flag
    static constexpr uint32_t RSR_LPWRRSTF = 0x40000000;// Reset due to illegal D1 DStandby or CPU CStop flag
    static const uint32_t RSR_RESET_VALUE = 0x0;

    static constexpr uint32_t AHB3ENR_MDMAEN = 0x1;         // MDMA Peripheral Clock Enable
    static constexpr uint32_t AHB3ENR_DMA2DEN = 0x10;       // DMA2D Peripheral Clock Enable
    static constexpr uint32_t AHB3ENR_JPGDECEN = 0x20;      // JPGDEC Peripheral Clock Enable
    static constexpr uint32_t AHB3ENR_FMCEN = 0x1000;       // FMC Peripheral Clocks Enable
    static constexpr uint32_t AHB3ENR_QSPIEN = 0x4000;      // QUADSPI and QUADSPI Delay Clock Enable
    static constexpr uint32_t AHB3ENR_SDMMC1EN = 0x10000;   // SDMMC1 and SDMMC1 Delay Clock Enable
    static const uint32_t AHB3ENR_RESET_VALUE = 0x0;

    static constexpr uint32_t AHB1ENR_DMA1EN = 0x1;         // DMA1 Clock Enable
    static constexpr uint32_t AHB1ENR_DMA2EN = 0x2;         // DMA2 Clock Enable
    static constexpr uint32_t AHB1ENR_ADC12EN = 0x20;       // ADC1/2 Peripheral Clocks Enable
    static constexpr uint32_t AHB1ENR_ETH1MACEN = 0x8000;   // Ethernet MAC bus interface Clock Enable
    static constexpr uint32_t AHB1ENR_ETH1TXEN = 0x10000;   // Ethernet Transmission Clock Enable
    static constexpr uint32_t AHB1ENR_ETH1RXEN = 0x20000;   // Ethernet Reception Clock Enable
    static constexpr uint32_t AHB1ENR_USB2OTGHSULPIEN = 0x40000;// Enable USB_PHY2 clocks
    static constexpr uint32_t AHB1ENR_USB1OTGEN = 0x2000000;// USB1OTG Peripheral Clocks Enable
    static constexpr uint32_t AHB1ENR_USB1ULPIEN = 0x4000000;// USB_PHY1 Clocks Enable
    static constexpr uint32_t AHB1ENR_USB2OTGEN = 0x8000000;// USB2OTG Peripheral Clocks Enable
    static constexpr uint32_t AHB1ENR_USB2ULPIEN = 0x10000000;// USB_PHY2 Clocks Enable
    static const uint32_t AHB1ENR_RESET_VALUE = 0x0;

    static constexpr uint32_t AHB2ENR_CAMITFEN = 0x1;       // CAMITF peripheral clock enable
    static constexpr uint32_t AHB2ENR_CRYPTEN = 0x10;       // CRYPT peripheral clock enable
    static constexpr uint32_t AHB2ENR_HASHEN = 0x20;        // HASH peripheral clock enable
    static constexpr uint32_t AHB2ENR_RNGEN = 0x40;         // RNG peripheral clocks enable
    static constexpr uint32_t AHB2ENR_SDMMC2EN = 0x200;     // SDMMC2 and SDMMC2 delay clock enable
    static constexpr uint32_t AHB2ENR_SRAM1EN = 0x20000000; // SRAM1 block enable
    static constexpr uint32_t AHB2ENR_SRAM2EN = 0x40000000; // SRAM2 block enable
    static constexpr uint32_t AHB2ENR_SRAM3EN = 0x80000000; // SRAM3 block enable
    static const uint32_t AHB2ENR_RESET_VALUE = 0x0;

    static constexpr uint32_t AHB4ENR_GPIOAEN = 0x1;        // 0GPIO peripheral clock enable
    static constexpr uint32_t AHB4ENR_GPIOBEN = 0x2;        // 0GPIO peripheral clock enable
    static constexpr uint32_t AHB4ENR_GPIOCEN = 0x4;        // 0GPIO peripheral clock enable
    static constexpr uint32_t AHB4ENR_GPIODEN = 0x8;        // 0GPIO peripheral clock enable
    static constexpr uint32_t AHB4ENR_GPIOEEN = 0x10;       // 0GPIO peripheral clock enable
    static constexpr uint32_t AHB4ENR_GPIOFEN = 0x20;       // 0GPIO peripheral clock enable
    static constexpr uint32_t AHB4ENR_GPIOGEN = 0x40;       // 0GPIO peripheral clock enable
    static constexpr uint32_t AHB4ENR_GPIOHEN = 0x80;       // 0GPIO peripheral clock enable
    static constexpr uint32_t AHB4ENR_GPIOIEN = 0x100;      // 0GPIO peripheral clock enable
    static constexpr uint32_t AHB4ENR_GPIOJEN = 0x200;      // 0GPIO peripheral clock enable
    static constexpr uint32_t AHB4ENR_GPIOKEN = 0x400;      // 0GPIO peripheral clock enable
    static constexpr uint32_t AHB4ENR_CRCEN = 0x80000;      // CRC peripheral clock enable
    static constexpr uint32_t AHB4ENR_BDMAEN = 0x200000;    // BDMA and DMAMUX2 Clock Enable
    static constexpr uint32_t AHB4ENR_ADC3EN = 0x1000000;   // ADC3 Peripheral Clocks Enable
    static constexpr uint32_t AHB4ENR_HSEMEN = 0x2000000;   // HSEM peripheral clock enable
    static constexpr uint32_t AHB4ENR_BKPRAMEN = 0x10000000;// Backup RAM Clock Enable
    static const uint32_t AHB4ENR_RESET_VALUE = 0x0;

    static constexpr uint32_t APB3ENR_LTDCEN = 0x8;         // LTDC peripheral clock enable
    static constexpr uint32_t APB3ENR_WWDG1EN = 0x40;       // WWDG1 Clock Enable
    static const uint32_t APB3ENR_RESET_VALUE = 0x0;

    static constexpr uint32_t APB1LENR_TIM2EN = 0x1;         // TIM peripheral clock enable
    static constexpr uint32_t APB1LENR_TIM3EN = 0x2;         // TIM peripheral clock enable
    static constexpr uint32_t APB1LENR_TIM4EN = 0x4;         // TIM peripheral clock enable
    static constexpr uint32_t APB1LENR_TIM5EN = 0x8;         // TIM peripheral clock enable
    static constexpr uint32_t APB1LENR_TIM6EN = 0x10;        // TIM peripheral clock enable
    static constexpr uint32_t APB1LENR_TIM7EN = 0x20;        // TIM peripheral clock enable
    static constexpr uint32_t APB1LENR_TIM12EN = 0x40;       // TIM peripheral clock enable
    static constexpr uint32_t APB1LENR_TIM13EN = 0x80;       // TIM peripheral clock enable
    static constexpr uint32_t APB1LENR_TIM14EN = 0x100;      // TIM peripheral clock enable
    static constexpr uint32_t APB1LENR_LPTIM1EN = 0x200;     // LPTIM1 Peripheral Clocks Enable
    static constexpr uint32_t APB1LENR_SPI2EN = 0x4000;      // SPI2 Peripheral Clocks Enable
    static constexpr uint32_t APB1LENR_SPI3EN = 0x8000;      // SPI3 Peripheral Clocks Enable
    static constexpr uint32_t APB1LENR_SPDIFRXEN = 0x10000;  // SPDIFRX Peripheral Clocks Enable
    static constexpr uint32_t APB1LENR_USART2EN = 0x20000;   // USART2 Peripheral Clocks Enable
    static constexpr uint32_t APB1LENR_USART3EN = 0x40000;   // USART3 Peripheral Clocks Enable
    static constexpr uint32_t APB1LENR_UART4EN = 0x80000;    // UART4 Peripheral Clocks Enable
    static constexpr uint32_t APB1LENR_UART5EN = 0x100000;   // UART5 Peripheral Clocks Enable
    static constexpr uint32_t APB1LENR_I2C1EN = 0x200000;    // I2C1 Peripheral Clocks Enable
    static constexpr uint32_t APB1LENR_I2C2EN = 0x400000;    // I2C2 Peripheral Clocks Enable
    static constexpr uint32_t APB1LENR_I2C3EN = 0x800000;    // I2C3 Peripheral Clocks Enable
    static constexpr uint32_t APB1LENR_CECEN = 0x8000000;    // HDMI-CEC peripheral clock enable
    static constexpr uint32_t APB1LENR_DAC12EN = 0x20000000; // DAC1&amp;2 peripheral clock enable
    static constexpr uint32_t APB1LENR_USART7EN = 0x40000000;// USART7 Peripheral Clocks Enable
    static constexpr uint32_t APB1LENR_USART8EN = 0x80000000;// USART8 Peripheral Clocks Enable
    static const uint32_t APB1LENR_RESET_VALUE = 0x0;

    static constexpr uint32_t APB1HENR_CRSEN = 0x2;          // Clock Recovery System peripheral clock enable
    static constexpr uint32_t APB1HENR_SWPEN = 0x4;          // SWPMI Peripheral Clocks Enable
    static constexpr uint32_t APB1HENR_OPAMPEN = 0x10;       // OPAMP peripheral clock enable
    static constexpr uint32_t APB1HENR_MDIOSEN = 0x20;       // MDIOS peripheral clock enable
    static constexpr uint32_t APB1HENR_FDCANEN = 0x100;      // FDCAN Peripheral Clocks Enable
    static const uint32_t APB1HENR_RESET_VALUE = 0x0;

    static constexpr uint32_t APB2ENR_TIM1EN = 0x1;         // TIM1 peripheral clock enable
    static constexpr uint32_t APB2ENR_TIM8EN = 0x2;         // TIM8 peripheral clock enable
    static constexpr uint32_t APB2ENR_USART1EN = 0x10;      // USART1 Peripheral Clocks Enable
    static constexpr uint32_t APB2ENR_USART6EN = 0x20;      // USART6 Peripheral Clocks Enable
    static constexpr uint32_t APB2ENR_SPI1EN = 0x1000;      // SPI1 Peripheral Clocks Enable
    static constexpr uint32_t APB2ENR_SPI4EN = 0x2000;      // SPI4 Peripheral Clocks Enable
    static constexpr uint32_t APB2ENR_TIM16EN = 0x20000;    // TIM16 peripheral clock enable
    static constexpr uint32_t APB2ENR_TIM15EN = 0x10000;    // TIM15 peripheral clock enable
    static constexpr uint32_t APB2ENR_TIM17EN = 0x40000;    // TIM17 peripheral clock enable
    static constexpr uint32_t APB2ENR_SPI5EN = 0x100000;    // SPI5 Peripheral Clocks Enable
    static constexpr uint32_t APB2ENR_SAI1EN = 0x400000;    // SAI1 Peripheral Clocks Enable
    static constexpr uint32_t APB2ENR_SAI2EN = 0x800000;    // SAI2 Peripheral Clocks Enable
    static constexpr uint32_t APB2ENR_SAI3EN = 0x1000000;   // SAI3 Peripheral Clocks Enable
    static constexpr uint32_t APB2ENR_DFSDM1EN = 0x10000000;// DFSDM1 Peripheral Clocks Enable
    static constexpr uint32_t APB2ENR_HRTIMEN = 0x20000000; // HRTIM peripheral clock enable
    static const uint32_t APB2ENR_RESET_VALUE = 0x0;

    static constexpr uint32_t APB4ENR_SYSCFGEN = 0x2;       // SYSCFG peripheral clock enable
    static constexpr uint32_t APB4ENR_LPUART1EN = 0x8;      // LPUART1 Peripheral Clocks Enable
    static constexpr uint32_t APB4ENR_SPI6EN = 0x20;        // SPI6 Peripheral Clocks Enable
    static constexpr uint32_t APB4ENR_I2C4EN = 0x80;        // I2C4 Peripheral Clocks Enable
    static constexpr uint32_t APB4ENR_LPTIM2EN = 0x200;     // LPTIM2 Peripheral Clocks Enable
    static constexpr uint32_t APB4ENR_LPTIM3EN = 0x400;     // LPTIM3 Peripheral Clocks Enable
    static constexpr uint32_t APB4ENR_LPTIM4EN = 0x800;     // LPTIM4 Peripheral Clocks Enable
    static constexpr uint32_t APB4ENR_LPTIM5EN = 0x1000;    // LPTIM5 Peripheral Clocks Enable
    static constexpr uint32_t APB4ENR_COMP12EN = 0x4000;    // COMP1/2 peripheral clock enable
    static constexpr uint32_t APB4ENR_VREFEN = 0x8000;      // VREF peripheral clock enable
    static constexpr uint32_t APB4ENR_RTCAPBEN = 0x10000;   // RTC APB Clock Enable
    static constexpr uint32_t APB4ENR_SAI4EN = 0x200000;    // SAI4 Peripheral Clocks Enable
    static const uint32_t APB4ENR_RESET_VALUE = 0x0;

    static constexpr uint32_t AHB3LPENR_MDMALPEN = 0x1;       // MDMA Clock Enable During CSleep Mode
    static constexpr uint32_t AHB3LPENR_DMA2DLPEN = 0x10;     // DMA2D Clock Enable During CSleep Mode
    static constexpr uint32_t AHB3LPENR_JPGDECLPEN = 0x20;    // JPGDEC Clock Enable During CSleep Mode
    static constexpr uint32_t AHB3LPENR_FLASHLPEN = 0x100;    // FLITF Clock Enable During CSleep Mode
    static constexpr uint32_t AHB3LPENR_FMCLPEN = 0x1000;     // FMC Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t AHB3LPENR_QSPILPEN = 0x4000;    // QUADSPI and QUADSPI Delay Clock Enable During CSleep Mode
    static constexpr uint32_t AHB3LPENR_SDMMC1LPEN = 0x10000; // SDMMC1 and SDMMC1 Delay Clock Enable During CSleep Mode
    static constexpr uint32_t AHB3LPENR_D1DTCM1LPEN = 0x10000000;// D1DTCM1 Block Clock Enable During CSleep mode
    static constexpr uint32_t AHB3LPENR_DTCM2LPEN = 0x20000000;// D1 DTCM2 Block Clock Enable During CSleep mode
    static constexpr uint32_t AHB3LPENR_ITCMLPEN = 0x40000000;// D1ITCM Block Clock Enable During CSleep mode
    static constexpr uint32_t AHB3LPENR_AXISRAMLPEN = 0x80000000;// AXISRAM Block Clock Enable During CSleep mode
    static const uint32_t AHB3LPENR_RESET_VALUE = 0x0;

    static constexpr uint32_t AHB1LPENR_DMA1LPEN = 0x1;       // DMA1 Clock Enable During CSleep Mode
    static constexpr uint32_t AHB1LPENR_DMA2LPEN = 0x2;       // DMA2 Clock Enable During CSleep Mode
    static constexpr uint32_t AHB1LPENR_ADC12LPEN = 0x20;     // ADC1/2 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t AHB1LPENR_ETH1MACLPEN = 0x8000; // Ethernet MAC bus interface Clock Enable During CSleep Mode
    static constexpr uint32_t AHB1LPENR_ETH1TXLPEN = 0x10000; // Ethernet Transmission Clock Enable During CSleep Mode
    static constexpr uint32_t AHB1LPENR_ETH1RXLPEN = 0x20000; // Ethernet Reception Clock Enable During CSleep Mode
    static constexpr uint32_t AHB1LPENR_USB1OTGHSLPEN = 0x2000000;// USB1OTG peripheral clock enable during CSleep mode
    static constexpr uint32_t AHB1LPENR_USB1OTGHSULPILPEN = 0x4000000;// USB_PHY1 clock enable during CSleep mode
    static constexpr uint32_t AHB1LPENR_USB2OTGHSLPEN = 0x8000000;// USB2OTG peripheral clock enable during CSleep mode
    static constexpr uint32_t AHB1LPENR_USB2OTGHSULPILPEN = 0x10000000;// USB_PHY2 clocks enable during CSleep mode
    static const uint32_t AHB1LPENR_RESET_VALUE = 0x0;

    static constexpr uint32_t AHB2LPENR_CAMITFLPEN = 0x1;     // CAMITF peripheral clock enable during CSleep mode
    static constexpr uint32_t AHB2LPENR_CRYPTLPEN = 0x10;     // CRYPT peripheral clock enable during CSleep mode
    static constexpr uint32_t AHB2LPENR_HASHLPEN = 0x20;      // HASH peripheral clock enable during CSleep mode
    static constexpr uint32_t AHB2LPENR_SDMMC2LPEN = 0x200;   // SDMMC2 and SDMMC2 Delay Clock Enable During CSleep Mode
    static constexpr uint32_t AHB2LPENR_RNGLPEN = 0x40;       // RNG peripheral clock enable during CSleep mode
    static constexpr uint32_t AHB2LPENR_SRAM1LPEN = 0x20000000;// SRAM1 Clock Enable During CSleep Mode
    static constexpr uint32_t AHB2LPENR_SRAM2LPEN = 0x40000000;// SRAM2 Clock Enable During CSleep Mode
    static constexpr uint32_t AHB2LPENR_SRAM3LPEN = 0x80000000;// SRAM3 Clock Enable During CSleep Mode
    static const uint32_t AHB2LPENR_RESET_VALUE = 0x0;

    static constexpr uint32_t AHB4LPENR_GPIOALPEN = 0x1;      // GPIO peripheral clock enable during CSleep mode
    static constexpr uint32_t AHB4LPENR_GPIOBLPEN = 0x2;      // GPIO peripheral clock enable during CSleep mode
    static constexpr uint32_t AHB4LPENR_GPIOCLPEN = 0x4;      // GPIO peripheral clock enable during CSleep mode
    static constexpr uint32_t AHB4LPENR_GPIODLPEN = 0x8;      // GPIO peripheral clock enable during CSleep mode
    static constexpr uint32_t AHB4LPENR_GPIOELPEN = 0x10;     // GPIO peripheral clock enable during CSleep mode
    static constexpr uint32_t AHB4LPENR_GPIOFLPEN = 0x20;     // GPIO peripheral clock enable during CSleep mode
    static constexpr uint32_t AHB4LPENR_GPIOGLPEN = 0x40;     // GPIO peripheral clock enable during CSleep mode
    static constexpr uint32_t AHB4LPENR_GPIOHLPEN = 0x80;     // GPIO peripheral clock enable during CSleep mode
    static constexpr uint32_t AHB4LPENR_GPIOILPEN = 0x100;    // GPIO peripheral clock enable during CSleep mode
    static constexpr uint32_t AHB4LPENR_GPIOJLPEN = 0x200;    // GPIO peripheral clock enable during CSleep mode
    static constexpr uint32_t AHB4LPENR_GPIOKLPEN = 0x400;    // GPIO peripheral clock enable during CSleep mode
    static constexpr uint32_t AHB4LPENR_CRCLPEN = 0x80000;    // CRC peripheral clock enable during CSleep mode
    static constexpr uint32_t AHB4LPENR_BDMALPEN = 0x200000;  // BDMA Clock Enable During CSleep Mode
    static constexpr uint32_t AHB4LPENR_ADC3LPEN = 0x1000000; // ADC3 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t AHB4LPENR_BKPRAMLPEN = 0x10000000;// Backup RAM Clock Enable During CSleep Mode
    static constexpr uint32_t AHB4LPENR_SRAM4LPEN = 0x20000000;// SRAM4 Clock Enable During CSleep Mode
    static const uint32_t AHB4LPENR_RESET_VALUE = 0x0;

    static constexpr uint32_t APB3LPENR_LTDCLPEN = 0x8;       // LTDC peripheral clock enable during CSleep mode
    static constexpr uint32_t APB3LPENR_WWDG1LPEN = 0x40;     // WWDG1 Clock Enable During CSleep Mode
    static const uint32_t APB3LPENR_RESET_VALUE = 0x0;

    static constexpr uint32_t APB1LLPENR_TIM2LPEN = 0x1;       // TIM2 peripheral clock enable during CSleep mode
    static constexpr uint32_t APB1LLPENR_TIM3LPEN = 0x2;       // TIM3 peripheral clock enable during CSleep mode
    static constexpr uint32_t APB1LLPENR_TIM4LPEN = 0x4;       // TIM4 peripheral clock enable during CSleep mode
    static constexpr uint32_t APB1LLPENR_TIM5LPEN = 0x8;       // TIM5 peripheral clock enable during CSleep mode
    static constexpr uint32_t APB1LLPENR_TIM6LPEN = 0x10;      // TIM6 peripheral clock enable during CSleep mode
    static constexpr uint32_t APB1LLPENR_TIM7LPEN = 0x20;      // TIM7 peripheral clock enable during CSleep mode
    static constexpr uint32_t APB1LLPENR_TIM12LPEN = 0x40;     // TIM12 peripheral clock enable during CSleep mode
    static constexpr uint32_t APB1LLPENR_TIM13LPEN = 0x80;     // TIM13 peripheral clock enable during CSleep mode
    static constexpr uint32_t APB1LLPENR_TIM14LPEN = 0x100;    // TIM14 peripheral clock enable during CSleep mode
    static constexpr uint32_t APB1LLPENR_LPTIM1LPEN = 0x200;   // LPTIM1 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t APB1LLPENR_SPI2LPEN = 0x4000;    // SPI2 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t APB1LLPENR_SPI3LPEN = 0x8000;    // SPI3 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t APB1LLPENR_SPDIFRXLPEN = 0x10000;// SPDIFRX Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t APB1LLPENR_USART2LPEN = 0x20000; // USART2 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t APB1LLPENR_USART3LPEN = 0x40000; // USART3 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t APB1LLPENR_UART4LPEN = 0x80000;  // UART4 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t APB1LLPENR_UART5LPEN = 0x100000; // UART5 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t APB1LLPENR_I2C1LPEN = 0x200000;  // I2C1 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t APB1LLPENR_I2C2LPEN = 0x400000;  // I2C2 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t APB1LLPENR_I2C3LPEN = 0x800000;  // I2C3 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t APB1LLPENR_HDMICECLPEN = 0x8000000;// HDMI-CEC Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t APB1LLPENR_DAC12LPEN = 0x20000000;// DAC1/2 peripheral clock enable during CSleep mode
    static constexpr uint32_t APB1LLPENR_USART7LPEN = 0x40000000;// USART7 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t APB1LLPENR_USART8LPEN = 0x80000000;// USART8 Peripheral Clocks Enable During CSleep Mode
    static const uint32_t APB1LLPENR_RESET_VALUE = 0x0;

    static constexpr uint32_t APB1HLPENR_CRSLPEN = 0x2;        // Clock Recovery System peripheral clock enable during CSleep mode
    static constexpr uint32_t APB1HLPENR_SWPLPEN = 0x4;        // SWPMI Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t APB1HLPENR_OPAMPLPEN = 0x10;     // OPAMP peripheral clock enable during CSleep mode
    static constexpr uint32_t APB1HLPENR_MDIOSLPEN = 0x20;     // MDIOS peripheral clock enable during CSleep mode
    static constexpr uint32_t APB1HLPENR_FDCANLPEN = 0x100;    // FDCAN Peripheral Clocks Enable During CSleep Mode
    static const uint32_t APB1HLPENR_RESET_VALUE = 0x0;

    static constexpr uint32_t APB2LPENR_TIM1LPEN = 0x1;       // TIM1 peripheral clock enable during CSleep mode
    static constexpr uint32_t APB2LPENR_TIM8LPEN = 0x2;       // TIM8 peripheral clock enable during CSleep mode
    static constexpr uint32_t APB2LPENR_USART1LPEN = 0x10;    // USART1 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t APB2LPENR_USART6LPEN = 0x20;    // USART6 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t APB2LPENR_SPI1LPEN = 0x1000;    // SPI1 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t APB2LPENR_SPI4LPEN = 0x2000;    // SPI4 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t APB2LPENR_TIM15LPEN = 0x10000;  // TIM15 peripheral clock enable during CSleep mode
    static constexpr uint32_t APB2LPENR_TIM16LPEN = 0x20000;  // TIM16 peripheral clock enable during CSleep mode
    static constexpr uint32_t APB2LPENR_TIM17LPEN = 0x40000;  // TIM17 peripheral clock enable during CSleep mode
    static constexpr uint32_t APB2LPENR_SPI5LPEN = 0x100000;  // SPI5 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t APB2LPENR_SAI1LPEN = 0x400000;  // SAI1 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t APB2LPENR_SAI2LPEN = 0x800000;  // SAI2 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t APB2LPENR_SAI3LPEN = 0x1000000; // SAI3 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t APB2LPENR_DFSDM1LPEN = 0x10000000;// DFSDM1 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t APB2LPENR_HRTIMLPEN = 0x20000000;// HRTIM peripheral clock enable during CSleep mode
    static const uint32_t APB2LPENR_RESET_VALUE = 0x0;

    static constexpr uint32_t APB4LPENR_SYSCFGLPEN = 0x2;     // SYSCFG peripheral clock enable during CSleep mode
    static constexpr uint32_t APB4LPENR_LPUART1LPEN = 0x8;    // LPUART1 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t APB4LPENR_SPI6LPEN = 0x20;      // SPI6 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t APB4LPENR_I2C4LPEN = 0x80;      // I2C4 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t APB4LPENR_LPTIM2LPEN = 0x200;   // LPTIM2 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t APB4LPENR_LPTIM3LPEN = 0x400;   // LPTIM3 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t APB4LPENR_LPTIM4LPEN = 0x800;   // LPTIM4 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t APB4LPENR_LPTIM5LPEN = 0x1000;  // LPTIM5 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t APB4LPENR_COMP12LPEN = 0x4000;  // COMP1/2 peripheral clock enable during CSleep mode
    static constexpr uint32_t APB4LPENR_VREFLPEN = 0x8000;    // VREF peripheral clock enable during CSleep mode
    static constexpr uint32_t APB4LPENR_RTCAPBLPEN = 0x10000; // RTC APB Clock Enable During CSleep Mode
    static constexpr uint32_t APB4LPENR_SAI4LPEN = 0x200000;  // SAI4 Peripheral Clocks Enable During CSleep Mode
    static const uint32_t APB4LPENR_RESET_VALUE = 0x0;

    static constexpr uint32_t C1_RSR_RMVF = 0x10000;       // Remove reset flag
    static constexpr uint32_t C1_RSR_CPURSTF = 0x20000;    // CPU reset flag
    static constexpr uint32_t C1_RSR_D1RSTF = 0x80000;     // D1 domain power switch reset flag
    static constexpr uint32_t C1_RSR_D2RSTF = 0x100000;    // D2 domain power switch reset flag
    static constexpr uint32_t C1_RSR_BORRSTF = 0x200000;   // BOR reset flag
    static constexpr uint32_t C1_RSR_PINRSTF = 0x400000;   // Pin reset flag (NRST)
    static constexpr uint32_t C1_RSR_PORRSTF = 0x800000;   // POR/PDR reset flag
    static constexpr uint32_t C1_RSR_SFTRSTF = 0x1000000;  // System reset from CPU reset flag
    static constexpr uint32_t C1_RSR_IWDG1RSTF = 0x4000000;// Independent Watchdog reset flag
    static constexpr uint32_t C1_RSR_WWDG1RSTF = 0x10000000;// Window Watchdog reset flag
    static constexpr uint32_t C1_RSR_LPWRRSTF = 0x40000000;// Reset due to illegal D1 DStandby or CPU CStop flag
    static const uint32_t C1_RSR_RESET_VALUE = 0x0;

    static constexpr uint32_t C1_AHB3ENR_MDMAEN = 0x1;         // MDMA Peripheral Clock Enable
    static constexpr uint32_t C1_AHB3ENR_DMA2DEN = 0x10;       // DMA2D Peripheral Clock Enable
    static constexpr uint32_t C1_AHB3ENR_JPGDECEN = 0x20;      // JPGDEC Peripheral Clock Enable
    static constexpr uint32_t C1_AHB3ENR_FMCEN = 0x1000;       // FMC Peripheral Clocks Enable
    static constexpr uint32_t C1_AHB3ENR_QSPIEN = 0x4000;      // QUADSPI and QUADSPI Delay Clock Enable
    static constexpr uint32_t C1_AHB3ENR_SDMMC1EN = 0x10000;   // SDMMC1 and SDMMC1 Delay Clock Enable
    static const uint32_t C1_AHB3ENR_RESET_VALUE = 0x0;

    static constexpr uint32_t C1_AHB1ENR_DMA1EN = 0x1;         // DMA1 Clock Enable
    static constexpr uint32_t C1_AHB1ENR_DMA2EN = 0x2;         // DMA2 Clock Enable
    static constexpr uint32_t C1_AHB1ENR_ADC12EN = 0x20;       // ADC1/2 Peripheral Clocks Enable
    static constexpr uint32_t C1_AHB1ENR_ETH1MACEN = 0x8000;   // Ethernet MAC bus interface Clock Enable
    static constexpr uint32_t C1_AHB1ENR_ETH1TXEN = 0x10000;   // Ethernet Transmission Clock Enable
    static constexpr uint32_t C1_AHB1ENR_ETH1RXEN = 0x20000;   // Ethernet Reception Clock Enable
    static constexpr uint32_t C1_AHB1ENR_USB1OTGEN = 0x2000000;// USB1OTG Peripheral Clocks Enable
    static constexpr uint32_t C1_AHB1ENR_USB1ULPIEN = 0x4000000;// USB_PHY1 Clocks Enable
    static constexpr uint32_t C1_AHB1ENR_USB2OTGEN = 0x8000000;// USB2OTG Peripheral Clocks Enable
    static constexpr uint32_t C1_AHB1ENR_USB2ULPIEN = 0x10000000;// USB_PHY2 Clocks Enable
    static const uint32_t C1_AHB1ENR_RESET_VALUE = 0x0;

    static constexpr uint32_t C1_AHB2ENR_CAMITFEN = 0x1;       // CAMITF peripheral clock enable
    static constexpr uint32_t C1_AHB2ENR_CRYPTEN = 0x10;       // CRYPT peripheral clock enable
    static constexpr uint32_t C1_AHB2ENR_HASHEN = 0x20;        // HASH peripheral clock enable
    static constexpr uint32_t C1_AHB2ENR_RNGEN = 0x40;         // RNG peripheral clocks enable
    static constexpr uint32_t C1_AHB2ENR_SDMMC2EN = 0x200;     // SDMMC2 and SDMMC2 delay clock enable
    static constexpr uint32_t C1_AHB2ENR_SRAM1EN = 0x20000000; // SRAM1 block enable
    static constexpr uint32_t C1_AHB2ENR_SRAM2EN = 0x40000000; // SRAM2 block enable
    static constexpr uint32_t C1_AHB2ENR_SRAM3EN = 0x80000000; // SRAM3 block enable
    static const uint32_t C1_AHB2ENR_RESET_VALUE = 0x0;

    static constexpr uint32_t C1_AHB4ENR_GPIOAEN = 0x1;        // 0GPIO peripheral clock enable
    static constexpr uint32_t C1_AHB4ENR_GPIOBEN = 0x2;        // 0GPIO peripheral clock enable
    static constexpr uint32_t C1_AHB4ENR_GPIOCEN = 0x4;        // 0GPIO peripheral clock enable
    static constexpr uint32_t C1_AHB4ENR_GPIODEN = 0x8;        // 0GPIO peripheral clock enable
    static constexpr uint32_t C1_AHB4ENR_GPIOEEN = 0x10;       // 0GPIO peripheral clock enable
    static constexpr uint32_t C1_AHB4ENR_GPIOFEN = 0x20;       // 0GPIO peripheral clock enable
    static constexpr uint32_t C1_AHB4ENR_GPIOGEN = 0x40;       // 0GPIO peripheral clock enable
    static constexpr uint32_t C1_AHB4ENR_GPIOHEN = 0x80;       // 0GPIO peripheral clock enable
    static constexpr uint32_t C1_AHB4ENR_GPIOIEN = 0x100;      // 0GPIO peripheral clock enable
    static constexpr uint32_t C1_AHB4ENR_GPIOJEN = 0x200;      // 0GPIO peripheral clock enable
    static constexpr uint32_t C1_AHB4ENR_GPIOKEN = 0x400;      // 0GPIO peripheral clock enable
    static constexpr uint32_t C1_AHB4ENR_CRCEN = 0x80000;      // CRC peripheral clock enable
    static constexpr uint32_t C1_AHB4ENR_BDMAEN = 0x200000;    // BDMA and DMAMUX2 Clock Enable
    static constexpr uint32_t C1_AHB4ENR_ADC3EN = 0x1000000;   // ADC3 Peripheral Clocks Enable
    static constexpr uint32_t C1_AHB4ENR_HSEMEN = 0x2000000;   // HSEM peripheral clock enable
    static constexpr uint32_t C1_AHB4ENR_BKPRAMEN = 0x10000000;// Backup RAM Clock Enable
    static const uint32_t C1_AHB4ENR_RESET_VALUE = 0x0;

    static constexpr uint32_t C1_APB3ENR_LTDCEN = 0x8;         // LTDC peripheral clock enable
    static constexpr uint32_t C1_APB3ENR_WWDG1EN = 0x40;       // WWDG1 Clock Enable
    static const uint32_t C1_APB3ENR_RESET_VALUE = 0x0;

    static constexpr uint32_t C1_APB1LENR_TIM2EN = 0x1;         // TIM peripheral clock enable
    static constexpr uint32_t C1_APB1LENR_TIM3EN = 0x2;         // TIM peripheral clock enable
    static constexpr uint32_t C1_APB1LENR_TIM4EN = 0x4;         // TIM peripheral clock enable
    static constexpr uint32_t C1_APB1LENR_TIM5EN = 0x8;         // TIM peripheral clock enable
    static constexpr uint32_t C1_APB1LENR_TIM6EN = 0x10;        // TIM peripheral clock enable
    static constexpr uint32_t C1_APB1LENR_TIM7EN = 0x20;        // TIM peripheral clock enable
    static constexpr uint32_t C1_APB1LENR_TIM12EN = 0x40;       // TIM peripheral clock enable
    static constexpr uint32_t C1_APB1LENR_TIM13EN = 0x80;       // TIM peripheral clock enable
    static constexpr uint32_t C1_APB1LENR_TIM14EN = 0x100;      // TIM peripheral clock enable
    static constexpr uint32_t C1_APB1LENR_LPTIM1EN = 0x200;     // LPTIM1 Peripheral Clocks Enable
    static constexpr uint32_t C1_APB1LENR_SPI2EN = 0x4000;      // SPI2 Peripheral Clocks Enable
    static constexpr uint32_t C1_APB1LENR_SPI3EN = 0x8000;      // SPI3 Peripheral Clocks Enable
    static constexpr uint32_t C1_APB1LENR_SPDIFRXEN = 0x10000;  // SPDIFRX Peripheral Clocks Enable
    static constexpr uint32_t C1_APB1LENR_USART2EN = 0x20000;   // USART2 Peripheral Clocks Enable
    static constexpr uint32_t C1_APB1LENR_USART3EN = 0x40000;   // USART3 Peripheral Clocks Enable
    static constexpr uint32_t C1_APB1LENR_UART4EN = 0x80000;    // UART4 Peripheral Clocks Enable
    static constexpr uint32_t C1_APB1LENR_UART5EN = 0x100000;   // UART5 Peripheral Clocks Enable
    static constexpr uint32_t C1_APB1LENR_I2C1EN = 0x200000;    // I2C1 Peripheral Clocks Enable
    static constexpr uint32_t C1_APB1LENR_I2C2EN = 0x400000;    // I2C2 Peripheral Clocks Enable
    static constexpr uint32_t C1_APB1LENR_I2C3EN = 0x800000;    // I2C3 Peripheral Clocks Enable
    static constexpr uint32_t C1_APB1LENR_HDMICECEN = 0x8000000;// HDMI-CEC peripheral clock enable
    static constexpr uint32_t C1_APB1LENR_DAC12EN = 0x20000000; // DAC1&amp;2 peripheral clock enable
    static constexpr uint32_t C1_APB1LENR_USART7EN = 0x40000000;// USART7 Peripheral Clocks Enable
    static constexpr uint32_t C1_APB1LENR_USART8EN = 0x80000000;// USART8 Peripheral Clocks Enable
    static const uint32_t C1_APB1LENR_RESET_VALUE = 0x0;

    static constexpr uint32_t C1_APB1HENR_CRSEN = 0x2;          // Clock Recovery System peripheral clock enable
    static constexpr uint32_t C1_APB1HENR_SWPEN = 0x4;          // SWPMI Peripheral Clocks Enable
    static constexpr uint32_t C1_APB1HENR_OPAMPEN = 0x10;       // OPAMP peripheral clock enable
    static constexpr uint32_t C1_APB1HENR_MDIOSEN = 0x20;       // MDIOS peripheral clock enable
    static constexpr uint32_t C1_APB1HENR_FDCANEN = 0x100;      // FDCAN Peripheral Clocks Enable
    static const uint32_t C1_APB1HENR_RESET_VALUE = 0x0;

    static constexpr uint32_t C1_APB2ENR_TIM1EN = 0x1;         // TIM1 peripheral clock enable
    static constexpr uint32_t C1_APB2ENR_TIM8EN = 0x2;         // TIM8 peripheral clock enable
    static constexpr uint32_t C1_APB2ENR_USART1EN = 0x10;      // USART1 Peripheral Clocks Enable
    static constexpr uint32_t C1_APB2ENR_USART6EN = 0x20;      // USART6 Peripheral Clocks Enable
    static constexpr uint32_t C1_APB2ENR_SPI1EN = 0x1000;      // SPI1 Peripheral Clocks Enable
    static constexpr uint32_t C1_APB2ENR_SPI4EN = 0x2000;      // SPI4 Peripheral Clocks Enable
    static constexpr uint32_t C1_APB2ENR_TIM16EN = 0x20000;    // TIM16 peripheral clock enable
    static constexpr uint32_t C1_APB2ENR_TIM15EN = 0x10000;    // TIM15 peripheral clock enable
    static constexpr uint32_t C1_APB2ENR_TIM17EN = 0x40000;    // TIM17 peripheral clock enable
    static constexpr uint32_t C1_APB2ENR_SPI5EN = 0x100000;    // SPI5 Peripheral Clocks Enable
    static constexpr uint32_t C1_APB2ENR_SAI1EN = 0x400000;    // SAI1 Peripheral Clocks Enable
    static constexpr uint32_t C1_APB2ENR_SAI2EN = 0x800000;    // SAI2 Peripheral Clocks Enable
    static constexpr uint32_t C1_APB2ENR_SAI3EN = 0x1000000;   // SAI3 Peripheral Clocks Enable
    static constexpr uint32_t C1_APB2ENR_DFSDM1EN = 0x10000000;// DFSDM1 Peripheral Clocks Enable
    static constexpr uint32_t C1_APB2ENR_HRTIMEN = 0x20000000; // HRTIM peripheral clock enable
    static const uint32_t C1_APB2ENR_RESET_VALUE = 0x0;

    static constexpr uint32_t C1_APB4ENR_SYSCFGEN = 0x2;       // SYSCFG peripheral clock enable
    static constexpr uint32_t C1_APB4ENR_LPUART1EN = 0x8;      // LPUART1 Peripheral Clocks Enable
    static constexpr uint32_t C1_APB4ENR_SPI6EN = 0x20;        // SPI6 Peripheral Clocks Enable
    static constexpr uint32_t C1_APB4ENR_I2C4EN = 0x80;        // I2C4 Peripheral Clocks Enable
    static constexpr uint32_t C1_APB4ENR_LPTIM2EN = 0x200;     // LPTIM2 Peripheral Clocks Enable
    static constexpr uint32_t C1_APB4ENR_LPTIM3EN = 0x400;     // LPTIM3 Peripheral Clocks Enable
    static constexpr uint32_t C1_APB4ENR_LPTIM4EN = 0x800;     // LPTIM4 Peripheral Clocks Enable
    static constexpr uint32_t C1_APB4ENR_LPTIM5EN = 0x1000;    // LPTIM5 Peripheral Clocks Enable
    static constexpr uint32_t C1_APB4ENR_COMP12EN = 0x4000;    // COMP1/2 peripheral clock enable
    static constexpr uint32_t C1_APB4ENR_VREFEN = 0x8000;      // VREF peripheral clock enable
    static constexpr uint32_t C1_APB4ENR_RTCAPBEN = 0x10000;   // RTC APB Clock Enable
    static constexpr uint32_t C1_APB4ENR_SAI4EN = 0x200000;    // SAI4 Peripheral Clocks Enable
    static const uint32_t C1_APB4ENR_RESET_VALUE = 0x0;

    static constexpr uint32_t C1_AHB3LPENR_MDMALPEN = 0x1;       // MDMA Clock Enable During CSleep Mode
    static constexpr uint32_t C1_AHB3LPENR_DMA2DLPEN = 0x10;     // DMA2D Clock Enable During CSleep Mode
    static constexpr uint32_t C1_AHB3LPENR_JPGDECLPEN = 0x20;    // JPGDEC Clock Enable During CSleep Mode
    static constexpr uint32_t C1_AHB3LPENR_FLITFLPEN = 0x100;    // FLITF Clock Enable During CSleep Mode
    static constexpr uint32_t C1_AHB3LPENR_FMCLPEN = 0x1000;     // FMC Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t C1_AHB3LPENR_QSPILPEN = 0x4000;    // QUADSPI and QUADSPI Delay Clock Enable During CSleep Mode
    static constexpr uint32_t C1_AHB3LPENR_SDMMC1LPEN = 0x10000; // SDMMC1 and SDMMC1 Delay Clock Enable During CSleep Mode
    static constexpr uint32_t C1_AHB3LPENR_D1DTCM1LPEN = 0x10000000;// D1DTCM1 Block Clock Enable During CSleep mode
    static constexpr uint32_t C1_AHB3LPENR_DTCM2LPEN = 0x20000000;// D1 DTCM2 Block Clock Enable During CSleep mode
    static constexpr uint32_t C1_AHB3LPENR_ITCMLPEN = 0x40000000;// D1ITCM Block Clock Enable During CSleep mode
    static constexpr uint32_t C1_AHB3LPENR_AXISRAMLPEN = 0x80000000;// AXISRAM Block Clock Enable During CSleep mode
    static const uint32_t C1_AHB3LPENR_RESET_VALUE = 0x0;

    static constexpr uint32_t C1_AHB1LPENR_DMA1LPEN = 0x1;       // DMA1 Clock Enable During CSleep Mode
    static constexpr uint32_t C1_AHB1LPENR_DMA2LPEN = 0x2;       // DMA2 Clock Enable During CSleep Mode
    static constexpr uint32_t C1_AHB1LPENR_ADC12LPEN = 0x20;     // ADC1/2 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t C1_AHB1LPENR_ETH1MACLPEN = 0x8000; // Ethernet MAC bus interface Clock Enable During CSleep Mode
    static constexpr uint32_t C1_AHB1LPENR_ETH1TXLPEN = 0x10000; // Ethernet Transmission Clock Enable During CSleep Mode
    static constexpr uint32_t C1_AHB1LPENR_ETH1RXLPEN = 0x20000; // Ethernet Reception Clock Enable During CSleep Mode
    static constexpr uint32_t C1_AHB1LPENR_USB1OTGLPEN = 0x2000000;// USB1OTG peripheral clock enable during CSleep mode
    static constexpr uint32_t C1_AHB1LPENR_USB1ULPILPEN = 0x4000000;// USB_PHY1 clock enable during CSleep mode
    static constexpr uint32_t C1_AHB1LPENR_USB2OTGLPEN = 0x8000000;// USB2OTG peripheral clock enable during CSleep mode
    static constexpr uint32_t C1_AHB1LPENR_USB2ULPILPEN = 0x10000000;// USB_PHY2 clocks enable during CSleep mode
    static const uint32_t C1_AHB1LPENR_RESET_VALUE = 0x0;

    static constexpr uint32_t C1_AHB2LPENR_CAMITFLPEN = 0x1;     // CAMITF peripheral clock enable during CSleep mode
    static constexpr uint32_t C1_AHB2LPENR_CRYPTLPEN = 0x10;     // CRYPT peripheral clock enable during CSleep mode
    static constexpr uint32_t C1_AHB2LPENR_HASHLPEN = 0x20;      // HASH peripheral clock enable during CSleep mode
    static constexpr uint32_t C1_AHB2LPENR_SDMMC2LPEN = 0x200;   // SDMMC2 and SDMMC2 Delay Clock Enable During CSleep Mode
    static constexpr uint32_t C1_AHB2LPENR_RNGLPEN = 0x40;       // RNG peripheral clock enable during CSleep mode
    static constexpr uint32_t C1_AHB2LPENR_SRAM1LPEN = 0x20000000;// SRAM1 Clock Enable During CSleep Mode
    static constexpr uint32_t C1_AHB2LPENR_SRAM2LPEN = 0x40000000;// SRAM2 Clock Enable During CSleep Mode
    static constexpr uint32_t C1_AHB2LPENR_SRAM3LPEN = 0x80000000;// SRAM3 Clock Enable During CSleep Mode
    static const uint32_t C1_AHB2LPENR_RESET_VALUE = 0x0;

    static constexpr uint32_t C1_AHB4LPENR_GPIOALPEN = 0x1;      // GPIO peripheral clock enable during CSleep mode
    static constexpr uint32_t C1_AHB4LPENR_GPIOBLPEN = 0x2;      // GPIO peripheral clock enable during CSleep mode
    static constexpr uint32_t C1_AHB4LPENR_GPIOCLPEN = 0x4;      // GPIO peripheral clock enable during CSleep mode
    static constexpr uint32_t C1_AHB4LPENR_GPIODLPEN = 0x8;      // GPIO peripheral clock enable during CSleep mode
    static constexpr uint32_t C1_AHB4LPENR_GPIOELPEN = 0x10;     // GPIO peripheral clock enable during CSleep mode
    static constexpr uint32_t C1_AHB4LPENR_GPIOFLPEN = 0x20;     // GPIO peripheral clock enable during CSleep mode
    static constexpr uint32_t C1_AHB4LPENR_GPIOGLPEN = 0x40;     // GPIO peripheral clock enable during CSleep mode
    static constexpr uint32_t C1_AHB4LPENR_GPIOHLPEN = 0x80;     // GPIO peripheral clock enable during CSleep mode
    static constexpr uint32_t C1_AHB4LPENR_GPIOILPEN = 0x100;    // GPIO peripheral clock enable during CSleep mode
    static constexpr uint32_t C1_AHB4LPENR_GPIOJLPEN = 0x200;    // GPIO peripheral clock enable during CSleep mode
    static constexpr uint32_t C1_AHB4LPENR_GPIOKLPEN = 0x400;    // GPIO peripheral clock enable during CSleep mode
    static constexpr uint32_t C1_AHB4LPENR_CRCLPEN = 0x80000;    // CRC peripheral clock enable during CSleep mode
    static constexpr uint32_t C1_AHB4LPENR_BDMALPEN = 0x200000;  // BDMA Clock Enable During CSleep Mode
    static constexpr uint32_t C1_AHB4LPENR_ADC3LPEN = 0x1000000; // ADC3 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t C1_AHB4LPENR_BKPRAMLPEN = 0x10000000;// Backup RAM Clock Enable During CSleep Mode
    static constexpr uint32_t C1_AHB4LPENR_SRAM4LPEN = 0x20000000;// SRAM4 Clock Enable During CSleep Mode
    static const uint32_t C1_AHB4LPENR_RESET_VALUE = 0x0;

    static constexpr uint32_t C1_APB3LPENR_LTDCLPEN = 0x8;       // LTDC peripheral clock enable during CSleep mode
    static constexpr uint32_t C1_APB3LPENR_WWDG1LPEN = 0x40;     // WWDG1 Clock Enable During CSleep Mode
    static const uint32_t C1_APB3LPENR_RESET_VALUE = 0x0;

    static constexpr uint32_t C1_APB1LLPENR_TIM2LPEN = 0x1;       // TIM2 peripheral clock enable during CSleep mode
    static constexpr uint32_t C1_APB1LLPENR_TIM3LPEN = 0x2;       // TIM3 peripheral clock enable during CSleep mode
    static constexpr uint32_t C1_APB1LLPENR_TIM4LPEN = 0x4;       // TIM4 peripheral clock enable during CSleep mode
    static constexpr uint32_t C1_APB1LLPENR_TIM5LPEN = 0x8;       // TIM5 peripheral clock enable during CSleep mode
    static constexpr uint32_t C1_APB1LLPENR_TIM6LPEN = 0x10;      // TIM6 peripheral clock enable during CSleep mode
    static constexpr uint32_t C1_APB1LLPENR_TIM7LPEN = 0x20;      // TIM7 peripheral clock enable during CSleep mode
    static constexpr uint32_t C1_APB1LLPENR_TIM12LPEN = 0x40;     // TIM12 peripheral clock enable during CSleep mode
    static constexpr uint32_t C1_APB1LLPENR_TIM13LPEN = 0x80;     // TIM13 peripheral clock enable during CSleep mode
    static constexpr uint32_t C1_APB1LLPENR_TIM14LPEN = 0x100;    // TIM14 peripheral clock enable during CSleep mode
    static constexpr uint32_t C1_APB1LLPENR_LPTIM1LPEN = 0x200;   // LPTIM1 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t C1_APB1LLPENR_SPI2LPEN = 0x4000;    // SPI2 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t C1_APB1LLPENR_SPI3LPEN = 0x8000;    // SPI3 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t C1_APB1LLPENR_SPDIFRXLPEN = 0x10000;// SPDIFRX Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t C1_APB1LLPENR_USART2LPEN = 0x20000; // USART2 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t C1_APB1LLPENR_USART3LPEN = 0x40000; // USART3 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t C1_APB1LLPENR_UART4LPEN = 0x80000;  // UART4 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t C1_APB1LLPENR_UART5LPEN = 0x100000; // UART5 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t C1_APB1LLPENR_I2C1LPEN = 0x200000;  // I2C1 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t C1_APB1LLPENR_I2C2LPEN = 0x400000;  // I2C2 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t C1_APB1LLPENR_I2C3LPEN = 0x800000;  // I2C3 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t C1_APB1LLPENR_HDMICECLPEN = 0x8000000;// HDMI-CEC Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t C1_APB1LLPENR_DAC12LPEN = 0x20000000;// DAC1/2 peripheral clock enable during CSleep mode
    static constexpr uint32_t C1_APB1LLPENR_USART7LPEN = 0x40000000;// USART7 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t C1_APB1LLPENR_USART8LPEN = 0x80000000;// USART8 Peripheral Clocks Enable During CSleep Mode
    static const uint32_t C1_APB1LLPENR_RESET_VALUE = 0x0;

    static constexpr uint32_t C1_APB1HLPENR_CRSLPEN = 0x2;        // Clock Recovery System peripheral clock enable during CSleep mode
    static constexpr uint32_t C1_APB1HLPENR_SWPLPEN = 0x4;        // SWPMI Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t C1_APB1HLPENR_OPAMPLPEN = 0x10;     // OPAMP peripheral clock enable during CSleep mode
    static constexpr uint32_t C1_APB1HLPENR_MDIOSLPEN = 0x20;     // MDIOS peripheral clock enable during CSleep mode
    static constexpr uint32_t C1_APB1HLPENR_FDCANLPEN = 0x100;    // FDCAN Peripheral Clocks Enable During CSleep Mode
    static const uint32_t C1_APB1HLPENR_RESET_VALUE = 0x0;

    static constexpr uint32_t C1_APB2LPENR_TIM1LPEN = 0x1;       // TIM1 peripheral clock enable during CSleep mode
    static constexpr uint32_t C1_APB2LPENR_TIM8LPEN = 0x2;       // TIM8 peripheral clock enable during CSleep mode
    static constexpr uint32_t C1_APB2LPENR_USART1LPEN = 0x10;    // USART1 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t C1_APB2LPENR_USART6LPEN = 0x20;    // USART6 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t C1_APB2LPENR_SPI1LPEN = 0x1000;    // SPI1 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t C1_APB2LPENR_SPI4LPEN = 0x2000;    // SPI4 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t C1_APB2LPENR_TIM15LPEN = 0x10000;  // TIM15 peripheral clock enable during CSleep mode
    static constexpr uint32_t C1_APB2LPENR_TIM16LPEN = 0x20000;  // TIM16 peripheral clock enable during CSleep mode
    static constexpr uint32_t C1_APB2LPENR_TIM17LPEN = 0x40000;  // TIM17 peripheral clock enable during CSleep mode
    static constexpr uint32_t C1_APB2LPENR_SPI5LPEN = 0x100000;  // SPI5 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t C1_APB2LPENR_SAI1LPEN = 0x400000;  // SAI1 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t C1_APB2LPENR_SAI2LPEN = 0x800000;  // SAI2 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t C1_APB2LPENR_SAI3LPEN = 0x1000000; // SAI3 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t C1_APB2LPENR_DFSDM1LPEN = 0x10000000;// DFSDM1 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t C1_APB2LPENR_HRTIMLPEN = 0x20000000;// HRTIM peripheral clock enable during CSleep mode
    static const uint32_t C1_APB2LPENR_RESET_VALUE = 0x0;

    static constexpr uint32_t C1_APB4LPENR_SYSCFGLPEN = 0x2;     // SYSCFG peripheral clock enable during CSleep mode
    static constexpr uint32_t C1_APB4LPENR_LPUART1LPEN = 0x8;    // LPUART1 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t C1_APB4LPENR_SPI6LPEN = 0x20;      // SPI6 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t C1_APB4LPENR_I2C4LPEN = 0x80;      // I2C4 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t C1_APB4LPENR_LPTIM2LPEN = 0x200;   // LPTIM2 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t C1_APB4LPENR_LPTIM3LPEN = 0x400;   // LPTIM3 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t C1_APB4LPENR_LPTIM4LPEN = 0x800;   // LPTIM4 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t C1_APB4LPENR_LPTIM5LPEN = 0x1000;  // LPTIM5 Peripheral Clocks Enable During CSleep Mode
    static constexpr uint32_t C1_APB4LPENR_COMP12LPEN = 0x4000;  // COMP1/2 peripheral clock enable during CSleep mode
    static constexpr uint32_t C1_APB4LPENR_VREFLPEN = 0x8000;    // VREF peripheral clock enable during CSleep mode
    static constexpr uint32_t C1_APB4LPENR_RTCAPBLPEN = 0x10000; // RTC APB Clock Enable During CSleep Mode
    static constexpr uint32_t C1_APB4LPENR_SAI4LPEN = 0x200000;  // SAI4 Peripheral Clocks Enable During CSleep Mode
    static const uint32_t C1_APB4LPENR_RESET_VALUE = 0x0;

    static constexpr uint8_t RCC = 5; // RCC global interrupt
};

static rcc_t& RCC = *reinterpret_cast<rcc_t*>(0x58024400);

#define HAVE_PERIPHERAL_RCC


////
//
//    Low power timer
//
////

struct lptim1_t
{
    volatile uint32_t    ISR;                  // [Read-only] Interrupt and Status Register
    volatile uint32_t    ICR;                  // [Write-only] Interrupt Clear Register
    volatile uint32_t    IER;                  // [Read-write] Interrupt Enable Register
    volatile uint32_t    CFGR;                 // [Read-write] Configuration Register
    volatile uint32_t    CR;                   // [Read-write] Control Register
    volatile uint32_t    CMP;                  // [Read-write] Compare Register
    volatile uint32_t    ARR;                  // [Read-write] Autoreload Register
    volatile uint32_t    CNT;                  // [Read-only] Counter Register
    reserved_t<1>        _0;
    volatile uint32_t    CFGR2;                // [Read-write] LPTIM configuration register 2

    static constexpr uint32_t ISR_DOWN = 0x40;          // Counter direction change up to down
    static constexpr uint32_t ISR_UP = 0x20;            // Counter direction change down to up
    static constexpr uint32_t ISR_ARROK = 0x10;         // Autoreload register update OK
    static constexpr uint32_t ISR_CMPOK = 0x8;          // Compare register update OK
    static constexpr uint32_t ISR_EXTTRIG = 0x4;        // External trigger edge event
    static constexpr uint32_t ISR_ARRM = 0x2;           // Autoreload match
    static constexpr uint32_t ISR_CMPM = 0x1;           // Compare match
    static const uint32_t ISR_RESET_VALUE = 0x0;

    static constexpr uint32_t ICR_DOWNCF = 0x40;        // Direction change to down Clear Flag
    static constexpr uint32_t ICR_UPCF = 0x20;          // Direction change to UP Clear Flag
    static constexpr uint32_t ICR_ARROKCF = 0x10;       // Autoreload register update OK Clear Flag
    static constexpr uint32_t ICR_CMPOKCF = 0x8;        // Compare register update OK Clear Flag
    static constexpr uint32_t ICR_EXTTRIGCF = 0x4;      // External trigger valid edge Clear Flag
    static constexpr uint32_t ICR_ARRMCF = 0x2;         // Autoreload match Clear Flag
    static constexpr uint32_t ICR_CMPMCF = 0x1;         // compare match Clear Flag
    static const uint32_t ICR_RESET_VALUE = 0x0;

    static constexpr uint32_t IER_DOWNIE = 0x40;        // Direction change to down Interrupt Enable
    static constexpr uint32_t IER_UPIE = 0x20;          // Direction change to UP Interrupt Enable
    static constexpr uint32_t IER_ARROKIE = 0x10;       // Autoreload register update OK Interrupt Enable
    static constexpr uint32_t IER_CMPOKIE = 0x8;        // Compare register update OK Interrupt Enable
    static constexpr uint32_t IER_EXTTRIGIE = 0x4;      // External trigger valid edge Interrupt Enable
    static constexpr uint32_t IER_ARRMIE = 0x2;         // Autoreload match Interrupt Enable
    static constexpr uint32_t IER_CMPMIE = 0x1;         // Compare match Interrupt Enable
    static const uint32_t IER_RESET_VALUE = 0x0;

    static constexpr uint32_t CFGR_ENC = 0x1000000;      // Encoder mode enable
    static constexpr uint32_t CFGR_COUNTMODE = 0x800000; // counter mode enabled
    static constexpr uint32_t CFGR_PRELOAD = 0x400000;   // Registers update mode
    static constexpr uint32_t CFGR_WAVPOL = 0x200000;    // Waveform shape polarity
    static constexpr uint32_t CFGR_WAVE = 0x100000;      // Waveform shape
    static constexpr uint32_t CFGR_TIMOUT = 0x80000;     // Timeout enable
    template<uint32_t X>
    static constexpr uint32_t CFGR_TRIGEN =              // Trigger enable and polarity (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_TRIGSEL =             // Trigger selector (3 bits)
        bit_field_t<13, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_PRESC =               // Clock prescaler (3 bits)
        bit_field_t<9, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_TRGFLT =              // Configurable digital filter for trigger (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_CKFLT =               // Configurable digital filter for external clock (2 bits)
        bit_field_t<3, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_CKPOL =               // Clock Polarity (2 bits)
        bit_field_t<1, 0x3>::value<X>();
    static constexpr uint32_t CFGR_CKSEL = 0x1;          // Clock selector
    static const uint32_t CFGR_RESET_VALUE = 0x0;

    static constexpr uint32_t CR_ENABLE = 0x1;         // LPTIM Enable
    static constexpr uint32_t CR_SNGSTRT = 0x2;        // LPTIM start in single mode
    static constexpr uint32_t CR_CNTSTRT = 0x4;        // Timer start in continuous mode
    static constexpr uint32_t CR_COUNTRST = 0x8;       // Counter reset
    static constexpr uint32_t CR_RSTARE = 0x10;        // Reset after read enable
    static const uint32_t CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CMP_CMP =                 // Compare value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CMP_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ARR_ARR =                 // Auto reload value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t ARR_RESET_VALUE = 0x1;

    template<uint32_t X>
    static constexpr uint32_t CNT_CNT =                 // Counter value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CNT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CFGR2_IN1SEL =              // LPTIM Input 1 selection (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR2_IN2SEL =              // LPTIM Input 2 selection (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static const uint32_t CFGR2_RESET_VALUE = 0x0;

    static constexpr uint8_t LPTIM1 = 93; // LPTIM1 global interrupt
};

static lptim1_t& LPTIM1 = *reinterpret_cast<lptim1_t*>(0x40002400);

#define HAVE_PERIPHERAL_LPTIM1


////
//
//    Low power timer
//
////

struct lptim2_t
{
    volatile uint32_t    ISR;                  // [Read-only] Interrupt and Status Register
    volatile uint32_t    ICR;                  // [Write-only] Interrupt Clear Register
    volatile uint32_t    IER;                  // [Read-write] Interrupt Enable Register
    volatile uint32_t    CFGR;                 // [Read-write] Configuration Register
    volatile uint32_t    CR;                   // [Read-write] Control Register
    volatile uint32_t    CMP;                  // [Read-write] Compare Register
    volatile uint32_t    ARR;                  // [Read-write] Autoreload Register
    volatile uint32_t    CNT;                  // [Read-only] Counter Register
    reserved_t<1>        _0;
    volatile uint32_t    CFGR2;                // [Read-write] LPTIM configuration register 2

    static constexpr uint32_t ISR_DOWN = 0x40;          // Counter direction change up to down
    static constexpr uint32_t ISR_UP = 0x20;            // Counter direction change down to up
    static constexpr uint32_t ISR_ARROK = 0x10;         // Autoreload register update OK
    static constexpr uint32_t ISR_CMPOK = 0x8;          // Compare register update OK
    static constexpr uint32_t ISR_EXTTRIG = 0x4;        // External trigger edge event
    static constexpr uint32_t ISR_ARRM = 0x2;           // Autoreload match
    static constexpr uint32_t ISR_CMPM = 0x1;           // Compare match
    static const uint32_t ISR_RESET_VALUE = 0x0;

    static constexpr uint32_t ICR_DOWNCF = 0x40;        // Direction change to down Clear Flag
    static constexpr uint32_t ICR_UPCF = 0x20;          // Direction change to UP Clear Flag
    static constexpr uint32_t ICR_ARROKCF = 0x10;       // Autoreload register update OK Clear Flag
    static constexpr uint32_t ICR_CMPOKCF = 0x8;        // Compare register update OK Clear Flag
    static constexpr uint32_t ICR_EXTTRIGCF = 0x4;      // External trigger valid edge Clear Flag
    static constexpr uint32_t ICR_ARRMCF = 0x2;         // Autoreload match Clear Flag
    static constexpr uint32_t ICR_CMPMCF = 0x1;         // compare match Clear Flag
    static const uint32_t ICR_RESET_VALUE = 0x0;

    static constexpr uint32_t IER_DOWNIE = 0x40;        // Direction change to down Interrupt Enable
    static constexpr uint32_t IER_UPIE = 0x20;          // Direction change to UP Interrupt Enable
    static constexpr uint32_t IER_ARROKIE = 0x10;       // Autoreload register update OK Interrupt Enable
    static constexpr uint32_t IER_CMPOKIE = 0x8;        // Compare register update OK Interrupt Enable
    static constexpr uint32_t IER_EXTTRIGIE = 0x4;      // External trigger valid edge Interrupt Enable
    static constexpr uint32_t IER_ARRMIE = 0x2;         // Autoreload match Interrupt Enable
    static constexpr uint32_t IER_CMPMIE = 0x1;         // Compare match Interrupt Enable
    static const uint32_t IER_RESET_VALUE = 0x0;

    static constexpr uint32_t CFGR_ENC = 0x1000000;      // Encoder mode enable
    static constexpr uint32_t CFGR_COUNTMODE = 0x800000; // counter mode enabled
    static constexpr uint32_t CFGR_PRELOAD = 0x400000;   // Registers update mode
    static constexpr uint32_t CFGR_WAVPOL = 0x200000;    // Waveform shape polarity
    static constexpr uint32_t CFGR_WAVE = 0x100000;      // Waveform shape
    static constexpr uint32_t CFGR_TIMOUT = 0x80000;     // Timeout enable
    template<uint32_t X>
    static constexpr uint32_t CFGR_TRIGEN =              // Trigger enable and polarity (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_TRIGSEL =             // Trigger selector (3 bits)
        bit_field_t<13, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_PRESC =               // Clock prescaler (3 bits)
        bit_field_t<9, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_TRGFLT =              // Configurable digital filter for trigger (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_CKFLT =               // Configurable digital filter for external clock (2 bits)
        bit_field_t<3, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_CKPOL =               // Clock Polarity (2 bits)
        bit_field_t<1, 0x3>::value<X>();
    static constexpr uint32_t CFGR_CKSEL = 0x1;          // Clock selector
    static const uint32_t CFGR_RESET_VALUE = 0x0;

    static constexpr uint32_t CR_ENABLE = 0x1;         // LPTIM Enable
    static constexpr uint32_t CR_SNGSTRT = 0x2;        // LPTIM start in single mode
    static constexpr uint32_t CR_CNTSTRT = 0x4;        // Timer start in continuous mode
    static constexpr uint32_t CR_COUNTRST = 0x8;       // Counter reset
    static constexpr uint32_t CR_RSTARE = 0x10;        // Reset after read enable
    static const uint32_t CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CMP_CMP =                 // Compare value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CMP_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ARR_ARR =                 // Auto reload value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t ARR_RESET_VALUE = 0x1;

    template<uint32_t X>
    static constexpr uint32_t CNT_CNT =                 // Counter value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CNT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CFGR2_IN1SEL =              // LPTIM Input 1 selection (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR2_IN2SEL =              // LPTIM Input 2 selection (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static const uint32_t CFGR2_RESET_VALUE = 0x0;

    static constexpr uint8_t LPTIM2 = 138; // LPTIM2 timer interrupt
};

static lptim2_t& LPTIM2 = *reinterpret_cast<lptim2_t*>(0x58002400);

#define HAVE_PERIPHERAL_LPTIM2


////
//
//    Low power timer
//
////

struct lptim3_t
{
    volatile uint32_t    ISR;                  // [Read-only] Interrupt and Status Register
    volatile uint32_t    ICR;                  // [Write-only] Interrupt Clear Register
    volatile uint32_t    IER;                  // [Read-write] Interrupt Enable Register
    volatile uint32_t    CFGR;                 // [Read-write] Configuration Register
    volatile uint32_t    CR;                   // [Read-write] Control Register
    volatile uint32_t    CMP;                  // [Read-write] Compare Register
    volatile uint32_t    ARR;                  // [Read-write] Autoreload Register
    volatile uint32_t    CNT;                  // [Read-only] Counter Register
    reserved_t<1>        _0;
    volatile uint32_t    CFGR2;                // [Read-write] LPTIM configuration register 2

    static constexpr uint32_t ISR_DOWN = 0x40;          // Counter direction change up to down
    static constexpr uint32_t ISR_UP = 0x20;            // Counter direction change down to up
    static constexpr uint32_t ISR_ARROK = 0x10;         // Autoreload register update OK
    static constexpr uint32_t ISR_CMPOK = 0x8;          // Compare register update OK
    static constexpr uint32_t ISR_EXTTRIG = 0x4;        // External trigger edge event
    static constexpr uint32_t ISR_ARRM = 0x2;           // Autoreload match
    static constexpr uint32_t ISR_CMPM = 0x1;           // Compare match
    static const uint32_t ISR_RESET_VALUE = 0x0;

    static constexpr uint32_t ICR_DOWNCF = 0x40;        // Direction change to down Clear Flag
    static constexpr uint32_t ICR_UPCF = 0x20;          // Direction change to UP Clear Flag
    static constexpr uint32_t ICR_ARROKCF = 0x10;       // Autoreload register update OK Clear Flag
    static constexpr uint32_t ICR_CMPOKCF = 0x8;        // Compare register update OK Clear Flag
    static constexpr uint32_t ICR_EXTTRIGCF = 0x4;      // External trigger valid edge Clear Flag
    static constexpr uint32_t ICR_ARRMCF = 0x2;         // Autoreload match Clear Flag
    static constexpr uint32_t ICR_CMPMCF = 0x1;         // compare match Clear Flag
    static const uint32_t ICR_RESET_VALUE = 0x0;

    static constexpr uint32_t IER_DOWNIE = 0x40;        // Direction change to down Interrupt Enable
    static constexpr uint32_t IER_UPIE = 0x20;          // Direction change to UP Interrupt Enable
    static constexpr uint32_t IER_ARROKIE = 0x10;       // Autoreload register update OK Interrupt Enable
    static constexpr uint32_t IER_CMPOKIE = 0x8;        // Compare register update OK Interrupt Enable
    static constexpr uint32_t IER_EXTTRIGIE = 0x4;      // External trigger valid edge Interrupt Enable
    static constexpr uint32_t IER_ARRMIE = 0x2;         // Autoreload match Interrupt Enable
    static constexpr uint32_t IER_CMPMIE = 0x1;         // Compare match Interrupt Enable
    static const uint32_t IER_RESET_VALUE = 0x0;

    static constexpr uint32_t CFGR_ENC = 0x1000000;      // Encoder mode enable
    static constexpr uint32_t CFGR_COUNTMODE = 0x800000; // counter mode enabled
    static constexpr uint32_t CFGR_PRELOAD = 0x400000;   // Registers update mode
    static constexpr uint32_t CFGR_WAVPOL = 0x200000;    // Waveform shape polarity
    static constexpr uint32_t CFGR_WAVE = 0x100000;      // Waveform shape
    static constexpr uint32_t CFGR_TIMOUT = 0x80000;     // Timeout enable
    template<uint32_t X>
    static constexpr uint32_t CFGR_TRIGEN =              // Trigger enable and polarity (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_TRIGSEL =             // Trigger selector (3 bits)
        bit_field_t<13, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_PRESC =               // Clock prescaler (3 bits)
        bit_field_t<9, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_TRGFLT =              // Configurable digital filter for trigger (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_CKFLT =               // Configurable digital filter for external clock (2 bits)
        bit_field_t<3, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_CKPOL =               // Clock Polarity (2 bits)
        bit_field_t<1, 0x3>::value<X>();
    static constexpr uint32_t CFGR_CKSEL = 0x1;          // Clock selector
    static const uint32_t CFGR_RESET_VALUE = 0x0;

    static constexpr uint32_t CR_ENABLE = 0x1;         // LPTIM Enable
    static constexpr uint32_t CR_SNGSTRT = 0x2;        // LPTIM start in single mode
    static constexpr uint32_t CR_CNTSTRT = 0x4;        // Timer start in continuous mode
    static constexpr uint32_t CR_COUNTRST = 0x8;       // Counter reset
    static constexpr uint32_t CR_RSTARE = 0x10;        // Reset after read enable
    static const uint32_t CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CMP_CMP =                 // Compare value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CMP_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ARR_ARR =                 // Auto reload value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t ARR_RESET_VALUE = 0x1;

    template<uint32_t X>
    static constexpr uint32_t CNT_CNT =                 // Counter value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CNT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CFGR2_IN1SEL =              // LPTIM Input 1 selection (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t CFGR2_RESET_VALUE = 0x0;

    static constexpr uint8_t LPTIM3 = 139; // LPTIM2 timer interrupt
};

static lptim3_t& LPTIM3 = *reinterpret_cast<lptim3_t*>(0x58002800);

#define HAVE_PERIPHERAL_LPTIM3


////
//
//    Low power timer
//
////

struct lptim4_t
{
    volatile uint32_t    ISR;                  // [Read-only] Interrupt and Status Register
    volatile uint32_t    ICR;                  // [Write-only] Interrupt Clear Register
    volatile uint32_t    IER;                  // [Read-write] Interrupt Enable Register
    volatile uint32_t    CFGR;                 // [Read-write] Configuration Register
    volatile uint32_t    CR;                   // [Read-write] Control Register
    volatile uint32_t    CMP;                  // [Read-write] Compare Register
    volatile uint32_t    ARR;                  // [Read-write] Autoreload Register
    volatile uint32_t    CNT;                  // [Read-only] Counter Register
    reserved_t<1>        _0;
    volatile uint32_t    CFGR2;                // [Read-write] LPTIM configuration register 2

    static constexpr uint32_t ISR_DOWN = 0x40;          // Counter direction change up to down
    static constexpr uint32_t ISR_UP = 0x20;            // Counter direction change down to up
    static constexpr uint32_t ISR_ARROK = 0x10;         // Autoreload register update OK
    static constexpr uint32_t ISR_CMPOK = 0x8;          // Compare register update OK
    static constexpr uint32_t ISR_EXTTRIG = 0x4;        // External trigger edge event
    static constexpr uint32_t ISR_ARRM = 0x2;           // Autoreload match
    static constexpr uint32_t ISR_CMPM = 0x1;           // Compare match
    static const uint32_t ISR_RESET_VALUE = 0x0;

    static constexpr uint32_t ICR_DOWNCF = 0x40;        // Direction change to down Clear Flag
    static constexpr uint32_t ICR_UPCF = 0x20;          // Direction change to UP Clear Flag
    static constexpr uint32_t ICR_ARROKCF = 0x10;       // Autoreload register update OK Clear Flag
    static constexpr uint32_t ICR_CMPOKCF = 0x8;        // Compare register update OK Clear Flag
    static constexpr uint32_t ICR_EXTTRIGCF = 0x4;      // External trigger valid edge Clear Flag
    static constexpr uint32_t ICR_ARRMCF = 0x2;         // Autoreload match Clear Flag
    static constexpr uint32_t ICR_CMPMCF = 0x1;         // compare match Clear Flag
    static const uint32_t ICR_RESET_VALUE = 0x0;

    static constexpr uint32_t IER_DOWNIE = 0x40;        // Direction change to down Interrupt Enable
    static constexpr uint32_t IER_UPIE = 0x20;          // Direction change to UP Interrupt Enable
    static constexpr uint32_t IER_ARROKIE = 0x10;       // Autoreload register update OK Interrupt Enable
    static constexpr uint32_t IER_CMPOKIE = 0x8;        // Compare register update OK Interrupt Enable
    static constexpr uint32_t IER_EXTTRIGIE = 0x4;      // External trigger valid edge Interrupt Enable
    static constexpr uint32_t IER_ARRMIE = 0x2;         // Autoreload match Interrupt Enable
    static constexpr uint32_t IER_CMPMIE = 0x1;         // Compare match Interrupt Enable
    static const uint32_t IER_RESET_VALUE = 0x0;

    static constexpr uint32_t CFGR_ENC = 0x1000000;      // Encoder mode enable
    static constexpr uint32_t CFGR_COUNTMODE = 0x800000; // counter mode enabled
    static constexpr uint32_t CFGR_PRELOAD = 0x400000;   // Registers update mode
    static constexpr uint32_t CFGR_WAVPOL = 0x200000;    // Waveform shape polarity
    static constexpr uint32_t CFGR_WAVE = 0x100000;      // Waveform shape
    static constexpr uint32_t CFGR_TIMOUT = 0x80000;     // Timeout enable
    template<uint32_t X>
    static constexpr uint32_t CFGR_TRIGEN =              // Trigger enable and polarity (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_TRIGSEL =             // Trigger selector (3 bits)
        bit_field_t<13, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_PRESC =               // Clock prescaler (3 bits)
        bit_field_t<9, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_TRGFLT =              // Configurable digital filter for trigger (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_CKFLT =               // Configurable digital filter for external clock (2 bits)
        bit_field_t<3, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_CKPOL =               // Clock Polarity (2 bits)
        bit_field_t<1, 0x3>::value<X>();
    static constexpr uint32_t CFGR_CKSEL = 0x1;          // Clock selector
    static const uint32_t CFGR_RESET_VALUE = 0x0;

    static constexpr uint32_t CR_ENABLE = 0x1;         // LPTIM Enable
    static constexpr uint32_t CR_SNGSTRT = 0x2;        // LPTIM start in single mode
    static constexpr uint32_t CR_CNTSTRT = 0x4;        // Timer start in continuous mode
    static constexpr uint32_t CR_COUNTRST = 0x8;       // Counter reset
    static constexpr uint32_t CR_RSTARE = 0x10;        // Reset after read enable
    static const uint32_t CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CMP_CMP =                 // Compare value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CMP_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ARR_ARR =                 // Auto reload value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t ARR_RESET_VALUE = 0x1;

    template<uint32_t X>
    static constexpr uint32_t CNT_CNT =                 // Counter value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CNT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CFGR2_IN1SEL =              // LPTIM Input 1 selection (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t CFGR2_RESET_VALUE = 0x0;

    static constexpr uint8_t ETH_WKUP = 62; // Ethernet wakeup through EXTI
    static constexpr uint8_t LPTIM4 = 140; // LPTIM2 timer interrupt
};

static lptim4_t& LPTIM4 = *reinterpret_cast<lptim4_t*>(0x58002c00);

#define HAVE_PERIPHERAL_LPTIM4


////
//
//    Low power timer
//
////

struct lptim5_t
{
    volatile uint32_t    ISR;                  // [Read-only] Interrupt and Status Register
    volatile uint32_t    ICR;                  // [Write-only] Interrupt Clear Register
    volatile uint32_t    IER;                  // [Read-write] Interrupt Enable Register
    volatile uint32_t    CFGR;                 // [Read-write] Configuration Register
    volatile uint32_t    CR;                   // [Read-write] Control Register
    volatile uint32_t    CMP;                  // [Read-write] Compare Register
    volatile uint32_t    ARR;                  // [Read-write] Autoreload Register
    volatile uint32_t    CNT;                  // [Read-only] Counter Register
    reserved_t<1>        _0;
    volatile uint32_t    CFGR2;                // [Read-write] LPTIM configuration register 2

    static constexpr uint32_t ISR_DOWN = 0x40;          // Counter direction change up to down
    static constexpr uint32_t ISR_UP = 0x20;            // Counter direction change down to up
    static constexpr uint32_t ISR_ARROK = 0x10;         // Autoreload register update OK
    static constexpr uint32_t ISR_CMPOK = 0x8;          // Compare register update OK
    static constexpr uint32_t ISR_EXTTRIG = 0x4;        // External trigger edge event
    static constexpr uint32_t ISR_ARRM = 0x2;           // Autoreload match
    static constexpr uint32_t ISR_CMPM = 0x1;           // Compare match
    static const uint32_t ISR_RESET_VALUE = 0x0;

    static constexpr uint32_t ICR_DOWNCF = 0x40;        // Direction change to down Clear Flag
    static constexpr uint32_t ICR_UPCF = 0x20;          // Direction change to UP Clear Flag
    static constexpr uint32_t ICR_ARROKCF = 0x10;       // Autoreload register update OK Clear Flag
    static constexpr uint32_t ICR_CMPOKCF = 0x8;        // Compare register update OK Clear Flag
    static constexpr uint32_t ICR_EXTTRIGCF = 0x4;      // External trigger valid edge Clear Flag
    static constexpr uint32_t ICR_ARRMCF = 0x2;         // Autoreload match Clear Flag
    static constexpr uint32_t ICR_CMPMCF = 0x1;         // compare match Clear Flag
    static const uint32_t ICR_RESET_VALUE = 0x0;

    static constexpr uint32_t IER_DOWNIE = 0x40;        // Direction change to down Interrupt Enable
    static constexpr uint32_t IER_UPIE = 0x20;          // Direction change to UP Interrupt Enable
    static constexpr uint32_t IER_ARROKIE = 0x10;       // Autoreload register update OK Interrupt Enable
    static constexpr uint32_t IER_CMPOKIE = 0x8;        // Compare register update OK Interrupt Enable
    static constexpr uint32_t IER_EXTTRIGIE = 0x4;      // External trigger valid edge Interrupt Enable
    static constexpr uint32_t IER_ARRMIE = 0x2;         // Autoreload match Interrupt Enable
    static constexpr uint32_t IER_CMPMIE = 0x1;         // Compare match Interrupt Enable
    static const uint32_t IER_RESET_VALUE = 0x0;

    static constexpr uint32_t CFGR_ENC = 0x1000000;      // Encoder mode enable
    static constexpr uint32_t CFGR_COUNTMODE = 0x800000; // counter mode enabled
    static constexpr uint32_t CFGR_PRELOAD = 0x400000;   // Registers update mode
    static constexpr uint32_t CFGR_WAVPOL = 0x200000;    // Waveform shape polarity
    static constexpr uint32_t CFGR_WAVE = 0x100000;      // Waveform shape
    static constexpr uint32_t CFGR_TIMOUT = 0x80000;     // Timeout enable
    template<uint32_t X>
    static constexpr uint32_t CFGR_TRIGEN =              // Trigger enable and polarity (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_TRIGSEL =             // Trigger selector (3 bits)
        bit_field_t<13, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_PRESC =               // Clock prescaler (3 bits)
        bit_field_t<9, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_TRGFLT =              // Configurable digital filter for trigger (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_CKFLT =               // Configurable digital filter for external clock (2 bits)
        bit_field_t<3, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_CKPOL =               // Clock Polarity (2 bits)
        bit_field_t<1, 0x3>::value<X>();
    static constexpr uint32_t CFGR_CKSEL = 0x1;          // Clock selector
    static const uint32_t CFGR_RESET_VALUE = 0x0;

    static constexpr uint32_t CR_ENABLE = 0x1;         // LPTIM Enable
    static constexpr uint32_t CR_SNGSTRT = 0x2;        // LPTIM start in single mode
    static constexpr uint32_t CR_CNTSTRT = 0x4;        // Timer start in continuous mode
    static constexpr uint32_t CR_COUNTRST = 0x8;       // Counter reset
    static constexpr uint32_t CR_RSTARE = 0x10;        // Reset after read enable
    static const uint32_t CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CMP_CMP =                 // Compare value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CMP_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ARR_ARR =                 // Auto reload value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t ARR_RESET_VALUE = 0x1;

    template<uint32_t X>
    static constexpr uint32_t CNT_CNT =                 // Counter value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CNT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CFGR2_IN1SEL =              // LPTIM Input 1 selection (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t CFGR2_RESET_VALUE = 0x0;

    static constexpr uint8_t LPTIM5 = 141; // LPTIM2 timer interrupt
};

static lptim5_t& LPTIM5 = *reinterpret_cast<lptim5_t*>(0x58003000);

#define HAVE_PERIPHERAL_LPTIM5


////
//
//    LPUART1
//
////

struct lpuart1_t
{
    volatile uint32_t    CR1;                  // [Read-write] Control register 1
    volatile uint32_t    CR2;                  // [Read-write] Control register 2
    volatile uint32_t    CR3;                  // [Read-write] Control register 3
    volatile uint32_t    BRR;                  // [Read-write] Baud rate register
    volatile uint32_t    GTPR;                 // [Read-write] Guard time and prescaler register
    volatile uint32_t    RTOR;                 // [Read-write] Receiver timeout register
    volatile uint32_t    RQR;                  // [Write-only] Request register
    volatile uint32_t    ISR;                  // [Read-only] Interrupt &amp; status register
    volatile uint32_t    ICR;                  // [Write-only] Interrupt flag clear register
    volatile uint32_t    RDR;                  // [Read-only] Receive data register
    volatile uint32_t    TDR;                  // [Read-write] Transmit data register
    volatile uint32_t    PRESC;                // [Read-write] Prescaler register

    static constexpr uint32_t CR1_RXFFIE = 0x80000000;  // RXFIFO Full interrupt enable
    static constexpr uint32_t CR1_TXFEIE = 0x40000000;  // TXFIFO empty interrupt enable
    static constexpr uint32_t CR1_FIFOEN = 0x20000000;  // FIFO mode enable
    static constexpr uint32_t CR1_M1 = 0x10000000;      // Word length
    template<uint32_t X>
    static constexpr uint32_t CR1_DEAT =                // Driver Enable assertion time (5 bits)
        bit_field_t<21, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR1_DEDT =                // Driver Enable deassertion time (5 bits)
        bit_field_t<16, 0x1f>::value<X>();
    static constexpr uint32_t CR1_CMIE = 0x4000;        // Character match interrupt enable
    static constexpr uint32_t CR1_MME = 0x2000;         // Mute mode enable
    static constexpr uint32_t CR1_M0 = 0x1000;          // Word length
    static constexpr uint32_t CR1_WAKE = 0x800;         // Receiver wakeup method
    static constexpr uint32_t CR1_PCE = 0x400;          // Parity control enable
    static constexpr uint32_t CR1_PS = 0x200;           // Parity selection
    static constexpr uint32_t CR1_PEIE = 0x100;         // PE interrupt enable
    static constexpr uint32_t CR1_TXEIE = 0x80;         // interrupt enable
    static constexpr uint32_t CR1_TCIE = 0x40;          // Transmission complete interrupt enable
    static constexpr uint32_t CR1_RXNEIE = 0x20;        // RXNE interrupt enable
    static constexpr uint32_t CR1_IDLEIE = 0x10;        // IDLE interrupt enable
    static constexpr uint32_t CR1_TE = 0x8;             // Transmitter enable
    static constexpr uint32_t CR1_RE = 0x4;             // Receiver enable
    static constexpr uint32_t CR1_UESM = 0x2;           // USART enable in Stop mode
    static constexpr uint32_t CR1_UE = 0x1;             // USART enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CR2_ADD =                 // Address of the USART node (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static constexpr uint32_t CR2_MSBFIRST = 0x80000;   // Most significant bit first
    static constexpr uint32_t CR2_DATAINV = 0x40000;    // Binary data inversion
    static constexpr uint32_t CR2_TXINV = 0x20000;      // TX pin active level inversion
    static constexpr uint32_t CR2_RXINV = 0x10000;      // RX pin active level inversion
    static constexpr uint32_t CR2_SWAP = 0x8000;        // Swap TX/RX pins
    template<uint32_t X>
    static constexpr uint32_t CR2_STOP =                // STOP bits (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    static constexpr uint32_t CR2_ADDM7 = 0x10;         // 7-bit Address Detection/4-bit Address Detection
    static const uint32_t CR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CR3_TXFTCFG =             // TXFIFO threshold configuration (3 bits)
        bit_field_t<29, 0x7>::value<X>();
    static constexpr uint32_t CR3_RXFTIE = 0x10000000;  // RXFIFO threshold interrupt enable
    template<uint32_t X>
    static constexpr uint32_t CR3_RXFTCFG =             // Receive FIFO threshold configuration (3 bits)
        bit_field_t<25, 0x7>::value<X>();
    static constexpr uint32_t CR3_TXFTIE = 0x800000;    // TXFIFO threshold interrupt enable
    static constexpr uint32_t CR3_WUFIE = 0x400000;     // Wakeup from Stop mode interrupt enable
    template<uint32_t X>
    static constexpr uint32_t CR3_WUS =                 // Wakeup from Stop mode interrupt flag selection (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    static constexpr uint32_t CR3_DEP = 0x8000;         // Driver enable polarity selection
    static constexpr uint32_t CR3_DEM = 0x4000;         // Driver enable mode
    static constexpr uint32_t CR3_DDRE = 0x2000;        // DMA Disable on Reception Error
    static constexpr uint32_t CR3_OVRDIS = 0x1000;      // Overrun Disable
    static constexpr uint32_t CR3_CTSIE = 0x400;        // CTS interrupt enable
    static constexpr uint32_t CR3_CTSE = 0x200;         // CTS enable
    static constexpr uint32_t CR3_RTSE = 0x100;         // RTS enable
    static constexpr uint32_t CR3_DMAT = 0x80;          // DMA enable transmitter
    static constexpr uint32_t CR3_DMAR = 0x40;          // DMA enable receiver
    static constexpr uint32_t CR3_HDSEL = 0x8;          // Half-duplex selection
    static constexpr uint32_t CR3_EIE = 0x1;            // Error interrupt enable
    static const uint32_t CR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BRR_BRR =                 // BRR (20 bits)
        bit_field_t<0, 0xfffff>::value<X>();
    static const uint32_t BRR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t GTPR_GT =                  // Guard time value (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GTPR_PSC =                 // Prescaler value (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t GTPR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RTOR_BLEN =                // Block Length (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RTOR_RTO =                 // Receiver timeout value (24 bits)
        bit_field_t<0, 0xffffff>::value<X>();
    static const uint32_t RTOR_RESET_VALUE = 0x0;

    static constexpr uint32_t RQR_TXFRQ = 0x10;         // Transmit data flush request
    static constexpr uint32_t RQR_RXFRQ = 0x8;          // Receive data flush request
    static constexpr uint32_t RQR_MMRQ = 0x4;           // Mute mode request
    static constexpr uint32_t RQR_SBKRQ = 0x2;          // Send break request
    static constexpr uint32_t RQR_ABRRQ = 0x1;          // Auto baud rate request
    static const uint32_t RQR_RESET_VALUE = 0x0;

    static constexpr uint32_t ISR_TXFT = 0x8000000;     // TXFIFO threshold flag
    static constexpr uint32_t ISR_RXFT = 0x4000000;     // RXFIFO threshold flag
    static constexpr uint32_t ISR_RXFF = 0x1000000;     // RXFIFO Full
    static constexpr uint32_t ISR_TXFE = 0x800000;      // TXFIFO Empty
    static constexpr uint32_t ISR_REACK = 0x400000;     // REACK
    static constexpr uint32_t ISR_TEACK = 0x200000;     // TEACK
    static constexpr uint32_t ISR_WUF = 0x100000;       // WUF
    static constexpr uint32_t ISR_RWU = 0x80000;        // RWU
    static constexpr uint32_t ISR_SBKF = 0x40000;       // SBKF
    static constexpr uint32_t ISR_CMF = 0x20000;        // CMF
    static constexpr uint32_t ISR_BUSY = 0x10000;       // BUSY
    static constexpr uint32_t ISR_CTS = 0x400;          // CTS
    static constexpr uint32_t ISR_CTSIF = 0x200;        // CTSIF
    static constexpr uint32_t ISR_TXE = 0x80;           // TXE
    static constexpr uint32_t ISR_TC = 0x40;            // TC
    static constexpr uint32_t ISR_RXNE = 0x20;          // RXNE
    static constexpr uint32_t ISR_IDLE = 0x10;          // IDLE
    static constexpr uint32_t ISR_ORE = 0x8;            // ORE
    static constexpr uint32_t ISR_NE = 0x4;             // NE
    static constexpr uint32_t ISR_FE = 0x2;             // FE
    static constexpr uint32_t ISR_PE = 0x1;             // PE
    static const uint32_t ISR_RESET_VALUE = 0xc0;

    static constexpr uint32_t ICR_WUCF = 0x100000;      // Wakeup from Stop mode clear flag
    static constexpr uint32_t ICR_CMCF = 0x20000;       // Character match clear flag
    static constexpr uint32_t ICR_CTSCF = 0x200;        // CTS clear flag
    static constexpr uint32_t ICR_TCCF = 0x40;          // Transmission complete clear flag
    static constexpr uint32_t ICR_IDLECF = 0x10;        // Idle line detected clear flag
    static constexpr uint32_t ICR_ORECF = 0x8;          // Overrun error clear flag
    static constexpr uint32_t ICR_NCF = 0x4;            // Noise detected clear flag
    static constexpr uint32_t ICR_FECF = 0x2;           // Framing error clear flag
    static constexpr uint32_t ICR_PECF = 0x1;           // Parity error clear flag
    static const uint32_t ICR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RDR_RDR =                 // Receive data value (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static const uint32_t RDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDR_TDR =                 // Transmit data value (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static const uint32_t TDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PRESC_PRESCALER =           // Clock prescaler (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t PRESC_RESET_VALUE = 0x0;

    static constexpr uint8_t LPUART = 142; // LPUART global interrupt
};

static lpuart1_t& LPUART1 = *reinterpret_cast<lpuart1_t*>(0x58000c00);

#define HAVE_PERIPHERAL_LPUART1


////
//
//    System configuration controller
//
////

struct syscfg_t
{
    volatile uint32_t    PMCR;                 // [Read-write] peripheral mode configuration register
    volatile uint32_t    EXTICR1;              // [Read-write] external interrupt configuration register 1
    volatile uint32_t    EXTICR2;              // [Read-write] external interrupt configuration register 2
    volatile uint32_t    EXTICR3;              // [Read-write] external interrupt configuration register 3
    volatile uint32_t    EXTICR4;              // [Read-write] external interrupt configuration register 4
    reserved_t<2>        _0;
    volatile uint32_t    CCCSR;                // [Read-write] compensation cell control/status register
    volatile uint32_t    CCVR;                 // [Read-only] SYSCFG compensation cell value register
    volatile uint32_t    CCCR;                 // [Read-write] SYSCFG compensation cell code register
    volatile uint32_t    PWRCR;                // [Read-write] SYSCFG power control register
    reserved_t<61>       _1;
    volatile uint32_t    PKGR;                 // [Read-only] SYSCFG package register
    reserved_t<118>      _2;
    volatile uint32_t    UR0;                  // [Read-only] SYSCFG user register 0
    reserved_t<1>        _3;
    volatile uint32_t    UR2;                  // [Read-write] SYSCFG user register 2
    volatile uint32_t    UR3;                  // [Read-write] SYSCFG user register 3
    volatile uint32_t    UR4;                  // [Read-only] SYSCFG user register 4
    volatile uint32_t    UR5;                  // [Read-only] SYSCFG user register 5
    volatile uint32_t    UR6;                  // [Read-only] SYSCFG user register 6
    volatile uint32_t    UR7;                  // [Read-only] SYSCFG user register 7
    volatile uint32_t    UR8;                  // [Read-only] SYSCFG user register 8
    volatile uint32_t    UR9;                  // [Read-only] SYSCFG user register 9
    volatile uint32_t    UR10;                 // [Read-only] SYSCFG user register 10
    volatile uint32_t    UR11;                 // [Read-only] SYSCFG user register 11
    volatile uint32_t    UR12;                 // [Read-only] SYSCFG user register 12
    volatile uint32_t    UR13;                 // [Read-only] SYSCFG user register 13
    volatile uint32_t    UR14;                 // [Read-write] SYSCFG user register 14
    volatile uint32_t    UR15;                 // [Read-only] SYSCFG user register 15
    volatile uint32_t    UR16;                 // [Read-only] SYSCFG user register 16
    volatile uint32_t    UR17;                 // [Read-only] SYSCFG user register 17

    static constexpr uint32_t PMCR_I2C1FMP = 0x1;        // I2C1 Fm+
    static constexpr uint32_t PMCR_I2C2FMP = 0x2;        // I2C2 Fm+
    static constexpr uint32_t PMCR_I2C3FMP = 0x4;        // I2C3 Fm+
    static constexpr uint32_t PMCR_I2C4FMP = 0x8;        // I2C4 Fm+
    static constexpr uint32_t PMCR_PB6FMP = 0x10;        // PB(6) Fm+
    static constexpr uint32_t PMCR_PB7FMP = 0x20;        // PB(7) Fast Mode Plus
    static constexpr uint32_t PMCR_PB8FMP = 0x40;        // PB(8) Fast Mode Plus
    static constexpr uint32_t PMCR_PB9FMP = 0x80;        // PB(9) Fm+
    static constexpr uint32_t PMCR_BOOSTE = 0x100;       // Booster Enable
    static constexpr uint32_t PMCR_BOOSTVDDSEL = 0x200;  // Analog switch supply voltage selection
    template<uint32_t X>
    static constexpr uint32_t PMCR_EPIS =                // Ethernet PHY Interface Selection (3 bits)
        bit_field_t<21, 0x7>::value<X>();
    static constexpr uint32_t PMCR_PA0SO = 0x1000000;    // PA0 Switch Open
    static constexpr uint32_t PMCR_PA1SO = 0x2000000;    // PA1 Switch Open
    static constexpr uint32_t PMCR_PC2SO = 0x4000000;    // PC2 Switch Open
    static constexpr uint32_t PMCR_PC3SO = 0x8000000;    // PC3 Switch Open
    static const uint32_t PMCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t EXTICR1_EXTI3 =               // EXTI x configuration (x = 0 to 3) (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t EXTICR1_EXTI2 =               // EXTI x configuration (x = 0 to 3) (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t EXTICR1_EXTI1 =               // EXTI x configuration (x = 0 to 3) (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t EXTICR1_EXTI0 =               // EXTI x configuration (x = 0 to 3) (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t EXTICR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t EXTICR2_EXTI7 =               // EXTI x configuration (x = 4 to 7) (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t EXTICR2_EXTI6 =               // EXTI x configuration (x = 4 to 7) (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t EXTICR2_EXTI5 =               // EXTI x configuration (x = 4 to 7) (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t EXTICR2_EXTI4 =               // EXTI x configuration (x = 4 to 7) (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t EXTICR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t EXTICR3_EXTI11 =              // EXTI x configuration (x = 8 to 11) (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t EXTICR3_EXTI10 =              // EXTI10 (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t EXTICR3_EXTI9 =               // EXTI x configuration (x = 8 to 11) (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t EXTICR3_EXTI8 =               // EXTI x configuration (x = 8 to 11) (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t EXTICR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t EXTICR4_EXTI15 =              // EXTI x configuration (x = 12 to 15) (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t EXTICR4_EXTI14 =              // EXTI x configuration (x = 12 to 15) (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t EXTICR4_EXTI13 =              // EXTI x configuration (x = 12 to 15) (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t EXTICR4_EXTI12 =              // EXTI x configuration (x = 12 to 15) (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t EXTICR4_RESET_VALUE = 0x0;

    static constexpr uint32_t CCCSR_EN = 0x1;             // enable
    static constexpr uint32_t CCCSR_CS = 0x2;             // Code selection
    static constexpr uint32_t CCCSR_READY = 0x100;        // Compensation cell ready flag
    static constexpr uint32_t CCCSR_HSLV = 0x10000;       // High-speed at low-voltage
    static const uint32_t CCCSR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCVR_NCV =                 // NMOS compensation value (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCVR_PCV =                 // PMOS compensation value (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    static const uint32_t CCVR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCCR_NCC =                 // NMOS compensation code (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCCR_PCC =                 // PMOS compensation code (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    static const uint32_t CCCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PWRCR_ODEN =                // Overdrive enable (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t PWRCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PKGR_PKG =                 // Package (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t PKGR_RESET_VALUE = 0x0;

    static constexpr uint32_t UR0_BKS = 0x1;            // Bank Swap
    template<uint32_t X>
    static constexpr uint32_t UR0_RDP =                 // Readout protection (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static const uint32_t UR0_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t UR2_BORH =                // BOR_LVL Brownout Reset Threshold Level (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t UR2_BOOT_ADD0 =           // Boot Address 0 (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t UR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t UR3_BOOT_ADD1 =           // Boot Address 1 (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t UR3_RESET_VALUE = 0x0;

    static constexpr uint32_t UR4_MEPAD_1 = 0x10000;    // Mass Erase Protected Area Disabled for bank 1
    static const uint32_t UR4_RESET_VALUE = 0x0;

    static constexpr uint32_t UR5_MESAD_1 = 0x1;        // Mass erase secured area disabled for bank 1
    template<uint32_t X>
    static constexpr uint32_t UR5_WRPN_1 =              // Write protection for flash bank 1 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static const uint32_t UR5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t UR6_PA_BEG_1 =            // Protected area start address for bank 1 (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t UR6_PA_END_1 =            // Protected area end address for bank 1 (12 bits)
        bit_field_t<16, 0xfff>::value<X>();
    static const uint32_t UR6_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t UR7_SA_BEG_1 =            // Secured area start address for bank 1 (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t UR7_SA_END_1 =            // Secured area end address for bank 1 (12 bits)
        bit_field_t<16, 0xfff>::value<X>();
    static const uint32_t UR7_RESET_VALUE = 0x0;

    static constexpr uint32_t UR8_MEPAD_2 = 0x1;        // Mass erase protected area disabled for bank 2
    static constexpr uint32_t UR8_MESAD_2 = 0x10000;    // Mass erase secured area disabled for bank 2
    static const uint32_t UR8_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t UR9_WRPN_2 =              // Write protection for flash bank 2 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t UR9_PA_BEG_2 =            // Protected area start address for bank 2 (12 bits)
        bit_field_t<16, 0xfff>::value<X>();
    static const uint32_t UR9_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t UR10_PA_END_2 =            // Protected area end address for bank 2 (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t UR10_SA_BEG_2 =            // Secured area start address for bank 2 (12 bits)
        bit_field_t<16, 0xfff>::value<X>();
    static const uint32_t UR10_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t UR11_SA_END_2 =            // Secured area end address for bank 2 (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static constexpr uint32_t UR11_IWDG1M = 0x10000;     // Independent Watchdog 1 mode
    static const uint32_t UR11_RESET_VALUE = 0x0;

    static constexpr uint32_t UR12_SECURE = 0x10000;     // Secure mode
    static const uint32_t UR12_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t UR13_SDRS =                // Secured DTCM RAM Size (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static constexpr uint32_t UR13_D1SBRST = 0x10000;    // D1 Standby reset
    static const uint32_t UR13_RESET_VALUE = 0x0;

    static constexpr uint32_t UR14_D1STPRST = 0x1;       // D1 Stop Reset
    static const uint32_t UR14_RESET_VALUE = 0x0;

    static constexpr uint32_t UR15_FZIWDGSTB = 0x10000;  // Freeze independent watchdog in Standby mode
    static const uint32_t UR15_RESET_VALUE = 0x0;

    static constexpr uint32_t UR16_FZIWDGSTP = 0x1;      // Freeze independent watchdog in Stop mode
    static constexpr uint32_t UR16_PKP = 0x10000;        // Private key programmed
    static const uint32_t UR16_RESET_VALUE = 0x0;

    static constexpr uint32_t UR17_IO_HSLV = 0x1;        // I/O high speed / low voltage
    static const uint32_t UR17_RESET_VALUE = 0x0;
};

static syscfg_t& SYSCFG = *reinterpret_cast<syscfg_t*>(0x58000400);

#define HAVE_PERIPHERAL_SYSCFG


////
//
//    External interrupt/event controller
//
////

struct exti_t
{
    volatile uint32_t    RTSR1;                // [Read-write] EXTI rising trigger selection register
    volatile uint32_t    FTSR1;                // [Read-write] EXTI falling trigger selection register
    volatile uint32_t    SWIER1;               // [Read-write] EXTI software interrupt event register
    volatile uint32_t    D3PMR1;               // [Read-write] EXTI D3 pending mask register
    volatile uint32_t    D3PCR1L;              // [Read-write] EXTI D3 pending clear selection register low
    volatile uint32_t    D3PCR1H;              // [Read-write] EXTI D3 pending clear selection register high
    reserved_t<2>        _0;
    volatile uint32_t    RTSR2;                // [Read-write] EXTI rising trigger selection register
    volatile uint32_t    FTSR2;                // [Read-write] EXTI falling trigger selection register
    volatile uint32_t    SWIER2;               // [Read-write] EXTI software interrupt event register
    volatile uint32_t    D3PMR2;               // [Read-write] EXTI D3 pending mask register
    volatile uint32_t    D3PCR2L;              // [Read-write] EXTI D3 pending clear selection register low
    volatile uint32_t    D3PCR2H;              // [Read-write] EXTI D3 pending clear selection register high
    reserved_t<2>        _1;
    volatile uint32_t    RTSR3;                // [Read-write] EXTI rising trigger selection register
    volatile uint32_t    FTSR3;                // [Read-write] EXTI falling trigger selection register
    volatile uint32_t    SWIER3;               // [Read-write] EXTI software interrupt event register
    volatile uint32_t    D3PMR3;               // [Read-write] EXTI D3 pending mask register
    reserved_t<1>        _2;
    volatile uint32_t    D3PCR3H;              // [Read-write] EXTI D3 pending clear selection register high
    reserved_t<10>       _3;
    volatile uint32_t    CPUIMR1;              // [Read-write] EXTI interrupt mask register
    volatile uint32_t    CPUEMR1;              // [Read-write] EXTI event mask register
    volatile uint32_t    CPUPR1;               // [Read-write] EXTI pending register
    reserved_t<1>        _4;
    volatile uint32_t    CPUIMR2;              // [Read-write] EXTI interrupt mask register
    volatile uint32_t    CPUEMR2;              // [Read-write] EXTI event mask register
    volatile uint32_t    CPUPR2;               // [Read-only] EXTI pending register
    reserved_t<1>        _5;
    volatile uint32_t    CPUIMR3;              // [Read-only] EXTI interrupt mask register
    volatile uint32_t    CPUEMR3;              // [Read-only] EXTI event mask register
    volatile uint32_t    CPUPR3;               // [Read-only] EXTI pending register

    static constexpr uint32_t RTSR1_TR0 = 0x1;            // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t RTSR1_TR1 = 0x2;            // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t RTSR1_TR2 = 0x4;            // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t RTSR1_TR3 = 0x8;            // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t RTSR1_TR4 = 0x10;           // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t RTSR1_TR5 = 0x20;           // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t RTSR1_TR6 = 0x40;           // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t RTSR1_TR7 = 0x80;           // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t RTSR1_TR8 = 0x100;          // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t RTSR1_TR9 = 0x200;          // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t RTSR1_TR10 = 0x400;         // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t RTSR1_TR11 = 0x800;         // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t RTSR1_TR12 = 0x1000;        // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t RTSR1_TR13 = 0x2000;        // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t RTSR1_TR14 = 0x4000;        // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t RTSR1_TR15 = 0x8000;        // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t RTSR1_TR16 = 0x10000;       // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t RTSR1_TR17 = 0x20000;       // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t RTSR1_TR18 = 0x40000;       // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t RTSR1_TR19 = 0x80000;       // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t RTSR1_TR20 = 0x100000;      // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t RTSR1_TR21 = 0x200000;      // Rising trigger event configuration bit of Configurable Event input
    static const uint32_t RTSR1_RESET_VALUE = 0x0;

    static constexpr uint32_t FTSR1_TR0 = 0x1;            // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t FTSR1_TR1 = 0x2;            // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t FTSR1_TR2 = 0x4;            // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t FTSR1_TR3 = 0x8;            // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t FTSR1_TR4 = 0x10;           // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t FTSR1_TR5 = 0x20;           // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t FTSR1_TR6 = 0x40;           // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t FTSR1_TR7 = 0x80;           // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t FTSR1_TR8 = 0x100;          // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t FTSR1_TR9 = 0x200;          // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t FTSR1_TR10 = 0x400;         // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t FTSR1_TR11 = 0x800;         // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t FTSR1_TR12 = 0x1000;        // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t FTSR1_TR13 = 0x2000;        // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t FTSR1_TR14 = 0x4000;        // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t FTSR1_TR15 = 0x8000;        // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t FTSR1_TR16 = 0x10000;       // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t FTSR1_TR17 = 0x20000;       // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t FTSR1_TR18 = 0x40000;       // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t FTSR1_TR19 = 0x80000;       // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t FTSR1_TR20 = 0x100000;      // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t FTSR1_TR21 = 0x200000;      // Rising trigger event configuration bit of Configurable Event input
    static const uint32_t FTSR1_RESET_VALUE = 0x0;

    static constexpr uint32_t SWIER1_SWIER0 = 0x1;         // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t SWIER1_SWIER1 = 0x2;         // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t SWIER1_SWIER2 = 0x4;         // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t SWIER1_SWIER3 = 0x8;         // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t SWIER1_SWIER4 = 0x10;        // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t SWIER1_SWIER5 = 0x20;        // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t SWIER1_SWIER6 = 0x40;        // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t SWIER1_SWIER7 = 0x80;        // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t SWIER1_SWIER8 = 0x100;       // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t SWIER1_SWIER9 = 0x200;       // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t SWIER1_SWIER10 = 0x400;      // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t SWIER1_SWIER11 = 0x800;      // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t SWIER1_SWIER12 = 0x1000;     // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t SWIER1_SWIER13 = 0x2000;     // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t SWIER1_SWIER14 = 0x4000;     // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t SWIER1_SWIER15 = 0x8000;     // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t SWIER1_SWIER16 = 0x10000;    // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t SWIER1_SWIER17 = 0x20000;    // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t SWIER1_SWIER18 = 0x40000;    // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t SWIER1_SWIER19 = 0x80000;    // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t SWIER1_SWIER20 = 0x100000;   // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t SWIER1_SWIER21 = 0x200000;   // Rising trigger event configuration bit of Configurable Event input
    static const uint32_t SWIER1_RESET_VALUE = 0x0;

    static constexpr uint32_t D3PMR1_MR0 = 0x1;            // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t D3PMR1_MR1 = 0x2;            // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t D3PMR1_MR2 = 0x4;            // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t D3PMR1_MR3 = 0x8;            // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t D3PMR1_MR4 = 0x10;           // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t D3PMR1_MR5 = 0x20;           // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t D3PMR1_MR6 = 0x40;           // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t D3PMR1_MR7 = 0x80;           // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t D3PMR1_MR8 = 0x100;          // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t D3PMR1_MR9 = 0x200;          // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t D3PMR1_MR10 = 0x400;         // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t D3PMR1_MR11 = 0x800;         // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t D3PMR1_MR12 = 0x1000;        // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t D3PMR1_MR13 = 0x2000;        // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t D3PMR1_MR14 = 0x4000;        // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t D3PMR1_MR15 = 0x8000;        // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t D3PMR1_MR19 = 0x80000;       // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t D3PMR1_MR20 = 0x100000;      // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t D3PMR1_MR21 = 0x200000;      // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t D3PMR1_MR25 = 0x2000000;     // Rising trigger event configuration bit of Configurable Event input
    static const uint32_t D3PMR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t D3PCR1L_PCS0 =                // D3 Pending request clear input signal selection on Event input x = truncate (n/2) (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D3PCR1L_PCS1 =                // D3 Pending request clear input signal selection on Event input x = truncate (n/2) (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D3PCR1L_PCS2 =                // D3 Pending request clear input signal selection on Event input x = truncate (n/2) (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D3PCR1L_PCS3 =                // D3 Pending request clear input signal selection on Event input x = truncate (n/2) (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D3PCR1L_PCS4 =                // D3 Pending request clear input signal selection on Event input x = truncate (n/2) (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D3PCR1L_PCS5 =                // D3 Pending request clear input signal selection on Event input x = truncate (n/2) (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D3PCR1L_PCS6 =                // D3 Pending request clear input signal selection on Event input x = truncate (n/2) (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D3PCR1L_PCS7 =                // D3 Pending request clear input signal selection on Event input x = truncate (n/2) (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D3PCR1L_PCS8 =                // D3 Pending request clear input signal selection on Event input x = truncate (n/2) (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D3PCR1L_PCS9 =                // D3 Pending request clear input signal selection on Event input x = truncate (n/2) (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D3PCR1L_PCS10 =               // D3 Pending request clear input signal selection on Event input x = truncate (n/2) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D3PCR1L_PCS11 =               // D3 Pending request clear input signal selection on Event input x = truncate (n/2) (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D3PCR1L_PCS12 =               // D3 Pending request clear input signal selection on Event input x = truncate (n/2) (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D3PCR1L_PCS13 =               // D3 Pending request clear input signal selection on Event input x = truncate (n/2) (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D3PCR1L_PCS14 =               // D3 Pending request clear input signal selection on Event input x = truncate (n/2) (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D3PCR1L_PCS15 =               // D3 Pending request clear input signal selection on Event input x = truncate (n/2) (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    static const uint32_t D3PCR1L_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t D3PCR1H_PCS19 =               // D3 Pending request clear input signal selection on Event input x = truncate ((n+32)/2) (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D3PCR1H_PCS20 =               // D3 Pending request clear input signal selection on Event input x = truncate ((n+32)/2) (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D3PCR1H_PCS21 =               // D3 Pending request clear input signal selection on Event input x = truncate ((n+32)/2) (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D3PCR1H_PCS25 =               // D3 Pending request clear input signal selection on Event input x = truncate ((n+32)/2) (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    static const uint32_t D3PCR1H_RESET_VALUE = 0x0;

    static constexpr uint32_t RTSR2_TR49 = 0x20000;       // Rising trigger event configuration bit of Configurable Event input x+32
    static constexpr uint32_t RTSR2_TR51 = 0x80000;       // Rising trigger event configuration bit of Configurable Event input x+32
    static const uint32_t RTSR2_RESET_VALUE = 0x0;

    static constexpr uint32_t FTSR2_TR49 = 0x20000;       // Falling trigger event configuration bit of Configurable Event input x+32
    static constexpr uint32_t FTSR2_TR51 = 0x80000;       // Falling trigger event configuration bit of Configurable Event input x+32
    static const uint32_t FTSR2_RESET_VALUE = 0x0;

    static constexpr uint32_t SWIER2_SWIER49 = 0x20000;    // Software interrupt on line x+32
    static constexpr uint32_t SWIER2_SWIER51 = 0x80000;    // Software interrupt on line x+32
    static const uint32_t SWIER2_RESET_VALUE = 0x0;

    static constexpr uint32_t D3PMR2_MR34 = 0x4;           // D3 Pending Mask on Event input x+32
    static constexpr uint32_t D3PMR2_MR35 = 0x8;           // D3 Pending Mask on Event input x+32
    static constexpr uint32_t D3PMR2_MR41 = 0x200;         // D3 Pending Mask on Event input x+32
    static constexpr uint32_t D3PMR2_MR48 = 0x10000;       // D3 Pending Mask on Event input x+32
    static constexpr uint32_t D3PMR2_MR49 = 0x20000;       // D3 Pending Mask on Event input x+32
    static constexpr uint32_t D3PMR2_MR50 = 0x40000;       // D3 Pending Mask on Event input x+32
    static constexpr uint32_t D3PMR2_MR51 = 0x80000;       // D3 Pending Mask on Event input x+32
    static constexpr uint32_t D3PMR2_MR52 = 0x100000;      // D3 Pending Mask on Event input x+32
    static constexpr uint32_t D3PMR2_MR53 = 0x200000;      // D3 Pending Mask on Event input x+32
    static const uint32_t D3PMR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t D3PCR2L_PCS35 =               // D3 Pending request clear input signal selection on Event input x = truncate ((n+64)/2) (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D3PCR2L_PCS34 =               // D3 Pending request clear input signal selection on Event input x = truncate ((n+64)/2) (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D3PCR2L_PCS41 =               // D3 Pending request clear input signal selection on Event input x = truncate ((n+64)/2) (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    static const uint32_t D3PCR2L_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t D3PCR2H_PCS48 =               // Pending request clear input signal selection on Event input x= truncate ((n+96)/2) (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D3PCR2H_PCS49 =               // Pending request clear input signal selection on Event input x= truncate ((n+96)/2) (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D3PCR2H_PCS50 =               // Pending request clear input signal selection on Event input x= truncate ((n+96)/2) (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D3PCR2H_PCS51 =               // Pending request clear input signal selection on Event input x= truncate ((n+96)/2) (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D3PCR2H_PCS52 =               // Pending request clear input signal selection on Event input x= truncate ((n+96)/2) (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t D3PCR2H_PCS53 =               // Pending request clear input signal selection on Event input x= truncate ((n+96)/2) (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    static const uint32_t D3PCR2H_RESET_VALUE = 0x0;

    static constexpr uint32_t RTSR3_TR82 = 0x40000;       // Rising trigger event configuration bit of Configurable Event input x+64
    static constexpr uint32_t RTSR3_TR84 = 0x100000;      // Rising trigger event configuration bit of Configurable Event input x+64
    static constexpr uint32_t RTSR3_TR85 = 0x200000;      // Rising trigger event configuration bit of Configurable Event input x+64
    static constexpr uint32_t RTSR3_TR86 = 0x400000;      // Rising trigger event configuration bit of Configurable Event input x+64
    static const uint32_t RTSR3_RESET_VALUE = 0x0;

    static constexpr uint32_t FTSR3_TR82 = 0x40000;       // Falling trigger event configuration bit of Configurable Event input x+64
    static constexpr uint32_t FTSR3_TR84 = 0x100000;      // Falling trigger event configuration bit of Configurable Event input x+64
    static constexpr uint32_t FTSR3_TR85 = 0x200000;      // Falling trigger event configuration bit of Configurable Event input x+64
    static constexpr uint32_t FTSR3_TR86 = 0x400000;      // Falling trigger event configuration bit of Configurable Event input x+64
    static const uint32_t FTSR3_RESET_VALUE = 0x0;

    static constexpr uint32_t SWIER3_SWIER82 = 0x40000;    // Software interrupt on line x+64
    static constexpr uint32_t SWIER3_SWIER84 = 0x100000;   // Software interrupt on line x+64
    static constexpr uint32_t SWIER3_SWIER85 = 0x200000;   // Software interrupt on line x+64
    static constexpr uint32_t SWIER3_SWIER86 = 0x400000;   // Software interrupt on line x+64
    static const uint32_t SWIER3_RESET_VALUE = 0x0;

    static constexpr uint32_t D3PMR3_MR88 = 0x1000000;     // D3 Pending Mask on Event input x+64
    static const uint32_t D3PMR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t D3PCR3H_PCS88 =               // D3 Pending request clear input signal selection on Event input x= truncate N+160/2 (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    static const uint32_t D3PCR3H_RESET_VALUE = 0x0;

    static constexpr uint32_t CPUIMR1_MR0 = 0x1;            // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t CPUIMR1_MR1 = 0x2;            // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t CPUIMR1_MR2 = 0x4;            // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t CPUIMR1_MR3 = 0x8;            // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t CPUIMR1_MR4 = 0x10;           // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t CPUIMR1_MR5 = 0x20;           // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t CPUIMR1_MR6 = 0x40;           // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t CPUIMR1_MR7 = 0x80;           // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t CPUIMR1_MR8 = 0x100;          // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t CPUIMR1_MR9 = 0x200;          // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t CPUIMR1_MR10 = 0x400;         // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t CPUIMR1_MR11 = 0x800;         // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t CPUIMR1_MR12 = 0x1000;        // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t CPUIMR1_MR13 = 0x2000;        // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t CPUIMR1_MR14 = 0x4000;        // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t CPUIMR1_MR15 = 0x8000;        // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t CPUIMR1_MR16 = 0x10000;       // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t CPUIMR1_MR17 = 0x20000;       // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t CPUIMR1_MR18 = 0x40000;       // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t CPUIMR1_MR19 = 0x80000;       // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t CPUIMR1_MR20 = 0x100000;      // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t CPUIMR1_MR21 = 0x200000;      // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t CPUIMR1_MR22 = 0x400000;      // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t CPUIMR1_MR23 = 0x800000;      // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t CPUIMR1_MR24 = 0x1000000;     // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t CPUIMR1_MR25 = 0x2000000;     // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t CPUIMR1_MR26 = 0x4000000;     // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t CPUIMR1_MR27 = 0x8000000;     // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t CPUIMR1_MR28 = 0x10000000;    // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t CPUIMR1_MR29 = 0x20000000;    // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t CPUIMR1_MR30 = 0x40000000;    // Rising trigger event configuration bit of Configurable Event input
    static constexpr uint32_t CPUIMR1_MR31 = 0x80000000;    // Rising trigger event configuration bit of Configurable Event input
    static const uint32_t CPUIMR1_RESET_VALUE = 0xffc00000;

    static constexpr uint32_t CPUEMR1_MR0 = 0x1;            // CPU Event mask on Event input x
    static constexpr uint32_t CPUEMR1_MR1 = 0x2;            // CPU Event mask on Event input x
    static constexpr uint32_t CPUEMR1_MR2 = 0x4;            // CPU Event mask on Event input x
    static constexpr uint32_t CPUEMR1_MR3 = 0x8;            // CPU Event mask on Event input x
    static constexpr uint32_t CPUEMR1_MR4 = 0x10;           // CPU Event mask on Event input x
    static constexpr uint32_t CPUEMR1_MR5 = 0x20;           // CPU Event mask on Event input x
    static constexpr uint32_t CPUEMR1_MR6 = 0x40;           // CPU Event mask on Event input x
    static constexpr uint32_t CPUEMR1_MR7 = 0x80;           // CPU Event mask on Event input x
    static constexpr uint32_t CPUEMR1_MR8 = 0x100;          // CPU Event mask on Event input x
    static constexpr uint32_t CPUEMR1_MR9 = 0x200;          // CPU Event mask on Event input x
    static constexpr uint32_t CPUEMR1_MR10 = 0x400;         // CPU Event mask on Event input x
    static constexpr uint32_t CPUEMR1_MR11 = 0x800;         // CPU Event mask on Event input x
    static constexpr uint32_t CPUEMR1_MR12 = 0x1000;        // CPU Event mask on Event input x
    static constexpr uint32_t CPUEMR1_MR13 = 0x2000;        // CPU Event mask on Event input x
    static constexpr uint32_t CPUEMR1_MR14 = 0x4000;        // CPU Event mask on Event input x
    static constexpr uint32_t CPUEMR1_MR15 = 0x8000;        // CPU Event mask on Event input x
    static constexpr uint32_t CPUEMR1_MR16 = 0x10000;       // CPU Event mask on Event input x
    static constexpr uint32_t CPUEMR1_MR17 = 0x20000;       // CPU Event mask on Event input x
    static constexpr uint32_t CPUEMR1_MR18 = 0x40000;       // CPU Event mask on Event input x
    static constexpr uint32_t CPUEMR1_MR19 = 0x80000;       // CPU Event mask on Event input x
    static constexpr uint32_t CPUEMR1_MR20 = 0x100000;      // CPU Event mask on Event input x
    static constexpr uint32_t CPUEMR1_MR21 = 0x200000;      // CPU Event mask on Event input x
    static constexpr uint32_t CPUEMR1_MR22 = 0x400000;      // CPU Event mask on Event input x
    static constexpr uint32_t CPUEMR1_MR23 = 0x800000;      // CPU Event mask on Event input x
    static constexpr uint32_t CPUEMR1_MR24 = 0x1000000;     // CPU Event mask on Event input x
    static constexpr uint32_t CPUEMR1_MR25 = 0x2000000;     // CPU Event mask on Event input x
    static constexpr uint32_t CPUEMR1_MR26 = 0x4000000;     // CPU Event mask on Event input x
    static constexpr uint32_t CPUEMR1_MR27 = 0x8000000;     // CPU Event mask on Event input x
    static constexpr uint32_t CPUEMR1_MR28 = 0x10000000;    // CPU Event mask on Event input x
    static constexpr uint32_t CPUEMR1_MR29 = 0x20000000;    // CPU Event mask on Event input x
    static constexpr uint32_t CPUEMR1_MR30 = 0x40000000;    // CPU Event mask on Event input x
    static constexpr uint32_t CPUEMR1_MR31 = 0x80000000;    // CPU Event mask on Event input x
    static const uint32_t CPUEMR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CPUPR1_PR0 = 0x1;            // CPU Event mask on Event input x
    static constexpr uint32_t CPUPR1_PR1 = 0x2;            // CPU Event mask on Event input x
    static constexpr uint32_t CPUPR1_PR2 = 0x4;            // CPU Event mask on Event input x
    static constexpr uint32_t CPUPR1_PR3 = 0x8;            // CPU Event mask on Event input x
    static constexpr uint32_t CPUPR1_PR4 = 0x10;           // CPU Event mask on Event input x
    static constexpr uint32_t CPUPR1_PR5 = 0x20;           // CPU Event mask on Event input x
    static constexpr uint32_t CPUPR1_PR6 = 0x40;           // CPU Event mask on Event input x
    static constexpr uint32_t CPUPR1_PR7 = 0x80;           // CPU Event mask on Event input x
    static constexpr uint32_t CPUPR1_PR8 = 0x100;          // CPU Event mask on Event input x
    static constexpr uint32_t CPUPR1_PR9 = 0x200;          // CPU Event mask on Event input x
    static constexpr uint32_t CPUPR1_PR10 = 0x400;         // CPU Event mask on Event input x
    static constexpr uint32_t CPUPR1_PR11 = 0x800;         // CPU Event mask on Event input x
    static constexpr uint32_t CPUPR1_PR12 = 0x1000;        // CPU Event mask on Event input x
    static constexpr uint32_t CPUPR1_PR13 = 0x2000;        // CPU Event mask on Event input x
    static constexpr uint32_t CPUPR1_PR14 = 0x4000;        // CPU Event mask on Event input x
    static constexpr uint32_t CPUPR1_PR15 = 0x8000;        // CPU Event mask on Event input x
    static constexpr uint32_t CPUPR1_PR16 = 0x10000;       // CPU Event mask on Event input x
    static constexpr uint32_t CPUPR1_PR17 = 0x20000;       // CPU Event mask on Event input x
    static constexpr uint32_t CPUPR1_PR18 = 0x40000;       // CPU Event mask on Event input x
    static constexpr uint32_t CPUPR1_PR19 = 0x80000;       // CPU Event mask on Event input x
    static constexpr uint32_t CPUPR1_PR20 = 0x100000;      // CPU Event mask on Event input x
    static constexpr uint32_t CPUPR1_PR21 = 0x200000;      // CPU Event mask on Event input x
    static const uint32_t CPUPR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CPUIMR2_MR0 = 0x1;            // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUIMR2_MR1 = 0x2;            // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUIMR2_MR2 = 0x4;            // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUIMR2_MR3 = 0x8;            // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUIMR2_MR4 = 0x10;           // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUIMR2_MR5 = 0x20;           // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUIMR2_MR6 = 0x40;           // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUIMR2_MR7 = 0x80;           // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUIMR2_MR8 = 0x100;          // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUIMR2_MR9 = 0x200;          // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUIMR2_MR10 = 0x400;         // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUIMR2_MR11 = 0x800;         // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUIMR2_MR12 = 0x1000;        // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUIMR2_MR14 = 0x4000;        // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUIMR2_MR15 = 0x8000;        // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUIMR2_MR16 = 0x10000;       // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUIMR2_MR17 = 0x20000;       // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUIMR2_MR18 = 0x40000;       // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUIMR2_MR19 = 0x80000;       // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUIMR2_MR20 = 0x100000;      // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUIMR2_MR21 = 0x200000;      // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUIMR2_MR22 = 0x400000;      // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUIMR2_MR23 = 0x800000;      // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUIMR2_MR24 = 0x1000000;     // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUIMR2_MR25 = 0x2000000;     // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUIMR2_MR26 = 0x4000000;     // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUIMR2_MR27 = 0x8000000;     // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUIMR2_MR28 = 0x10000000;    // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUIMR2_MR29 = 0x20000000;    // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUIMR2_MR30 = 0x40000000;    // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUIMR2_MR31 = 0x80000000;    // CPU Interrupt Mask on Direct Event input x+32
    static const uint32_t CPUIMR2_RESET_VALUE = 0x0;

    static constexpr uint32_t CPUEMR2_MR32 = 0x1;           // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUEMR2_MR33 = 0x2;           // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUEMR2_MR34 = 0x4;           // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUEMR2_MR35 = 0x8;           // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUEMR2_MR36 = 0x10;          // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUEMR2_MR37 = 0x20;          // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUEMR2_MR38 = 0x40;          // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUEMR2_MR39 = 0x80;          // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUEMR2_MR40 = 0x100;         // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUEMR2_MR41 = 0x200;         // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUEMR2_MR42 = 0x400;         // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUEMR2_MR43 = 0x800;         // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUEMR2_MR44 = 0x1000;        // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUEMR2_MR46 = 0x4000;        // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUEMR2_MR47 = 0x8000;        // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUEMR2_MR48 = 0x10000;       // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUEMR2_MR49 = 0x20000;       // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUEMR2_MR50 = 0x40000;       // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUEMR2_MR51 = 0x80000;       // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUEMR2_MR52 = 0x100000;      // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUEMR2_MR53 = 0x200000;      // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUEMR2_MR54 = 0x400000;      // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUEMR2_MR55 = 0x800000;      // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUEMR2_MR56 = 0x1000000;     // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUEMR2_MR57 = 0x2000000;     // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUEMR2_MR58 = 0x4000000;     // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUEMR2_MR59 = 0x8000000;     // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUEMR2_MR60 = 0x10000000;    // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUEMR2_MR61 = 0x20000000;    // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUEMR2_MR62 = 0x40000000;    // CPU Interrupt Mask on Direct Event input x+32
    static constexpr uint32_t CPUEMR2_MR63 = 0x80000000;    // CPU Interrupt Mask on Direct Event input x+32
    static const uint32_t CPUEMR2_RESET_VALUE = 0x0;

    static constexpr uint32_t CPUPR2_PR49 = 0x20000;       // Configurable event inputs x+32 Pending bit
    static constexpr uint32_t CPUPR2_PR51 = 0x80000;       // Configurable event inputs x+32 Pending bit
    static const uint32_t CPUPR2_RESET_VALUE = 0x0;

    static constexpr uint32_t CPUIMR3_MR64 = 0x1;           // CPU Interrupt Mask on Direct Event input x+64
    static constexpr uint32_t CPUIMR3_MR65 = 0x2;           // CPU Interrupt Mask on Direct Event input x+64
    static constexpr uint32_t CPUIMR3_MR66 = 0x4;           // CPU Interrupt Mask on Direct Event input x+64
    static constexpr uint32_t CPUIMR3_MR67 = 0x8;           // CPU Interrupt Mask on Direct Event input x+64
    static constexpr uint32_t CPUIMR3_MR68 = 0x10;          // CPU Interrupt Mask on Direct Event input x+64
    static constexpr uint32_t CPUIMR3_MR69 = 0x20;          // CPU Interrupt Mask on Direct Event input x+64
    static constexpr uint32_t CPUIMR3_MR70 = 0x40;          // CPU Interrupt Mask on Direct Event input x+64
    static constexpr uint32_t CPUIMR3_MR71 = 0x80;          // CPU Interrupt Mask on Direct Event input x+64
    static constexpr uint32_t CPUIMR3_MR72 = 0x100;         // CPU Interrupt Mask on Direct Event input x+64
    static constexpr uint32_t CPUIMR3_MR73 = 0x200;         // CPU Interrupt Mask on Direct Event input x+64
    static constexpr uint32_t CPUIMR3_MR74 = 0x400;         // CPU Interrupt Mask on Direct Event input x+64
    static constexpr uint32_t CPUIMR3_MR75 = 0x800;         // CPU Interrupt Mask on Direct Event input x+64
    static constexpr uint32_t CPUIMR3_MR76 = 0x1000;        // CPU Interrupt Mask on Direct Event input x+64
    static constexpr uint32_t CPUIMR3_MR77 = 0x2000;        // CPU Interrupt Mask on Direct Event input x+64
    static constexpr uint32_t CPUIMR3_MR78 = 0x4000;        // CPU Interrupt Mask on Direct Event input x+64
    static constexpr uint32_t CPUIMR3_MR79 = 0x8000;        // CPU Interrupt Mask on Direct Event input x+64
    static constexpr uint32_t CPUIMR3_MR80 = 0x10000;       // CPU Interrupt Mask on Direct Event input x+64
    static constexpr uint32_t CPUIMR3_MR82 = 0x40000;       // CPU Interrupt Mask on Direct Event input x+64
    static constexpr uint32_t CPUIMR3_MR84 = 0x100000;      // CPU Interrupt Mask on Direct Event input x+64
    static constexpr uint32_t CPUIMR3_MR85 = 0x200000;      // CPU Interrupt Mask on Direct Event input x+64
    static constexpr uint32_t CPUIMR3_MR86 = 0x400000;      // CPU Interrupt Mask on Direct Event input x+64
    static constexpr uint32_t CPUIMR3_MR87 = 0x800000;      // CPU Interrupt Mask on Direct Event input x+64
    static constexpr uint32_t CPUIMR3_MR88 = 0x1000000;     // CPU Interrupt Mask on Direct Event input x+64
    static const uint32_t CPUIMR3_RESET_VALUE = 0x0;

    static constexpr uint32_t CPUEMR3_MR64 = 0x1;           // CPU Event mask on Event input x+64
    static constexpr uint32_t CPUEMR3_MR65 = 0x2;           // CPU Event mask on Event input x+64
    static constexpr uint32_t CPUEMR3_MR66 = 0x4;           // CPU Event mask on Event input x+64
    static constexpr uint32_t CPUEMR3_MR67 = 0x8;           // CPU Event mask on Event input x+64
    static constexpr uint32_t CPUEMR3_MR68 = 0x10;          // CPU Event mask on Event input x+64
    static constexpr uint32_t CPUEMR3_MR69 = 0x20;          // CPU Event mask on Event input x+64
    static constexpr uint32_t CPUEMR3_MR70 = 0x40;          // CPU Event mask on Event input x+64
    static constexpr uint32_t CPUEMR3_MR71 = 0x80;          // CPU Event mask on Event input x+64
    static constexpr uint32_t CPUEMR3_MR72 = 0x100;         // CPU Event mask on Event input x+64
    static constexpr uint32_t CPUEMR3_MR73 = 0x200;         // CPU Event mask on Event input x+64
    static constexpr uint32_t CPUEMR3_MR74 = 0x400;         // CPU Event mask on Event input x+64
    static constexpr uint32_t CPUEMR3_MR75 = 0x800;         // CPU Event mask on Event input x+64
    static constexpr uint32_t CPUEMR3_MR76 = 0x1000;        // CPU Event mask on Event input x+64
    static constexpr uint32_t CPUEMR3_MR77 = 0x2000;        // CPU Event mask on Event input x+64
    static constexpr uint32_t CPUEMR3_MR78 = 0x4000;        // CPU Event mask on Event input x+64
    static constexpr uint32_t CPUEMR3_MR79 = 0x8000;        // CPU Event mask on Event input x+64
    static constexpr uint32_t CPUEMR3_MR80 = 0x10000;       // CPU Event mask on Event input x+64
    static constexpr uint32_t CPUEMR3_MR82 = 0x40000;       // CPU Event mask on Event input x+64
    static constexpr uint32_t CPUEMR3_MR84 = 0x100000;      // CPU Event mask on Event input x+64
    static constexpr uint32_t CPUEMR3_MR85 = 0x200000;      // CPU Event mask on Event input x+64
    static constexpr uint32_t CPUEMR3_MR86 = 0x400000;      // CPU Event mask on Event input x+64
    static constexpr uint32_t CPUEMR3_MR87 = 0x800000;      // CPU Event mask on Event input x+64
    static constexpr uint32_t CPUEMR3_MR88 = 0x1000000;     // CPU Event mask on Event input x+64
    static const uint32_t CPUEMR3_RESET_VALUE = 0x0;

    static constexpr uint32_t CPUPR3_PR82 = 0x40000;       // Configurable event inputs x+64 Pending bit
    static constexpr uint32_t CPUPR3_PR84 = 0x100000;      // Configurable event inputs x+64 Pending bit
    static constexpr uint32_t CPUPR3_PR85 = 0x200000;      // Configurable event inputs x+64 Pending bit
    static constexpr uint32_t CPUPR3_PR86 = 0x400000;      // Configurable event inputs x+64 Pending bit
    static const uint32_t CPUPR3_RESET_VALUE = 0x0;

    static constexpr uint8_t EXTI0 = 6; // EXTI Line 0 interrupt
    static constexpr uint8_t EXTI1 = 7; // EXTI Line 1 interrupt
    static constexpr uint8_t EXTI15_10 = 40; // EXTI Line[15:10] interrupts
    static constexpr uint8_t EXTI2 = 8; // EXTI Line 2 interrupt
    static constexpr uint8_t EXTI3 = 9; // EXTI Line 3interrupt
    static constexpr uint8_t EXTI4 = 10; // EXTI Line 4interrupt
    static constexpr uint8_t EXTI9_5 = 23; // EXTI Line[9:5] interrupts
    static constexpr uint8_t PVD_PVM = 1; // PVD through EXTI line
    static constexpr uint8_t RTC_ALARM = 41; // RTC alarms (A and B)
};

static exti_t& EXTI = *reinterpret_cast<exti_t*>(0x58000000);

#define HAVE_PERIPHERAL_EXTI


////
//
//    DELAY_Block_SDMMC1
//
////

struct delay_block_sdmmc1_t
{
    volatile uint32_t    CR;                   // [Read-write] DLYB control register
    volatile uint32_t    CFGR;                 // [Read-write] DLYB configuration register

    static constexpr uint32_t CR_DEN = 0x1;            // Delay block enable bit
    static constexpr uint32_t CR_SEN = 0x2;            // Sampler length enable bit
    static const uint32_t CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CFGR_SEL =                 // Select the phase for the Output clock (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_UNIT =                // Delay Defines the delay of a Unit delay cell (7 bits)
        bit_field_t<8, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_LNG =                 // Delay line length value (12 bits)
        bit_field_t<16, 0xfff>::value<X>();
    static constexpr uint32_t CFGR_LNGF = 0x80000000;    // Length valid flag
    static const uint32_t CFGR_RESET_VALUE = 0x0;

    static constexpr uint8_t WKUP = 149; // WKUP1 to WKUP6 pins
};

static delay_block_sdmmc1_t& DELAY_BLOCK_SDMMC1 = *reinterpret_cast<delay_block_sdmmc1_t*>(0x52008000);

#define HAVE_PERIPHERAL_DELAY_BLOCK_SDMMC1


////
//
//    DELAY_Block_SDMMC1
//
////

struct delay_block_quadspi_t
{
    volatile uint32_t    CR;                   // [Read-write] DLYB control register
    volatile uint32_t    CFGR;                 // [Read-write] DLYB configuration register

    static constexpr uint32_t CR_DEN = 0x1;            // Delay block enable bit
    static constexpr uint32_t CR_SEN = 0x2;            // Sampler length enable bit
    static const uint32_t CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CFGR_SEL =                 // Select the phase for the Output clock (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_UNIT =                // Delay Defines the delay of a Unit delay cell (7 bits)
        bit_field_t<8, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_LNG =                 // Delay line length value (12 bits)
        bit_field_t<16, 0xfff>::value<X>();
    static constexpr uint32_t CFGR_LNGF = 0x80000000;    // Length valid flag
    static const uint32_t CFGR_RESET_VALUE = 0x0;
};

static delay_block_quadspi_t& DELAY_BLOCK_QUADSPI = *reinterpret_cast<delay_block_quadspi_t*>(0x52006000);

#define HAVE_PERIPHERAL_DELAY_BLOCK_QUADSPI


////
//
//    DELAY_Block_SDMMC1
//
////

struct delay_block_sdmmc2_t
{
    volatile uint32_t    CR;                   // [Read-write] DLYB control register
    volatile uint32_t    CFGR;                 // [Read-write] DLYB configuration register

    static constexpr uint32_t CR_DEN = 0x1;            // Delay block enable bit
    static constexpr uint32_t CR_SEN = 0x2;            // Sampler length enable bit
    static const uint32_t CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CFGR_SEL =                 // Select the phase for the Output clock (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_UNIT =                // Delay Defines the delay of a Unit delay cell (7 bits)
        bit_field_t<8, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_LNG =                 // Delay line length value (12 bits)
        bit_field_t<16, 0xfff>::value<X>();
    static constexpr uint32_t CFGR_LNGF = 0x80000000;    // Length valid flag
    static const uint32_t CFGR_RESET_VALUE = 0x0;
};

static delay_block_sdmmc2_t& DELAY_BLOCK_SDMMC2 = *reinterpret_cast<delay_block_sdmmc2_t*>(0x48022800);

#define HAVE_PERIPHERAL_DELAY_BLOCK_SDMMC2


////
//
//    Flash
//
////

struct flash_t
{
    volatile uint32_t    ACR;                  // [Read-write] Access control register
    volatile uint32_t    KEYR1;                // [Read-write] FLASH key register for bank 1
    volatile uint32_t    OPTKEYR;              // [Read-write] FLASH option key register
    volatile uint32_t    CR1;                  // [Read-write] FLASH control register for bank 1
    volatile uint32_t    SR1;                  // [Read-write] FLASH status register for bank 1
    volatile uint32_t    CCR1;                 // [Read-write] FLASH clear control register for bank 1
    volatile uint32_t    OPTCR;                // [Read-write] FLASH option control register
    volatile uint32_t    OPTSR_CUR;            // [Read-write] FLASH option status register
    volatile uint32_t    OPTSR_PRG;            // [Read-write] FLASH option status register
    volatile uint32_t    OPTCCR;               // [Write-only] FLASH option clear control register
    volatile uint32_t    PRAR_CUR1;            // [Read-only] FLASH protection address for bank 1
    volatile uint32_t    PRAR_PRG1;            // [Read-write] FLASH protection address for bank 1
    volatile uint32_t    SCAR_CUR1;            // [Read-write] FLASH secure address for bank 1
    volatile uint32_t    SCAR_PRG1;            // [Read-write] FLASH secure address for bank 1
    volatile uint32_t    WPSN_CUR1R;           // [Read-only] FLASH write sector protection for bank 1
    volatile uint32_t    WPSN_PRG1R;           // [Read-write] FLASH write sector protection for bank 1
    volatile uint32_t    BOOT_CURR;            // [Read-only] FLASH register with boot address
    volatile uint32_t    BOOT_PRGR;            // [Read-only] FLASH register with boot address
    reserved_t<2>        _0;
    volatile uint32_t    CRCCR1;               // [Read-write] FLASH CRC control register for bank 1
    volatile uint32_t    CRCSADD1R;            // [Read-write] FLASH CRC start address register for bank 1
    volatile uint32_t    CRCEADD1R;            // [Read-write] FLASH CRC end address register for bank 1
    volatile uint32_t    CRCDATAR;             // [Read-write] FLASH CRC data register
    volatile uint32_t    ECC_FA1R;             // [Read-only] FLASH ECC fail address for bank 1
    reserved_t<39>       _1;
    volatile uint32_t    ACR_;                 // [Read-write] Access control register
    volatile uint32_t    KEYR2;                // [Read-only] FLASH key register for bank 2
    volatile uint32_t    OPTKEYR_;             // [Read-write] FLASH option key register
    volatile uint32_t    CR2;                  // [Read-write] FLASH control register for bank 2
    volatile uint32_t    SR2;                  // [Read-write] FLASH status register for bank 2
    volatile uint32_t    CCR2;                 // [Read-write] FLASH clear control register for bank 2
    volatile uint32_t    OPTCR_;               // [Read-write] FLASH option control register
    volatile uint32_t    OPTSR_CUR_;           // [Read-write] FLASH option status register
    volatile uint32_t    OPTSR_PRG_;           // [Read-write] FLASH option status register
    volatile uint32_t    OPTCCR_;              // [Write-only] FLASH option clear control register
    volatile uint32_t    PRAR_CUR2;            // [Read-only] FLASH protection address for bank 1
    reserved_t<1>        _2;
    volatile uint32_t    SCAR_CUR2;            // [Read-write] FLASH secure address for bank 2
    volatile uint32_t    SCAR_PRG2;            // [Read-write] FLASH secure address for bank 2
    volatile uint32_t    WPSN_CUR2R;           // [Read-only] FLASH write sector protection for bank 2
    volatile uint32_t    WPSN_PRG2R;           // [Read-write] FLASH write sector protection for bank 2
    reserved_t<4>        _3;
    volatile uint32_t    CRCCR2;               // [Read-write] FLASH CRC control register for bank 1
    volatile uint32_t    CRCSADD2R;            // [Read-write] FLASH CRC start address register for bank 2
    volatile uint32_t    CRCEADD2R;            // [Read-write] FLASH CRC end address register for bank 2
    reserved_t<1>        _4;
    volatile uint32_t    ECC_FA2R;             // [Read-only] FLASH ECC fail address for bank 2

    template<uint32_t X>
    static constexpr uint32_t ACR_LATENCY =             // Read latency (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ACR_WRHIGHFREQ =          // Flash signal delay (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static const uint32_t ACR_RESET_VALUE = 0x600;


    static const uint32_t KEYR1_RESET_VALUE = 0x0;


    static const uint32_t OPTKEYR_RESET_VALUE = 0x0;

    static constexpr uint32_t CR1_LOCK1 = 0x1;          // Bank 1 configuration lock bit
    static constexpr uint32_t CR1_PG1 = 0x2;            // Bank 1 program enable bit
    static constexpr uint32_t CR1_SER1 = 0x4;           // Bank 1 sector erase request
    static constexpr uint32_t CR1_BER1 = 0x8;           // Bank 1 erase request
    template<uint32_t X>
    static constexpr uint32_t CR1_PSIZE1 =              // Bank 1 program size (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static constexpr uint32_t CR1_FW1 = 0x40;           // Bank 1 write forcing control bit
    static constexpr uint32_t CR1_START1 = 0x80;        // Bank 1 bank or sector erase start control bit
    template<uint32_t X>
    static constexpr uint32_t CR1_SNB1 =                // Bank 1 sector erase selection number (3 bits)
        bit_field_t<8, 0x7>::value<X>();
    static constexpr uint32_t CR1_CRC_EN = 0x8000;      // Bank 1 CRC control bit
    static constexpr uint32_t CR1_EOPIE1 = 0x10000;     // Bank 1 end-of-program interrupt control bit
    static constexpr uint32_t CR1_WRPERRIE1 = 0x20000;  // Bank 1 write protection error interrupt enable bit
    static constexpr uint32_t CR1_PGSERRIE1 = 0x40000;  // Bank 1 programming sequence error interrupt enable bit
    static constexpr uint32_t CR1_STRBERRIE1 = 0x80000; // Bank 1 strobe error interrupt enable bit
    static constexpr uint32_t CR1_INCERRIE1 = 0x200000; // Bank 1 inconsistency error interrupt enable bit
    static constexpr uint32_t CR1_OPERRIE1 = 0x400000;  // Bank 1 write/erase error interrupt enable bit
    static constexpr uint32_t CR1_RDPERRIE1 = 0x800000; // Bank 1 read protection error interrupt enable bit
    static constexpr uint32_t CR1_RDSERRIE1 = 0x1000000;// Bank 1 secure error interrupt enable bit
    static constexpr uint32_t CR1_SNECCERRIE1 = 0x2000000;// Bank 1 ECC single correction error interrupt enable bit
    static constexpr uint32_t CR1_DBECCERRIE1 = 0x4000000;// Bank 1 ECC double detection error interrupt enable bit
    static constexpr uint32_t CR1_CRCENDIE1 = 0x8000000;// Bank 1 end of CRC calculation interrupt enable bit
    static const uint32_t CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t SR1_BSY1 = 0x1;           // Bank 1 ongoing program flag
    static constexpr uint32_t SR1_WBNE1 = 0x2;          // Bank 1 write buffer not empty flag
    static constexpr uint32_t SR1_QW1 = 0x4;            // Bank 1 wait queue flag
    static constexpr uint32_t SR1_CRC_BUSY1 = 0x8;      // Bank 1 CRC busy flag
    static constexpr uint32_t SR1_EOP1 = 0x10000;       // Bank 1 end-of-program flag
    static constexpr uint32_t SR1_WRPERR1 = 0x20000;    // Bank 1 write protection error flag
    static constexpr uint32_t SR1_PGSERR1 = 0x40000;    // Bank 1 programming sequence error flag
    static constexpr uint32_t SR1_STRBERR1 = 0x80000;   // Bank 1 strobe error flag
    static constexpr uint32_t SR1_INCERR1 = 0x200000;   // Bank 1 inconsistency error flag
    static constexpr uint32_t SR1_OPERR1 = 0x400000;    // Bank 1 write/erase error flag
    static constexpr uint32_t SR1_RDPERR1 = 0x800000;   // Bank 1 read protection error flag
    static constexpr uint32_t SR1_RDSERR1 = 0x1000000;  // Bank 1 secure error flag
    static constexpr uint32_t SR1_SNECCERR11 = 0x2000000;// Bank 1 single correction error flag
    static constexpr uint32_t SR1_DBECCERR1 = 0x4000000;// Bank 1 ECC double detection error flag
    static constexpr uint32_t SR1_CRCEND1 = 0x8000000;  // Bank 1 CRC-complete flag
    static const uint32_t SR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CCR1_CLR_EOP1 = 0x10000;   // Bank 1 EOP1 flag clear bit
    static constexpr uint32_t CCR1_CLR_WRPERR1 = 0x20000;// Bank 1 WRPERR1 flag clear bit
    static constexpr uint32_t CCR1_CLR_PGSERR1 = 0x40000;// Bank 1 PGSERR1 flag clear bi
    static constexpr uint32_t CCR1_CLR_STRBERR1 = 0x80000;// Bank 1 STRBERR1 flag clear bit
    static constexpr uint32_t CCR1_CLR_INCERR1 = 0x200000;// Bank 1 INCERR1 flag clear bit
    static constexpr uint32_t CCR1_CLR_OPERR1 = 0x400000;// Bank 1 OPERR1 flag clear bit
    static constexpr uint32_t CCR1_CLR_RDPERR1 = 0x800000;// Bank 1 RDPERR1 flag clear bit
    static constexpr uint32_t CCR1_CLR_RDSERR1 = 0x1000000;// Bank 1 RDSERR1 flag clear bit
    static constexpr uint32_t CCR1_CLR_SNECCERR1 = 0x2000000;// Bank 1 SNECCERR1 flag clear bit
    static constexpr uint32_t CCR1_CLR_DBECCERR1 = 0x4000000;// Bank 1 DBECCERR1 flag clear bit
    static constexpr uint32_t CCR1_CLR_CRCEND1 = 0x8000000;// Bank 1 CRCEND1 flag clear bit
    static const uint32_t CCR1_RESET_VALUE = 0x0;

    static constexpr uint32_t OPTCR_OPTLOCK = 0x1;        // FLASH_OPTCR lock option configuration bit
    static constexpr uint32_t OPTCR_OPTSTART = 0x2;       // Option byte start change option configuration bit
    static constexpr uint32_t OPTCR_MER = 0x10;           // Flash mass erase enable bit
    static constexpr uint32_t OPTCR_OPTCHANGEERRIE = 0x40000000;// Option byte change error interrupt enable bit
    static constexpr uint32_t OPTCR_SWAP_BANK = 0x80000000;// Bank swapping configuration bit
    static const uint32_t OPTCR_RESET_VALUE = 0x0;

    static constexpr uint32_t OPTSR_CUR_OPT_BUSY = 0x1;       // Option byte change ongoing flag
    template<uint32_t X>
    static constexpr uint32_t OPTSR_CUR_BOR_LEV =             // Brownout level option status bit (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t OPTSR_CUR_IWDG1_HW = 0x10;      // IWDG1 control option status bit
    static constexpr uint32_t OPTSR_CUR_nRST_STOP_D1 = 0x40;  // D1 DStop entry reset option status bit
    static constexpr uint32_t OPTSR_CUR_nRST_STBY_D1 = 0x80;  // D1 DStandby entry reset option status bit
    template<uint32_t X>
    static constexpr uint32_t OPTSR_CUR_RDP =                 // Readout protection level option status byte (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t OPTSR_CUR_FZ_IWDG_STOP = 0x20000;// IWDG Stop mode freeze option status bit
    static constexpr uint32_t OPTSR_CUR_FZ_IWDG_SDBY = 0x40000;// IWDG Standby mode freeze option status bit
    template<uint32_t X>
    static constexpr uint32_t OPTSR_CUR_ST_RAM_SIZE =         // DTCM RAM size option status (2 bits)
        bit_field_t<19, 0x3>::value<X>();
    static constexpr uint32_t OPTSR_CUR_SECURITY = 0x200000;  // Security enable option status bit
    static constexpr uint32_t OPTSR_CUR_RSS1 = 0x4000000;     // User option bit 1
    static constexpr uint32_t OPTSR_CUR_PERSO_OK = 0x10000000;// Device personalization status bit
    static constexpr uint32_t OPTSR_CUR_IO_HSLV = 0x20000000; // I/O high-speed at low-voltage status bit (PRODUCT_BELOW_25V)
    static constexpr uint32_t OPTSR_CUR_OPTCHANGEERR = 0x40000000;// Option byte change error flag
    static constexpr uint32_t OPTSR_CUR_SWAP_BANK_OPT = 0x80000000;// Bank swapping option status bit
    static const uint32_t OPTSR_CUR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OPTSR_PRG_BOR_LEV =             // BOR reset level option configuration bits (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t OPTSR_PRG_IWDG1_HW = 0x10;      // IWDG1 option configuration bit
    static constexpr uint32_t OPTSR_PRG_nRST_STOP_D1 = 0x40;  // Option byte erase after D1 DStop option configuration bit
    static constexpr uint32_t OPTSR_PRG_nRST_STBY_D1 = 0x80;  // Option byte erase after D1 DStandby option configuration bit
    template<uint32_t X>
    static constexpr uint32_t OPTSR_PRG_RDP =                 // Readout protection level option configuration byte (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t OPTSR_PRG_FZ_IWDG_STOP = 0x20000;// IWDG Stop mode freeze option configuration bit
    static constexpr uint32_t OPTSR_PRG_FZ_IWDG_SDBY = 0x40000;// IWDG Standby mode freeze option configuration bit
    template<uint32_t X>
    static constexpr uint32_t OPTSR_PRG_ST_RAM_SIZE =         // DTCM size select option configuration bits (2 bits)
        bit_field_t<19, 0x3>::value<X>();
    static constexpr uint32_t OPTSR_PRG_SECURITY = 0x200000;  // Security option configuration bit
    static constexpr uint32_t OPTSR_PRG_RSS1 = 0x4000000;     // User option configuration bit 1
    static constexpr uint32_t OPTSR_PRG_RSS2 = 0x8000000;     // User option configuration bit 2
    static constexpr uint32_t OPTSR_PRG_IO_HSLV = 0x20000000; // I/O high-speed at low-voltage (PRODUCT_BELOW_25V)
    static constexpr uint32_t OPTSR_PRG_SWAP_BANK_OPT = 0x80000000;// Bank swapping option configuration bit
    static const uint32_t OPTSR_PRG_RESET_VALUE = 0x0;

    static constexpr uint32_t OPTCCR_CLR_OPTCHANGEERR = 0x40000000;// OPTCHANGEERR reset bit
    static const uint32_t OPTCCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PRAR_CUR1_PROT_AREA_START1 =    // Bank 1 lowest PCROP protected address (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PRAR_CUR1_PROT_AREA_END1 =      // Bank 1 highest PCROP protected address (12 bits)
        bit_field_t<16, 0xfff>::value<X>();
    static constexpr uint32_t PRAR_CUR1_DMEP1 = 0x80000000;   // Bank 1 PCROP protected erase enable option status bit
    static const uint32_t PRAR_CUR1_RESET_VALUE = 0x0;

    static constexpr uint32_t PRAR_PRG1_DMEP1 = 0x80000000;   // Bank 1 PCROP protected erase enable option configuration bit
    static constexpr uint32_t PRAR_PRG1_DMEP2 = 0x80000000;   // Bank 2 PCROP protected erase enable option configuration bit
    template<uint32_t X>
    static constexpr uint32_t PRAR_PRG1_PROT_AREA_END1 =      // Bank 1 highest PCROP protected address configuration (12 bits)
        bit_field_t<16, 0xfff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PRAR_PRG1_PROT_AREA_END2 =      // Bank 2 highest PCROP protected address configuration (12 bits)
        bit_field_t<16, 0xfff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PRAR_PRG1_PROT_AREA_START1 =    // Bank 1 lowest PCROP protected address configuration (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PRAR_PRG1_PROT_AREA_START2 =    // Bank 2 lowest PCROP protected address configuration (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t PRAR_PRG1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SCAR_CUR1_SEC_AREA_START1 =     // Bank 1 lowest secure protected address (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SCAR_CUR1_SEC_AREA_END1 =       // Bank 1 highest secure protected address (12 bits)
        bit_field_t<16, 0xfff>::value<X>();
    static constexpr uint32_t SCAR_CUR1_DMES1 = 0x80000000;   // Bank 1 secure protected erase enable option status bit
    static const uint32_t SCAR_CUR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SCAR_PRG1_SEC_AREA_START1 =     // Bank 1 lowest secure protected address configuration (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SCAR_PRG1_SEC_AREA_END1 =       // Bank 1 highest secure protected address configuration (12 bits)
        bit_field_t<16, 0xfff>::value<X>();
    static constexpr uint32_t SCAR_PRG1_DMES1 = 0x80000000;   // Bank 1 secure protected erase enable option configuration bit
    static const uint32_t SCAR_PRG1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t WPSN_CUR1R_WRPSn1 =              // Bank 1 sector write protection option status byte (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t WPSN_CUR1R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t WPSN_PRG1R_WRPSn1 =              // Bank 1 sector write protection configuration byte (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t WPSN_PRG1R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BOOT_CURR_BOOT_ADD0 =           // Boot address 0 (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BOOT_CURR_BOOT_ADD1 =           // Boot address 1 (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t BOOT_CURR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BOOT_PRGR_BOOT_ADD0 =           // Boot address 0 (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BOOT_PRGR_BOOT_ADD1 =           // Boot address 1 (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t BOOT_PRGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CRCCR1_CRC_SECT =            // Bank 1 CRC sector number (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static constexpr uint32_t CRCCR1_ALL_BANK = 0x80;      // Bank 1 CRC select bit
    static constexpr uint32_t CRCCR1_CRC_BY_SECT = 0x100;  // Bank 1 CRC sector mode select bit
    static constexpr uint32_t CRCCR1_ADD_SECT = 0x200;     // Bank 1 CRC sector select bit
    static constexpr uint32_t CRCCR1_CLEAN_SECT = 0x400;   // Bank 1 CRC sector list clear bit
    static constexpr uint32_t CRCCR1_START_CRC = 0x10000;  // Bank 1 CRC start bit
    static constexpr uint32_t CRCCR1_CLEAN_CRC = 0x20000;  // Bank 1 CRC clear bit
    template<uint32_t X>
    static constexpr uint32_t CRCCR1_CRC_BURST =           // Bank 1 CRC burst size (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    static const uint32_t CRCCR1_RESET_VALUE = 0x0;


    static const uint32_t CRCSADD1R_RESET_VALUE = 0x0;


    static const uint32_t CRCEADD1R_RESET_VALUE = 0x0;


    static const uint32_t CRCDATAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ECC_FA1R_FAIL_ECC_ADDR1 =      // Bank 1 ECC error address (15 bits)
        bit_field_t<0, 0x7fff>::value<X>();
    static const uint32_t ECC_FA1R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ACR__LATENCY =             // Read latency (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ACR__WRHIGHFREQ =          // Flash signal delay (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static const uint32_t ACR__RESET_VALUE = 0x0;


    static const uint32_t KEYR2_RESET_VALUE = 0x0;


    static const uint32_t OPTKEYR__RESET_VALUE = 0x0;

    static constexpr uint32_t CR2_LOCK2 = 0x1;          // Bank 2 configuration lock bit
    static constexpr uint32_t CR2_PG2 = 0x2;            // Bank 2 program enable bit
    static constexpr uint32_t CR2_SER2 = 0x4;           // Bank 2 sector erase request
    static constexpr uint32_t CR2_BER2 = 0x8;           // Bank 2 erase request
    template<uint32_t X>
    static constexpr uint32_t CR2_PSIZE2 =              // Bank 2 program size (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static constexpr uint32_t CR2_FW2 = 0x40;           // Bank 2 write forcing control bit
    static constexpr uint32_t CR2_START2 = 0x80;        // Bank 2 bank or sector erase start control bit
    template<uint32_t X>
    static constexpr uint32_t CR2_SNB2 =                // Bank 2 sector erase selection number (3 bits)
        bit_field_t<8, 0x7>::value<X>();
    static constexpr uint32_t CR2_CRC_EN = 0x8000;      // Bank 2 CRC control bit
    static constexpr uint32_t CR2_EOPIE2 = 0x10000;     // Bank 2 end-of-program interrupt control bit
    static constexpr uint32_t CR2_WRPERRIE2 = 0x20000;  // Bank 2 write protection error interrupt enable bit
    static constexpr uint32_t CR2_PGSERRIE2 = 0x40000;  // Bank 2 programming sequence error interrupt enable bit
    static constexpr uint32_t CR2_STRBERRIE2 = 0x80000; // Bank 2 strobe error interrupt enable bit
    static constexpr uint32_t CR2_INCERRIE2 = 0x200000; // Bank 2 inconsistency error interrupt enable bit
    static constexpr uint32_t CR2_OPERRIE2 = 0x400000;  // Bank 2 write/erase error interrupt enable bit
    static constexpr uint32_t CR2_RDPERRIE2 = 0x800000; // Bank 2 read protection error interrupt enable bit
    static constexpr uint32_t CR2_RDSERRIE2 = 0x1000000;// Bank 2 secure error interrupt enable bit
    static constexpr uint32_t CR2_SNECCERRIE2 = 0x2000000;// Bank 2 ECC single correction error interrupt enable bit
    static constexpr uint32_t CR2_DBECCERRIE2 = 0x4000000;// Bank 2 ECC double detection error interrupt enable bit
    static constexpr uint32_t CR2_CRCENDIE2 = 0x8000000;// Bank 2 end of CRC calculation interrupt enable bit
    static const uint32_t CR2_RESET_VALUE = 0x0;

    static constexpr uint32_t SR2_BSY2 = 0x1;           // Bank 2 ongoing program flag
    static constexpr uint32_t SR2_WBNE2 = 0x2;          // Bank 2 write buffer not empty flag
    static constexpr uint32_t SR2_QW2 = 0x4;            // Bank 2 wait queue flag
    static constexpr uint32_t SR2_CRC_BUSY2 = 0x8;      // Bank 2 CRC busy flag
    static constexpr uint32_t SR2_EOP2 = 0x10000;       // Bank 2 end-of-program flag
    static constexpr uint32_t SR2_WRPERR2 = 0x20000;    // Bank 2 write protection error flag
    static constexpr uint32_t SR2_PGSERR2 = 0x40000;    // Bank 2 programming sequence error flag
    static constexpr uint32_t SR2_STRBERR2 = 0x80000;   // Bank 2 strobe error flag
    static constexpr uint32_t SR2_INCERR2 = 0x200000;   // Bank 2 inconsistency error flag
    static constexpr uint32_t SR2_OPERR2 = 0x400000;    // Bank 2 write/erase error flag
    static constexpr uint32_t SR2_RDPERR2 = 0x800000;   // Bank 2 read protection error flag
    static constexpr uint32_t SR2_RDSERR2 = 0x1000000;  // Bank 2 secure error flag
    static constexpr uint32_t SR2_SNECCERR2 = 0x2000000;// Bank 2 single correction error flag
    static constexpr uint32_t SR2_DBECCERR2 = 0x4000000;// Bank 2 ECC double detection error flag
    static constexpr uint32_t SR2_CRCEND2 = 0x8000000;  // Bank 2 CRC-complete flag
    static const uint32_t SR2_RESET_VALUE = 0x0;

    static constexpr uint32_t CCR2_CLR_EOP2 = 0x10000;   // Bank 1 EOP1 flag clear bit
    static constexpr uint32_t CCR2_CLR_WRPERR2 = 0x20000;// Bank 2 WRPERR1 flag clear bit
    static constexpr uint32_t CCR2_CLR_PGSERR2 = 0x40000;// Bank 2 PGSERR1 flag clear bi
    static constexpr uint32_t CCR2_CLR_STRBERR2 = 0x80000;// Bank 2 STRBERR1 flag clear bit
    static constexpr uint32_t CCR2_CLR_INCERR2 = 0x200000;// Bank 2 INCERR1 flag clear bit
    static constexpr uint32_t CCR2_CLR_OPERR2 = 0x400000;// Bank 2 OPERR1 flag clear bit
    static constexpr uint32_t CCR2_CLR_RDPERR2 = 0x800000;// Bank 2 RDPERR1 flag clear bit
    static constexpr uint32_t CCR2_CLR_RDSERR1 = 0x1000000;// Bank 1 RDSERR1 flag clear bit
    static constexpr uint32_t CCR2_CLR_SNECCERR2 = 0x2000000;// Bank 2 SNECCERR1 flag clear bit
    static constexpr uint32_t CCR2_CLR_DBECCERR1 = 0x4000000;// Bank 1 DBECCERR1 flag clear bit
    static constexpr uint32_t CCR2_CLR_CRCEND2 = 0x8000000;// Bank 2 CRCEND1 flag clear bit
    static const uint32_t CCR2_RESET_VALUE = 0x0;

    static constexpr uint32_t OPTCR__OPTLOCK = 0x1;        // FLASH_OPTCR lock option configuration bit
    static constexpr uint32_t OPTCR__OPTSTART = 0x2;       // Option byte start change option configuration bit
    static constexpr uint32_t OPTCR__MER = 0x10;           // Flash mass erase enable bit
    static constexpr uint32_t OPTCR__OPTCHANGEERRIE = 0x40000000;// Option byte change error interrupt enable bit
    static constexpr uint32_t OPTCR__SWAP_BANK = 0x80000000;// Bank swapping configuration bit
    static const uint32_t OPTCR__RESET_VALUE = 0x0;

    static constexpr uint32_t OPTSR_CUR__OPT_BUSY = 0x1;       // Option byte change ongoing flag
    template<uint32_t X>
    static constexpr uint32_t OPTSR_CUR__BOR_LEV =             // Brownout level option status bit (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t OPTSR_CUR__IWDG1_HW = 0x10;      // IWDG1 control option status bit
    static constexpr uint32_t OPTSR_CUR__nRST_STOP_D1 = 0x40;  // D1 DStop entry reset option status bit
    static constexpr uint32_t OPTSR_CUR__nRST_STBY_D1 = 0x80;  // D1 DStandby entry reset option status bit
    template<uint32_t X>
    static constexpr uint32_t OPTSR_CUR__RDP =                 // Readout protection level option status byte (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t OPTSR_CUR__FZ_IWDG_STOP = 0x20000;// IWDG Stop mode freeze option status bit
    static constexpr uint32_t OPTSR_CUR__FZ_IWDG_SDBY = 0x40000;// IWDG Standby mode freeze option status bit
    template<uint32_t X>
    static constexpr uint32_t OPTSR_CUR__ST_RAM_SIZE =         // DTCM RAM size option status (2 bits)
        bit_field_t<19, 0x3>::value<X>();
    static constexpr uint32_t OPTSR_CUR__SECURITY = 0x200000;  // Security enable option status bit
    static constexpr uint32_t OPTSR_CUR__RSS1 = 0x4000000;     // User option bit 1
    static constexpr uint32_t OPTSR_CUR__PERSO_OK = 0x10000000;// Device personalization status bit
    static constexpr uint32_t OPTSR_CUR__IO_HSLV = 0x20000000; // I/O high-speed at low-voltage status bit (PRODUCT_BELOW_25V)
    static constexpr uint32_t OPTSR_CUR__OPTCHANGEERR = 0x40000000;// Option byte change error flag
    static constexpr uint32_t OPTSR_CUR__SWAP_BANK_OPT = 0x80000000;// Bank swapping option status bit
    static const uint32_t OPTSR_CUR__RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OPTSR_PRG__BOR_LEV =             // BOR reset level option configuration bits (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t OPTSR_PRG__IWDG1_HW = 0x10;      // IWDG1 option configuration bit
    static constexpr uint32_t OPTSR_PRG__nRST_STOP_D1 = 0x40;  // Option byte erase after D1 DStop option configuration bit
    static constexpr uint32_t OPTSR_PRG__nRST_STBY_D1 = 0x80;  // Option byte erase after D1 DStandby option configuration bit
    template<uint32_t X>
    static constexpr uint32_t OPTSR_PRG__RDP =                 // Readout protection level option configuration byte (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t OPTSR_PRG__FZ_IWDG_STOP = 0x20000;// IWDG Stop mode freeze option configuration bit
    static constexpr uint32_t OPTSR_PRG__FZ_IWDG_SDBY = 0x40000;// IWDG Standby mode freeze option configuration bit
    template<uint32_t X>
    static constexpr uint32_t OPTSR_PRG__ST_RAM_SIZE =         // DTCM size select option configuration bits (2 bits)
        bit_field_t<19, 0x3>::value<X>();
    static constexpr uint32_t OPTSR_PRG__SECURITY = 0x200000;  // Security option configuration bit
    static constexpr uint32_t OPTSR_PRG__RSS1 = 0x4000000;     // User option configuration bit 1
    static constexpr uint32_t OPTSR_PRG__RSS2 = 0x8000000;     // User option configuration bit 2
    static constexpr uint32_t OPTSR_PRG__IO_HSLV = 0x20000000; // I/O high-speed at low-voltage (PRODUCT_BELOW_25V)
    static constexpr uint32_t OPTSR_PRG__SWAP_BANK_OPT = 0x80000000;// Bank swapping option configuration bit
    static const uint32_t OPTSR_PRG__RESET_VALUE = 0x0;

    static constexpr uint32_t OPTCCR__CLR_OPTCHANGEERR = 0x40000000;// OPTCHANGEERR reset bit
    static const uint32_t OPTCCR__RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PRAR_CUR2_PROT_AREA_START2 =    // Bank 2 lowest PCROP protected address (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PRAR_CUR2_PROT_AREA_END2 =      // Bank 2 highest PCROP protected address (12 bits)
        bit_field_t<16, 0xfff>::value<X>();
    static constexpr uint32_t PRAR_CUR2_DMEP2 = 0x80000000;   // Bank 2 PCROP protected erase enable option status bit
    static const uint32_t PRAR_CUR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SCAR_CUR2_SEC_AREA_START2 =     // Bank 2 lowest secure protected address (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SCAR_CUR2_SEC_AREA_END2 =       // Bank 2 highest secure protected address (12 bits)
        bit_field_t<16, 0xfff>::value<X>();
    static constexpr uint32_t SCAR_CUR2_DMES2 = 0x80000000;   // Bank 2 secure protected erase enable option status bit
    static const uint32_t SCAR_CUR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SCAR_PRG2_SEC_AREA_START2 =     // Bank 2 lowest secure protected address configuration (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SCAR_PRG2_SEC_AREA_END2 =       // Bank 2 highest secure protected address configuration (12 bits)
        bit_field_t<16, 0xfff>::value<X>();
    static constexpr uint32_t SCAR_PRG2_DMES2 = 0x80000000;   // Bank 2 secure protected erase enable option configuration bit
    static const uint32_t SCAR_PRG2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t WPSN_CUR2R_WRPSn2 =              // Bank 2 sector write protection option status byte (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t WPSN_CUR2R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t WPSN_PRG2R_WRPSn2 =              // Bank 2 sector write protection configuration byte (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t WPSN_PRG2R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CRCCR2_CRC_SECT =            // Bank 2 CRC sector number (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static constexpr uint32_t CRCCR2_ALL_BANK = 0x80;      // Bank 2 CRC select bit
    static constexpr uint32_t CRCCR2_CRC_BY_SECT = 0x100;  // Bank 2 CRC sector mode select bit
    static constexpr uint32_t CRCCR2_ADD_SECT = 0x200;     // Bank 2 CRC sector select bit
    static constexpr uint32_t CRCCR2_CLEAN_SECT = 0x400;   // Bank 2 CRC sector list clear bit
    static constexpr uint32_t CRCCR2_START_CRC = 0x10000;  // Bank 2 CRC start bit
    static constexpr uint32_t CRCCR2_CLEAN_CRC = 0x20000;  // Bank 2 CRC clear bit
    template<uint32_t X>
    static constexpr uint32_t CRCCR2_CRC_BURST =           // Bank 2 CRC burst size (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    static const uint32_t CRCCR2_RESET_VALUE = 0x0;


    static const uint32_t CRCSADD2R_RESET_VALUE = 0x0;


    static const uint32_t CRCEADD2R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ECC_FA2R_FAIL_ECC_ADDR2 =      // Bank 2 ECC error address (15 bits)
        bit_field_t<0, 0x7fff>::value<X>();
    static const uint32_t ECC_FA2R_RESET_VALUE = 0x0;

    static constexpr uint8_t FLASH = 4; // Flash memory
};

static flash_t& FLASH = *reinterpret_cast<flash_t*>(0x52002000);

#define HAVE_PERIPHERAL_FLASH


////
//
//    AXI interconnect registers
//
////

struct axi_t
{
    volatile uint32_t    PERIPH_ID_4;          // [Read-only] AXI interconnect - peripheral ID4 register
    reserved_t<3>        _0;
    volatile uint32_t    PERIPH_ID_0;          // [Read-only] AXI interconnect - peripheral ID0 register
    volatile uint32_t    PERIPH_ID_1;          // [Read-only] AXI interconnect - peripheral ID1 register
    volatile uint32_t    PERIPH_ID_2;          // [Read-only] AXI interconnect - peripheral ID2 register
    volatile uint32_t    PERIPH_ID_3;          // [Read-only] AXI interconnect - peripheral ID3 register
    volatile uint32_t    COMP_ID_0;            // [Read-only] AXI interconnect - component ID0 register
    volatile uint32_t    COMP_ID_1;            // [Read-only] AXI interconnect - component ID1 register
    volatile uint32_t    COMP_ID_2;            // [Read-only] AXI interconnect - component ID2 register
    volatile uint32_t    COMP_ID_3;            // [Read-only] AXI interconnect - component ID3 register
    reserved_t<2>        _1;
    volatile uint32_t    TARG1_FN_MOD_ISS_BM;  // [Read-write] AXI interconnect - TARG x bus matrix issuing functionality register
    reserved_t<6>        _2;
    volatile uint32_t    TARG1_FN_MOD2;        // [Read-write] AXI interconnect - TARG x bus matrix functionality 2 register
    reserved_t<1>        _3;
    volatile uint32_t    TARG1_FN_MOD_LB;      // [Read-write] AXI interconnect - TARG x long burst functionality modification
    reserved_t<54>       _4;
    volatile uint32_t    TARG1_FN_MOD;         // [Read-write] AXI interconnect - TARG x long burst functionality modification
    reserved_t<959>      _5;
    volatile uint32_t    TARG2_FN_MOD_ISS_BM;  // [Read-write] AXI interconnect - TARG x bus matrix issuing functionality register
    reserved_t<6>        _6;
    volatile uint32_t    TARG2_FN_MOD2;        // [Read-write] AXI interconnect - TARG x bus matrix functionality 2 register
    reserved_t<1>        _7;
    volatile uint32_t    TARG2_FN_MOD_LB;      // [Read-write] AXI interconnect - TARG x long burst functionality modification
    reserved_t<54>       _8;
    volatile uint32_t    TARG2_FN_MOD;         // [Read-write] AXI interconnect - TARG x long burst functionality modification
    reserved_t<959>      _9;
    volatile uint32_t    TARG3_FN_MOD_ISS_BM;  // [Read-write] AXI interconnect - TARG x bus matrix issuing functionality register
    reserved_t<1023>     _10;
    volatile uint32_t    TARG4_FN_MOD_ISS_BM;  // [Read-write] AXI interconnect - TARG x bus matrix issuing functionality register
    reserved_t<1023>     _11;
    volatile uint32_t    TARG5_FN_MOD_ISS_BM;  // [Read-write] AXI interconnect - TARG x bus matrix issuing functionality register
    reserved_t<1023>     _12;
    volatile uint32_t    TARG6_FN_MOD_ISS_BM;  // [Read-write] AXI interconnect - TARG x bus matrix issuing functionality register
    reserved_t<1024>     _13;
    volatile uint32_t    TARG7_FN_MOD_ISS_BM;  // [Read-write] AXI interconnect - TARG x bus matrix issuing functionality register
    reserved_t<5>        _14;
    volatile uint32_t    TARG7_FN_MOD2;        // [Read-write] AXI interconnect - TARG x bus matrix functionality 2 register
    reserved_t<56>       _15;
    volatile uint32_t    TARG7_FN_MOD;         // [Read-write] AXI interconnect - TARG x long burst functionality modification
    reserved_t<59334>    _16;
    volatile uint32_t    INI1_FN_MOD2;         // [Read-write] AXI interconnect - INI x functionality modification 2 register
    volatile uint32_t    INI1_FN_MOD_AHB;      // [Read-write] AXI interconnect - INI x AHB functionality modification register
    reserved_t<53>       _17;
    volatile uint32_t    INI1_READ_QOS;        // [Read-write] AXI interconnect - INI x read QoS register
    volatile uint32_t    INI1_WRITE_QOS;       // [Read-write] AXI interconnect - INI x write QoS register
    volatile uint32_t    INI1_FN_MOD;          // [Read-write] AXI interconnect - INI x issuing functionality modification register
    reserved_t<1021>     _18;
    volatile uint32_t    INI2_READ_QOS;        // [Read-write] AXI interconnect - INI x read QoS register
    volatile uint32_t    INI2_WRITE_QOS;       // [Read-write] AXI interconnect - INI x write QoS register
    volatile uint32_t    INI2_FN_MOD;          // [Read-write] AXI interconnect - INI x issuing functionality modification register
    reserved_t<966>      _19;
    volatile uint32_t    INI3_FN_MOD2;         // [Read-write] AXI interconnect - INI x functionality modification 2 register
    volatile uint32_t    INI3_FN_MOD_AHB;      // [Read-write] AXI interconnect - INI x AHB functionality modification register
    reserved_t<53>       _20;
    volatile uint32_t    INI3_READ_QOS;        // [Read-write] AXI interconnect - INI x read QoS register
    volatile uint32_t    INI3_WRITE_QOS;       // [Read-write] AXI interconnect - INI x write QoS register
    volatile uint32_t    INI3_FN_MOD;          // [Read-write] AXI interconnect - INI x issuing functionality modification register
    reserved_t<1021>     _21;
    volatile uint32_t    INI4_READ_QOS;        // [Read-write] AXI interconnect - INI x read QoS register
    volatile uint32_t    INI4_WRITE_QOS;       // [Read-write] AXI interconnect - INI x write QoS register
    volatile uint32_t    INI4_FN_MOD;          // [Read-write] AXI interconnect - INI x issuing functionality modification register
    reserved_t<1021>     _22;
    volatile uint32_t    INI5_READ_QOS;        // [Read-write] AXI interconnect - INI x read QoS register
    volatile uint32_t    INI5_WRITE_QOS;       // [Read-write] AXI interconnect - INI x write QoS register
    volatile uint32_t    INI5_FN_MOD;          // [Read-write] AXI interconnect - INI x issuing functionality modification register
    reserved_t<1021>     _23;
    volatile uint32_t    INI6_READ_QOS;        // [Read-write] AXI interconnect - INI x read QoS register
    volatile uint32_t    INI6_WRITE_QOS;       // [Read-write] AXI interconnect - INI x write QoS register
    volatile uint32_t    INI6_FN_MOD;          // [Read-write] AXI interconnect - INI x issuing functionality modification register

    template<uint32_t X>
    static constexpr uint32_t PERIPH_ID_4_JEP106CON =           // JEP106 continuation code (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PERIPH_ID_4_KCOUNT4 =             // Register file size (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    static const uint32_t PERIPH_ID_4_RESET_VALUE = 0x4;

    template<uint32_t X>
    static constexpr uint32_t PERIPH_ID_0_PARTNUM =             // Peripheral part number bits 0 to 7 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t PERIPH_ID_0_RESET_VALUE = 0x4;

    template<uint32_t X>
    static constexpr uint32_t PERIPH_ID_1_PARTNUM =             // Peripheral part number bits 8 to 11 (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PERIPH_ID_1_JEP106I =             // JEP106 identity bits 0 to 3 (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    static const uint32_t PERIPH_ID_1_RESET_VALUE = 0x4;

    template<uint32_t X>
    static constexpr uint32_t PERIPH_ID_2_JEP106ID =            // JEP106 Identity bits 4 to 6 (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static constexpr uint32_t PERIPH_ID_2_JEDEC = 0x8;          // JEP106 code flag
    template<uint32_t X>
    static constexpr uint32_t PERIPH_ID_2_REVISION =            // Peripheral revision number (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    static const uint32_t PERIPH_ID_2_RESET_VALUE = 0x4;

    template<uint32_t X>
    static constexpr uint32_t PERIPH_ID_3_CUST_MOD_NUM =        // Customer modification (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PERIPH_ID_3_REV_AND =             // Customer version (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    static const uint32_t PERIPH_ID_3_RESET_VALUE = 0x4;

    template<uint32_t X>
    static constexpr uint32_t COMP_ID_0_PREAMBLE =            // Preamble bits 0 to 7 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t COMP_ID_0_RESET_VALUE = 0x4;

    template<uint32_t X>
    static constexpr uint32_t COMP_ID_1_PREAMBLE =            // Preamble bits 8 to 11 (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t COMP_ID_1_CLASS =               // Component class (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    static const uint32_t COMP_ID_1_RESET_VALUE = 0x4;

    template<uint32_t X>
    static constexpr uint32_t COMP_ID_2_PREAMBLE =            // Preamble bits 12 to 19 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t COMP_ID_2_RESET_VALUE = 0x4;

    template<uint32_t X>
    static constexpr uint32_t COMP_ID_3_PREAMBLE =            // Preamble bits 20 to 27 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t COMP_ID_3_RESET_VALUE = 0x4;

    static constexpr uint32_t TARG1_FN_MOD_ISS_BM_READ_ISS_OVERRIDE = 0x1;// READ_ISS_OVERRIDE
    static constexpr uint32_t TARG1_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE = 0x2;// Switch matrix write issuing override for target
    static const uint32_t TARG1_FN_MOD_ISS_BM_RESET_VALUE = 0x4;

    static constexpr uint32_t TARG1_FN_MOD2_BYPASS_MERGE = 0x1;   // Disable packing of beats to match the output data width
    static const uint32_t TARG1_FN_MOD2_RESET_VALUE = 0x4;

    static constexpr uint32_t TARG1_FN_MOD_LB_FN_MOD_LB = 0x1;      // Controls burst breaking of long bursts
    static const uint32_t TARG1_FN_MOD_LB_RESET_VALUE = 0x4;

    static constexpr uint32_t TARG1_FN_MOD_READ_ISS_OVERRIDE = 0x1;// Override AMIB read issuing capability
    static constexpr uint32_t TARG1_FN_MOD_WRITE_ISS_OVERRIDE = 0x2;// Override AMIB write issuing capability
    static const uint32_t TARG1_FN_MOD_RESET_VALUE = 0x4;

    static constexpr uint32_t TARG2_FN_MOD_ISS_BM_READ_ISS_OVERRIDE = 0x1;// READ_ISS_OVERRIDE
    static constexpr uint32_t TARG2_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE = 0x2;// Switch matrix write issuing override for target
    static const uint32_t TARG2_FN_MOD_ISS_BM_RESET_VALUE = 0x4;

    static constexpr uint32_t TARG2_FN_MOD2_BYPASS_MERGE = 0x1;   // Disable packing of beats to match the output data width
    static const uint32_t TARG2_FN_MOD2_RESET_VALUE = 0x4;

    static constexpr uint32_t TARG2_FN_MOD_LB_FN_MOD_LB = 0x1;      // Controls burst breaking of long bursts
    static const uint32_t TARG2_FN_MOD_LB_RESET_VALUE = 0x4;

    static constexpr uint32_t TARG2_FN_MOD_READ_ISS_OVERRIDE = 0x1;// Override AMIB read issuing capability
    static constexpr uint32_t TARG2_FN_MOD_WRITE_ISS_OVERRIDE = 0x2;// Override AMIB write issuing capability
    static const uint32_t TARG2_FN_MOD_RESET_VALUE = 0x4;

    static constexpr uint32_t TARG3_FN_MOD_ISS_BM_READ_ISS_OVERRIDE = 0x1;// READ_ISS_OVERRIDE
    static constexpr uint32_t TARG3_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE = 0x2;// Switch matrix write issuing override for target
    static const uint32_t TARG3_FN_MOD_ISS_BM_RESET_VALUE = 0x4;

    static constexpr uint32_t TARG4_FN_MOD_ISS_BM_READ_ISS_OVERRIDE = 0x1;// READ_ISS_OVERRIDE
    static constexpr uint32_t TARG4_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE = 0x2;// Switch matrix write issuing override for target
    static const uint32_t TARG4_FN_MOD_ISS_BM_RESET_VALUE = 0x4;

    static constexpr uint32_t TARG5_FN_MOD_ISS_BM_READ_ISS_OVERRIDE = 0x1;// READ_ISS_OVERRIDE
    static constexpr uint32_t TARG5_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE = 0x2;// Switch matrix write issuing override for target
    static const uint32_t TARG5_FN_MOD_ISS_BM_RESET_VALUE = 0x4;

    static constexpr uint32_t TARG6_FN_MOD_ISS_BM_READ_ISS_OVERRIDE = 0x1;// READ_ISS_OVERRIDE
    static constexpr uint32_t TARG6_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE = 0x2;// Switch matrix write issuing override for target
    static const uint32_t TARG6_FN_MOD_ISS_BM_RESET_VALUE = 0x4;

    static constexpr uint32_t TARG7_FN_MOD_ISS_BM_READ_ISS_OVERRIDE = 0x1;// READ_ISS_OVERRIDE
    static constexpr uint32_t TARG7_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE = 0x2;// Switch matrix write issuing override for target
    static const uint32_t TARG7_FN_MOD_ISS_BM_RESET_VALUE = 0x4;

    static constexpr uint32_t TARG7_FN_MOD2_BYPASS_MERGE = 0x1;   // Disable packing of beats to match the output data width
    static const uint32_t TARG7_FN_MOD2_RESET_VALUE = 0x4;

    static constexpr uint32_t TARG7_FN_MOD_READ_ISS_OVERRIDE = 0x1;// Override AMIB read issuing capability
    static constexpr uint32_t TARG7_FN_MOD_WRITE_ISS_OVERRIDE = 0x2;// Override AMIB write issuing capability
    static const uint32_t TARG7_FN_MOD_RESET_VALUE = 0x4;

    static constexpr uint32_t INI1_FN_MOD2_BYPASS_MERGE = 0x1;   // Disables alteration of transactions by the up-sizer unless required by the protocol
    static const uint32_t INI1_FN_MOD2_RESET_VALUE = 0x4;

    static constexpr uint32_t INI1_FN_MOD_AHB_RD_INC_OVERRIDE = 0x1;// Converts all AHB-Lite write transactions to a series of single beat AXI
    static constexpr uint32_t INI1_FN_MOD_AHB_WR_INC_OVERRIDE = 0x2;// Converts all AHB-Lite read transactions to a series of single beat AXI
    static const uint32_t INI1_FN_MOD_AHB_RESET_VALUE = 0x4;

    template<uint32_t X>
    static constexpr uint32_t INI1_READ_QOS_AR_QOS =              // Read channel QoS setting (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t INI1_READ_QOS_RESET_VALUE = 0x4;

    template<uint32_t X>
    static constexpr uint32_t INI1_WRITE_QOS_AW_QOS =              // Write channel QoS setting (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t INI1_WRITE_QOS_RESET_VALUE = 0x4;

    static constexpr uint32_t INI1_FN_MOD_READ_ISS_OVERRIDE = 0x1;// Override ASIB read issuing capability
    static constexpr uint32_t INI1_FN_MOD_WRITE_ISS_OVERRIDE = 0x2;// Override ASIB write issuing capability
    static const uint32_t INI1_FN_MOD_RESET_VALUE = 0x4;

    template<uint32_t X>
    static constexpr uint32_t INI2_READ_QOS_AR_QOS =              // Read channel QoS setting (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t INI2_READ_QOS_RESET_VALUE = 0x4;

    template<uint32_t X>
    static constexpr uint32_t INI2_WRITE_QOS_AW_QOS =              // Write channel QoS setting (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t INI2_WRITE_QOS_RESET_VALUE = 0x4;

    static constexpr uint32_t INI2_FN_MOD_READ_ISS_OVERRIDE = 0x1;// Override ASIB read issuing capability
    static constexpr uint32_t INI2_FN_MOD_WRITE_ISS_OVERRIDE = 0x2;// Override ASIB write issuing capability
    static const uint32_t INI2_FN_MOD_RESET_VALUE = 0x4;

    static constexpr uint32_t INI3_FN_MOD2_BYPASS_MERGE = 0x1;   // Disables alteration of transactions by the up-sizer unless required by the protocol
    static const uint32_t INI3_FN_MOD2_RESET_VALUE = 0x4;

    static constexpr uint32_t INI3_FN_MOD_AHB_RD_INC_OVERRIDE = 0x1;// Converts all AHB-Lite write transactions to a series of single beat AXI
    static constexpr uint32_t INI3_FN_MOD_AHB_WR_INC_OVERRIDE = 0x2;// Converts all AHB-Lite read transactions to a series of single beat AXI
    static const uint32_t INI3_FN_MOD_AHB_RESET_VALUE = 0x4;

    template<uint32_t X>
    static constexpr uint32_t INI3_READ_QOS_AR_QOS =              // Read channel QoS setting (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t INI3_READ_QOS_RESET_VALUE = 0x4;

    template<uint32_t X>
    static constexpr uint32_t INI3_WRITE_QOS_AW_QOS =              // Write channel QoS setting (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t INI3_WRITE_QOS_RESET_VALUE = 0x4;

    static constexpr uint32_t INI3_FN_MOD_READ_ISS_OVERRIDE = 0x1;// Override ASIB read issuing capability
    static constexpr uint32_t INI3_FN_MOD_WRITE_ISS_OVERRIDE = 0x2;// Override ASIB write issuing capability
    static const uint32_t INI3_FN_MOD_RESET_VALUE = 0x4;

    template<uint32_t X>
    static constexpr uint32_t INI4_READ_QOS_AR_QOS =              // Read channel QoS setting (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t INI4_READ_QOS_RESET_VALUE = 0x4;

    template<uint32_t X>
    static constexpr uint32_t INI4_WRITE_QOS_AW_QOS =              // Write channel QoS setting (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t INI4_WRITE_QOS_RESET_VALUE = 0x4;

    static constexpr uint32_t INI4_FN_MOD_READ_ISS_OVERRIDE = 0x1;// Override ASIB read issuing capability
    static constexpr uint32_t INI4_FN_MOD_WRITE_ISS_OVERRIDE = 0x2;// Override ASIB write issuing capability
    static const uint32_t INI4_FN_MOD_RESET_VALUE = 0x4;

    template<uint32_t X>
    static constexpr uint32_t INI5_READ_QOS_AR_QOS =              // Read channel QoS setting (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t INI5_READ_QOS_RESET_VALUE = 0x4;

    template<uint32_t X>
    static constexpr uint32_t INI5_WRITE_QOS_AW_QOS =              // Write channel QoS setting (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t INI5_WRITE_QOS_RESET_VALUE = 0x4;

    static constexpr uint32_t INI5_FN_MOD_READ_ISS_OVERRIDE = 0x1;// Override ASIB read issuing capability
    static constexpr uint32_t INI5_FN_MOD_WRITE_ISS_OVERRIDE = 0x2;// Override ASIB write issuing capability
    static const uint32_t INI5_FN_MOD_RESET_VALUE = 0x4;

    template<uint32_t X>
    static constexpr uint32_t INI6_READ_QOS_AR_QOS =              // Read channel QoS setting (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t INI6_READ_QOS_RESET_VALUE = 0x4;

    template<uint32_t X>
    static constexpr uint32_t INI6_WRITE_QOS_AW_QOS =              // Write channel QoS setting (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t INI6_WRITE_QOS_RESET_VALUE = 0x4;

    static constexpr uint32_t INI6_FN_MOD_READ_ISS_OVERRIDE = 0x1;// Override ASIB read issuing capability
    static constexpr uint32_t INI6_FN_MOD_WRITE_ISS_OVERRIDE = 0x2;// Override ASIB write issuing capability
    static const uint32_t INI6_FN_MOD_RESET_VALUE = 0x4;
};

static axi_t& AXI = *reinterpret_cast<axi_t*>(0x51000000);

#define HAVE_PERIPHERAL_AXI


////
//
//    Hash processor
//
////

struct hash_t
{
    volatile uint32_t    CR;                   // control register
    volatile uint32_t    DIN;                  // [Read-write] data input register
    volatile uint32_t    STR;                  // start register
    volatile uint32_t    _HR0;                 // [Read-only] digest registers
    volatile uint32_t    _HR1;                 // [Read-only] digest registers
    volatile uint32_t    _HR2;                 // [Read-only] digest registers
    volatile uint32_t    _HR3;                 // [Read-only] digest registers
    volatile uint32_t    _HR4;                 // [Read-only] digest registers
    volatile uint32_t    IMR;                  // [Read-write] interrupt enable register
    volatile uint32_t    SR;                   // status register
    reserved_t<52>       _0;
    volatile uint32_t    CSR0;                 // [Read-write] context swap registers
    volatile uint32_t    CSR1;                 // [Read-write] context swap registers
    volatile uint32_t    CSR2;                 // [Read-write] context swap registers
    volatile uint32_t    CSR3;                 // [Read-write] context swap registers
    volatile uint32_t    CSR4;                 // [Read-write] context swap registers
    volatile uint32_t    CSR5;                 // [Read-write] context swap registers
    volatile uint32_t    CSR6;                 // [Read-write] context swap registers
    volatile uint32_t    CSR7;                 // [Read-write] context swap registers
    volatile uint32_t    CSR8;                 // [Read-write] context swap registers
    volatile uint32_t    CSR9;                 // [Read-write] context swap registers
    volatile uint32_t    CSR10;                // [Read-write] context swap registers
    volatile uint32_t    CSR11;                // [Read-write] context swap registers
    volatile uint32_t    CSR12;                // [Read-write] context swap registers
    volatile uint32_t    CSR13;                // [Read-write] context swap registers
    volatile uint32_t    CSR14;                // [Read-write] context swap registers
    volatile uint32_t    CSR15;                // [Read-write] context swap registers
    volatile uint32_t    CSR16;                // [Read-write] context swap registers
    volatile uint32_t    CSR17;                // [Read-write] context swap registers
    volatile uint32_t    CSR18;                // [Read-write] context swap registers
    volatile uint32_t    CSR19;                // [Read-write] context swap registers
    volatile uint32_t    CSR20;                // [Read-write] context swap registers
    volatile uint32_t    CSR21;                // [Read-write] context swap registers
    volatile uint32_t    CSR22;                // [Read-write] context swap registers
    volatile uint32_t    CSR23;                // [Read-write] context swap registers
    volatile uint32_t    CSR24;                // [Read-write] context swap registers
    volatile uint32_t    CSR25;                // [Read-write] context swap registers
    volatile uint32_t    CSR26;                // [Read-write] context swap registers
    volatile uint32_t    CSR27;                // [Read-write] context swap registers
    volatile uint32_t    CSR28;                // [Read-write] context swap registers
    volatile uint32_t    CSR29;                // [Read-write] context swap registers
    volatile uint32_t    CSR30;                // [Read-write] context swap registers
    volatile uint32_t    CSR31;                // [Read-write] context swap registers
    volatile uint32_t    CSR32;                // [Read-write] context swap registers
    volatile uint32_t    CSR33;                // [Read-write] context swap registers
    volatile uint32_t    CSR34;                // [Read-write] context swap registers
    volatile uint32_t    CSR35;                // [Read-write] context swap registers
    volatile uint32_t    CSR36;                // [Read-write] context swap registers
    volatile uint32_t    CSR37;                // [Read-write] context swap registers
    volatile uint32_t    CSR38;                // [Read-write] context swap registers
    volatile uint32_t    CSR39;                // [Read-write] context swap registers
    volatile uint32_t    CSR40;                // [Read-write] context swap registers
    volatile uint32_t    CSR41;                // [Read-write] context swap registers
    volatile uint32_t    CSR42;                // [Read-write] context swap registers
    volatile uint32_t    CSR43;                // [Read-write] context swap registers
    volatile uint32_t    CSR44;                // [Read-write] context swap registers
    volatile uint32_t    CSR45;                // [Read-write] context swap registers
    volatile uint32_t    CSR46;                // [Read-write] context swap registers
    volatile uint32_t    CSR47;                // [Read-write] context swap registers
    volatile uint32_t    CSR48;                // [Read-write] context swap registers
    volatile uint32_t    CSR49;                // [Read-write] context swap registers
    volatile uint32_t    CSR50;                // [Read-write] context swap registers
    volatile uint32_t    CSR51;                // [Read-write] context swap registers
    volatile uint32_t    CSR52;                // [Read-write] context swap registers
    volatile uint32_t    CSR53;                // [Read-write] context swap registers
    reserved_t<80>       _1;
    volatile uint32_t    HR0;                  // [Read-only] HASH digest register
    volatile uint32_t    HR1;                  // [Read-only] read-only
    volatile uint32_t    HR2;                  // [Read-only] read-only
    volatile uint32_t    HR3;                  // [Read-only] read-only
    volatile uint32_t    HR4;                  // [Read-only] read-only
    volatile uint32_t    HR5;                  // [Read-only] read-only
    volatile uint32_t    HR6;                  // [Read-only] read-only
    volatile uint32_t    HR7;                  // [Read-only] read-only

    static constexpr uint32_t CR_INIT = 0x4;           // Initialize message digest calculation, Write-only
    static constexpr uint32_t CR_DMAE = 0x8;           // DMA enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t CR_DATATYPE =            // Data type selection (2 bits), Read-write
        bit_field_t<4, 0x3>::value<X>();
    static constexpr uint32_t CR_MODE = 0x40;          // Mode selection, Read-write
    static constexpr uint32_t CR_ALGO0 = 0x80;         // Algorithm selection, Read-write
    template<uint32_t X>
    static constexpr uint32_t CR_NBW =                 // Number of words already pushed (4 bits), Read-only
        bit_field_t<8, 0xf>::value<X>();
    static constexpr uint32_t CR_DINNE = 0x1000;       // DIN not empty, Read-only
    static constexpr uint32_t CR_MDMAT = 0x2000;       // Multiple DMA Transfers, Read-write
    static constexpr uint32_t CR_LKEY = 0x10000;       // Long key selection, Read-write
    static constexpr uint32_t CR_ALGO1 = 0x40000;      // ALGO, Read-write
    static const uint32_t CR_RESET_VALUE = 0x0;


    static const uint32_t DIN_RESET_VALUE = 0x0;

    static constexpr uint32_t STR_DCAL = 0x100;         // Digest calculation, Write-only
    template<uint32_t X>
    static constexpr uint32_t STR_NBLW =                // Number of valid bits in the last word of the message (5 bits), Read-write
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t STR_RESET_VALUE = 0x0;


    static const uint32_t _HR0_RESET_VALUE = 0x0;


    static const uint32_t _HR1_RESET_VALUE = 0x0;


    static const uint32_t _HR2_RESET_VALUE = 0x0;


    static const uint32_t _HR3_RESET_VALUE = 0x0;


    static const uint32_t _HR4_RESET_VALUE = 0x0;

    static constexpr uint32_t IMR_DCIE = 0x2;           // Digest calculation completion interrupt enable
    static constexpr uint32_t IMR_DINIE = 0x1;          // Data input interrupt enable
    static const uint32_t IMR_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_BUSY = 0x8;           // Busy bit, Read-only
    static constexpr uint32_t SR_DMAS = 0x4;           // DMA Status, Read-only
    static constexpr uint32_t SR_DCIS = 0x2;           // Digest calculation completion interrupt status, Read-write
    static constexpr uint32_t SR_DINIS = 0x1;          // Data input interrupt status, Read-write
    static const uint32_t SR_RESET_VALUE = 0x1;


    static const uint32_t CSR0_RESET_VALUE = 0x0;


    static const uint32_t CSR1_RESET_VALUE = 0x0;


    static const uint32_t CSR2_RESET_VALUE = 0x0;


    static const uint32_t CSR3_RESET_VALUE = 0x0;


    static const uint32_t CSR4_RESET_VALUE = 0x0;


    static const uint32_t CSR5_RESET_VALUE = 0x0;


    static const uint32_t CSR6_RESET_VALUE = 0x0;


    static const uint32_t CSR7_RESET_VALUE = 0x0;


    static const uint32_t CSR8_RESET_VALUE = 0x0;


    static const uint32_t CSR9_RESET_VALUE = 0x0;


    static const uint32_t CSR10_RESET_VALUE = 0x0;


    static const uint32_t CSR11_RESET_VALUE = 0x0;


    static const uint32_t CSR12_RESET_VALUE = 0x0;


    static const uint32_t CSR13_RESET_VALUE = 0x0;


    static const uint32_t CSR14_RESET_VALUE = 0x0;


    static const uint32_t CSR15_RESET_VALUE = 0x0;


    static const uint32_t CSR16_RESET_VALUE = 0x0;


    static const uint32_t CSR17_RESET_VALUE = 0x0;


    static const uint32_t CSR18_RESET_VALUE = 0x0;


    static const uint32_t CSR19_RESET_VALUE = 0x0;


    static const uint32_t CSR20_RESET_VALUE = 0x0;


    static const uint32_t CSR21_RESET_VALUE = 0x0;


    static const uint32_t CSR22_RESET_VALUE = 0x0;


    static const uint32_t CSR23_RESET_VALUE = 0x0;


    static const uint32_t CSR24_RESET_VALUE = 0x0;


    static const uint32_t CSR25_RESET_VALUE = 0x0;


    static const uint32_t CSR26_RESET_VALUE = 0x0;


    static const uint32_t CSR27_RESET_VALUE = 0x0;


    static const uint32_t CSR28_RESET_VALUE = 0x0;


    static const uint32_t CSR29_RESET_VALUE = 0x0;


    static const uint32_t CSR30_RESET_VALUE = 0x0;


    static const uint32_t CSR31_RESET_VALUE = 0x0;


    static const uint32_t CSR32_RESET_VALUE = 0x0;


    static const uint32_t CSR33_RESET_VALUE = 0x0;


    static const uint32_t CSR34_RESET_VALUE = 0x0;


    static const uint32_t CSR35_RESET_VALUE = 0x0;


    static const uint32_t CSR36_RESET_VALUE = 0x0;


    static const uint32_t CSR37_RESET_VALUE = 0x0;


    static const uint32_t CSR38_RESET_VALUE = 0x0;


    static const uint32_t CSR39_RESET_VALUE = 0x0;


    static const uint32_t CSR40_RESET_VALUE = 0x0;


    static const uint32_t CSR41_RESET_VALUE = 0x0;


    static const uint32_t CSR42_RESET_VALUE = 0x0;


    static const uint32_t CSR43_RESET_VALUE = 0x0;


    static const uint32_t CSR44_RESET_VALUE = 0x0;


    static const uint32_t CSR45_RESET_VALUE = 0x0;


    static const uint32_t CSR46_RESET_VALUE = 0x0;


    static const uint32_t CSR47_RESET_VALUE = 0x0;


    static const uint32_t CSR48_RESET_VALUE = 0x0;


    static const uint32_t CSR49_RESET_VALUE = 0x0;


    static const uint32_t CSR50_RESET_VALUE = 0x0;


    static const uint32_t CSR51_RESET_VALUE = 0x0;


    static const uint32_t CSR52_RESET_VALUE = 0x0;


    static const uint32_t CSR53_RESET_VALUE = 0x0;


    static const uint32_t HR0_RESET_VALUE = 0x0;


    static const uint32_t HR1_RESET_VALUE = 0x0;


    static const uint32_t HR2_RESET_VALUE = 0x0;


    static const uint32_t HR3_RESET_VALUE = 0x0;


    static const uint32_t HR4_RESET_VALUE = 0x0;


    static const uint32_t HR5_RESET_VALUE = 0x0;


    static const uint32_t HR6_RESET_VALUE = 0x0;


    static const uint32_t HR7_RESET_VALUE = 0x0;

    static constexpr uint8_t HASH_RNG = 80; // HASH and RNG
};

static hash_t& HASH = *reinterpret_cast<hash_t*>(0x48021400);

#define HAVE_PERIPHERAL_HASH


////
//
//    Cryptographic processor
//
////

struct cryp_t
{
    volatile uint32_t    CR;                   // control register
    volatile uint32_t    SR;                   // [Read-only] status register
    volatile uint32_t    DIN;                  // [Read-write] data input register
    volatile uint32_t    DOUT;                 // [Read-only] data output register
    volatile uint32_t    DMACR;                // [Read-write] DMA control register
    volatile uint32_t    IMSCR;                // [Read-write] interrupt mask set/clear register
    volatile uint32_t    RISR;                 // [Read-only] raw interrupt status register
    volatile uint32_t    MISR;                 // [Read-only] masked interrupt status register
    volatile uint32_t    K0LR;                 // [Write-only] key registers
    volatile uint32_t    K0RR;                 // [Write-only] key registers
    volatile uint32_t    K1LR;                 // [Write-only] key registers
    volatile uint32_t    K1RR;                 // [Write-only] key registers
    volatile uint32_t    K2LR;                 // [Write-only] key registers
    volatile uint32_t    K2RR;                 // [Write-only] key registers
    volatile uint32_t    K3LR;                 // [Write-only] key registers
    volatile uint32_t    K3RR;                 // [Write-only] key registers
    volatile uint32_t    IV0LR;                // [Read-write] initialization vector registers
    volatile uint32_t    IV0RR;                // [Read-write] initialization vector registers
    volatile uint32_t    IV1LR;                // [Read-write] initialization vector registers
    volatile uint32_t    IV1RR;                // [Read-write] initialization vector registers
    volatile uint32_t    CSGCMCCM0R;           // [Read-write] context swap register
    volatile uint32_t    CSGCMCCM1R;           // [Read-write] context swap register
    volatile uint32_t    CSGCMCCM2R;           // [Read-write] context swap register
    volatile uint32_t    CSGCMCCM3R;           // [Read-write] context swap register
    volatile uint32_t    CSGCMCCM4R;           // [Read-write] context swap register
    volatile uint32_t    CSGCMCCM5R;           // [Read-write] context swap register
    volatile uint32_t    CSGCMCCM6R;           // [Read-write] context swap register
    volatile uint32_t    CSGCMCCM7R;           // [Read-write] context swap register
    volatile uint32_t    CSGCM0R;              // [Read-write] context swap register
    volatile uint32_t    CSGCM1R;              // [Read-write] context swap register
    volatile uint32_t    CSGCM2R;              // [Read-write] context swap register
    volatile uint32_t    CSGCM3R;              // [Read-write] context swap register
    volatile uint32_t    CSGCM4R;              // [Read-write] context swap register
    volatile uint32_t    CSGCM5R;              // [Read-write] context swap register
    volatile uint32_t    CSGCM6R;              // [Read-write] context swap register
    volatile uint32_t    CSGCM7R;              // [Read-write] context swap register

    static constexpr uint32_t CR_ALGODIR = 0x4;        // Algorithm direction, Read-write
    template<uint32_t X>
    static constexpr uint32_t CR_ALGOMODE0 =           // Algorithm mode (3 bits), Read-write
        bit_field_t<3, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR_DATATYPE =            // Data type selection (2 bits), Read-write
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR_KEYSIZE =             // Key size selection (AES mode only) (2 bits), Read-write
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t CR_FFLUSH = 0x4000;      // FIFO flush, Write-only
    static constexpr uint32_t CR_CRYPEN = 0x8000;      // Cryptographic processor enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t CR_GCM_CCMPH =           // GCM_CCMPH (2 bits), Read-write
        bit_field_t<16, 0x3>::value<X>();
    static constexpr uint32_t CR_ALGOMODE3 = 0x80000;  // ALGOMODE, Read-write
    static const uint32_t CR_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_BUSY = 0x10;          // Busy bit
    static constexpr uint32_t SR_OFFU = 0x8;           // Output FIFO full
    static constexpr uint32_t SR_OFNE = 0x4;           // Output FIFO not empty
    static constexpr uint32_t SR_IFNF = 0x2;           // Input FIFO not full
    static constexpr uint32_t SR_IFEM = 0x1;           // Input FIFO empty
    static const uint32_t SR_RESET_VALUE = 0x3;


    static const uint32_t DIN_RESET_VALUE = 0x0;


    static const uint32_t DOUT_RESET_VALUE = 0x0;

    static constexpr uint32_t DMACR_DOEN = 0x2;           // DMA output enable
    static constexpr uint32_t DMACR_DIEN = 0x1;           // DMA input enable
    static const uint32_t DMACR_RESET_VALUE = 0x0;

    static constexpr uint32_t IMSCR_OUTIM = 0x2;          // Output FIFO service interrupt mask
    static constexpr uint32_t IMSCR_INIM = 0x1;           // Input FIFO service interrupt mask
    static const uint32_t IMSCR_RESET_VALUE = 0x0;

    static constexpr uint32_t RISR_OUTRIS = 0x2;         // Output FIFO service raw interrupt status
    static constexpr uint32_t RISR_INRIS = 0x1;          // Input FIFO service raw interrupt status
    static const uint32_t RISR_RESET_VALUE = 0x1;

    static constexpr uint32_t MISR_OUTMIS = 0x2;         // Output FIFO service masked interrupt status
    static constexpr uint32_t MISR_INMIS = 0x1;          // Input FIFO service masked interrupt status
    static const uint32_t MISR_RESET_VALUE = 0x0;

    static constexpr uint32_t K0LR_K224 = 0x1;           // K224
    static constexpr uint32_t K0LR_K225 = 0x2;           // K225
    static constexpr uint32_t K0LR_K226 = 0x4;           // K226
    static constexpr uint32_t K0LR_K227 = 0x8;           // K227
    static constexpr uint32_t K0LR_K228 = 0x10;          // K228
    static constexpr uint32_t K0LR_K229 = 0x20;          // K229
    static constexpr uint32_t K0LR_K230 = 0x40;          // K230
    static constexpr uint32_t K0LR_K231 = 0x80;          // K231
    static constexpr uint32_t K0LR_K232 = 0x100;         // K232
    static constexpr uint32_t K0LR_K233 = 0x200;         // K233
    static constexpr uint32_t K0LR_K234 = 0x400;         // K234
    static constexpr uint32_t K0LR_K235 = 0x800;         // K235
    static constexpr uint32_t K0LR_K236 = 0x1000;        // K236
    static constexpr uint32_t K0LR_K237 = 0x2000;        // K237
    static constexpr uint32_t K0LR_K238 = 0x4000;        // K238
    static constexpr uint32_t K0LR_K239 = 0x8000;        // K239
    static constexpr uint32_t K0LR_K240 = 0x10000;       // K240
    static constexpr uint32_t K0LR_K241 = 0x20000;       // K241
    static constexpr uint32_t K0LR_K242 = 0x40000;       // K242
    static constexpr uint32_t K0LR_K243 = 0x80000;       // K243
    static constexpr uint32_t K0LR_K244 = 0x100000;      // K244
    static constexpr uint32_t K0LR_K245 = 0x200000;      // K245
    static constexpr uint32_t K0LR_K246 = 0x400000;      // K246
    static constexpr uint32_t K0LR_K247 = 0x800000;      // K247
    static constexpr uint32_t K0LR_K248 = 0x1000000;     // K248
    static constexpr uint32_t K0LR_K249 = 0x2000000;     // K249
    static constexpr uint32_t K0LR_K250 = 0x4000000;     // K250
    static constexpr uint32_t K0LR_K251 = 0x8000000;     // K251
    static constexpr uint32_t K0LR_K252 = 0x10000000;    // K252
    static constexpr uint32_t K0LR_K253 = 0x20000000;    // K253
    static constexpr uint32_t K0LR_K254 = 0x40000000;    // K254
    static constexpr uint32_t K0LR_K255 = 0x80000000;    // K255
    static const uint32_t K0LR_RESET_VALUE = 0x0;

    static constexpr uint32_t K0RR_K192 = 0x1;           // K192
    static constexpr uint32_t K0RR_K193 = 0x2;           // K193
    static constexpr uint32_t K0RR_K194 = 0x4;           // K194
    static constexpr uint32_t K0RR_K195 = 0x8;           // K195
    static constexpr uint32_t K0RR_K196 = 0x10;          // K196
    static constexpr uint32_t K0RR_K197 = 0x20;          // K197
    static constexpr uint32_t K0RR_K198 = 0x40;          // K198
    static constexpr uint32_t K0RR_K199 = 0x80;          // K199
    static constexpr uint32_t K0RR_K200 = 0x100;         // K200
    static constexpr uint32_t K0RR_K201 = 0x200;         // K201
    static constexpr uint32_t K0RR_K202 = 0x400;         // K202
    static constexpr uint32_t K0RR_K203 = 0x800;         // K203
    static constexpr uint32_t K0RR_K204 = 0x1000;        // K204
    static constexpr uint32_t K0RR_K205 = 0x2000;        // K205
    static constexpr uint32_t K0RR_K206 = 0x4000;        // K206
    static constexpr uint32_t K0RR_K207 = 0x8000;        // K207
    static constexpr uint32_t K0RR_K208 = 0x10000;       // K208
    static constexpr uint32_t K0RR_K209 = 0x20000;       // K209
    static constexpr uint32_t K0RR_K210 = 0x40000;       // K210
    static constexpr uint32_t K0RR_K211 = 0x80000;       // K211
    static constexpr uint32_t K0RR_K212 = 0x100000;      // K212
    static constexpr uint32_t K0RR_K213 = 0x200000;      // K213
    static constexpr uint32_t K0RR_K214 = 0x400000;      // K214
    static constexpr uint32_t K0RR_K215 = 0x800000;      // K215
    static constexpr uint32_t K0RR_K216 = 0x1000000;     // K216
    static constexpr uint32_t K0RR_K217 = 0x2000000;     // K217
    static constexpr uint32_t K0RR_K218 = 0x4000000;     // K218
    static constexpr uint32_t K0RR_K219 = 0x8000000;     // K219
    static constexpr uint32_t K0RR_K220 = 0x10000000;    // K220
    static constexpr uint32_t K0RR_K221 = 0x20000000;    // K221
    static constexpr uint32_t K0RR_K222 = 0x40000000;    // K222
    static constexpr uint32_t K0RR_K223 = 0x80000000;    // K223
    static const uint32_t K0RR_RESET_VALUE = 0x0;

    static constexpr uint32_t K1LR_K160 = 0x1;           // K160
    static constexpr uint32_t K1LR_K161 = 0x2;           // K161
    static constexpr uint32_t K1LR_K162 = 0x4;           // K162
    static constexpr uint32_t K1LR_K163 = 0x8;           // K163
    static constexpr uint32_t K1LR_K164 = 0x10;          // K164
    static constexpr uint32_t K1LR_K165 = 0x20;          // K165
    static constexpr uint32_t K1LR_K166 = 0x40;          // K166
    static constexpr uint32_t K1LR_K167 = 0x80;          // K167
    static constexpr uint32_t K1LR_K168 = 0x100;         // K168
    static constexpr uint32_t K1LR_K169 = 0x200;         // K169
    static constexpr uint32_t K1LR_K170 = 0x400;         // K170
    static constexpr uint32_t K1LR_K171 = 0x800;         // K171
    static constexpr uint32_t K1LR_K172 = 0x1000;        // K172
    static constexpr uint32_t K1LR_K173 = 0x2000;        // K173
    static constexpr uint32_t K1LR_K174 = 0x4000;        // K174
    static constexpr uint32_t K1LR_K175 = 0x8000;        // K175
    static constexpr uint32_t K1LR_K176 = 0x10000;       // K176
    static constexpr uint32_t K1LR_K177 = 0x20000;       // K177
    static constexpr uint32_t K1LR_K178 = 0x40000;       // K178
    static constexpr uint32_t K1LR_K179 = 0x80000;       // K179
    static constexpr uint32_t K1LR_K180 = 0x100000;      // K180
    static constexpr uint32_t K1LR_K181 = 0x200000;      // K181
    static constexpr uint32_t K1LR_K182 = 0x400000;      // K182
    static constexpr uint32_t K1LR_K183 = 0x800000;      // K183
    static constexpr uint32_t K1LR_K184 = 0x1000000;     // K184
    static constexpr uint32_t K1LR_K185 = 0x2000000;     // K185
    static constexpr uint32_t K1LR_K186 = 0x4000000;     // K186
    static constexpr uint32_t K1LR_K187 = 0x8000000;     // K187
    static constexpr uint32_t K1LR_K188 = 0x10000000;    // K188
    static constexpr uint32_t K1LR_K189 = 0x20000000;    // K189
    static constexpr uint32_t K1LR_K190 = 0x40000000;    // K190
    static constexpr uint32_t K1LR_K191 = 0x80000000;    // K191
    static const uint32_t K1LR_RESET_VALUE = 0x0;

    static constexpr uint32_t K1RR_K128 = 0x1;           // K128
    static constexpr uint32_t K1RR_K129 = 0x2;           // K129
    static constexpr uint32_t K1RR_K130 = 0x4;           // K130
    static constexpr uint32_t K1RR_K131 = 0x8;           // K131
    static constexpr uint32_t K1RR_K132 = 0x10;          // K132
    static constexpr uint32_t K1RR_K133 = 0x20;          // K133
    static constexpr uint32_t K1RR_K134 = 0x40;          // K134
    static constexpr uint32_t K1RR_K135 = 0x80;          // K135
    static constexpr uint32_t K1RR_K136 = 0x100;         // K136
    static constexpr uint32_t K1RR_K137 = 0x200;         // K137
    static constexpr uint32_t K1RR_K138 = 0x400;         // K138
    static constexpr uint32_t K1RR_K139 = 0x800;         // K139
    static constexpr uint32_t K1RR_K140 = 0x1000;        // K140
    static constexpr uint32_t K1RR_K141 = 0x2000;        // K141
    static constexpr uint32_t K1RR_K142 = 0x4000;        // K142
    static constexpr uint32_t K1RR_K143 = 0x8000;        // K143
    static constexpr uint32_t K1RR_K144 = 0x10000;       // K144
    static constexpr uint32_t K1RR_K145 = 0x20000;       // K145
    static constexpr uint32_t K1RR_K146 = 0x40000;       // K146
    static constexpr uint32_t K1RR_K147 = 0x80000;       // K147
    static constexpr uint32_t K1RR_K148 = 0x100000;      // K148
    static constexpr uint32_t K1RR_K149 = 0x200000;      // K149
    static constexpr uint32_t K1RR_K150 = 0x400000;      // K150
    static constexpr uint32_t K1RR_K151 = 0x800000;      // K151
    static constexpr uint32_t K1RR_K152 = 0x1000000;     // K152
    static constexpr uint32_t K1RR_K153 = 0x2000000;     // K153
    static constexpr uint32_t K1RR_K154 = 0x4000000;     // K154
    static constexpr uint32_t K1RR_K155 = 0x8000000;     // K155
    static constexpr uint32_t K1RR_K156 = 0x10000000;    // K156
    static constexpr uint32_t K1RR_K157 = 0x20000000;    // K157
    static constexpr uint32_t K1RR_K158 = 0x40000000;    // K158
    static constexpr uint32_t K1RR_K159 = 0x80000000;    // K159
    static const uint32_t K1RR_RESET_VALUE = 0x0;

    static constexpr uint32_t K2LR_K96 = 0x1;            // K96
    static constexpr uint32_t K2LR_K97 = 0x2;            // K97
    static constexpr uint32_t K2LR_K98 = 0x4;            // K98
    static constexpr uint32_t K2LR_K99 = 0x8;            // K99
    static constexpr uint32_t K2LR_K100 = 0x10;          // K100
    static constexpr uint32_t K2LR_K101 = 0x20;          // K101
    static constexpr uint32_t K2LR_K102 = 0x40;          // K102
    static constexpr uint32_t K2LR_K103 = 0x80;          // K103
    static constexpr uint32_t K2LR_K104 = 0x100;         // K104
    static constexpr uint32_t K2LR_K105 = 0x200;         // K105
    static constexpr uint32_t K2LR_K106 = 0x400;         // K106
    static constexpr uint32_t K2LR_K107 = 0x800;         // K107
    static constexpr uint32_t K2LR_K108 = 0x1000;        // K108
    static constexpr uint32_t K2LR_K109 = 0x2000;        // K109
    static constexpr uint32_t K2LR_K110 = 0x4000;        // K110
    static constexpr uint32_t K2LR_K111 = 0x8000;        // K111
    static constexpr uint32_t K2LR_K112 = 0x10000;       // K112
    static constexpr uint32_t K2LR_K113 = 0x20000;       // K113
    static constexpr uint32_t K2LR_K114 = 0x40000;       // K114
    static constexpr uint32_t K2LR_K115 = 0x80000;       // K115
    static constexpr uint32_t K2LR_K116 = 0x100000;      // K116
    static constexpr uint32_t K2LR_K117 = 0x200000;      // K117
    static constexpr uint32_t K2LR_K118 = 0x400000;      // K118
    static constexpr uint32_t K2LR_K119 = 0x800000;      // K119
    static constexpr uint32_t K2LR_K120 = 0x1000000;     // K120
    static constexpr uint32_t K2LR_K121 = 0x2000000;     // K121
    static constexpr uint32_t K2LR_K122 = 0x4000000;     // K122
    static constexpr uint32_t K2LR_K123 = 0x8000000;     // K123
    static constexpr uint32_t K2LR_K124 = 0x10000000;    // K124
    static constexpr uint32_t K2LR_K125 = 0x20000000;    // K125
    static constexpr uint32_t K2LR_K126 = 0x40000000;    // K126
    static constexpr uint32_t K2LR_K127 = 0x80000000;    // K127
    static const uint32_t K2LR_RESET_VALUE = 0x0;

    static constexpr uint32_t K2RR_K64 = 0x1;            // K64
    static constexpr uint32_t K2RR_K65 = 0x2;            // K65
    static constexpr uint32_t K2RR_K66 = 0x4;            // K66
    static constexpr uint32_t K2RR_K67 = 0x8;            // K67
    static constexpr uint32_t K2RR_K68 = 0x10;           // K68
    static constexpr uint32_t K2RR_K69 = 0x20;           // K69
    static constexpr uint32_t K2RR_K70 = 0x40;           // K70
    static constexpr uint32_t K2RR_K71 = 0x80;           // K71
    static constexpr uint32_t K2RR_K72 = 0x100;          // K72
    static constexpr uint32_t K2RR_K73 = 0x200;          // K73
    static constexpr uint32_t K2RR_K74 = 0x400;          // K74
    static constexpr uint32_t K2RR_K75 = 0x800;          // K75
    static constexpr uint32_t K2RR_K76 = 0x1000;         // K76
    static constexpr uint32_t K2RR_K77 = 0x2000;         // K77
    static constexpr uint32_t K2RR_K78 = 0x4000;         // K78
    static constexpr uint32_t K2RR_K79 = 0x8000;         // K79
    static constexpr uint32_t K2RR_K80 = 0x10000;        // K80
    static constexpr uint32_t K2RR_K81 = 0x20000;        // K81
    static constexpr uint32_t K2RR_K82 = 0x40000;        // K82
    static constexpr uint32_t K2RR_K83 = 0x80000;        // K83
    static constexpr uint32_t K2RR_K84 = 0x100000;       // K84
    static constexpr uint32_t K2RR_K85 = 0x200000;       // K85
    static constexpr uint32_t K2RR_K86 = 0x400000;       // K86
    static constexpr uint32_t K2RR_K87 = 0x800000;       // K87
    static constexpr uint32_t K2RR_K88 = 0x1000000;      // K88
    static constexpr uint32_t K2RR_K89 = 0x2000000;      // K89
    static constexpr uint32_t K2RR_K90 = 0x4000000;      // K90
    static constexpr uint32_t K2RR_K91 = 0x8000000;      // K91
    static constexpr uint32_t K2RR_K92 = 0x10000000;     // K92
    static constexpr uint32_t K2RR_K93 = 0x20000000;     // K93
    static constexpr uint32_t K2RR_K94 = 0x40000000;     // K94
    static constexpr uint32_t K2RR_K95 = 0x80000000;     // K95
    static const uint32_t K2RR_RESET_VALUE = 0x0;

    static constexpr uint32_t K3LR_K32 = 0x1;            // K32
    static constexpr uint32_t K3LR_K33 = 0x2;            // K33
    static constexpr uint32_t K3LR_K34 = 0x4;            // K34
    static constexpr uint32_t K3LR_K35 = 0x8;            // K35
    static constexpr uint32_t K3LR_K36 = 0x10;           // K36
    static constexpr uint32_t K3LR_K37 = 0x20;           // K37
    static constexpr uint32_t K3LR_K38 = 0x40;           // K38
    static constexpr uint32_t K3LR_K39 = 0x80;           // K39
    static constexpr uint32_t K3LR_K40 = 0x100;          // K40
    static constexpr uint32_t K3LR_K41 = 0x200;          // K41
    static constexpr uint32_t K3LR_K42 = 0x400;          // K42
    static constexpr uint32_t K3LR_K43 = 0x800;          // K43
    static constexpr uint32_t K3LR_K44 = 0x1000;         // K44
    static constexpr uint32_t K3LR_K45 = 0x2000;         // K45
    static constexpr uint32_t K3LR_K46 = 0x4000;         // K46
    static constexpr uint32_t K3LR_K47 = 0x8000;         // K47
    static constexpr uint32_t K3LR_K48 = 0x10000;        // K48
    static constexpr uint32_t K3LR_K49 = 0x20000;        // K49
    static constexpr uint32_t K3LR_K50 = 0x40000;        // K50
    static constexpr uint32_t K3LR_K51 = 0x80000;        // K51
    static constexpr uint32_t K3LR_K52 = 0x100000;       // K52
    static constexpr uint32_t K3LR_K53 = 0x200000;       // K53
    static constexpr uint32_t K3LR_K54 = 0x400000;       // K54
    static constexpr uint32_t K3LR_K55 = 0x800000;       // K55
    static constexpr uint32_t K3LR_K56 = 0x1000000;      // K56
    static constexpr uint32_t K3LR_K57 = 0x2000000;      // K57
    static constexpr uint32_t K3LR_K58 = 0x4000000;      // K58
    static constexpr uint32_t K3LR_K59 = 0x8000000;      // K59
    static constexpr uint32_t K3LR_K60 = 0x10000000;     // K60
    static constexpr uint32_t K3LR_K61 = 0x20000000;     // K61
    static constexpr uint32_t K3LR_K62 = 0x40000000;     // K62
    static constexpr uint32_t K3LR_K63 = 0x80000000;     // K63
    static const uint32_t K3LR_RESET_VALUE = 0x0;

    static constexpr uint32_t K3RR_K0 = 0x1;             // K0
    static constexpr uint32_t K3RR_K1 = 0x2;             // K1
    static constexpr uint32_t K3RR_K2 = 0x4;             // K2
    static constexpr uint32_t K3RR_K3 = 0x8;             // K3
    static constexpr uint32_t K3RR_K4 = 0x10;            // K4
    static constexpr uint32_t K3RR_K5 = 0x20;            // K5
    static constexpr uint32_t K3RR_K6 = 0x40;            // K6
    static constexpr uint32_t K3RR_K7 = 0x80;            // K7
    static constexpr uint32_t K3RR_K8 = 0x100;           // K8
    static constexpr uint32_t K3RR_K9 = 0x200;           // K9
    static constexpr uint32_t K3RR_K10 = 0x400;          // K10
    static constexpr uint32_t K3RR_K11 = 0x800;          // K11
    static constexpr uint32_t K3RR_K12 = 0x1000;         // K12
    static constexpr uint32_t K3RR_K13 = 0x2000;         // K13
    static constexpr uint32_t K3RR_K14 = 0x4000;         // K14
    static constexpr uint32_t K3RR_K15 = 0x8000;         // K15
    static constexpr uint32_t K3RR_K16 = 0x10000;        // K16
    static constexpr uint32_t K3RR_K17 = 0x20000;        // K17
    static constexpr uint32_t K3RR_K18 = 0x40000;        // K18
    static constexpr uint32_t K3RR_K19 = 0x80000;        // K19
    static constexpr uint32_t K3RR_K20 = 0x100000;       // K20
    static constexpr uint32_t K3RR_K21 = 0x200000;       // K21
    static constexpr uint32_t K3RR_K22 = 0x400000;       // K22
    static constexpr uint32_t K3RR_K23 = 0x800000;       // K23
    static constexpr uint32_t K3RR_K24 = 0x1000000;      // K24
    static constexpr uint32_t K3RR_K25 = 0x2000000;      // K25
    static constexpr uint32_t K3RR_K26 = 0x4000000;      // K26
    static constexpr uint32_t K3RR_K27 = 0x8000000;      // K27
    static constexpr uint32_t K3RR_K28 = 0x10000000;     // K28
    static constexpr uint32_t K3RR_K29 = 0x20000000;     // K29
    static constexpr uint32_t K3RR_K30 = 0x40000000;     // K30
    static constexpr uint32_t K3RR_K31 = 0x80000000;     // K31
    static const uint32_t K3RR_RESET_VALUE = 0x0;

    static constexpr uint32_t IV0LR_IV31 = 0x1;           // IV31
    static constexpr uint32_t IV0LR_IV30 = 0x2;           // IV30
    static constexpr uint32_t IV0LR_IV29 = 0x4;           // IV29
    static constexpr uint32_t IV0LR_IV28 = 0x8;           // IV28
    static constexpr uint32_t IV0LR_IV27 = 0x10;          // IV27
    static constexpr uint32_t IV0LR_IV26 = 0x20;          // IV26
    static constexpr uint32_t IV0LR_IV25 = 0x40;          // IV25
    static constexpr uint32_t IV0LR_IV24 = 0x80;          // IV24
    static constexpr uint32_t IV0LR_IV23 = 0x100;         // IV23
    static constexpr uint32_t IV0LR_IV22 = 0x200;         // IV22
    static constexpr uint32_t IV0LR_IV21 = 0x400;         // IV21
    static constexpr uint32_t IV0LR_IV20 = 0x800;         // IV20
    static constexpr uint32_t IV0LR_IV19 = 0x1000;        // IV19
    static constexpr uint32_t IV0LR_IV18 = 0x2000;        // IV18
    static constexpr uint32_t IV0LR_IV17 = 0x4000;        // IV17
    static constexpr uint32_t IV0LR_IV16 = 0x8000;        // IV16
    static constexpr uint32_t IV0LR_IV15 = 0x10000;       // IV15
    static constexpr uint32_t IV0LR_IV14 = 0x20000;       // IV14
    static constexpr uint32_t IV0LR_IV13 = 0x40000;       // IV13
    static constexpr uint32_t IV0LR_IV12 = 0x80000;       // IV12
    static constexpr uint32_t IV0LR_IV11 = 0x100000;      // IV11
    static constexpr uint32_t IV0LR_IV10 = 0x200000;      // IV10
    static constexpr uint32_t IV0LR_IV9 = 0x400000;       // IV9
    static constexpr uint32_t IV0LR_IV8 = 0x800000;       // IV8
    static constexpr uint32_t IV0LR_IV7 = 0x1000000;      // IV7
    static constexpr uint32_t IV0LR_IV6 = 0x2000000;      // IV6
    static constexpr uint32_t IV0LR_IV5 = 0x4000000;      // IV5
    static constexpr uint32_t IV0LR_IV4 = 0x8000000;      // IV4
    static constexpr uint32_t IV0LR_IV3 = 0x10000000;     // IV3
    static constexpr uint32_t IV0LR_IV2 = 0x20000000;     // IV2
    static constexpr uint32_t IV0LR_IV1 = 0x40000000;     // IV1
    static constexpr uint32_t IV0LR_IV0 = 0x80000000;     // IV0
    static const uint32_t IV0LR_RESET_VALUE = 0x0;

    static constexpr uint32_t IV0RR_IV63 = 0x1;           // IV63
    static constexpr uint32_t IV0RR_IV62 = 0x2;           // IV62
    static constexpr uint32_t IV0RR_IV61 = 0x4;           // IV61
    static constexpr uint32_t IV0RR_IV60 = 0x8;           // IV60
    static constexpr uint32_t IV0RR_IV59 = 0x10;          // IV59
    static constexpr uint32_t IV0RR_IV58 = 0x20;          // IV58
    static constexpr uint32_t IV0RR_IV57 = 0x40;          // IV57
    static constexpr uint32_t IV0RR_IV56 = 0x80;          // IV56
    static constexpr uint32_t IV0RR_IV55 = 0x100;         // IV55
    static constexpr uint32_t IV0RR_IV54 = 0x200;         // IV54
    static constexpr uint32_t IV0RR_IV53 = 0x400;         // IV53
    static constexpr uint32_t IV0RR_IV52 = 0x800;         // IV52
    static constexpr uint32_t IV0RR_IV51 = 0x1000;        // IV51
    static constexpr uint32_t IV0RR_IV50 = 0x2000;        // IV50
    static constexpr uint32_t IV0RR_IV49 = 0x4000;        // IV49
    static constexpr uint32_t IV0RR_IV48 = 0x8000;        // IV48
    static constexpr uint32_t IV0RR_IV47 = 0x10000;       // IV47
    static constexpr uint32_t IV0RR_IV46 = 0x20000;       // IV46
    static constexpr uint32_t IV0RR_IV45 = 0x40000;       // IV45
    static constexpr uint32_t IV0RR_IV44 = 0x80000;       // IV44
    static constexpr uint32_t IV0RR_IV43 = 0x100000;      // IV43
    static constexpr uint32_t IV0RR_IV42 = 0x200000;      // IV42
    static constexpr uint32_t IV0RR_IV41 = 0x400000;      // IV41
    static constexpr uint32_t IV0RR_IV40 = 0x800000;      // IV40
    static constexpr uint32_t IV0RR_IV39 = 0x1000000;     // IV39
    static constexpr uint32_t IV0RR_IV38 = 0x2000000;     // IV38
    static constexpr uint32_t IV0RR_IV37 = 0x4000000;     // IV37
    static constexpr uint32_t IV0RR_IV36 = 0x8000000;     // IV36
    static constexpr uint32_t IV0RR_IV35 = 0x10000000;    // IV35
    static constexpr uint32_t IV0RR_IV34 = 0x20000000;    // IV34
    static constexpr uint32_t IV0RR_IV33 = 0x40000000;    // IV33
    static constexpr uint32_t IV0RR_IV32 = 0x80000000;    // IV32
    static const uint32_t IV0RR_RESET_VALUE = 0x0;

    static constexpr uint32_t IV1LR_IV95 = 0x1;           // IV95
    static constexpr uint32_t IV1LR_IV94 = 0x2;           // IV94
    static constexpr uint32_t IV1LR_IV93 = 0x4;           // IV93
    static constexpr uint32_t IV1LR_IV92 = 0x8;           // IV92
    static constexpr uint32_t IV1LR_IV91 = 0x10;          // IV91
    static constexpr uint32_t IV1LR_IV90 = 0x20;          // IV90
    static constexpr uint32_t IV1LR_IV89 = 0x40;          // IV89
    static constexpr uint32_t IV1LR_IV88 = 0x80;          // IV88
    static constexpr uint32_t IV1LR_IV87 = 0x100;         // IV87
    static constexpr uint32_t IV1LR_IV86 = 0x200;         // IV86
    static constexpr uint32_t IV1LR_IV85 = 0x400;         // IV85
    static constexpr uint32_t IV1LR_IV84 = 0x800;         // IV84
    static constexpr uint32_t IV1LR_IV83 = 0x1000;        // IV83
    static constexpr uint32_t IV1LR_IV82 = 0x2000;        // IV82
    static constexpr uint32_t IV1LR_IV81 = 0x4000;        // IV81
    static constexpr uint32_t IV1LR_IV80 = 0x8000;        // IV80
    static constexpr uint32_t IV1LR_IV79 = 0x10000;       // IV79
    static constexpr uint32_t IV1LR_IV78 = 0x20000;       // IV78
    static constexpr uint32_t IV1LR_IV77 = 0x40000;       // IV77
    static constexpr uint32_t IV1LR_IV76 = 0x80000;       // IV76
    static constexpr uint32_t IV1LR_IV75 = 0x100000;      // IV75
    static constexpr uint32_t IV1LR_IV74 = 0x200000;      // IV74
    static constexpr uint32_t IV1LR_IV73 = 0x400000;      // IV73
    static constexpr uint32_t IV1LR_IV72 = 0x800000;      // IV72
    static constexpr uint32_t IV1LR_IV71 = 0x1000000;     // IV71
    static constexpr uint32_t IV1LR_IV70 = 0x2000000;     // IV70
    static constexpr uint32_t IV1LR_IV69 = 0x4000000;     // IV69
    static constexpr uint32_t IV1LR_IV68 = 0x8000000;     // IV68
    static constexpr uint32_t IV1LR_IV67 = 0x10000000;    // IV67
    static constexpr uint32_t IV1LR_IV66 = 0x20000000;    // IV66
    static constexpr uint32_t IV1LR_IV65 = 0x40000000;    // IV65
    static constexpr uint32_t IV1LR_IV64 = 0x80000000;    // IV64
    static const uint32_t IV1LR_RESET_VALUE = 0x0;

    static constexpr uint32_t IV1RR_IV127 = 0x1;          // IV127
    static constexpr uint32_t IV1RR_IV126 = 0x2;          // IV126
    static constexpr uint32_t IV1RR_IV125 = 0x4;          // IV125
    static constexpr uint32_t IV1RR_IV124 = 0x8;          // IV124
    static constexpr uint32_t IV1RR_IV123 = 0x10;         // IV123
    static constexpr uint32_t IV1RR_IV122 = 0x20;         // IV122
    static constexpr uint32_t IV1RR_IV121 = 0x40;         // IV121
    static constexpr uint32_t IV1RR_IV120 = 0x80;         // IV120
    static constexpr uint32_t IV1RR_IV119 = 0x100;        // IV119
    static constexpr uint32_t IV1RR_IV118 = 0x200;        // IV118
    static constexpr uint32_t IV1RR_IV117 = 0x400;        // IV117
    static constexpr uint32_t IV1RR_IV116 = 0x800;        // IV116
    static constexpr uint32_t IV1RR_IV115 = 0x1000;       // IV115
    static constexpr uint32_t IV1RR_IV114 = 0x2000;       // IV114
    static constexpr uint32_t IV1RR_IV113 = 0x4000;       // IV113
    static constexpr uint32_t IV1RR_IV112 = 0x8000;       // IV112
    static constexpr uint32_t IV1RR_IV111 = 0x10000;      // IV111
    static constexpr uint32_t IV1RR_IV110 = 0x20000;      // IV110
    static constexpr uint32_t IV1RR_IV109 = 0x40000;      // IV109
    static constexpr uint32_t IV1RR_IV108 = 0x80000;      // IV108
    static constexpr uint32_t IV1RR_IV107 = 0x100000;     // IV107
    static constexpr uint32_t IV1RR_IV106 = 0x200000;     // IV106
    static constexpr uint32_t IV1RR_IV105 = 0x400000;     // IV105
    static constexpr uint32_t IV1RR_IV104 = 0x800000;     // IV104
    static constexpr uint32_t IV1RR_IV103 = 0x1000000;    // IV103
    static constexpr uint32_t IV1RR_IV102 = 0x2000000;    // IV102
    static constexpr uint32_t IV1RR_IV101 = 0x4000000;    // IV101
    static constexpr uint32_t IV1RR_IV100 = 0x8000000;    // IV100
    static constexpr uint32_t IV1RR_IV99 = 0x10000000;    // IV99
    static constexpr uint32_t IV1RR_IV98 = 0x20000000;    // IV98
    static constexpr uint32_t IV1RR_IV97 = 0x40000000;    // IV97
    static constexpr uint32_t IV1RR_IV96 = 0x80000000;    // IV96
    static const uint32_t IV1RR_RESET_VALUE = 0x0;


    static const uint32_t CSGCMCCM0R_RESET_VALUE = 0x0;


    static const uint32_t CSGCMCCM1R_RESET_VALUE = 0x0;


    static const uint32_t CSGCMCCM2R_RESET_VALUE = 0x0;


    static const uint32_t CSGCMCCM3R_RESET_VALUE = 0x0;


    static const uint32_t CSGCMCCM4R_RESET_VALUE = 0x0;


    static const uint32_t CSGCMCCM5R_RESET_VALUE = 0x0;


    static const uint32_t CSGCMCCM6R_RESET_VALUE = 0x0;


    static const uint32_t CSGCMCCM7R_RESET_VALUE = 0x0;


    static const uint32_t CSGCM0R_RESET_VALUE = 0x0;


    static const uint32_t CSGCM1R_RESET_VALUE = 0x0;


    static const uint32_t CSGCM2R_RESET_VALUE = 0x0;


    static const uint32_t CSGCM3R_RESET_VALUE = 0x0;


    static const uint32_t CSGCM4R_RESET_VALUE = 0x0;


    static const uint32_t CSGCM5R_RESET_VALUE = 0x0;


    static const uint32_t CSGCM6R_RESET_VALUE = 0x0;


    static const uint32_t CSGCM7R_RESET_VALUE = 0x0;

    static constexpr uint8_t CRYP = 79; // CRYP global interrupt
};

static cryp_t& CRYP = *reinterpret_cast<cryp_t*>(0x48021000);

#define HAVE_PERIPHERAL_CRYP


////
//
//    Digital camera interface
//
////

struct dcmi_t
{
    volatile uint32_t    CR;                   // [Read-write] control register 1
    volatile uint32_t    SR;                   // [Read-only] status register
    volatile uint32_t    RIS;                  // [Read-only] raw interrupt status register
    volatile uint32_t    IER;                  // [Read-write] interrupt enable register
    volatile uint32_t    MIS;                  // [Read-only] masked interrupt status register
    volatile uint32_t    ICR;                  // [Write-only] interrupt clear register
    volatile uint32_t    ESCR;                 // [Read-write] embedded synchronization code register
    volatile uint32_t    ESUR;                 // [Read-write] embedded synchronization unmask register
    volatile uint32_t    CWSTRT;               // [Read-write] crop window start
    volatile uint32_t    CWSIZE;               // [Read-write] crop window size
    volatile uint32_t    DR;                   // [Read-only] data register

    static constexpr uint32_t CR_OELS = 0x100000;      // Odd/Even Line Select (Line Select Start)
    static constexpr uint32_t CR_LSM = 0x80000;        // Line Select mode
    static constexpr uint32_t CR_OEBS = 0x40000;       // Odd/Even Byte Select (Byte Select Start)
    template<uint32_t X>
    static constexpr uint32_t CR_BSM =                 // Byte Select mode (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    static constexpr uint32_t CR_ENABLE = 0x4000;      // DCMI enable
    template<uint32_t X>
    static constexpr uint32_t CR_EDM =                 // Extended data mode (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR_FCRC =                // Frame capture rate control (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t CR_VSPOL = 0x80;         // Vertical synchronization polarity
    static constexpr uint32_t CR_HSPOL = 0x40;         // Horizontal synchronization polarity
    static constexpr uint32_t CR_PCKPOL = 0x20;        // Pixel clock polarity
    static constexpr uint32_t CR_ESS = 0x10;           // Embedded synchronization select
    static constexpr uint32_t CR_JPEG = 0x8;           // JPEG format
    static constexpr uint32_t CR_CROP = 0x4;           // Crop feature
    static constexpr uint32_t CR_CM = 0x2;             // Capture mode
    static constexpr uint32_t CR_CAPTURE = 0x1;        // Capture enable
    static const uint32_t CR_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_FNE = 0x4;            // FIFO not empty
    static constexpr uint32_t SR_VSYNC = 0x2;          // VSYNC
    static constexpr uint32_t SR_HSYNC = 0x1;          // HSYNC
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint32_t RIS_LINE_RIS = 0x10;      // Line raw interrupt status
    static constexpr uint32_t RIS_VSYNC_RIS = 0x8;      // VSYNC raw interrupt status
    static constexpr uint32_t RIS_ERR_RIS = 0x4;        // Synchronization error raw interrupt status
    static constexpr uint32_t RIS_OVR_RIS = 0x2;        // Overrun raw interrupt status
    static constexpr uint32_t RIS_FRAME_RIS = 0x1;      // Capture complete raw interrupt status
    static const uint32_t RIS_RESET_VALUE = 0x0;

    static constexpr uint32_t IER_LINE_IE = 0x10;       // Line interrupt enable
    static constexpr uint32_t IER_VSYNC_IE = 0x8;       // VSYNC interrupt enable
    static constexpr uint32_t IER_ERR_IE = 0x4;         // Synchronization error interrupt enable
    static constexpr uint32_t IER_OVR_IE = 0x2;         // Overrun interrupt enable
    static constexpr uint32_t IER_FRAME_IE = 0x1;       // Capture complete interrupt enable
    static const uint32_t IER_RESET_VALUE = 0x0;

    static constexpr uint32_t MIS_LINE_MIS = 0x10;      // Line masked interrupt status
    static constexpr uint32_t MIS_VSYNC_MIS = 0x8;      // VSYNC masked interrupt status
    static constexpr uint32_t MIS_ERR_MIS = 0x4;        // Synchronization error masked interrupt status
    static constexpr uint32_t MIS_OVR_MIS = 0x2;        // Overrun masked interrupt status
    static constexpr uint32_t MIS_FRAME_MIS = 0x1;      // Capture complete masked interrupt status
    static const uint32_t MIS_RESET_VALUE = 0x0;

    static constexpr uint32_t ICR_LINE_ISC = 0x10;      // line interrupt status clear
    static constexpr uint32_t ICR_VSYNC_ISC = 0x8;      // Vertical synch interrupt status clear
    static constexpr uint32_t ICR_ERR_ISC = 0x4;        // Synchronization error interrupt status clear
    static constexpr uint32_t ICR_OVR_ISC = 0x2;        // Overrun interrupt status clear
    static constexpr uint32_t ICR_FRAME_ISC = 0x1;      // Capture complete interrupt status clear
    static const uint32_t ICR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ESCR_FEC =                 // Frame end delimiter code (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ESCR_LEC =                 // Line end delimiter code (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ESCR_LSC =                 // Line start delimiter code (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ESCR_FSC =                 // Frame start delimiter code (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t ESCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ESUR_FEU =                 // Frame end delimiter unmask (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ESUR_LEU =                 // Line end delimiter unmask (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ESUR_LSU =                 // Line start delimiter unmask (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ESUR_FSU =                 // Frame start delimiter unmask (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t ESUR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CWSTRT_VST =                 // Vertical start line count (13 bits)
        bit_field_t<16, 0x1fff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CWSTRT_HOFFCNT =             // Horizontal offset count (14 bits)
        bit_field_t<0, 0x3fff>::value<X>();
    static const uint32_t CWSTRT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CWSIZE_VLINE =               // Vertical line count (14 bits)
        bit_field_t<16, 0x3fff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CWSIZE_CAPCNT =              // Capture count (14 bits)
        bit_field_t<0, 0x3fff>::value<X>();
    static const uint32_t CWSIZE_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DR_Byte3 =               // Data byte 3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DR_Byte2 =               // Data byte 2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DR_Byte1 =               // Data byte 1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DR_Byte0 =               // Data byte 0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t DR_RESET_VALUE = 0x0;

    static constexpr uint8_t DCMI = 78; // DCMI global interrupt
};

static dcmi_t& DCMI = *reinterpret_cast<dcmi_t*>(0x48020000);

#define HAVE_PERIPHERAL_DCMI


////
//
//    USB 1 on the go high speed
//
////

struct otg1_hs_global_t
{
    volatile uint32_t    OTG_HS_GOTGCTL;       // OTG_HS control and status register
    volatile uint32_t    OTG_HS_GOTGINT;       // [Read-write] OTG_HS interrupt register
    volatile uint32_t    OTG_HS_GAHBCFG;       // [Read-write] OTG_HS AHB configuration register
    volatile uint32_t    OTG_HS_GUSBCFG;       // OTG_HS USB configuration register
    volatile uint32_t    OTG_HS_GRSTCTL;       // OTG_HS reset register
    volatile uint32_t    OTG_HS_GINTSTS;       // OTG_HS core interrupt register
    volatile uint32_t    OTG_HS_GINTMSK;       // OTG_HS interrupt mask register
    volatile uint32_t    OTG_HS_GRXSTSR_Host;  // [Read-only] OTG_HS Receive status debug read register (host mode)
    volatile uint32_t    OTG_HS_GRXSTSP_Host;  // [Read-only] OTG_HS status read and pop register (host mode)
    volatile uint32_t    OTG_HS_GRXFSIZ;       // [Read-write] OTG_HS Receive FIFO size register
    volatile uint32_t    OTG_HS_HNPTXFSIZ_Host;// [Read-write] OTG_HS nonperiodic transmit FIFO size register (host mode)
    volatile uint32_t    OTG_HS_GNPTXSTS;      // [Read-only] OTG_HS nonperiodic transmit FIFO/queue status register
    reserved_t<2>        _0;
    volatile uint32_t    OTG_HS_GCCFG;         // [Read-write] OTG_HS general core configuration register
    volatile uint32_t    OTG_HS_CID;           // [Read-write] OTG_HS core ID register
    reserved_t<5>        _1;
    volatile uint32_t    OTG_HS_GLPMCFG;       // OTG core LPM configuration register
    reserved_t<42>       _2;
    volatile uint32_t    OTG_HS_HPTXFSIZ;      // [Read-write] OTG_HS Host periodic transmit FIFO size register
    volatile uint32_t    OTG_HS_DIEPTXF1;      // [Read-write] OTG_HS device IN endpoint transmit FIFO size register
    volatile uint32_t    OTG_HS_DIEPTXF2;      // [Read-write] OTG_HS device IN endpoint transmit FIFO size register
    reserved_t<4>        _3;
    volatile uint32_t    OTG_HS_DIEPTXF3;      // [Read-write] OTG_HS device IN endpoint transmit FIFO size register
    volatile uint32_t    OTG_HS_DIEPTXF4;      // [Read-write] OTG_HS device IN endpoint transmit FIFO size register
    volatile uint32_t    OTG_HS_DIEPTXF5;      // [Read-write] OTG_HS device IN endpoint transmit FIFO size register
    volatile uint32_t    OTG_HS_DIEPTXF6;      // [Read-write] OTG_HS device IN endpoint transmit FIFO size register
    volatile uint32_t    OTG_HS_DIEPTXF7;      // [Read-write] OTG_HS device IN endpoint transmit FIFO size register

    static constexpr uint32_t OTG_HS_GOTGCTL_SRQSCS = 0x1;         // Session request success, Read-only
    static constexpr uint32_t OTG_HS_GOTGCTL_SRQ = 0x2;            // Session request, Read-write
    static constexpr uint32_t OTG_HS_GOTGCTL_HNGSCS = 0x100;       // Host negotiation success, Read-only
    static constexpr uint32_t OTG_HS_GOTGCTL_HNPRQ = 0x200;        // HNP request, Read-write
    static constexpr uint32_t OTG_HS_GOTGCTL_HSHNPEN = 0x400;      // Host set HNP enable, Read-write
    static constexpr uint32_t OTG_HS_GOTGCTL_DHNPEN = 0x800;       // Device HNP enabled, Read-write
    static constexpr uint32_t OTG_HS_GOTGCTL_CIDSTS = 0x10000;     // Connector ID status, Read-only
    static constexpr uint32_t OTG_HS_GOTGCTL_DBCT = 0x20000;       // Long/short debounce time, Read-only
    static constexpr uint32_t OTG_HS_GOTGCTL_ASVLD = 0x40000;      // A-session valid, Read-only
    static constexpr uint32_t OTG_HS_GOTGCTL_BSVLD = 0x80000;      // B-session valid, Read-only
    static constexpr uint32_t OTG_HS_GOTGCTL_EHEN = 0x1000;        // Embedded host enable, Read-write
    static const uint32_t OTG_HS_GOTGCTL_RESET_VALUE = 0x800;

    static constexpr uint32_t OTG_HS_GOTGINT_SEDET = 0x4;          // Session end detected
    static constexpr uint32_t OTG_HS_GOTGINT_SRSSCHG = 0x100;      // Session request success status change
    static constexpr uint32_t OTG_HS_GOTGINT_HNSSCHG = 0x200;      // Host negotiation success status change
    static constexpr uint32_t OTG_HS_GOTGINT_HNGDET = 0x20000;     // Host negotiation detected
    static constexpr uint32_t OTG_HS_GOTGINT_ADTOCHG = 0x40000;    // A-device timeout change
    static constexpr uint32_t OTG_HS_GOTGINT_DBCDNE = 0x80000;     // Debounce done
    static constexpr uint32_t OTG_HS_GOTGINT_IDCHNG = 0x100000;    // ID input pin changed
    static const uint32_t OTG_HS_GOTGINT_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_GAHBCFG_GINT = 0x1;           // Global interrupt mask
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GAHBCFG_HBSTLEN =             // Burst length/type (4 bits)
        bit_field_t<1, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_GAHBCFG_DMAEN = 0x20;         // DMA enable
    static constexpr uint32_t OTG_HS_GAHBCFG_TXFELVL = 0x80;       // TxFIFO empty level
    static constexpr uint32_t OTG_HS_GAHBCFG_PTXFELVL = 0x100;     // Periodic TxFIFO empty level
    static const uint32_t OTG_HS_GAHBCFG_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GUSBCFG_TOCAL =               // FS timeout calibration (3 bits), Read-write
        bit_field_t<0, 0x7>::value<X>();
    static constexpr uint32_t OTG_HS_GUSBCFG_PHYSEL = 0x40;        // USB 2.0 high-speed ULPI PHY or USB 1.1 full-speed serial transceiver select, Write-only
    static constexpr uint32_t OTG_HS_GUSBCFG_SRPCAP = 0x100;       // SRP-capable, Read-write
    static constexpr uint32_t OTG_HS_GUSBCFG_HNPCAP = 0x200;       // HNP-capable, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GUSBCFG_TRDT =                // USB turnaround time (4 bits), Read-write
        bit_field_t<10, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_GUSBCFG_PHYLPCS = 0x8000;     // PHY Low-power clock select, Read-write
    static constexpr uint32_t OTG_HS_GUSBCFG_ULPIFSLS = 0x20000;   // ULPI FS/LS select, Read-write
    static constexpr uint32_t OTG_HS_GUSBCFG_ULPIAR = 0x40000;     // ULPI Auto-resume, Read-write
    static constexpr uint32_t OTG_HS_GUSBCFG_ULPICSM = 0x80000;    // ULPI Clock SuspendM, Read-write
    static constexpr uint32_t OTG_HS_GUSBCFG_ULPIEVBUSD = 0x100000;// ULPI External VBUS Drive, Read-write
    static constexpr uint32_t OTG_HS_GUSBCFG_ULPIEVBUSI = 0x200000;// ULPI external VBUS indicator, Read-write
    static constexpr uint32_t OTG_HS_GUSBCFG_TSDPS = 0x400000;     // TermSel DLine pulsing selection, Read-write
    static constexpr uint32_t OTG_HS_GUSBCFG_PCCI = 0x800000;      // Indicator complement, Read-write
    static constexpr uint32_t OTG_HS_GUSBCFG_PTCI = 0x1000000;     // Indicator pass through, Read-write
    static constexpr uint32_t OTG_HS_GUSBCFG_ULPIIPD = 0x2000000;  // ULPI interface protect disable, Read-write
    static constexpr uint32_t OTG_HS_GUSBCFG_FHMOD = 0x20000000;   // Forced host mode, Read-write
    static constexpr uint32_t OTG_HS_GUSBCFG_FDMOD = 0x40000000;   // Forced peripheral mode, Read-write
    static const uint32_t OTG_HS_GUSBCFG_RESET_VALUE = 0xa00;

    static constexpr uint32_t OTG_HS_GRSTCTL_CSRST = 0x1;          // Core soft reset, Read-write
    static constexpr uint32_t OTG_HS_GRSTCTL_HSRST = 0x2;          // HCLK soft reset, Read-write
    static constexpr uint32_t OTG_HS_GRSTCTL_FCRST = 0x4;          // Host frame counter reset, Read-write
    static constexpr uint32_t OTG_HS_GRSTCTL_RXFFLSH = 0x10;       // RxFIFO flush, Read-write
    static constexpr uint32_t OTG_HS_GRSTCTL_TXFFLSH = 0x20;       // TxFIFO flush, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GRSTCTL_TXFNUM =              // TxFIFO number (5 bits), Read-write
        bit_field_t<6, 0x1f>::value<X>();
    static constexpr uint32_t OTG_HS_GRSTCTL_AHBIDL = 0x80000000;  // AHB master idle, Read-only
    static constexpr uint32_t OTG_HS_GRSTCTL_DMAREQ = 0x40000000;  // DMA request signal enabled for USB OTG HS, Read-only
    static const uint32_t OTG_HS_GRSTCTL_RESET_VALUE = 0x20000000;

    static constexpr uint32_t OTG_HS_GINTSTS_CMOD = 0x1;           // Current mode of operation, Read-only
    static constexpr uint32_t OTG_HS_GINTSTS_MMIS = 0x2;           // Mode mismatch interrupt, Read-write
    static constexpr uint32_t OTG_HS_GINTSTS_OTGINT = 0x4;         // OTG interrupt, Read-only
    static constexpr uint32_t OTG_HS_GINTSTS_SOF = 0x8;            // Start of frame, Read-write
    static constexpr uint32_t OTG_HS_GINTSTS_RXFLVL = 0x10;        // RxFIFO nonempty, Read-only
    static constexpr uint32_t OTG_HS_GINTSTS_NPTXFE = 0x20;        // Nonperiodic TxFIFO empty, Read-only
    static constexpr uint32_t OTG_HS_GINTSTS_GINAKEFF = 0x40;      // Global IN nonperiodic NAK effective, Read-only
    static constexpr uint32_t OTG_HS_GINTSTS_BOUTNAKEFF = 0x80;    // Global OUT NAK effective, Read-only
    static constexpr uint32_t OTG_HS_GINTSTS_ESUSP = 0x400;        // Early suspend, Read-write
    static constexpr uint32_t OTG_HS_GINTSTS_USBSUSP = 0x800;      // USB suspend, Read-write
    static constexpr uint32_t OTG_HS_GINTSTS_USBRST = 0x1000;      // USB reset, Read-write
    static constexpr uint32_t OTG_HS_GINTSTS_ENUMDNE = 0x2000;     // Enumeration done, Read-write
    static constexpr uint32_t OTG_HS_GINTSTS_ISOODRP = 0x4000;     // Isochronous OUT packet dropped interrupt, Read-write
    static constexpr uint32_t OTG_HS_GINTSTS_EOPF = 0x8000;        // End of periodic frame interrupt, Read-write
    static constexpr uint32_t OTG_HS_GINTSTS_IEPINT = 0x40000;     // IN endpoint interrupt, Read-only
    static constexpr uint32_t OTG_HS_GINTSTS_OEPINT = 0x80000;     // OUT endpoint interrupt, Read-only
    static constexpr uint32_t OTG_HS_GINTSTS_IISOIXFR = 0x100000;  // Incomplete isochronous IN transfer, Read-write
    static constexpr uint32_t OTG_HS_GINTSTS_PXFR_INCOMPISOOUT = 0x200000;// Incomplete periodic transfer, Read-write
    static constexpr uint32_t OTG_HS_GINTSTS_DATAFSUSP = 0x400000; // Data fetch suspended, Read-write
    static constexpr uint32_t OTG_HS_GINTSTS_HPRTINT = 0x1000000;  // Host port interrupt, Read-only
    static constexpr uint32_t OTG_HS_GINTSTS_HCINT = 0x2000000;    // Host channels interrupt, Read-only
    static constexpr uint32_t OTG_HS_GINTSTS_PTXFE = 0x4000000;    // Periodic TxFIFO empty, Read-only
    static constexpr uint32_t OTG_HS_GINTSTS_CIDSCHG = 0x10000000; // Connector ID status change, Read-write
    static constexpr uint32_t OTG_HS_GINTSTS_DISCINT = 0x20000000; // Disconnect detected interrupt, Read-write
    static constexpr uint32_t OTG_HS_GINTSTS_SRQINT = 0x40000000;  // Session request/new session detected interrupt, Read-write
    static constexpr uint32_t OTG_HS_GINTSTS_WKUINT = 0x80000000;  // Resume/remote wakeup detected interrupt, Read-write
    static const uint32_t OTG_HS_GINTSTS_RESET_VALUE = 0x4000020;

    static constexpr uint32_t OTG_HS_GINTMSK_MMISM = 0x2;          // Mode mismatch interrupt mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_OTGINT = 0x4;         // OTG interrupt mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_SOFM = 0x8;           // Start of frame mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_RXFLVLM = 0x10;       // Receive FIFO nonempty mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_NPTXFEM = 0x20;       // Nonperiodic TxFIFO empty mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_GINAKEFFM = 0x40;     // Global nonperiodic IN NAK effective mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_GONAKEFFM = 0x80;     // Global OUT NAK effective mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_ESUSPM = 0x400;       // Early suspend mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_USBSUSPM = 0x800;     // USB suspend mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_USBRST = 0x1000;      // USB reset mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_ENUMDNEM = 0x2000;    // Enumeration done mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_ISOODRPM = 0x4000;    // Isochronous OUT packet dropped interrupt mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_EOPFM = 0x8000;       // End of periodic frame interrupt mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_IEPINT = 0x40000;     // IN endpoints interrupt mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_OEPINT = 0x80000;     // OUT endpoints interrupt mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_IISOIXFRM = 0x100000; // Incomplete isochronous IN transfer mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_PXFRM_IISOOXFRM = 0x200000;// Incomplete periodic transfer mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_FSUSPM = 0x400000;    // Data fetch suspended mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_PRTIM = 0x1000000;    // Host port interrupt mask, Read-only
    static constexpr uint32_t OTG_HS_GINTMSK_HCIM = 0x2000000;     // Host channels interrupt mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_PTXFEM = 0x4000000;   // Periodic TxFIFO empty mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_CIDSCHGM = 0x10000000;// Connector ID status change mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_DISCINT = 0x20000000; // Disconnect detected interrupt mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_SRQIM = 0x40000000;   // Session request/new session detected interrupt mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_WUIM = 0x80000000;    // Resume/remote wakeup detected interrupt mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_RSTDE = 0x800000;     // Reset detected interrupt mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_LPMINTM = 0x8000000;  // LPM interrupt mask, Read-write
    static const uint32_t OTG_HS_GINTMSK_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GRXSTSR_Host_BCNT =                // Byte count (11 bits)
        bit_field_t<4, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GRXSTSR_Host_CHNUM =               // Channel number (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GRXSTSR_Host_DPID =                // Data PID (2 bits)
        bit_field_t<15, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GRXSTSR_Host_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GRXSTSR_Host_FRMNUM =              // Frame number (4 bits)
        bit_field_t<21, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GRXSTSR_Host_PKTSTS =              // Packet status (4 bits)
        bit_field_t<17, 0xf>::value<X>();
    static const uint32_t OTG_HS_GRXSTSR_Host_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GRXSTSP_Host_BCNT =                // Byte count (11 bits)
        bit_field_t<4, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GRXSTSP_Host_CHNUM =               // Channel number (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GRXSTSP_Host_DPID =                // Data PID (2 bits)
        bit_field_t<15, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GRXSTSP_Host_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GRXSTSP_Host_FRMNUM =              // Frame number (4 bits)
        bit_field_t<21, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GRXSTSP_Host_PKTSTS =              // Packet status (4 bits)
        bit_field_t<17, 0xf>::value<X>();
    static const uint32_t OTG_HS_GRXSTSP_Host_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GRXFSIZ_RXFD =                // RxFIFO depth (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_GRXFSIZ_RESET_VALUE = 0x200;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HNPTXFSIZ_Host_NPTXFD =              // Nonperiodic TxFIFO depth (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HNPTXFSIZ_Host_NPTXFSA =             // Nonperiodic transmit RAM start address (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HNPTXFSIZ_Host_TX0FD =               // Endpoint 0 TxFIFO depth (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HNPTXFSIZ_Host_TX0FSA =              // Endpoint 0 transmit RAM start address (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_HNPTXFSIZ_Host_RESET_VALUE = 0x200;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GNPTXSTS_NPTXFSAV =            // Nonperiodic TxFIFO space available (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GNPTXSTS_NPTQXSAV =            // Nonperiodic transmit request queue space available (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GNPTXSTS_NPTXQTOP =            // Top of the nonperiodic transmit request queue (7 bits)
        bit_field_t<24, 0x7f>::value<X>();
    static const uint32_t OTG_HS_GNPTXSTS_RESET_VALUE = 0x80200;

    static constexpr uint32_t OTG_HS_GCCFG_PWRDWN = 0x10000;     // Power down
    static constexpr uint32_t OTG_HS_GCCFG_BCDEN = 0x20000;      // Battery charging detector (BCD) enable
    static constexpr uint32_t OTG_HS_GCCFG_DCDEN = 0x40000;      // Data contact detection (DCD) mode enable
    static constexpr uint32_t OTG_HS_GCCFG_PDEN = 0x80000;       // Primary detection (PD) mode enable
    static constexpr uint32_t OTG_HS_GCCFG_SDEN = 0x100000;      // Secondary detection (SD) mode enable
    static constexpr uint32_t OTG_HS_GCCFG_VBDEN = 0x200000;     // USB VBUS detection enable
    static constexpr uint32_t OTG_HS_GCCFG_DCDET = 0x1;          // Data contact detection (DCD) status
    static constexpr uint32_t OTG_HS_GCCFG_PDET = 0x2;           // Primary detection (PD) status
    static constexpr uint32_t OTG_HS_GCCFG_SDET = 0x4;           // Secondary detection (SD) status
    static constexpr uint32_t OTG_HS_GCCFG_PS2DET = 0x8;         // DM pull-up detection status
    static const uint32_t OTG_HS_GCCFG_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_CID_RESET_VALUE = 0x1200;

    static constexpr uint32_t OTG_HS_GLPMCFG_LPMEN = 0x1;          // LPM support enable, Read-write
    static constexpr uint32_t OTG_HS_GLPMCFG_LPMACK = 0x2;         // LPM token acknowledge enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GLPMCFG_BESL =                // Best effort service latency (4 bits), Read-only
        bit_field_t<2, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_GLPMCFG_REMWAKE = 0x40;       // bRemoteWake value, Read-only
    static constexpr uint32_t OTG_HS_GLPMCFG_L1SSEN = 0x80;        // L1 Shallow Sleep enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GLPMCFG_BESLTHRS =            // BESL threshold (4 bits), Read-write
        bit_field_t<8, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_GLPMCFG_L1DSEN = 0x1000;      // L1 deep sleep enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GLPMCFG_LPMRST =              // LPM response (2 bits), Read-only
        bit_field_t<13, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_GLPMCFG_SLPSTS = 0x8000;      // Port sleep status, Read-only
    static constexpr uint32_t OTG_HS_GLPMCFG_L1RSMOK = 0x10000;    // Sleep State Resume OK, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GLPMCFG_LPMCHIDX =            // LPM Channel Index (4 bits), Read-write
        bit_field_t<17, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GLPMCFG_LPMRCNT =             // LPM retry count (3 bits), Read-write
        bit_field_t<21, 0x7>::value<X>();
    static constexpr uint32_t OTG_HS_GLPMCFG_SNDLPM = 0x1000000;   // Send LPM transaction, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GLPMCFG_LPMRCNTSTS =          // LPM retry count status (3 bits), Read-only
        bit_field_t<25, 0x7>::value<X>();
    static constexpr uint32_t OTG_HS_GLPMCFG_ENBESL = 0x10000000;  // Enable best effort service latency, Read-write
    static const uint32_t OTG_HS_GLPMCFG_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HPTXFSIZ_PTXSA =               // Host periodic TxFIFO start address (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HPTXFSIZ_PTXFD =               // Host periodic TxFIFO depth (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OTG_HS_HPTXFSIZ_RESET_VALUE = 0x2000600;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTXF1_INEPTXSA =            // IN endpoint FIFOx transmit RAM start address (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTXF1_INEPTXFD =            // IN endpoint TxFIFO depth (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DIEPTXF1_RESET_VALUE = 0x2000400;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTXF2_INEPTXSA =            // IN endpoint FIFOx transmit RAM start address (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTXF2_INEPTXFD =            // IN endpoint TxFIFO depth (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DIEPTXF2_RESET_VALUE = 0x2000400;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTXF3_INEPTXSA =            // IN endpoint FIFOx transmit RAM start address (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTXF3_INEPTXFD =            // IN endpoint TxFIFO depth (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DIEPTXF3_RESET_VALUE = 0x2000400;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTXF4_INEPTXSA =            // IN endpoint FIFOx transmit RAM start address (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTXF4_INEPTXFD =            // IN endpoint TxFIFO depth (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DIEPTXF4_RESET_VALUE = 0x2000400;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTXF5_INEPTXSA =            // IN endpoint FIFOx transmit RAM start address (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTXF5_INEPTXFD =            // IN endpoint TxFIFO depth (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DIEPTXF5_RESET_VALUE = 0x2000400;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTXF6_INEPTXSA =            // IN endpoint FIFOx transmit RAM start address (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTXF6_INEPTXFD =            // IN endpoint TxFIFO depth (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DIEPTXF6_RESET_VALUE = 0x2000400;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTXF7_INEPTXSA =            // IN endpoint FIFOx transmit RAM start address (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTXF7_INEPTXFD =            // IN endpoint TxFIFO depth (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DIEPTXF7_RESET_VALUE = 0x2000400;
};

static otg1_hs_global_t& OTG1_HS_GLOBAL = *reinterpret_cast<otg1_hs_global_t*>(0x40040000);

#define HAVE_PERIPHERAL_OTG1_HS_GLOBAL


////
//
//    USB 1 on the go high speed
//
////

struct otg2_hs_global_t
{
    volatile uint32_t    OTG_HS_GOTGCTL;       // OTG_HS control and status register
    volatile uint32_t    OTG_HS_GOTGINT;       // [Read-write] OTG_HS interrupt register
    volatile uint32_t    OTG_HS_GAHBCFG;       // [Read-write] OTG_HS AHB configuration register
    volatile uint32_t    OTG_HS_GUSBCFG;       // OTG_HS USB configuration register
    volatile uint32_t    OTG_HS_GRSTCTL;       // OTG_HS reset register
    volatile uint32_t    OTG_HS_GINTSTS;       // OTG_HS core interrupt register
    volatile uint32_t    OTG_HS_GINTMSK;       // OTG_HS interrupt mask register
    volatile uint32_t    OTG_HS_GRXSTSR_Host;  // [Read-only] OTG_HS Receive status debug read register (host mode)
    volatile uint32_t    OTG_HS_GRXSTSP_Host;  // [Read-only] OTG_HS status read and pop register (host mode)
    volatile uint32_t    OTG_HS_GRXFSIZ;       // [Read-write] OTG_HS Receive FIFO size register
    volatile uint32_t    OTG_HS_HNPTXFSIZ_Host;// [Read-write] OTG_HS nonperiodic transmit FIFO size register (host mode)
    volatile uint32_t    OTG_HS_GNPTXSTS;      // [Read-only] OTG_HS nonperiodic transmit FIFO/queue status register
    reserved_t<2>        _0;
    volatile uint32_t    OTG_HS_GCCFG;         // [Read-write] OTG_HS general core configuration register
    volatile uint32_t    OTG_HS_CID;           // [Read-write] OTG_HS core ID register
    reserved_t<5>        _1;
    volatile uint32_t    OTG_HS_GLPMCFG;       // OTG core LPM configuration register
    reserved_t<42>       _2;
    volatile uint32_t    OTG_HS_HPTXFSIZ;      // [Read-write] OTG_HS Host periodic transmit FIFO size register
    volatile uint32_t    OTG_HS_DIEPTXF1;      // [Read-write] OTG_HS device IN endpoint transmit FIFO size register
    volatile uint32_t    OTG_HS_DIEPTXF2;      // [Read-write] OTG_HS device IN endpoint transmit FIFO size register
    reserved_t<4>        _3;
    volatile uint32_t    OTG_HS_DIEPTXF3;      // [Read-write] OTG_HS device IN endpoint transmit FIFO size register
    volatile uint32_t    OTG_HS_DIEPTXF4;      // [Read-write] OTG_HS device IN endpoint transmit FIFO size register
    volatile uint32_t    OTG_HS_DIEPTXF5;      // [Read-write] OTG_HS device IN endpoint transmit FIFO size register
    volatile uint32_t    OTG_HS_DIEPTXF6;      // [Read-write] OTG_HS device IN endpoint transmit FIFO size register
    volatile uint32_t    OTG_HS_DIEPTXF7;      // [Read-write] OTG_HS device IN endpoint transmit FIFO size register

    static constexpr uint32_t OTG_HS_GOTGCTL_SRQSCS = 0x1;         // Session request success, Read-only
    static constexpr uint32_t OTG_HS_GOTGCTL_SRQ = 0x2;            // Session request, Read-write
    static constexpr uint32_t OTG_HS_GOTGCTL_HNGSCS = 0x100;       // Host negotiation success, Read-only
    static constexpr uint32_t OTG_HS_GOTGCTL_HNPRQ = 0x200;        // HNP request, Read-write
    static constexpr uint32_t OTG_HS_GOTGCTL_HSHNPEN = 0x400;      // Host set HNP enable, Read-write
    static constexpr uint32_t OTG_HS_GOTGCTL_DHNPEN = 0x800;       // Device HNP enabled, Read-write
    static constexpr uint32_t OTG_HS_GOTGCTL_CIDSTS = 0x10000;     // Connector ID status, Read-only
    static constexpr uint32_t OTG_HS_GOTGCTL_DBCT = 0x20000;       // Long/short debounce time, Read-only
    static constexpr uint32_t OTG_HS_GOTGCTL_ASVLD = 0x40000;      // A-session valid, Read-only
    static constexpr uint32_t OTG_HS_GOTGCTL_BSVLD = 0x80000;      // B-session valid, Read-only
    static constexpr uint32_t OTG_HS_GOTGCTL_EHEN = 0x1000;        // Embedded host enable, Read-write
    static const uint32_t OTG_HS_GOTGCTL_RESET_VALUE = 0x800;

    static constexpr uint32_t OTG_HS_GOTGINT_SEDET = 0x4;          // Session end detected
    static constexpr uint32_t OTG_HS_GOTGINT_SRSSCHG = 0x100;      // Session request success status change
    static constexpr uint32_t OTG_HS_GOTGINT_HNSSCHG = 0x200;      // Host negotiation success status change
    static constexpr uint32_t OTG_HS_GOTGINT_HNGDET = 0x20000;     // Host negotiation detected
    static constexpr uint32_t OTG_HS_GOTGINT_ADTOCHG = 0x40000;    // A-device timeout change
    static constexpr uint32_t OTG_HS_GOTGINT_DBCDNE = 0x80000;     // Debounce done
    static constexpr uint32_t OTG_HS_GOTGINT_IDCHNG = 0x100000;    // ID input pin changed
    static const uint32_t OTG_HS_GOTGINT_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_GAHBCFG_GINT = 0x1;           // Global interrupt mask
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GAHBCFG_HBSTLEN =             // Burst length/type (4 bits)
        bit_field_t<1, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_GAHBCFG_DMAEN = 0x20;         // DMA enable
    static constexpr uint32_t OTG_HS_GAHBCFG_TXFELVL = 0x80;       // TxFIFO empty level
    static constexpr uint32_t OTG_HS_GAHBCFG_PTXFELVL = 0x100;     // Periodic TxFIFO empty level
    static const uint32_t OTG_HS_GAHBCFG_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GUSBCFG_TOCAL =               // FS timeout calibration (3 bits), Read-write
        bit_field_t<0, 0x7>::value<X>();
    static constexpr uint32_t OTG_HS_GUSBCFG_PHYSEL = 0x40;        // USB 2.0 high-speed ULPI PHY or USB 1.1 full-speed serial transceiver select, Write-only
    static constexpr uint32_t OTG_HS_GUSBCFG_SRPCAP = 0x100;       // SRP-capable, Read-write
    static constexpr uint32_t OTG_HS_GUSBCFG_HNPCAP = 0x200;       // HNP-capable, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GUSBCFG_TRDT =                // USB turnaround time (4 bits), Read-write
        bit_field_t<10, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_GUSBCFG_PHYLPCS = 0x8000;     // PHY Low-power clock select, Read-write
    static constexpr uint32_t OTG_HS_GUSBCFG_ULPIFSLS = 0x20000;   // ULPI FS/LS select, Read-write
    static constexpr uint32_t OTG_HS_GUSBCFG_ULPIAR = 0x40000;     // ULPI Auto-resume, Read-write
    static constexpr uint32_t OTG_HS_GUSBCFG_ULPICSM = 0x80000;    // ULPI Clock SuspendM, Read-write
    static constexpr uint32_t OTG_HS_GUSBCFG_ULPIEVBUSD = 0x100000;// ULPI External VBUS Drive, Read-write
    static constexpr uint32_t OTG_HS_GUSBCFG_ULPIEVBUSI = 0x200000;// ULPI external VBUS indicator, Read-write
    static constexpr uint32_t OTG_HS_GUSBCFG_TSDPS = 0x400000;     // TermSel DLine pulsing selection, Read-write
    static constexpr uint32_t OTG_HS_GUSBCFG_PCCI = 0x800000;      // Indicator complement, Read-write
    static constexpr uint32_t OTG_HS_GUSBCFG_PTCI = 0x1000000;     // Indicator pass through, Read-write
    static constexpr uint32_t OTG_HS_GUSBCFG_ULPIIPD = 0x2000000;  // ULPI interface protect disable, Read-write
    static constexpr uint32_t OTG_HS_GUSBCFG_FHMOD = 0x20000000;   // Forced host mode, Read-write
    static constexpr uint32_t OTG_HS_GUSBCFG_FDMOD = 0x40000000;   // Forced peripheral mode, Read-write
    static const uint32_t OTG_HS_GUSBCFG_RESET_VALUE = 0xa00;

    static constexpr uint32_t OTG_HS_GRSTCTL_CSRST = 0x1;          // Core soft reset, Read-write
    static constexpr uint32_t OTG_HS_GRSTCTL_HSRST = 0x2;          // HCLK soft reset, Read-write
    static constexpr uint32_t OTG_HS_GRSTCTL_FCRST = 0x4;          // Host frame counter reset, Read-write
    static constexpr uint32_t OTG_HS_GRSTCTL_RXFFLSH = 0x10;       // RxFIFO flush, Read-write
    static constexpr uint32_t OTG_HS_GRSTCTL_TXFFLSH = 0x20;       // TxFIFO flush, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GRSTCTL_TXFNUM =              // TxFIFO number (5 bits), Read-write
        bit_field_t<6, 0x1f>::value<X>();
    static constexpr uint32_t OTG_HS_GRSTCTL_AHBIDL = 0x80000000;  // AHB master idle, Read-only
    static constexpr uint32_t OTG_HS_GRSTCTL_DMAREQ = 0x40000000;  // DMA request signal enabled for USB OTG HS, Read-only
    static const uint32_t OTG_HS_GRSTCTL_RESET_VALUE = 0x20000000;

    static constexpr uint32_t OTG_HS_GINTSTS_CMOD = 0x1;           // Current mode of operation, Read-only
    static constexpr uint32_t OTG_HS_GINTSTS_MMIS = 0x2;           // Mode mismatch interrupt, Read-write
    static constexpr uint32_t OTG_HS_GINTSTS_OTGINT = 0x4;         // OTG interrupt, Read-only
    static constexpr uint32_t OTG_HS_GINTSTS_SOF = 0x8;            // Start of frame, Read-write
    static constexpr uint32_t OTG_HS_GINTSTS_RXFLVL = 0x10;        // RxFIFO nonempty, Read-only
    static constexpr uint32_t OTG_HS_GINTSTS_NPTXFE = 0x20;        // Nonperiodic TxFIFO empty, Read-only
    static constexpr uint32_t OTG_HS_GINTSTS_GINAKEFF = 0x40;      // Global IN nonperiodic NAK effective, Read-only
    static constexpr uint32_t OTG_HS_GINTSTS_BOUTNAKEFF = 0x80;    // Global OUT NAK effective, Read-only
    static constexpr uint32_t OTG_HS_GINTSTS_ESUSP = 0x400;        // Early suspend, Read-write
    static constexpr uint32_t OTG_HS_GINTSTS_USBSUSP = 0x800;      // USB suspend, Read-write
    static constexpr uint32_t OTG_HS_GINTSTS_USBRST = 0x1000;      // USB reset, Read-write
    static constexpr uint32_t OTG_HS_GINTSTS_ENUMDNE = 0x2000;     // Enumeration done, Read-write
    static constexpr uint32_t OTG_HS_GINTSTS_ISOODRP = 0x4000;     // Isochronous OUT packet dropped interrupt, Read-write
    static constexpr uint32_t OTG_HS_GINTSTS_EOPF = 0x8000;        // End of periodic frame interrupt, Read-write
    static constexpr uint32_t OTG_HS_GINTSTS_IEPINT = 0x40000;     // IN endpoint interrupt, Read-only
    static constexpr uint32_t OTG_HS_GINTSTS_OEPINT = 0x80000;     // OUT endpoint interrupt, Read-only
    static constexpr uint32_t OTG_HS_GINTSTS_IISOIXFR = 0x100000;  // Incomplete isochronous IN transfer, Read-write
    static constexpr uint32_t OTG_HS_GINTSTS_PXFR_INCOMPISOOUT = 0x200000;// Incomplete periodic transfer, Read-write
    static constexpr uint32_t OTG_HS_GINTSTS_DATAFSUSP = 0x400000; // Data fetch suspended, Read-write
    static constexpr uint32_t OTG_HS_GINTSTS_HPRTINT = 0x1000000;  // Host port interrupt, Read-only
    static constexpr uint32_t OTG_HS_GINTSTS_HCINT = 0x2000000;    // Host channels interrupt, Read-only
    static constexpr uint32_t OTG_HS_GINTSTS_PTXFE = 0x4000000;    // Periodic TxFIFO empty, Read-only
    static constexpr uint32_t OTG_HS_GINTSTS_CIDSCHG = 0x10000000; // Connector ID status change, Read-write
    static constexpr uint32_t OTG_HS_GINTSTS_DISCINT = 0x20000000; // Disconnect detected interrupt, Read-write
    static constexpr uint32_t OTG_HS_GINTSTS_SRQINT = 0x40000000;  // Session request/new session detected interrupt, Read-write
    static constexpr uint32_t OTG_HS_GINTSTS_WKUINT = 0x80000000;  // Resume/remote wakeup detected interrupt, Read-write
    static const uint32_t OTG_HS_GINTSTS_RESET_VALUE = 0x4000020;

    static constexpr uint32_t OTG_HS_GINTMSK_MMISM = 0x2;          // Mode mismatch interrupt mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_OTGINT = 0x4;         // OTG interrupt mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_SOFM = 0x8;           // Start of frame mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_RXFLVLM = 0x10;       // Receive FIFO nonempty mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_NPTXFEM = 0x20;       // Nonperiodic TxFIFO empty mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_GINAKEFFM = 0x40;     // Global nonperiodic IN NAK effective mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_GONAKEFFM = 0x80;     // Global OUT NAK effective mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_ESUSPM = 0x400;       // Early suspend mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_USBSUSPM = 0x800;     // USB suspend mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_USBRST = 0x1000;      // USB reset mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_ENUMDNEM = 0x2000;    // Enumeration done mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_ISOODRPM = 0x4000;    // Isochronous OUT packet dropped interrupt mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_EOPFM = 0x8000;       // End of periodic frame interrupt mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_IEPINT = 0x40000;     // IN endpoints interrupt mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_OEPINT = 0x80000;     // OUT endpoints interrupt mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_IISOIXFRM = 0x100000; // Incomplete isochronous IN transfer mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_PXFRM_IISOOXFRM = 0x200000;// Incomplete periodic transfer mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_FSUSPM = 0x400000;    // Data fetch suspended mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_PRTIM = 0x1000000;    // Host port interrupt mask, Read-only
    static constexpr uint32_t OTG_HS_GINTMSK_HCIM = 0x2000000;     // Host channels interrupt mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_PTXFEM = 0x4000000;   // Periodic TxFIFO empty mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_CIDSCHGM = 0x10000000;// Connector ID status change mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_DISCINT = 0x20000000; // Disconnect detected interrupt mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_SRQIM = 0x40000000;   // Session request/new session detected interrupt mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_WUIM = 0x80000000;    // Resume/remote wakeup detected interrupt mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_RSTDE = 0x800000;     // Reset detected interrupt mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_LPMINTM = 0x8000000;  // LPM interrupt mask, Read-write
    static const uint32_t OTG_HS_GINTMSK_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GRXSTSR_Host_BCNT =                // Byte count (11 bits)
        bit_field_t<4, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GRXSTSR_Host_CHNUM =               // Channel number (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GRXSTSR_Host_DPID =                // Data PID (2 bits)
        bit_field_t<15, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GRXSTSR_Host_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GRXSTSR_Host_FRMNUM =              // Frame number (4 bits)
        bit_field_t<21, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GRXSTSR_Host_PKTSTS =              // Packet status (4 bits)
        bit_field_t<17, 0xf>::value<X>();
    static const uint32_t OTG_HS_GRXSTSR_Host_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GRXSTSP_Host_BCNT =                // Byte count (11 bits)
        bit_field_t<4, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GRXSTSP_Host_CHNUM =               // Channel number (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GRXSTSP_Host_DPID =                // Data PID (2 bits)
        bit_field_t<15, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GRXSTSP_Host_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GRXSTSP_Host_FRMNUM =              // Frame number (4 bits)
        bit_field_t<21, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GRXSTSP_Host_PKTSTS =              // Packet status (4 bits)
        bit_field_t<17, 0xf>::value<X>();
    static const uint32_t OTG_HS_GRXSTSP_Host_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GRXFSIZ_RXFD =                // RxFIFO depth (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_GRXFSIZ_RESET_VALUE = 0x200;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HNPTXFSIZ_Host_NPTXFD =              // Nonperiodic TxFIFO depth (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HNPTXFSIZ_Host_NPTXFSA =             // Nonperiodic transmit RAM start address (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HNPTXFSIZ_Host_TX0FD =               // Endpoint 0 TxFIFO depth (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HNPTXFSIZ_Host_TX0FSA =              // Endpoint 0 transmit RAM start address (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_HNPTXFSIZ_Host_RESET_VALUE = 0x200;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GNPTXSTS_NPTXFSAV =            // Nonperiodic TxFIFO space available (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GNPTXSTS_NPTQXSAV =            // Nonperiodic transmit request queue space available (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GNPTXSTS_NPTXQTOP =            // Top of the nonperiodic transmit request queue (7 bits)
        bit_field_t<24, 0x7f>::value<X>();
    static const uint32_t OTG_HS_GNPTXSTS_RESET_VALUE = 0x80200;

    static constexpr uint32_t OTG_HS_GCCFG_PWRDWN = 0x10000;     // Power down
    static constexpr uint32_t OTG_HS_GCCFG_BCDEN = 0x20000;      // Battery charging detector (BCD) enable
    static constexpr uint32_t OTG_HS_GCCFG_DCDEN = 0x40000;      // Data contact detection (DCD) mode enable
    static constexpr uint32_t OTG_HS_GCCFG_PDEN = 0x80000;       // Primary detection (PD) mode enable
    static constexpr uint32_t OTG_HS_GCCFG_SDEN = 0x100000;      // Secondary detection (SD) mode enable
    static constexpr uint32_t OTG_HS_GCCFG_VBDEN = 0x200000;     // USB VBUS detection enable
    static constexpr uint32_t OTG_HS_GCCFG_DCDET = 0x1;          // Data contact detection (DCD) status
    static constexpr uint32_t OTG_HS_GCCFG_PDET = 0x2;           // Primary detection (PD) status
    static constexpr uint32_t OTG_HS_GCCFG_SDET = 0x4;           // Secondary detection (SD) status
    static constexpr uint32_t OTG_HS_GCCFG_PS2DET = 0x8;         // DM pull-up detection status
    static const uint32_t OTG_HS_GCCFG_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_CID_RESET_VALUE = 0x1200;

    static constexpr uint32_t OTG_HS_GLPMCFG_LPMEN = 0x1;          // LPM support enable, Read-write
    static constexpr uint32_t OTG_HS_GLPMCFG_LPMACK = 0x2;         // LPM token acknowledge enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GLPMCFG_BESL =                // Best effort service latency (4 bits), Read-only
        bit_field_t<2, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_GLPMCFG_REMWAKE = 0x40;       // bRemoteWake value, Read-only
    static constexpr uint32_t OTG_HS_GLPMCFG_L1SSEN = 0x80;        // L1 Shallow Sleep enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GLPMCFG_BESLTHRS =            // BESL threshold (4 bits), Read-write
        bit_field_t<8, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_GLPMCFG_L1DSEN = 0x1000;      // L1 deep sleep enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GLPMCFG_LPMRST =              // LPM response (2 bits), Read-only
        bit_field_t<13, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_GLPMCFG_SLPSTS = 0x8000;      // Port sleep status, Read-only
    static constexpr uint32_t OTG_HS_GLPMCFG_L1RSMOK = 0x10000;    // Sleep State Resume OK, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GLPMCFG_LPMCHIDX =            // LPM Channel Index (4 bits), Read-write
        bit_field_t<17, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GLPMCFG_LPMRCNT =             // LPM retry count (3 bits), Read-write
        bit_field_t<21, 0x7>::value<X>();
    static constexpr uint32_t OTG_HS_GLPMCFG_SNDLPM = 0x1000000;   // Send LPM transaction, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GLPMCFG_LPMRCNTSTS =          // LPM retry count status (3 bits), Read-only
        bit_field_t<25, 0x7>::value<X>();
    static constexpr uint32_t OTG_HS_GLPMCFG_ENBESL = 0x10000000;  // Enable best effort service latency, Read-write
    static const uint32_t OTG_HS_GLPMCFG_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HPTXFSIZ_PTXSA =               // Host periodic TxFIFO start address (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HPTXFSIZ_PTXFD =               // Host periodic TxFIFO depth (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OTG_HS_HPTXFSIZ_RESET_VALUE = 0x2000600;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTXF1_INEPTXSA =            // IN endpoint FIFOx transmit RAM start address (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTXF1_INEPTXFD =            // IN endpoint TxFIFO depth (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DIEPTXF1_RESET_VALUE = 0x2000400;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTXF2_INEPTXSA =            // IN endpoint FIFOx transmit RAM start address (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTXF2_INEPTXFD =            // IN endpoint TxFIFO depth (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DIEPTXF2_RESET_VALUE = 0x2000400;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTXF3_INEPTXSA =            // IN endpoint FIFOx transmit RAM start address (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTXF3_INEPTXFD =            // IN endpoint TxFIFO depth (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DIEPTXF3_RESET_VALUE = 0x2000400;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTXF4_INEPTXSA =            // IN endpoint FIFOx transmit RAM start address (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTXF4_INEPTXFD =            // IN endpoint TxFIFO depth (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DIEPTXF4_RESET_VALUE = 0x2000400;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTXF5_INEPTXSA =            // IN endpoint FIFOx transmit RAM start address (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTXF5_INEPTXFD =            // IN endpoint TxFIFO depth (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DIEPTXF5_RESET_VALUE = 0x2000400;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTXF6_INEPTXSA =            // IN endpoint FIFOx transmit RAM start address (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTXF6_INEPTXFD =            // IN endpoint TxFIFO depth (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DIEPTXF6_RESET_VALUE = 0x2000400;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTXF7_INEPTXSA =            // IN endpoint FIFOx transmit RAM start address (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTXF7_INEPTXFD =            // IN endpoint TxFIFO depth (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DIEPTXF7_RESET_VALUE = 0x2000400;

    static constexpr uint8_t OTG_FS_EP1_IN = 99; // OTG_FS in global interrupt
    static constexpr uint8_t OTG_FS_EP1_OUT = 98; // OTG_FS out global interrupt
    static constexpr uint8_t OTG_FS_WKUP = 100; // OTG_FS wakeup
    static constexpr uint8_t OTG_HS = 77; // OTG_HS global interrupt
    static constexpr uint8_t OTG_HS_EP1_IN = 75; // OTG_HS in global interrupt
    static constexpr uint8_t OTG_HS_EP1_OUT = 74; // OTG_HS out global interrupt
    static constexpr uint8_t OTG_HS_WKUP = 76; // OTG_HS wakeup interrupt
};

static otg2_hs_global_t& OTG2_HS_GLOBAL = *reinterpret_cast<otg2_hs_global_t*>(0x40080000);

#define HAVE_PERIPHERAL_OTG2_HS_GLOBAL


////
//
//    USB 1 on the go high speed
//
////

struct otg1_hs_host_t
{
    volatile uint32_t    OTG_HS_HCFG;          // OTG_HS host configuration register
    volatile uint32_t    OTG_HS_HFIR;          // [Read-write] OTG_HS Host frame interval register
    volatile uint32_t    OTG_HS_HFNUM;         // [Read-only] OTG_HS host frame number/frame time remaining register
    reserved_t<1>        _0;
    volatile uint32_t    OTG_HS_HPTXSTS;       // OTG_HS_Host periodic transmit FIFO/queue status register
    volatile uint32_t    OTG_HS_HAINT;         // [Read-only] OTG_HS Host all channels interrupt register
    volatile uint32_t    OTG_HS_HAINTMSK;      // [Read-write] OTG_HS host all channels interrupt mask register
    reserved_t<9>        _1;
    volatile uint32_t    OTG_HS_HPRT;          // OTG_HS host port control and status register
    reserved_t<47>       _2;
    volatile uint32_t    OTG_HS_HCCHAR0;       // [Read-write] OTG_HS host channel-0 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT0;       // [Read-write] OTG_HS host channel-0 split control register
    volatile uint32_t    OTG_HS_HCINT0;        // [Read-write] OTG_HS host channel-11 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK0;     // [Read-write] OTG_HS host channel-11 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ0;       // [Read-write] OTG_HS host channel-11 transfer size register
    volatile uint32_t    OTG_HS_HCDMA0;        // [Read-write] OTG_HS host channel-0 DMA address register
    reserved_t<2>        _3;
    volatile uint32_t    OTG_HS_HCCHAR1;       // [Read-write] OTG_HS host channel-1 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT1;       // [Read-write] OTG_HS host channel-1 split control register
    volatile uint32_t    OTG_HS_HCINT1;        // [Read-write] OTG_HS host channel-1 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK1;     // [Read-write] OTG_HS host channel-1 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ1;       // [Read-write] OTG_HS host channel-1 transfer size register
    volatile uint32_t    OTG_HS_HCDMA1;        // [Read-write] OTG_HS host channel-1 DMA address register
    reserved_t<2>        _4;
    volatile uint32_t    OTG_HS_HCCHAR2;       // [Read-write] OTG_HS host channel-2 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT2;       // [Read-write] OTG_HS host channel-2 split control register
    volatile uint32_t    OTG_HS_HCINT2;        // [Read-write] OTG_HS host channel-2 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK2;     // [Read-write] OTG_HS host channel-2 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ2;       // [Read-write] OTG_HS host channel-2 transfer size register
    volatile uint32_t    OTG_HS_HCDMA2;        // [Read-write] OTG_HS host channel-2 DMA address register
    reserved_t<2>        _5;
    volatile uint32_t    OTG_HS_HCCHAR3;       // [Read-write] OTG_HS host channel-3 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT3;       // [Read-write] OTG_HS host channel-3 split control register
    volatile uint32_t    OTG_HS_HCINT3;        // [Read-write] OTG_HS host channel-3 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK3;     // [Read-write] OTG_HS host channel-3 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ3;       // [Read-write] OTG_HS host channel-3 transfer size register
    volatile uint32_t    OTG_HS_HCDMA3;        // [Read-write] OTG_HS host channel-3 DMA address register
    reserved_t<2>        _6;
    volatile uint32_t    OTG_HS_HCCHAR4;       // [Read-write] OTG_HS host channel-4 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT4;       // [Read-write] OTG_HS host channel-4 split control register
    volatile uint32_t    OTG_HS_HCINT4;        // [Read-write] OTG_HS host channel-4 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK4;     // [Read-write] OTG_HS host channel-4 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ4;       // [Read-write] OTG_HS host channel-4 transfer size register
    volatile uint32_t    OTG_HS_HCDMA4;        // [Read-write] OTG_HS host channel-4 DMA address register
    reserved_t<2>        _7;
    volatile uint32_t    OTG_HS_HCCHAR5;       // [Read-write] OTG_HS host channel-5 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT5;       // [Read-write] OTG_HS host channel-5 split control register
    volatile uint32_t    OTG_HS_HCINT5;        // [Read-write] OTG_HS host channel-5 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK5;     // [Read-write] OTG_HS host channel-5 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ5;       // [Read-write] OTG_HS host channel-5 transfer size register
    volatile uint32_t    OTG_HS_HCDMA5;        // [Read-write] OTG_HS host channel-5 DMA address register
    reserved_t<2>        _8;
    volatile uint32_t    OTG_HS_HCCHAR6;       // [Read-write] OTG_HS host channel-6 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT6;       // [Read-write] OTG_HS host channel-6 split control register
    volatile uint32_t    OTG_HS_HCINT6;        // [Read-write] OTG_HS host channel-6 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK6;     // [Read-write] OTG_HS host channel-6 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ6;       // [Read-write] OTG_HS host channel-6 transfer size register
    volatile uint32_t    OTG_HS_HCDMA6;        // [Read-write] OTG_HS host channel-6 DMA address register
    reserved_t<2>        _9;
    volatile uint32_t    OTG_HS_HCCHAR7;       // [Read-write] OTG_HS host channel-7 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT7;       // [Read-write] OTG_HS host channel-7 split control register
    volatile uint32_t    OTG_HS_HCINT7;        // [Read-write] OTG_HS host channel-7 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK7;     // [Read-write] OTG_HS host channel-7 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ7;       // [Read-write] OTG_HS host channel-7 transfer size register
    volatile uint32_t    OTG_HS_HCDMA7;        // [Read-write] OTG_HS host channel-7 DMA address register
    reserved_t<2>        _10;
    volatile uint32_t    OTG_HS_HCCHAR8;       // [Read-write] OTG_HS host channel-8 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT8;       // [Read-write] OTG_HS host channel-8 split control register
    volatile uint32_t    OTG_HS_HCINT8;        // [Read-write] OTG_HS host channel-8 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK8;     // [Read-write] OTG_HS host channel-8 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ8;       // [Read-write] OTG_HS host channel-8 transfer size register
    volatile uint32_t    OTG_HS_HCDMA8;        // [Read-write] OTG_HS host channel-8 DMA address register
    reserved_t<2>        _11;
    volatile uint32_t    OTG_HS_HCCHAR9;       // [Read-write] OTG_HS host channel-9 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT9;       // [Read-write] OTG_HS host channel-9 split control register
    volatile uint32_t    OTG_HS_HCINT9;        // [Read-write] OTG_HS host channel-9 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK9;     // [Read-write] OTG_HS host channel-9 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ9;       // [Read-write] OTG_HS host channel-9 transfer size register
    volatile uint32_t    OTG_HS_HCDMA9;        // [Read-write] OTG_HS host channel-9 DMA address register
    reserved_t<2>        _12;
    volatile uint32_t    OTG_HS_HCCHAR10;      // [Read-write] OTG_HS host channel-10 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT10;      // [Read-write] OTG_HS host channel-10 split control register
    volatile uint32_t    OTG_HS_HCINT10;       // [Read-write] OTG_HS host channel-10 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK10;    // [Read-write] OTG_HS host channel-10 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ10;      // [Read-write] OTG_HS host channel-10 transfer size register
    volatile uint32_t    OTG_HS_HCDMA10;       // [Read-write] OTG_HS host channel-10 DMA address register
    reserved_t<2>        _13;
    volatile uint32_t    OTG_HS_HCCHAR11;      // [Read-write] OTG_HS host channel-11 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT11;      // [Read-write] OTG_HS host channel-11 split control register
    volatile uint32_t    OTG_HS_HCINT11;       // [Read-write] OTG_HS host channel-11 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK11;    // [Read-write] OTG_HS host channel-11 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ11;      // [Read-write] OTG_HS host channel-11 transfer size register
    volatile uint32_t    OTG_HS_HCDMA11;       // [Read-write] OTG_HS host channel-11 DMA address register
    volatile uint32_t    OTG_HS_HCCHAR12;      // [Read-write] OTG_HS host channel-12 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT12;      // [Read-write] OTG_HS host channel-12 split control register
    volatile uint32_t    OTG_HS_HCINT12;       // [Read-write] OTG_HS host channel-12 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK12;    // [Read-write] OTG_HS host channel-12 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ12;      // [Read-write] OTG_HS host channel-12 transfer size register
    volatile uint32_t    OTG_HS_HCDMA12;       // [Read-write] OTG_HS host channel-12 DMA address register
    volatile uint32_t    OTG_HS_HCCHAR13;      // [Read-write] OTG_HS host channel-13 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT13;      // [Read-write] OTG_HS host channel-13 split control register
    volatile uint32_t    OTG_HS_HCINT13;       // [Read-write] OTG_HS host channel-13 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK13;    // [Read-write] OTG_HS host channel-13 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ13;      // [Read-write] OTG_HS host channel-13 transfer size register
    volatile uint32_t    OTG_HS_HCDMA13;       // [Read-write] OTG_HS host channel-13 DMA address register
    volatile uint32_t    OTG_HS_HCCHAR14;      // [Read-write] OTG_HS host channel-14 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT14;      // [Read-write] OTG_HS host channel-14 split control register
    volatile uint32_t    OTG_HS_HCINT14;       // [Read-write] OTG_HS host channel-14 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK14;    // [Read-write] OTG_HS host channel-14 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ14;      // [Read-write] OTG_HS host channel-14 transfer size register
    volatile uint32_t    OTG_HS_HCDMA14;       // [Read-write] OTG_HS host channel-14 DMA address register
    volatile uint32_t    OTG_HS_HCCHAR15;      // [Read-write] OTG_HS host channel-15 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT15;      // [Read-write] OTG_HS host channel-15 split control register
    volatile uint32_t    OTG_HS_HCINT15;       // [Read-write] OTG_HS host channel-15 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK15;    // [Read-write] OTG_HS host channel-15 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ15;      // [Read-write] OTG_HS host channel-15 transfer size register
    volatile uint32_t    OTG_HS_HCDMA15;       // [Read-write] OTG_HS host channel-15 DMA address register

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCFG_FSLSPCS =             // FS/LS PHY clock select (2 bits), Read-write
        bit_field_t<0, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCFG_FSLSS = 0x4;          // FS- and LS-only support, Read-only
    static const uint32_t OTG_HS_HCFG_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HFIR_FRIVL =               // Frame interval (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_HFIR_RESET_VALUE = 0xea60;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HFNUM_FRNUM =               // Frame number (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HFNUM_FTREM =               // Frame time remaining (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OTG_HS_HFNUM_RESET_VALUE = 0x3fff;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HPTXSTS_PTXFSAVL =            // Periodic transmit data FIFO space available (16 bits), Read-write
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HPTXSTS_PTXQSAV =             // Periodic transmit request queue space available (8 bits), Read-only
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HPTXSTS_PTXQTOP =             // Top of the periodic transmit request queue (8 bits), Read-only
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t OTG_HS_HPTXSTS_RESET_VALUE = 0x80100;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HAINT_HAINT =               // Channel interrupts (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_HAINT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HAINTMSK_HAINTM =              // Channel interrupt mask (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_HAINTMSK_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HPRT_PCSTS = 0x1;          // Port connect status, Read-only
    static constexpr uint32_t OTG_HS_HPRT_PCDET = 0x2;          // Port connect detected, Read-write
    static constexpr uint32_t OTG_HS_HPRT_PENA = 0x4;           // Port enable, Read-write
    static constexpr uint32_t OTG_HS_HPRT_PENCHNG = 0x8;        // Port enable/disable change, Read-write
    static constexpr uint32_t OTG_HS_HPRT_POCA = 0x10;          // Port overcurrent active, Read-only
    static constexpr uint32_t OTG_HS_HPRT_POCCHNG = 0x20;       // Port overcurrent change, Read-write
    static constexpr uint32_t OTG_HS_HPRT_PRES = 0x40;          // Port resume, Read-write
    static constexpr uint32_t OTG_HS_HPRT_PSUSP = 0x80;         // Port suspend, Read-write
    static constexpr uint32_t OTG_HS_HPRT_PRST = 0x100;         // Port reset, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HPRT_PLSTS =               // Port line status (2 bits), Read-only
        bit_field_t<10, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HPRT_PPWR = 0x1000;        // Port power, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HPRT_PTCTL =               // Port test control (4 bits), Read-write
        bit_field_t<13, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HPRT_PSPD =                // Port speed (2 bits), Read-only
        bit_field_t<17, 0x3>::value<X>();
    static const uint32_t OTG_HS_HPRT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR0_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR0_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR0_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR0_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR0_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR0_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR0_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR0_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR0_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR0_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR0_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT0_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT0_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT0_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT0_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT0_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT0_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT0_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT0_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT0_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT0_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT0_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT0_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT0_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT0_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT0_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT0_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT0_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT0_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK0_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK0_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK0_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK0_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK0_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK0_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK0_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK0_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_HS_HCINTMSK0_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_HS_HCINTMSK0_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK0_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK0_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ0_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ0_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ0_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ0_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA0_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR1_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR1_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR1_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR1_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR1_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR1_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR1_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR1_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR1_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR1_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT1_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT1_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT1_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT1_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT1_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT1_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT1_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT1_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT1_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT1_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT1_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT1_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT1_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT1_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT1_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT1_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT1_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT1_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK1_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK1_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK1_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK1_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK1_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK1_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK1_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK1_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_HS_HCINTMSK1_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_HS_HCINTMSK1_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK1_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ1_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ1_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ1_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ1_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR2_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR2_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR2_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR2_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR2_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR2_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR2_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR2_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR2_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR2_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT2_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT2_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT2_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT2_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT2_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT2_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT2_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT2_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT2_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT2_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT2_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT2_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT2_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT2_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT2_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT2_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT2_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT2_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK2_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK2_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK2_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK2_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK2_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK2_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK2_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK2_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_HS_HCINTMSK2_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_HS_HCINTMSK2_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK2_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ2_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ2_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ2_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ2_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR3_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR3_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR3_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR3_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR3_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR3_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR3_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR3_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR3_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR3_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT3_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT3_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT3_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT3_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT3_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT3_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT3_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT3_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT3_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT3_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT3_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT3_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT3_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT3_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT3_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT3_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT3_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT3_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK3_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK3_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK3_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK3_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK3_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK3_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK3_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK3_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_HS_HCINTMSK3_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_HS_HCINTMSK3_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK3_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ3_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ3_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ3_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ3_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR4_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR4_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR4_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR4_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR4_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR4_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR4_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR4_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR4_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR4_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT4_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT4_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT4_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT4_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT4_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT4_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT4_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT4_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT4_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT4_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT4_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT4_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT4_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT4_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT4_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT4_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT4_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT4_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK4_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK4_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK4_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK4_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK4_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK4_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK4_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK4_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_HS_HCINTMSK4_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_HS_HCINTMSK4_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK4_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ4_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ4_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ4_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ4_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR5_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR5_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR5_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR5_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR5_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR5_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR5_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR5_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR5_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR5_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT5_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT5_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT5_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT5_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT5_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT5_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT5_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT5_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT5_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT5_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT5_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT5_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT5_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT5_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT5_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT5_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT5_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT5_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK5_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK5_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK5_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK5_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK5_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK5_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK5_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK5_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_HS_HCINTMSK5_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_HS_HCINTMSK5_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK5_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ5_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ5_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ5_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ5_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR6_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR6_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR6_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR6_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR6_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR6_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR6_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR6_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR6_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR6_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR6_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT6_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT6_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT6_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT6_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT6_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT6_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT6_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT6_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT6_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT6_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT6_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT6_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT6_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT6_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT6_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT6_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT6_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT6_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK6_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK6_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK6_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK6_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK6_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK6_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK6_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK6_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_HS_HCINTMSK6_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_HS_HCINTMSK6_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK6_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK6_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ6_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ6_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ6_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ6_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA6_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR7_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR7_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR7_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR7_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR7_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR7_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR7_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR7_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR7_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR7_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR7_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT7_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT7_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT7_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT7_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT7_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT7_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT7_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT7_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT7_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT7_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT7_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT7_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT7_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT7_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT7_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT7_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT7_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT7_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK7_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK7_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK7_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK7_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK7_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK7_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK7_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK7_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_HS_HCINTMSK7_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_HS_HCINTMSK7_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK7_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK7_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ7_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ7_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ7_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ7_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA7_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR8_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR8_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR8_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR8_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR8_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR8_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR8_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR8_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR8_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR8_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR8_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT8_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT8_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT8_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT8_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT8_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT8_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT8_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT8_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT8_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT8_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT8_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT8_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT8_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT8_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT8_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT8_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT8_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT8_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK8_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK8_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK8_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK8_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK8_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK8_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK8_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK8_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_HS_HCINTMSK8_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_HS_HCINTMSK8_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK8_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK8_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ8_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ8_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ8_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ8_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA8_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR9_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR9_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR9_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR9_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR9_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR9_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR9_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR9_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR9_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR9_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR9_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT9_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT9_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT9_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT9_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT9_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT9_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT9_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT9_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT9_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT9_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT9_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT9_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT9_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT9_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT9_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT9_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT9_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT9_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK9_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK9_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK9_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK9_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK9_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK9_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK9_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK9_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_HS_HCINTMSK9_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_HS_HCINTMSK9_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK9_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK9_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ9_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ9_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ9_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ9_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA9_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR10_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR10_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR10_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR10_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR10_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR10_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR10_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR10_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR10_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR10_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR10_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT10_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT10_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT10_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT10_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT10_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT10_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT10_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT10_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT10_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT10_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT10_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT10_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT10_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT10_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT10_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT10_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT10_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT10_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK10_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK10_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK10_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK10_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK10_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK10_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK10_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK10_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_HS_HCINTMSK10_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_HS_HCINTMSK10_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK10_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK10_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ10_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ10_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ10_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ10_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA10_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR11_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR11_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR11_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR11_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR11_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR11_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR11_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR11_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR11_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR11_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR11_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT11_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT11_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT11_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT11_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT11_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT11_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT11_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT11_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT11_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT11_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT11_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT11_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT11_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT11_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT11_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT11_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT11_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT11_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK11_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK11_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK11_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK11_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK11_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK11_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK11_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK11_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_HS_HCINTMSK11_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_HS_HCINTMSK11_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK11_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK11_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ11_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ11_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ11_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ11_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA11_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR12_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR12_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR12_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR12_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR12_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR12_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR12_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR12_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR12_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR12_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR12_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT12_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT12_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT12_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT12_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT12_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT12_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT12_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT12_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT12_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT12_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT12_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT12_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT12_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT12_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT12_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT12_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT12_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT12_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK12_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK12_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK12_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK12_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK12_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK12_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK12_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINTMSK12_TXERRM = 0x80;        // Transaction error
    static constexpr uint32_t OTG_HS_HCINTMSK12_BBERRM = 0x100;       // Babble error
    static constexpr uint32_t OTG_HS_HCINTMSK12_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK12_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK12_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ12_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ12_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ12_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ12_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA12_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR13_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR13_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR13_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR13_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR13_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR13_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR13_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR13_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR13_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR13_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR13_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT13_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT13_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT13_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT13_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT13_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT13_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT13_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT13_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT13_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT13_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT13_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT13_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT13_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT13_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT13_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT13_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT13_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT13_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK13_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK13_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK13_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK13_STALLM = 0x8;         // STALLM response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK13_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK13_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK13_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINTMSK13_TXERRM = 0x80;        // Transaction error
    static constexpr uint32_t OTG_HS_HCINTMSK13_BBERRM = 0x100;       // Babble error
    static constexpr uint32_t OTG_HS_HCINTMSK13_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK13_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK13_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ13_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ13_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ13_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ13_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA13_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR14_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR14_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR14_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR14_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR14_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR14_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR14_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR14_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR14_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR14_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR14_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT14_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT14_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT14_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT14_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT14_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT14_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT14_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT14_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT14_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT14_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT14_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT14_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT14_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT14_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT14_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT14_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT14_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT14_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK14_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK14_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK14_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK14_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK14_NAKM = 0x10;          // NAKM response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK14_ACKM = 0x20;          // ACKM response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK14_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINTMSK14_TXERRM = 0x80;        // Transaction error
    static constexpr uint32_t OTG_HS_HCINTMSK14_BBERRM = 0x100;       // Babble error
    static constexpr uint32_t OTG_HS_HCINTMSK14_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK14_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK14_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ14_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ14_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ14_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ14_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA14_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR15_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR15_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR15_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR15_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR15_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR15_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR15_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR15_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR15_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR15_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR15_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT15_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT15_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT15_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT15_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT15_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT15_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT15_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT15_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT15_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT15_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT15_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT15_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT15_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT15_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT15_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT15_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT15_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT15_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK15_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK15_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK15_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK15_STALL = 0x8;          // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK15_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK15_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK15_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINTMSK15_TXERRM = 0x80;        // Transaction error
    static constexpr uint32_t OTG_HS_HCINTMSK15_BBERRM = 0x100;       // Babble error
    static constexpr uint32_t OTG_HS_HCINTMSK15_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK15_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK15_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ15_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ15_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ15_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ15_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA15_RESET_VALUE = 0x0;

    static constexpr uint8_t OTG_FS = 101; // OTG_FS global interrupt
};

static otg1_hs_host_t& OTG1_HS_HOST = *reinterpret_cast<otg1_hs_host_t*>(0x40040400);

#define HAVE_PERIPHERAL_OTG1_HS_HOST


////
//
//    USB 1 on the go high speed
//
////

struct otg2_hs_host_t
{
    volatile uint32_t    OTG_HS_HCFG;          // OTG_HS host configuration register
    volatile uint32_t    OTG_HS_HFIR;          // [Read-write] OTG_HS Host frame interval register
    volatile uint32_t    OTG_HS_HFNUM;         // [Read-only] OTG_HS host frame number/frame time remaining register
    reserved_t<1>        _0;
    volatile uint32_t    OTG_HS_HPTXSTS;       // OTG_HS_Host periodic transmit FIFO/queue status register
    volatile uint32_t    OTG_HS_HAINT;         // [Read-only] OTG_HS Host all channels interrupt register
    volatile uint32_t    OTG_HS_HAINTMSK;      // [Read-write] OTG_HS host all channels interrupt mask register
    reserved_t<9>        _1;
    volatile uint32_t    OTG_HS_HPRT;          // OTG_HS host port control and status register
    reserved_t<47>       _2;
    volatile uint32_t    OTG_HS_HCCHAR0;       // [Read-write] OTG_HS host channel-0 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT0;       // [Read-write] OTG_HS host channel-0 split control register
    volatile uint32_t    OTG_HS_HCINT0;        // [Read-write] OTG_HS host channel-11 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK0;     // [Read-write] OTG_HS host channel-11 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ0;       // [Read-write] OTG_HS host channel-11 transfer size register
    volatile uint32_t    OTG_HS_HCDMA0;        // [Read-write] OTG_HS host channel-0 DMA address register
    reserved_t<2>        _3;
    volatile uint32_t    OTG_HS_HCCHAR1;       // [Read-write] OTG_HS host channel-1 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT1;       // [Read-write] OTG_HS host channel-1 split control register
    volatile uint32_t    OTG_HS_HCINT1;        // [Read-write] OTG_HS host channel-1 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK1;     // [Read-write] OTG_HS host channel-1 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ1;       // [Read-write] OTG_HS host channel-1 transfer size register
    volatile uint32_t    OTG_HS_HCDMA1;        // [Read-write] OTG_HS host channel-1 DMA address register
    reserved_t<2>        _4;
    volatile uint32_t    OTG_HS_HCCHAR2;       // [Read-write] OTG_HS host channel-2 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT2;       // [Read-write] OTG_HS host channel-2 split control register
    volatile uint32_t    OTG_HS_HCINT2;        // [Read-write] OTG_HS host channel-2 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK2;     // [Read-write] OTG_HS host channel-2 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ2;       // [Read-write] OTG_HS host channel-2 transfer size register
    volatile uint32_t    OTG_HS_HCDMA2;        // [Read-write] OTG_HS host channel-2 DMA address register
    reserved_t<2>        _5;
    volatile uint32_t    OTG_HS_HCCHAR3;       // [Read-write] OTG_HS host channel-3 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT3;       // [Read-write] OTG_HS host channel-3 split control register
    volatile uint32_t    OTG_HS_HCINT3;        // [Read-write] OTG_HS host channel-3 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK3;     // [Read-write] OTG_HS host channel-3 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ3;       // [Read-write] OTG_HS host channel-3 transfer size register
    volatile uint32_t    OTG_HS_HCDMA3;        // [Read-write] OTG_HS host channel-3 DMA address register
    reserved_t<2>        _6;
    volatile uint32_t    OTG_HS_HCCHAR4;       // [Read-write] OTG_HS host channel-4 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT4;       // [Read-write] OTG_HS host channel-4 split control register
    volatile uint32_t    OTG_HS_HCINT4;        // [Read-write] OTG_HS host channel-4 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK4;     // [Read-write] OTG_HS host channel-4 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ4;       // [Read-write] OTG_HS host channel-4 transfer size register
    volatile uint32_t    OTG_HS_HCDMA4;        // [Read-write] OTG_HS host channel-4 DMA address register
    reserved_t<2>        _7;
    volatile uint32_t    OTG_HS_HCCHAR5;       // [Read-write] OTG_HS host channel-5 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT5;       // [Read-write] OTG_HS host channel-5 split control register
    volatile uint32_t    OTG_HS_HCINT5;        // [Read-write] OTG_HS host channel-5 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK5;     // [Read-write] OTG_HS host channel-5 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ5;       // [Read-write] OTG_HS host channel-5 transfer size register
    volatile uint32_t    OTG_HS_HCDMA5;        // [Read-write] OTG_HS host channel-5 DMA address register
    reserved_t<2>        _8;
    volatile uint32_t    OTG_HS_HCCHAR6;       // [Read-write] OTG_HS host channel-6 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT6;       // [Read-write] OTG_HS host channel-6 split control register
    volatile uint32_t    OTG_HS_HCINT6;        // [Read-write] OTG_HS host channel-6 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK6;     // [Read-write] OTG_HS host channel-6 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ6;       // [Read-write] OTG_HS host channel-6 transfer size register
    volatile uint32_t    OTG_HS_HCDMA6;        // [Read-write] OTG_HS host channel-6 DMA address register
    reserved_t<2>        _9;
    volatile uint32_t    OTG_HS_HCCHAR7;       // [Read-write] OTG_HS host channel-7 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT7;       // [Read-write] OTG_HS host channel-7 split control register
    volatile uint32_t    OTG_HS_HCINT7;        // [Read-write] OTG_HS host channel-7 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK7;     // [Read-write] OTG_HS host channel-7 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ7;       // [Read-write] OTG_HS host channel-7 transfer size register
    volatile uint32_t    OTG_HS_HCDMA7;        // [Read-write] OTG_HS host channel-7 DMA address register
    reserved_t<2>        _10;
    volatile uint32_t    OTG_HS_HCCHAR8;       // [Read-write] OTG_HS host channel-8 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT8;       // [Read-write] OTG_HS host channel-8 split control register
    volatile uint32_t    OTG_HS_HCINT8;        // [Read-write] OTG_HS host channel-8 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK8;     // [Read-write] OTG_HS host channel-8 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ8;       // [Read-write] OTG_HS host channel-8 transfer size register
    volatile uint32_t    OTG_HS_HCDMA8;        // [Read-write] OTG_HS host channel-8 DMA address register
    reserved_t<2>        _11;
    volatile uint32_t    OTG_HS_HCCHAR9;       // [Read-write] OTG_HS host channel-9 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT9;       // [Read-write] OTG_HS host channel-9 split control register
    volatile uint32_t    OTG_HS_HCINT9;        // [Read-write] OTG_HS host channel-9 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK9;     // [Read-write] OTG_HS host channel-9 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ9;       // [Read-write] OTG_HS host channel-9 transfer size register
    volatile uint32_t    OTG_HS_HCDMA9;        // [Read-write] OTG_HS host channel-9 DMA address register
    reserved_t<2>        _12;
    volatile uint32_t    OTG_HS_HCCHAR10;      // [Read-write] OTG_HS host channel-10 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT10;      // [Read-write] OTG_HS host channel-10 split control register
    volatile uint32_t    OTG_HS_HCINT10;       // [Read-write] OTG_HS host channel-10 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK10;    // [Read-write] OTG_HS host channel-10 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ10;      // [Read-write] OTG_HS host channel-10 transfer size register
    volatile uint32_t    OTG_HS_HCDMA10;       // [Read-write] OTG_HS host channel-10 DMA address register
    reserved_t<2>        _13;
    volatile uint32_t    OTG_HS_HCCHAR11;      // [Read-write] OTG_HS host channel-11 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT11;      // [Read-write] OTG_HS host channel-11 split control register
    volatile uint32_t    OTG_HS_HCINT11;       // [Read-write] OTG_HS host channel-11 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK11;    // [Read-write] OTG_HS host channel-11 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ11;      // [Read-write] OTG_HS host channel-11 transfer size register
    volatile uint32_t    OTG_HS_HCDMA11;       // [Read-write] OTG_HS host channel-11 DMA address register
    volatile uint32_t    OTG_HS_HCCHAR12;      // [Read-write] OTG_HS host channel-12 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT12;      // [Read-write] OTG_HS host channel-12 split control register
    volatile uint32_t    OTG_HS_HCINT12;       // [Read-write] OTG_HS host channel-12 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK12;    // [Read-write] OTG_HS host channel-12 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ12;      // [Read-write] OTG_HS host channel-12 transfer size register
    volatile uint32_t    OTG_HS_HCDMA12;       // [Read-write] OTG_HS host channel-12 DMA address register
    volatile uint32_t    OTG_HS_HCCHAR13;      // [Read-write] OTG_HS host channel-13 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT13;      // [Read-write] OTG_HS host channel-13 split control register
    volatile uint32_t    OTG_HS_HCINT13;       // [Read-write] OTG_HS host channel-13 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK13;    // [Read-write] OTG_HS host channel-13 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ13;      // [Read-write] OTG_HS host channel-13 transfer size register
    volatile uint32_t    OTG_HS_HCDMA13;       // [Read-write] OTG_HS host channel-13 DMA address register
    volatile uint32_t    OTG_HS_HCCHAR14;      // [Read-write] OTG_HS host channel-14 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT14;      // [Read-write] OTG_HS host channel-14 split control register
    volatile uint32_t    OTG_HS_HCINT14;       // [Read-write] OTG_HS host channel-14 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK14;    // [Read-write] OTG_HS host channel-14 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ14;      // [Read-write] OTG_HS host channel-14 transfer size register
    volatile uint32_t    OTG_HS_HCDMA14;       // [Read-write] OTG_HS host channel-14 DMA address register
    volatile uint32_t    OTG_HS_HCCHAR15;      // [Read-write] OTG_HS host channel-15 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT15;      // [Read-write] OTG_HS host channel-15 split control register
    volatile uint32_t    OTG_HS_HCINT15;       // [Read-write] OTG_HS host channel-15 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK15;    // [Read-write] OTG_HS host channel-15 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ15;      // [Read-write] OTG_HS host channel-15 transfer size register
    volatile uint32_t    OTG_HS_HCDMA15;       // [Read-write] OTG_HS host channel-15 DMA address register

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCFG_FSLSPCS =             // FS/LS PHY clock select (2 bits), Read-write
        bit_field_t<0, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCFG_FSLSS = 0x4;          // FS- and LS-only support, Read-only
    static const uint32_t OTG_HS_HCFG_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HFIR_FRIVL =               // Frame interval (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_HFIR_RESET_VALUE = 0xea60;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HFNUM_FRNUM =               // Frame number (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HFNUM_FTREM =               // Frame time remaining (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OTG_HS_HFNUM_RESET_VALUE = 0x3fff;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HPTXSTS_PTXFSAVL =            // Periodic transmit data FIFO space available (16 bits), Read-write
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HPTXSTS_PTXQSAV =             // Periodic transmit request queue space available (8 bits), Read-only
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HPTXSTS_PTXQTOP =             // Top of the periodic transmit request queue (8 bits), Read-only
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t OTG_HS_HPTXSTS_RESET_VALUE = 0x80100;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HAINT_HAINT =               // Channel interrupts (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_HAINT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HAINTMSK_HAINTM =              // Channel interrupt mask (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_HAINTMSK_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HPRT_PCSTS = 0x1;          // Port connect status, Read-only
    static constexpr uint32_t OTG_HS_HPRT_PCDET = 0x2;          // Port connect detected, Read-write
    static constexpr uint32_t OTG_HS_HPRT_PENA = 0x4;           // Port enable, Read-write
    static constexpr uint32_t OTG_HS_HPRT_PENCHNG = 0x8;        // Port enable/disable change, Read-write
    static constexpr uint32_t OTG_HS_HPRT_POCA = 0x10;          // Port overcurrent active, Read-only
    static constexpr uint32_t OTG_HS_HPRT_POCCHNG = 0x20;       // Port overcurrent change, Read-write
    static constexpr uint32_t OTG_HS_HPRT_PRES = 0x40;          // Port resume, Read-write
    static constexpr uint32_t OTG_HS_HPRT_PSUSP = 0x80;         // Port suspend, Read-write
    static constexpr uint32_t OTG_HS_HPRT_PRST = 0x100;         // Port reset, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HPRT_PLSTS =               // Port line status (2 bits), Read-only
        bit_field_t<10, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HPRT_PPWR = 0x1000;        // Port power, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HPRT_PTCTL =               // Port test control (4 bits), Read-write
        bit_field_t<13, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HPRT_PSPD =                // Port speed (2 bits), Read-only
        bit_field_t<17, 0x3>::value<X>();
    static const uint32_t OTG_HS_HPRT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR0_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR0_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR0_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR0_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR0_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR0_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR0_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR0_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR0_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR0_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR0_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT0_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT0_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT0_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT0_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT0_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT0_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT0_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT0_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT0_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT0_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT0_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT0_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT0_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT0_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT0_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT0_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT0_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT0_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK0_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK0_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK0_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK0_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK0_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK0_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK0_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK0_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_HS_HCINTMSK0_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_HS_HCINTMSK0_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK0_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK0_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ0_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ0_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ0_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ0_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA0_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR1_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR1_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR1_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR1_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR1_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR1_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR1_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR1_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR1_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR1_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT1_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT1_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT1_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT1_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT1_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT1_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT1_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT1_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT1_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT1_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT1_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT1_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT1_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT1_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT1_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT1_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT1_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT1_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK1_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK1_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK1_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK1_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK1_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK1_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK1_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK1_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_HS_HCINTMSK1_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_HS_HCINTMSK1_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK1_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ1_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ1_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ1_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ1_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR2_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR2_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR2_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR2_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR2_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR2_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR2_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR2_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR2_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR2_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT2_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT2_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT2_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT2_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT2_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT2_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT2_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT2_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT2_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT2_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT2_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT2_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT2_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT2_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT2_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT2_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT2_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT2_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK2_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK2_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK2_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK2_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK2_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK2_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK2_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK2_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_HS_HCINTMSK2_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_HS_HCINTMSK2_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK2_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ2_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ2_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ2_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ2_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR3_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR3_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR3_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR3_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR3_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR3_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR3_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR3_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR3_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR3_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT3_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT3_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT3_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT3_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT3_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT3_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT3_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT3_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT3_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT3_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT3_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT3_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT3_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT3_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT3_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT3_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT3_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT3_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK3_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK3_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK3_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK3_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK3_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK3_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK3_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK3_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_HS_HCINTMSK3_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_HS_HCINTMSK3_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK3_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ3_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ3_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ3_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ3_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR4_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR4_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR4_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR4_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR4_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR4_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR4_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR4_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR4_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR4_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT4_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT4_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT4_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT4_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT4_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT4_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT4_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT4_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT4_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT4_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT4_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT4_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT4_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT4_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT4_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT4_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT4_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT4_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK4_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK4_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK4_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK4_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK4_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK4_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK4_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK4_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_HS_HCINTMSK4_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_HS_HCINTMSK4_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK4_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ4_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ4_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ4_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ4_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR5_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR5_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR5_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR5_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR5_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR5_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR5_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR5_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR5_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR5_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT5_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT5_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT5_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT5_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT5_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT5_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT5_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT5_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT5_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT5_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT5_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT5_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT5_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT5_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT5_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT5_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT5_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT5_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK5_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK5_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK5_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK5_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK5_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK5_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK5_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK5_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_HS_HCINTMSK5_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_HS_HCINTMSK5_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK5_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ5_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ5_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ5_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ5_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR6_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR6_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR6_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR6_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR6_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR6_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR6_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR6_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR6_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR6_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR6_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT6_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT6_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT6_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT6_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT6_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT6_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT6_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT6_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT6_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT6_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT6_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT6_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT6_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT6_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT6_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT6_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT6_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT6_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK6_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK6_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK6_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK6_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK6_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK6_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK6_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK6_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_HS_HCINTMSK6_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_HS_HCINTMSK6_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK6_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK6_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ6_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ6_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ6_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ6_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA6_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR7_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR7_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR7_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR7_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR7_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR7_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR7_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR7_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR7_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR7_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR7_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT7_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT7_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT7_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT7_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT7_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT7_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT7_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT7_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT7_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT7_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT7_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT7_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT7_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT7_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT7_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT7_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT7_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT7_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK7_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK7_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK7_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK7_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK7_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK7_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK7_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK7_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_HS_HCINTMSK7_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_HS_HCINTMSK7_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK7_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK7_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ7_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ7_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ7_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ7_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA7_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR8_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR8_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR8_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR8_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR8_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR8_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR8_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR8_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR8_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR8_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR8_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT8_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT8_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT8_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT8_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT8_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT8_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT8_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT8_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT8_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT8_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT8_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT8_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT8_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT8_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT8_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT8_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT8_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT8_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK8_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK8_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK8_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK8_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK8_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK8_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK8_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK8_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_HS_HCINTMSK8_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_HS_HCINTMSK8_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK8_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK8_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ8_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ8_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ8_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ8_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA8_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR9_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR9_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR9_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR9_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR9_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR9_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR9_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR9_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR9_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR9_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR9_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT9_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT9_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT9_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT9_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT9_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT9_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT9_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT9_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT9_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT9_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT9_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT9_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT9_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT9_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT9_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT9_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT9_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT9_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK9_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK9_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK9_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK9_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK9_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK9_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK9_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK9_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_HS_HCINTMSK9_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_HS_HCINTMSK9_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK9_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK9_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ9_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ9_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ9_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ9_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA9_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR10_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR10_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR10_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR10_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR10_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR10_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR10_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR10_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR10_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR10_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR10_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT10_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT10_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT10_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT10_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT10_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT10_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT10_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT10_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT10_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT10_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT10_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT10_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT10_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT10_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT10_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT10_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT10_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT10_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK10_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK10_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK10_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK10_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK10_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK10_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK10_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK10_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_HS_HCINTMSK10_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_HS_HCINTMSK10_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK10_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK10_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ10_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ10_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ10_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ10_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA10_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR11_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR11_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR11_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR11_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR11_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR11_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR11_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR11_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR11_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR11_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR11_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT11_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT11_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT11_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT11_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT11_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT11_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT11_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT11_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT11_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT11_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT11_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT11_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT11_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT11_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT11_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT11_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT11_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT11_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK11_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK11_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK11_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK11_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK11_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK11_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK11_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK11_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_HS_HCINTMSK11_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_HS_HCINTMSK11_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK11_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK11_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ11_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ11_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ11_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ11_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA11_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR12_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR12_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR12_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR12_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR12_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR12_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR12_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR12_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR12_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR12_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR12_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT12_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT12_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT12_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT12_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT12_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT12_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT12_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT12_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT12_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT12_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT12_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT12_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT12_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT12_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT12_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT12_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT12_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT12_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK12_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK12_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK12_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK12_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK12_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK12_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK12_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINTMSK12_TXERRM = 0x80;        // Transaction error
    static constexpr uint32_t OTG_HS_HCINTMSK12_BBERRM = 0x100;       // Babble error
    static constexpr uint32_t OTG_HS_HCINTMSK12_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK12_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK12_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ12_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ12_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ12_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ12_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA12_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR13_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR13_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR13_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR13_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR13_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR13_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR13_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR13_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR13_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR13_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR13_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT13_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT13_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT13_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT13_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT13_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT13_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT13_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT13_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT13_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT13_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT13_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT13_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT13_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT13_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT13_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT13_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT13_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT13_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK13_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK13_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK13_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK13_STALLM = 0x8;         // STALLM response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK13_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK13_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK13_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINTMSK13_TXERRM = 0x80;        // Transaction error
    static constexpr uint32_t OTG_HS_HCINTMSK13_BBERRM = 0x100;       // Babble error
    static constexpr uint32_t OTG_HS_HCINTMSK13_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK13_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK13_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ13_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ13_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ13_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ13_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA13_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR14_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR14_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR14_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR14_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR14_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR14_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR14_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR14_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR14_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR14_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR14_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT14_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT14_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT14_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT14_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT14_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT14_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT14_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT14_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT14_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT14_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT14_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT14_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT14_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT14_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT14_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT14_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT14_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT14_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK14_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK14_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK14_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK14_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK14_NAKM = 0x10;          // NAKM response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK14_ACKM = 0x20;          // ACKM response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK14_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINTMSK14_TXERRM = 0x80;        // Transaction error
    static constexpr uint32_t OTG_HS_HCINTMSK14_BBERRM = 0x100;       // Babble error
    static constexpr uint32_t OTG_HS_HCINTMSK14_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK14_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK14_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ14_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ14_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ14_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ14_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA14_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR15_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR15_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR15_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR15_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR15_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR15_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR15_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR15_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR15_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR15_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR15_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT15_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT15_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT15_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT15_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT15_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT15_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT15_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT15_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT15_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT15_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT15_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT15_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT15_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT15_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT15_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT15_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT15_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT15_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK15_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK15_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK15_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK15_STALL = 0x8;          // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK15_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK15_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK15_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINTMSK15_TXERRM = 0x80;        // Transaction error
    static constexpr uint32_t OTG_HS_HCINTMSK15_BBERRM = 0x100;       // Babble error
    static constexpr uint32_t OTG_HS_HCINTMSK15_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK15_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK15_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ15_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ15_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ15_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ15_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA15_RESET_VALUE = 0x0;
};

static otg2_hs_host_t& OTG2_HS_HOST = *reinterpret_cast<otg2_hs_host_t*>(0x40080400);

#define HAVE_PERIPHERAL_OTG2_HS_HOST


////
//
//    USB 1 on the go high speed
//
////

struct otg1_hs_device_t
{
    volatile uint32_t    OTG_HS_DCFG;          // [Read-write] OTG_HS device configuration register
    volatile uint32_t    OTG_HS_DCTL;          // OTG_HS device control register
    volatile uint32_t    OTG_HS_DSTS;          // [Read-only] OTG_HS device status register
    reserved_t<1>        _0;
    volatile uint32_t    OTG_HS_DIEPMSK;       // [Read-write] OTG_HS device IN endpoint common interrupt mask register
    volatile uint32_t    OTG_HS_DOEPMSK;       // [Read-write] OTG_HS device OUT endpoint common interrupt mask register
    volatile uint32_t    OTG_HS_DAINT;         // [Read-only] OTG_HS device all endpoints interrupt register
    volatile uint32_t    OTG_HS_DAINTMSK;      // [Read-write] OTG_HS all endpoints interrupt mask register
    reserved_t<2>        _1;
    volatile uint32_t    OTG_HS_DVBUSDIS;      // [Read-write] OTG_HS device VBUS discharge time register
    volatile uint32_t    OTG_HS_DVBUSPULSE;    // [Read-write] OTG_HS device VBUS pulsing time register
    volatile uint32_t    OTG_HS_DTHRCTL;       // [Read-write] OTG_HS Device threshold control register
    volatile uint32_t    OTG_HS_DIEPEMPMSK;    // [Read-write] OTG_HS device IN endpoint FIFO empty interrupt mask register
    volatile uint32_t    OTG_HS_DEACHINT;      // [Read-write] OTG_HS device each endpoint interrupt register
    volatile uint32_t    OTG_HS_DEACHINTMSK;   // [Read-write] OTG_HS device each endpoint interrupt register mask
    reserved_t<48>       _2;
    volatile uint32_t    OTG_HS_DIEPCTL0;      // OTG device endpoint-0 control register
    reserved_t<1>        _3;
    volatile uint32_t    OTG_HS_DIEPINT0;      // OTG device endpoint-0 interrupt register
    reserved_t<1>        _4;
    volatile uint32_t    OTG_HS_DIEPTSIZ0;     // [Read-write] OTG_HS device IN endpoint 0 transfer size register
    volatile uint32_t    OTG_HS_DIEPDMA1;      // [Read-write] OTG_HS device endpoint-1 DMA address register
    volatile uint32_t    OTG_HS_DTXFSTS0;      // [Read-only] OTG_HS device IN endpoint transmit FIFO status register
    reserved_t<1>        _5;
    volatile uint32_t    OTG_HS_DIEPCTL1;      // OTG device endpoint-1 control register
    reserved_t<1>        _6;
    volatile uint32_t    OTG_HS_DIEPINT1;      // OTG device endpoint-1 interrupt register
    reserved_t<1>        _7;
    volatile uint32_t    OTG_HS_DIEPTSIZ1;     // [Read-write] OTG_HS device endpoint transfer size register
    volatile uint32_t    OTG_HS_DIEPDMA2;      // [Read-write] OTG_HS device endpoint-2 DMA address register
    volatile uint32_t    OTG_HS_DTXFSTS1;      // [Read-only] OTG_HS device IN endpoint transmit FIFO status register
    reserved_t<1>        _8;
    volatile uint32_t    OTG_HS_DIEPCTL2;      // OTG device endpoint-2 control register
    reserved_t<1>        _9;
    volatile uint32_t    OTG_HS_DIEPINT2;      // OTG device endpoint-2 interrupt register
    reserved_t<1>        _10;
    volatile uint32_t    OTG_HS_DIEPTSIZ2;     // [Read-write] OTG_HS device endpoint transfer size register
    volatile uint32_t    OTG_HS_DIEPDMA3;      // [Read-write] OTG_HS device endpoint-3 DMA address register
    volatile uint32_t    OTG_HS_DTXFSTS2;      // [Read-only] OTG_HS device IN endpoint transmit FIFO status register
    reserved_t<1>        _11;
    volatile uint32_t    OTG_HS_DIEPCTL3;      // OTG device endpoint-3 control register
    reserved_t<1>        _12;
    volatile uint32_t    OTG_HS_DIEPINT3;      // OTG device endpoint-3 interrupt register
    reserved_t<1>        _13;
    volatile uint32_t    OTG_HS_DIEPTSIZ3;     // [Read-write] OTG_HS device endpoint transfer size register
    volatile uint32_t    OTG_HS_DIEPDMA4;      // [Read-write] OTG_HS device endpoint-4 DMA address register
    volatile uint32_t    OTG_HS_DTXFSTS3;      // [Read-only] OTG_HS device IN endpoint transmit FIFO status register
    reserved_t<1>        _14;
    volatile uint32_t    OTG_HS_DIEPCTL4;      // OTG device endpoint-4 control register
    reserved_t<1>        _15;
    volatile uint32_t    OTG_HS_DIEPINT4;      // OTG device endpoint-4 interrupt register
    reserved_t<1>        _16;
    volatile uint32_t    OTG_HS_DIEPTSIZ4;     // [Read-write] OTG_HS device endpoint transfer size register
    volatile uint32_t    OTG_HS_DIEPDMA5;      // [Read-write] OTG_HS device endpoint-5 DMA address register
    volatile uint32_t    OTG_HS_DTXFSTS4;      // [Read-only] OTG_HS device IN endpoint transmit FIFO status register
    reserved_t<1>        _17;
    volatile uint32_t    OTG_HS_DIEPCTL5;      // OTG device endpoint-5 control register
    volatile uint32_t    OTG_HS_DTXFSTS6;      // [Read-write] OTG_HS device IN endpoint transmit FIFO status register
    volatile uint32_t    OTG_HS_DIEPINT5;      // OTG device endpoint-5 interrupt register
    volatile uint32_t    OTG_HS_DTXFSTS7;      // [Read-write] OTG_HS device IN endpoint transmit FIFO status register
    volatile uint32_t    OTG_HS_DIEPTSIZ5;     // [Read-write] OTG_HS device endpoint transfer size register
    reserved_t<1>        _18;
    volatile uint32_t    OTG_HS_DTXFSTS5;      // [Read-only] OTG_HS device IN endpoint transmit FIFO status register
    reserved_t<1>        _19;
    volatile uint32_t    OTG_HS_DIEPCTL6;      // OTG device endpoint-6 control register
    reserved_t<1>        _20;
    volatile uint32_t    OTG_HS_DIEPINT6;      // OTG device endpoint-6 interrupt register
    reserved_t<5>        _21;
    volatile uint32_t    OTG_HS_DIEPCTL7;      // OTG device endpoint-7 control register
    reserved_t<1>        _22;
    volatile uint32_t    OTG_HS_DIEPINT7;      // OTG device endpoint-7 interrupt register
    reserved_t<69>       _23;
    volatile uint32_t    OTG_HS_DOEPCTL0;      // OTG_HS device control OUT endpoint 0 control register
    reserved_t<1>        _24;
    volatile uint32_t    OTG_HS_DOEPINT0;      // [Read-write] OTG_HS device endpoint-0 interrupt register
    reserved_t<1>        _25;
    volatile uint32_t    OTG_HS_DOEPTSIZ0;     // [Read-write] OTG_HS device endpoint-0 transfer size register
    reserved_t<3>        _26;
    volatile uint32_t    OTG_HS_DOEPCTL1;      // OTG device endpoint-1 control register
    reserved_t<1>        _27;
    volatile uint32_t    OTG_HS_DOEPINT1;      // [Read-write] OTG_HS device endpoint-1 interrupt register
    reserved_t<1>        _28;
    volatile uint32_t    OTG_HS_DOEPTSIZ1;     // [Read-write] OTG_HS device endpoint-1 transfer size register
    reserved_t<3>        _29;
    volatile uint32_t    OTG_HS_DOEPCTL2;      // OTG device endpoint-2 control register
    reserved_t<1>        _30;
    volatile uint32_t    OTG_HS_DOEPINT2;      // [Read-write] OTG_HS device endpoint-2 interrupt register
    reserved_t<1>        _31;
    volatile uint32_t    OTG_HS_DOEPTSIZ2;     // [Read-write] OTG_HS device endpoint-2 transfer size register
    reserved_t<3>        _32;
    volatile uint32_t    OTG_HS_DOEPCTL3;      // OTG device endpoint-3 control register
    reserved_t<1>        _33;
    volatile uint32_t    OTG_HS_DOEPINT3;      // [Read-write] OTG_HS device endpoint-3 interrupt register
    reserved_t<1>        _34;
    volatile uint32_t    OTG_HS_DOEPTSIZ3;     // [Read-write] OTG_HS device endpoint-3 transfer size register
    reserved_t<3>        _35;
    volatile uint32_t    OTG_HS_DOEPCTL4;      // OTG device endpoint-4 control register
    reserved_t<1>        _36;
    volatile uint32_t    OTG_HS_DOEPINT4;      // [Read-write] OTG_HS device endpoint-4 interrupt register
    reserved_t<1>        _37;
    volatile uint32_t    OTG_HS_DOEPTSIZ4;     // [Read-write] OTG_HS device endpoint-4 transfer size register
    reserved_t<3>        _38;
    volatile uint32_t    OTG_HS_DOEPCTL5;      // OTG device endpoint-5 control register
    reserved_t<1>        _39;
    volatile uint32_t    OTG_HS_DOEPINT5;      // [Read-write] OTG_HS device endpoint-5 interrupt register
    reserved_t<1>        _40;
    volatile uint32_t    OTG_HS_DOEPTSIZ5;     // [Read-write] OTG_HS device endpoint-5 transfer size register
    reserved_t<3>        _41;
    volatile uint32_t    OTG_HS_DOEPCTL6;      // OTG device endpoint-6 control register
    reserved_t<1>        _42;
    volatile uint32_t    OTG_HS_DOEPINT6;      // [Read-write] OTG_HS device endpoint-6 interrupt register
    reserved_t<1>        _43;
    volatile uint32_t    OTG_HS_DOEPTSIZ6;     // [Read-write] OTG_HS device endpoint-6 transfer size register
    reserved_t<3>        _44;
    volatile uint32_t    OTG_HS_DOEPCTL7;      // OTG device endpoint-7 control register
    reserved_t<1>        _45;
    volatile uint32_t    OTG_HS_DOEPINT7;      // [Read-write] OTG_HS device endpoint-7 interrupt register
    reserved_t<1>        _46;
    volatile uint32_t    OTG_HS_DOEPTSIZ7;     // [Read-write] OTG_HS device endpoint-7 transfer size register

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DCFG_DSPD =                // Device speed (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DCFG_NZLSOHSK = 0x4;       // Nonzero-length status OUT handshake
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DCFG_DAD =                 // Device address (7 bits)
        bit_field_t<4, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DCFG_PFIVL =               // Periodic (micro)frame interval (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DCFG_PERSCHIVL =           // Periodic scheduling interval (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    static const uint32_t OTG_HS_DCFG_RESET_VALUE = 0x2200000;

    static constexpr uint32_t OTG_HS_DCTL_RWUSIG = 0x1;         // Remote wakeup signaling, Read-write
    static constexpr uint32_t OTG_HS_DCTL_SDIS = 0x2;           // Soft disconnect, Read-write
    static constexpr uint32_t OTG_HS_DCTL_GINSTS = 0x4;         // Global IN NAK status, Read-only
    static constexpr uint32_t OTG_HS_DCTL_GONSTS = 0x8;         // Global OUT NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DCTL_TCTL =                // Test control (3 bits), Read-write
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t OTG_HS_DCTL_SGINAK = 0x80;        // Set global IN NAK, Write-only
    static constexpr uint32_t OTG_HS_DCTL_CGINAK = 0x100;       // Clear global IN NAK, Write-only
    static constexpr uint32_t OTG_HS_DCTL_SGONAK = 0x200;       // Set global OUT NAK, Write-only
    static constexpr uint32_t OTG_HS_DCTL_CGONAK = 0x400;       // Clear global OUT NAK, Write-only
    static constexpr uint32_t OTG_HS_DCTL_POPRGDNE = 0x800;     // Power-on programming done, Read-write
    static const uint32_t OTG_HS_DCTL_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DSTS_SUSPSTS = 0x1;        // Suspend status
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DSTS_ENUMSPD =             // Enumerated speed (2 bits)
        bit_field_t<1, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DSTS_EERR = 0x8;           // Erratic error
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DSTS_FNSOF =               // Frame number of the received SOF (14 bits)
        bit_field_t<8, 0x3fff>::value<X>();
    static const uint32_t OTG_HS_DSTS_RESET_VALUE = 0x10;

    static constexpr uint32_t OTG_HS_DIEPMSK_XFRCM = 0x1;          // Transfer completed interrupt mask
    static constexpr uint32_t OTG_HS_DIEPMSK_EPDM = 0x2;           // Endpoint disabled interrupt mask
    static constexpr uint32_t OTG_HS_DIEPMSK_TOM = 0x8;            // Timeout condition mask (nonisochronous endpoints)
    static constexpr uint32_t OTG_HS_DIEPMSK_ITTXFEMSK = 0x10;     // IN token received when TxFIFO empty mask
    static constexpr uint32_t OTG_HS_DIEPMSK_INEPNMM = 0x20;       // IN token received with EP mismatch mask
    static constexpr uint32_t OTG_HS_DIEPMSK_INEPNEM = 0x40;       // IN endpoint NAK effective mask
    static constexpr uint32_t OTG_HS_DIEPMSK_TXFURM = 0x100;       // FIFO underrun mask
    static constexpr uint32_t OTG_HS_DIEPMSK_BIM = 0x200;          // BNA interrupt mask
    static const uint32_t OTG_HS_DIEPMSK_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DOEPMSK_XFRCM = 0x1;          // Transfer completed interrupt mask
    static constexpr uint32_t OTG_HS_DOEPMSK_EPDM = 0x2;           // Endpoint disabled interrupt mask
    static constexpr uint32_t OTG_HS_DOEPMSK_STUPM = 0x8;          // SETUP phase done mask
    static constexpr uint32_t OTG_HS_DOEPMSK_OTEPDM = 0x10;        // OUT token received when endpoint disabled mask
    static constexpr uint32_t OTG_HS_DOEPMSK_B2BSTUP = 0x40;       // Back-to-back SETUP packets received mask
    static constexpr uint32_t OTG_HS_DOEPMSK_OPEM = 0x100;         // OUT packet error mask
    static constexpr uint32_t OTG_HS_DOEPMSK_BOIM = 0x200;         // BNA interrupt mask
    static const uint32_t OTG_HS_DOEPMSK_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DAINT_IEPINT =              // IN endpoint interrupt bits (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DAINT_OEPINT =              // OUT endpoint interrupt bits (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DAINT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DAINTMSK_IEPM =                // IN EP interrupt mask bits (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DAINTMSK_OEPM =                // OUT EP interrupt mask bits (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DAINTMSK_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DVBUSDIS_VBUSDT =              // Device VBUS discharge time (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DVBUSDIS_RESET_VALUE = 0x17d7;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DVBUSPULSE_DVBUSP =              // Device VBUS pulsing time (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t OTG_HS_DVBUSPULSE_RESET_VALUE = 0x5b8;

    static constexpr uint32_t OTG_HS_DTHRCTL_NONISOTHREN = 0x1;    // Nonisochronous IN endpoints threshold enable
    static constexpr uint32_t OTG_HS_DTHRCTL_ISOTHREN = 0x2;       // ISO IN endpoint threshold enable
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DTHRCTL_TXTHRLEN =            // Transmit threshold length (9 bits)
        bit_field_t<2, 0x1ff>::value<X>();
    static constexpr uint32_t OTG_HS_DTHRCTL_RXTHREN = 0x10000;    // Receive threshold enable
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DTHRCTL_RXTHRLEN =            // Receive threshold length (9 bits)
        bit_field_t<17, 0x1ff>::value<X>();
    static constexpr uint32_t OTG_HS_DTHRCTL_ARPEN = 0x8000000;    // Arbiter parking enable
    static const uint32_t OTG_HS_DTHRCTL_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPEMPMSK_INEPTXFEM =           // IN EP Tx FIFO empty interrupt mask bits (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DIEPEMPMSK_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DEACHINT_IEP1INT = 0x2;        // IN endpoint 1interrupt bit
    static constexpr uint32_t OTG_HS_DEACHINT_OEP1INT = 0x20000;    // OUT endpoint 1 interrupt bit
    static const uint32_t OTG_HS_DEACHINT_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DEACHINTMSK_IEP1INTM = 0x2;       // IN Endpoint 1 interrupt mask bit
    static constexpr uint32_t OTG_HS_DEACHINTMSK_OEP1INTM = 0x20000;   // OUT Endpoint 1 interrupt mask bit
    static const uint32_t OTG_HS_DEACHINTMSK_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL0_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL0_USBAEP = 0x8000;      // USB active endpoint, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL0_EONUM_DPID = 0x10000; // Even/odd frame, Read-only
    static constexpr uint32_t OTG_HS_DIEPCTL0_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL0_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL0_Stall = 0x200000;     // STALL handshake, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL0_TXFNUM =              // TxFIFO number (4 bits), Read-write
        bit_field_t<22, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL0_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL0_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL0_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL0_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL0_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL0_EPENA = 0x80000000;   // Endpoint enable, Read-write
    static const uint32_t OTG_HS_DIEPCTL0_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DIEPINT0_XFRC = 0x1;           // Transfer completed interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT0_EPDISD = 0x2;         // Endpoint disabled interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT0_TOC = 0x8;            // Timeout condition, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT0_ITTXFE = 0x10;        // IN token received when TxFIFO is empty, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT0_INEPNE = 0x40;        // IN endpoint NAK effective, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT0_TXFE = 0x80;          // Transmit FIFO empty, Read-only
    static constexpr uint32_t OTG_HS_DIEPINT0_TXFIFOUDRN = 0x100;   // Transmit Fifo Underrun, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT0_BNA = 0x200;          // Buffer not available interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT0_PKTDRPSTS = 0x800;    // Packet dropped status, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT0_BERR = 0x1000;        // Babble error interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT0_NAK = 0x2000;         // NAK interrupt, Read-write
    static const uint32_t OTG_HS_DIEPINT0_RESET_VALUE = 0x80;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ0_XFRSIZ =              // Transfer size (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ0_PKTCNT =              // Packet count (2 bits)
        bit_field_t<19, 0x3>::value<X>();
    static const uint32_t OTG_HS_DIEPTSIZ0_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_DIEPDMA1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DTXFSTS0_INEPTFSAV =           // IN endpoint TxFIFO space avail (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DTXFSTS0_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL1_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL1_USBAEP = 0x8000;      // USB active endpoint, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL1_EONUM_DPID = 0x10000; // Even/odd frame, Read-only
    static constexpr uint32_t OTG_HS_DIEPCTL1_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL1_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL1_Stall = 0x200000;     // STALL handshake, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL1_TXFNUM =              // TxFIFO number (4 bits), Read-write
        bit_field_t<22, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL1_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL1_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL1_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL1_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL1_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL1_EPENA = 0x80000000;   // Endpoint enable, Read-write
    static const uint32_t OTG_HS_DIEPCTL1_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DIEPINT1_XFRC = 0x1;           // Transfer completed interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT1_EPDISD = 0x2;         // Endpoint disabled interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT1_TOC = 0x8;            // Timeout condition, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT1_ITTXFE = 0x10;        // IN token received when TxFIFO is empty, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT1_INEPNE = 0x40;        // IN endpoint NAK effective, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT1_TXFE = 0x80;          // Transmit FIFO empty, Read-only
    static constexpr uint32_t OTG_HS_DIEPINT1_TXFIFOUDRN = 0x100;   // Transmit Fifo Underrun, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT1_BNA = 0x200;          // Buffer not available interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT1_PKTDRPSTS = 0x800;    // Packet dropped status, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT1_BERR = 0x1000;        // Babble error interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT1_NAK = 0x2000;         // NAK interrupt, Read-write
    static const uint32_t OTG_HS_DIEPINT1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ1_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ1_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ1_MCNT =                // Multi count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_DIEPTSIZ1_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_DIEPDMA2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DTXFSTS1_INEPTFSAV =           // IN endpoint TxFIFO space avail (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DTXFSTS1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL2_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL2_USBAEP = 0x8000;      // USB active endpoint, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL2_EONUM_DPID = 0x10000; // Even/odd frame, Read-only
    static constexpr uint32_t OTG_HS_DIEPCTL2_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL2_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL2_Stall = 0x200000;     // STALL handshake, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL2_TXFNUM =              // TxFIFO number (4 bits), Read-write
        bit_field_t<22, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL2_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL2_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL2_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL2_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL2_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL2_EPENA = 0x80000000;   // Endpoint enable, Read-write
    static const uint32_t OTG_HS_DIEPCTL2_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DIEPINT2_XFRC = 0x1;           // Transfer completed interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT2_EPDISD = 0x2;         // Endpoint disabled interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT2_TOC = 0x8;            // Timeout condition, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT2_ITTXFE = 0x10;        // IN token received when TxFIFO is empty, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT2_INEPNE = 0x40;        // IN endpoint NAK effective, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT2_TXFE = 0x80;          // Transmit FIFO empty, Read-only
    static constexpr uint32_t OTG_HS_DIEPINT2_TXFIFOUDRN = 0x100;   // Transmit Fifo Underrun, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT2_BNA = 0x200;          // Buffer not available interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT2_PKTDRPSTS = 0x800;    // Packet dropped status, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT2_BERR = 0x1000;        // Babble error interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT2_NAK = 0x2000;         // NAK interrupt, Read-write
    static const uint32_t OTG_HS_DIEPINT2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ2_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ2_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ2_MCNT =                // Multi count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_DIEPTSIZ2_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_DIEPDMA3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DTXFSTS2_INEPTFSAV =           // IN endpoint TxFIFO space avail (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DTXFSTS2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL3_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL3_USBAEP = 0x8000;      // USB active endpoint, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL3_EONUM_DPID = 0x10000; // Even/odd frame, Read-only
    static constexpr uint32_t OTG_HS_DIEPCTL3_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL3_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL3_Stall = 0x200000;     // STALL handshake, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL3_TXFNUM =              // TxFIFO number (4 bits), Read-write
        bit_field_t<22, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL3_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL3_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL3_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL3_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL3_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL3_EPENA = 0x80000000;   // Endpoint enable, Read-write
    static const uint32_t OTG_HS_DIEPCTL3_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DIEPINT3_XFRC = 0x1;           // Transfer completed interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT3_EPDISD = 0x2;         // Endpoint disabled interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT3_TOC = 0x8;            // Timeout condition, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT3_ITTXFE = 0x10;        // IN token received when TxFIFO is empty, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT3_INEPNE = 0x40;        // IN endpoint NAK effective, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT3_TXFE = 0x80;          // Transmit FIFO empty, Read-only
    static constexpr uint32_t OTG_HS_DIEPINT3_TXFIFOUDRN = 0x100;   // Transmit Fifo Underrun, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT3_BNA = 0x200;          // Buffer not available interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT3_PKTDRPSTS = 0x800;    // Packet dropped status, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT3_BERR = 0x1000;        // Babble error interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT3_NAK = 0x2000;         // NAK interrupt, Read-write
    static const uint32_t OTG_HS_DIEPINT3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ3_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ3_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ3_MCNT =                // Multi count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_DIEPTSIZ3_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_DIEPDMA4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DTXFSTS3_INEPTFSAV =           // IN endpoint TxFIFO space avail (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DTXFSTS3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL4_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL4_USBAEP = 0x8000;      // USB active endpoint, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL4_EONUM_DPID = 0x10000; // Even/odd frame, Read-only
    static constexpr uint32_t OTG_HS_DIEPCTL4_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL4_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL4_Stall = 0x200000;     // STALL handshake, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL4_TXFNUM =              // TxFIFO number (4 bits), Read-write
        bit_field_t<22, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL4_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL4_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL4_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL4_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL4_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL4_EPENA = 0x80000000;   // Endpoint enable, Read-write
    static const uint32_t OTG_HS_DIEPCTL4_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DIEPINT4_XFRC = 0x1;           // Transfer completed interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT4_EPDISD = 0x2;         // Endpoint disabled interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT4_TOC = 0x8;            // Timeout condition, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT4_ITTXFE = 0x10;        // IN token received when TxFIFO is empty, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT4_INEPNE = 0x40;        // IN endpoint NAK effective, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT4_TXFE = 0x80;          // Transmit FIFO empty, Read-only
    static constexpr uint32_t OTG_HS_DIEPINT4_TXFIFOUDRN = 0x100;   // Transmit Fifo Underrun, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT4_BNA = 0x200;          // Buffer not available interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT4_PKTDRPSTS = 0x800;    // Packet dropped status, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT4_BERR = 0x1000;        // Babble error interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT4_NAK = 0x2000;         // NAK interrupt, Read-write
    static const uint32_t OTG_HS_DIEPINT4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ4_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ4_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ4_MCNT =                // Multi count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_DIEPTSIZ4_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_DIEPDMA5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DTXFSTS4_INEPTFSAV =           // IN endpoint TxFIFO space avail (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DTXFSTS4_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DIEPCTL5_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL5_EONUM_DPID = 0x10000; // Even/odd frame, Read-only
    static constexpr uint32_t OTG_HS_DIEPCTL5_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL5_EPENA = 0x80000000;   // Endpoint enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL5_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL5_MCNT =                // Multi count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL5_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL5_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL5_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL5_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL5_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL5_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL5_Stall = 0x200000;     // STALL handshake, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL5_TXFNUM =              // TxFIFO number (4 bits), Read-write
        bit_field_t<22, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL5_USBAEP = 0x8000;      // USB active endpoint, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL5_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    static const uint32_t OTG_HS_DIEPCTL5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DTXFSTS6_INEPTFSAV =           // IN endpoint TxFIFO space avail (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DTXFSTS6_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DIEPINT5_BERR = 0x1000;        // Babble error interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT5_BNA = 0x200;          // Buffer not available interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT5_EPDISD = 0x2;         // Endpoint disabled interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT5_INEPNE = 0x40;        // IN endpoint NAK effective, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT5_ITTXFE = 0x10;        // IN token received when TxFIFO is empty, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPINT5_MCNT =                // Multi count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPINT5_NAK = 0x2000;         // NAK interrupt, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPINT5_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPINT5_PKTDRPSTS = 0x800;    // Packet dropped status, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT5_TOC = 0x8;            // Timeout condition, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT5_TXFE = 0x80;          // Transmit FIFO empty, Read-only
    static constexpr uint32_t OTG_HS_DIEPINT5_TXFIFOUDRN = 0x100;   // Transmit Fifo Underrun, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT5_XFRC = 0x1;           // Transfer completed interrupt, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPINT5_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    static const uint32_t OTG_HS_DIEPINT5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DTXFSTS7_INEPTFSAV =           // IN endpoint TxFIFO space avail (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DTXFSTS7_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ5_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ5_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ5_MCNT =                // Multi count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_DIEPTSIZ5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DTXFSTS5_INEPTFSAV =           // IN endpoint TxFIFO space avail (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DTXFSTS5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL6_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL6_USBAEP = 0x8000;      // USB active endpoint, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL6_EONUM_DPID = 0x10000; // Even/odd frame, Read-only
    static constexpr uint32_t OTG_HS_DIEPCTL6_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL6_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL6_Stall = 0x200000;     // STALL handshake, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL6_TXFNUM =              // TxFIFO number (4 bits), Read-write
        bit_field_t<22, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL6_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL6_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL6_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL6_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL6_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL6_EPENA = 0x80000000;   // Endpoint enable, Read-write
    static const uint32_t OTG_HS_DIEPCTL6_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DIEPINT6_XFRC = 0x1;           // Transfer completed interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT6_EPDISD = 0x2;         // Endpoint disabled interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT6_TOC = 0x8;            // Timeout condition, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT6_ITTXFE = 0x10;        // IN token received when TxFIFO is empty, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT6_INEPNE = 0x40;        // IN endpoint NAK effective, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT6_TXFE = 0x80;          // Transmit FIFO empty, Read-only
    static constexpr uint32_t OTG_HS_DIEPINT6_TXFIFOUDRN = 0x100;   // Transmit Fifo Underrun, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT6_BNA = 0x200;          // Buffer not available interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT6_PKTDRPSTS = 0x800;    // Packet dropped status, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT6_BERR = 0x1000;        // Babble error interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT6_NAK = 0x2000;         // NAK interrupt, Read-write
    static const uint32_t OTG_HS_DIEPINT6_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL7_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL7_USBAEP = 0x8000;      // USB active endpoint, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL7_EONUM_DPID = 0x10000; // Even/odd frame, Read-only
    static constexpr uint32_t OTG_HS_DIEPCTL7_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL7_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL7_Stall = 0x200000;     // STALL handshake, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL7_TXFNUM =              // TxFIFO number (4 bits), Read-write
        bit_field_t<22, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL7_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL7_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL7_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL7_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL7_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL7_EPENA = 0x80000000;   // Endpoint enable, Read-write
    static const uint32_t OTG_HS_DIEPCTL7_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DIEPINT7_XFRC = 0x1;           // Transfer completed interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT7_EPDISD = 0x2;         // Endpoint disabled interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT7_TOC = 0x8;            // Timeout condition, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT7_ITTXFE = 0x10;        // IN token received when TxFIFO is empty, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT7_INEPNE = 0x40;        // IN endpoint NAK effective, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT7_TXFE = 0x80;          // Transmit FIFO empty, Read-only
    static constexpr uint32_t OTG_HS_DIEPINT7_TXFIFOUDRN = 0x100;   // Transmit Fifo Underrun, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT7_BNA = 0x200;          // Buffer not available interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT7_PKTDRPSTS = 0x800;    // Packet dropped status, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT7_BERR = 0x1000;        // Babble error interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT7_NAK = 0x2000;         // NAK interrupt, Read-write
    static const uint32_t OTG_HS_DIEPINT7_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL0_MPSIZ =               // Maximum packet size (2 bits), Read-only
        bit_field_t<0, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL0_USBAEP = 0x8000;      // USB active endpoint, Read-only
    static constexpr uint32_t OTG_HS_DOEPCTL0_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL0_EPTYP =               // Endpoint type (2 bits), Read-only
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL0_SNPM = 0x100000;      // Snoop mode, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL0_Stall = 0x200000;     // STALL handshake, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL0_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL0_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL0_EPDIS = 0x40000000;   // Endpoint disable, Read-only
    static constexpr uint32_t OTG_HS_DOEPCTL0_EPENA = 0x80000000;   // Endpoint enable, Write-only
    static const uint32_t OTG_HS_DOEPCTL0_RESET_VALUE = 0x8000;

    static constexpr uint32_t OTG_HS_DOEPINT0_XFRC = 0x1;           // Transfer completed interrupt
    static constexpr uint32_t OTG_HS_DOEPINT0_EPDISD = 0x2;         // Endpoint disabled interrupt
    static constexpr uint32_t OTG_HS_DOEPINT0_STUP = 0x8;           // SETUP phase done
    static constexpr uint32_t OTG_HS_DOEPINT0_OTEPDIS = 0x10;       // OUT token received when endpoint disabled
    static constexpr uint32_t OTG_HS_DOEPINT0_B2BSTUP = 0x40;       // Back-to-back SETUP packets received
    static constexpr uint32_t OTG_HS_DOEPINT0_NYET = 0x4000;        // NYET interrupt
    static const uint32_t OTG_HS_DOEPINT0_RESET_VALUE = 0x80;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ0_XFRSIZ =              // Transfer size (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPTSIZ0_PKTCNT = 0x80000;     // Packet count
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ0_STUPCNT =             // SETUP packet count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_DOEPTSIZ0_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL1_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL1_USBAEP = 0x8000;      // USB active endpoint, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL1_EONUM_DPID = 0x10000; // Even odd frame/Endpoint data PID, Read-only
    static constexpr uint32_t OTG_HS_DOEPCTL1_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL1_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL1_SNPM = 0x100000;      // Snoop mode, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL1_Stall = 0x200000;     // STALL handshake, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL1_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL1_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL1_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID/Set even frame, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL1_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL1_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL1_EPENA = 0x80000000;   // Endpoint enable, Read-write
    static const uint32_t OTG_HS_DOEPCTL1_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DOEPINT1_XFRC = 0x1;           // Transfer completed interrupt
    static constexpr uint32_t OTG_HS_DOEPINT1_EPDISD = 0x2;         // Endpoint disabled interrupt
    static constexpr uint32_t OTG_HS_DOEPINT1_STUP = 0x8;           // SETUP phase done
    static constexpr uint32_t OTG_HS_DOEPINT1_OTEPDIS = 0x10;       // OUT token received when endpoint disabled
    static constexpr uint32_t OTG_HS_DOEPINT1_B2BSTUP = 0x40;       // Back-to-back SETUP packets received
    static constexpr uint32_t OTG_HS_DOEPINT1_NYET = 0x4000;        // NYET interrupt
    static const uint32_t OTG_HS_DOEPINT1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ1_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ1_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ1_RXDPID_STUPCNT =      // Received data PID/SETUP packet count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_DOEPTSIZ1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL2_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL2_USBAEP = 0x8000;      // USB active endpoint, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL2_EONUM_DPID = 0x10000; // Even odd frame/Endpoint data PID, Read-only
    static constexpr uint32_t OTG_HS_DOEPCTL2_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL2_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL2_SNPM = 0x100000;      // Snoop mode, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL2_Stall = 0x200000;     // STALL handshake, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL2_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL2_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL2_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID/Set even frame, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL2_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL2_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL2_EPENA = 0x80000000;   // Endpoint enable, Read-write
    static const uint32_t OTG_HS_DOEPCTL2_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DOEPINT2_XFRC = 0x1;           // Transfer completed interrupt
    static constexpr uint32_t OTG_HS_DOEPINT2_EPDISD = 0x2;         // Endpoint disabled interrupt
    static constexpr uint32_t OTG_HS_DOEPINT2_STUP = 0x8;           // SETUP phase done
    static constexpr uint32_t OTG_HS_DOEPINT2_OTEPDIS = 0x10;       // OUT token received when endpoint disabled
    static constexpr uint32_t OTG_HS_DOEPINT2_B2BSTUP = 0x40;       // Back-to-back SETUP packets received
    static constexpr uint32_t OTG_HS_DOEPINT2_NYET = 0x4000;        // NYET interrupt
    static const uint32_t OTG_HS_DOEPINT2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ2_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ2_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ2_RXDPID_STUPCNT =      // Received data PID/SETUP packet count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_DOEPTSIZ2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL3_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL3_USBAEP = 0x8000;      // USB active endpoint, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL3_EONUM_DPID = 0x10000; // Even odd frame/Endpoint data PID, Read-only
    static constexpr uint32_t OTG_HS_DOEPCTL3_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL3_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL3_SNPM = 0x100000;      // Snoop mode, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL3_Stall = 0x200000;     // STALL handshake, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL3_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL3_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL3_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID/Set even frame, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL3_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL3_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL3_EPENA = 0x80000000;   // Endpoint enable, Read-write
    static const uint32_t OTG_HS_DOEPCTL3_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DOEPINT3_XFRC = 0x1;           // Transfer completed interrupt
    static constexpr uint32_t OTG_HS_DOEPINT3_EPDISD = 0x2;         // Endpoint disabled interrupt
    static constexpr uint32_t OTG_HS_DOEPINT3_STUP = 0x8;           // SETUP phase done
    static constexpr uint32_t OTG_HS_DOEPINT3_OTEPDIS = 0x10;       // OUT token received when endpoint disabled
    static constexpr uint32_t OTG_HS_DOEPINT3_B2BSTUP = 0x40;       // Back-to-back SETUP packets received
    static constexpr uint32_t OTG_HS_DOEPINT3_NYET = 0x4000;        // NYET interrupt
    static const uint32_t OTG_HS_DOEPINT3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ3_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ3_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ3_RXDPID_STUPCNT =      // Received data PID/SETUP packet count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_DOEPTSIZ3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL4_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL4_USBAEP = 0x8000;      // USB active endpoint, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL4_EONUM_DPID = 0x10000; // Even odd frame/Endpoint data PID, Read-only
    static constexpr uint32_t OTG_HS_DOEPCTL4_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL4_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL4_SNPM = 0x100000;      // Snoop mode, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL4_Stall = 0x200000;     // STALL handshake, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL4_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL4_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL4_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID/Set even frame, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL4_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL4_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL4_EPENA = 0x80000000;   // Endpoint enable, Read-write
    static const uint32_t OTG_HS_DOEPCTL4_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DOEPINT4_XFRC = 0x1;           // Transfer completed interrupt
    static constexpr uint32_t OTG_HS_DOEPINT4_EPDISD = 0x2;         // Endpoint disabled interrupt
    static constexpr uint32_t OTG_HS_DOEPINT4_STUP = 0x8;           // SETUP phase done
    static constexpr uint32_t OTG_HS_DOEPINT4_OTEPDIS = 0x10;       // OUT token received when endpoint disabled
    static constexpr uint32_t OTG_HS_DOEPINT4_B2BSTUP = 0x40;       // Back-to-back SETUP packets received
    static constexpr uint32_t OTG_HS_DOEPINT4_NYET = 0x4000;        // NYET interrupt
    static const uint32_t OTG_HS_DOEPINT4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ4_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ4_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ4_RXDPID_STUPCNT =      // Received data PID/SETUP packet count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_DOEPTSIZ4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL5_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL5_USBAEP = 0x8000;      // USB active endpoint, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL5_EONUM_DPID = 0x10000; // Even odd frame/Endpoint data PID, Read-only
    static constexpr uint32_t OTG_HS_DOEPCTL5_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL5_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL5_SNPM = 0x100000;      // Snoop mode, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL5_Stall = 0x200000;     // STALL handshake, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL5_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL5_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL5_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID/Set even frame, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL5_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL5_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL5_EPENA = 0x80000000;   // Endpoint enable, Read-write
    static const uint32_t OTG_HS_DOEPCTL5_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DOEPINT5_XFRC = 0x1;           // Transfer completed interrupt
    static constexpr uint32_t OTG_HS_DOEPINT5_EPDISD = 0x2;         // Endpoint disabled interrupt
    static constexpr uint32_t OTG_HS_DOEPINT5_STUP = 0x8;           // SETUP phase done
    static constexpr uint32_t OTG_HS_DOEPINT5_OTEPDIS = 0x10;       // OUT token received when endpoint disabled
    static constexpr uint32_t OTG_HS_DOEPINT5_B2BSTUP = 0x40;       // Back-to-back SETUP packets received
    static constexpr uint32_t OTG_HS_DOEPINT5_NYET = 0x4000;        // NYET interrupt
    static const uint32_t OTG_HS_DOEPINT5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ5_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ5_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ5_RXDPID_STUPCNT =      // Received data PID/SETUP packet count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_DOEPTSIZ5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL6_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL6_USBAEP = 0x8000;      // USB active endpoint, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL6_EONUM_DPID = 0x10000; // Even odd frame/Endpoint data PID, Read-only
    static constexpr uint32_t OTG_HS_DOEPCTL6_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL6_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL6_SNPM = 0x100000;      // Snoop mode, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL6_Stall = 0x200000;     // STALL handshake, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL6_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL6_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL6_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID/Set even frame, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL6_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL6_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL6_EPENA = 0x80000000;   // Endpoint enable, Read-write
    static const uint32_t OTG_HS_DOEPCTL6_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DOEPINT6_XFRC = 0x1;           // Transfer completed interrupt
    static constexpr uint32_t OTG_HS_DOEPINT6_EPDISD = 0x2;         // Endpoint disabled interrupt
    static constexpr uint32_t OTG_HS_DOEPINT6_STUP = 0x8;           // SETUP phase done
    static constexpr uint32_t OTG_HS_DOEPINT6_OTEPDIS = 0x10;       // OUT token received when endpoint disabled
    static constexpr uint32_t OTG_HS_DOEPINT6_B2BSTUP = 0x40;       // Back-to-back SETUP packets received
    static constexpr uint32_t OTG_HS_DOEPINT6_NYET = 0x4000;        // NYET interrupt
    static const uint32_t OTG_HS_DOEPINT6_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ6_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ6_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ6_RXDPID_STUPCNT =      // Received data PID/SETUP packet count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_DOEPTSIZ6_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL7_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL7_USBAEP = 0x8000;      // USB active endpoint, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL7_EONUM_DPID = 0x10000; // Even odd frame/Endpoint data PID, Read-only
    static constexpr uint32_t OTG_HS_DOEPCTL7_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL7_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL7_SNPM = 0x100000;      // Snoop mode, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL7_Stall = 0x200000;     // STALL handshake, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL7_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL7_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL7_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID/Set even frame, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL7_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL7_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL7_EPENA = 0x80000000;   // Endpoint enable, Read-write
    static const uint32_t OTG_HS_DOEPCTL7_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DOEPINT7_XFRC = 0x1;           // Transfer completed interrupt
    static constexpr uint32_t OTG_HS_DOEPINT7_EPDISD = 0x2;         // Endpoint disabled interrupt
    static constexpr uint32_t OTG_HS_DOEPINT7_STUP = 0x8;           // SETUP phase done
    static constexpr uint32_t OTG_HS_DOEPINT7_OTEPDIS = 0x10;       // OUT token received when endpoint disabled
    static constexpr uint32_t OTG_HS_DOEPINT7_B2BSTUP = 0x40;       // Back-to-back SETUP packets received
    static constexpr uint32_t OTG_HS_DOEPINT7_NYET = 0x4000;        // NYET interrupt
    static const uint32_t OTG_HS_DOEPINT7_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ7_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ7_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ7_RXDPID_STUPCNT =      // Received data PID/SETUP packet count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_DOEPTSIZ7_RESET_VALUE = 0x0;
};

static otg1_hs_device_t& OTG1_HS_DEVICE = *reinterpret_cast<otg1_hs_device_t*>(0x40040800);

#define HAVE_PERIPHERAL_OTG1_HS_DEVICE


////
//
//    USB 1 on the go high speed
//
////

struct otg2_hs_device_t
{
    volatile uint32_t    OTG_HS_DCFG;          // [Read-write] OTG_HS device configuration register
    volatile uint32_t    OTG_HS_DCTL;          // OTG_HS device control register
    volatile uint32_t    OTG_HS_DSTS;          // [Read-only] OTG_HS device status register
    reserved_t<1>        _0;
    volatile uint32_t    OTG_HS_DIEPMSK;       // [Read-write] OTG_HS device IN endpoint common interrupt mask register
    volatile uint32_t    OTG_HS_DOEPMSK;       // [Read-write] OTG_HS device OUT endpoint common interrupt mask register
    volatile uint32_t    OTG_HS_DAINT;         // [Read-only] OTG_HS device all endpoints interrupt register
    volatile uint32_t    OTG_HS_DAINTMSK;      // [Read-write] OTG_HS all endpoints interrupt mask register
    reserved_t<2>        _1;
    volatile uint32_t    OTG_HS_DVBUSDIS;      // [Read-write] OTG_HS device VBUS discharge time register
    volatile uint32_t    OTG_HS_DVBUSPULSE;    // [Read-write] OTG_HS device VBUS pulsing time register
    volatile uint32_t    OTG_HS_DTHRCTL;       // [Read-write] OTG_HS Device threshold control register
    volatile uint32_t    OTG_HS_DIEPEMPMSK;    // [Read-write] OTG_HS device IN endpoint FIFO empty interrupt mask register
    volatile uint32_t    OTG_HS_DEACHINT;      // [Read-write] OTG_HS device each endpoint interrupt register
    volatile uint32_t    OTG_HS_DEACHINTMSK;   // [Read-write] OTG_HS device each endpoint interrupt register mask
    reserved_t<48>       _2;
    volatile uint32_t    OTG_HS_DIEPCTL0;      // OTG device endpoint-0 control register
    reserved_t<1>        _3;
    volatile uint32_t    OTG_HS_DIEPINT0;      // OTG device endpoint-0 interrupt register
    reserved_t<1>        _4;
    volatile uint32_t    OTG_HS_DIEPTSIZ0;     // [Read-write] OTG_HS device IN endpoint 0 transfer size register
    volatile uint32_t    OTG_HS_DIEPDMA1;      // [Read-write] OTG_HS device endpoint-1 DMA address register
    volatile uint32_t    OTG_HS_DTXFSTS0;      // [Read-only] OTG_HS device IN endpoint transmit FIFO status register
    reserved_t<1>        _5;
    volatile uint32_t    OTG_HS_DIEPCTL1;      // OTG device endpoint-1 control register
    reserved_t<1>        _6;
    volatile uint32_t    OTG_HS_DIEPINT1;      // OTG device endpoint-1 interrupt register
    reserved_t<1>        _7;
    volatile uint32_t    OTG_HS_DIEPTSIZ1;     // [Read-write] OTG_HS device endpoint transfer size register
    volatile uint32_t    OTG_HS_DIEPDMA2;      // [Read-write] OTG_HS device endpoint-2 DMA address register
    volatile uint32_t    OTG_HS_DTXFSTS1;      // [Read-only] OTG_HS device IN endpoint transmit FIFO status register
    reserved_t<1>        _8;
    volatile uint32_t    OTG_HS_DIEPCTL2;      // OTG device endpoint-2 control register
    reserved_t<1>        _9;
    volatile uint32_t    OTG_HS_DIEPINT2;      // OTG device endpoint-2 interrupt register
    reserved_t<1>        _10;
    volatile uint32_t    OTG_HS_DIEPTSIZ2;     // [Read-write] OTG_HS device endpoint transfer size register
    volatile uint32_t    OTG_HS_DIEPDMA3;      // [Read-write] OTG_HS device endpoint-3 DMA address register
    volatile uint32_t    OTG_HS_DTXFSTS2;      // [Read-only] OTG_HS device IN endpoint transmit FIFO status register
    reserved_t<1>        _11;
    volatile uint32_t    OTG_HS_DIEPCTL3;      // OTG device endpoint-3 control register
    reserved_t<1>        _12;
    volatile uint32_t    OTG_HS_DIEPINT3;      // OTG device endpoint-3 interrupt register
    reserved_t<1>        _13;
    volatile uint32_t    OTG_HS_DIEPTSIZ3;     // [Read-write] OTG_HS device endpoint transfer size register
    volatile uint32_t    OTG_HS_DIEPDMA4;      // [Read-write] OTG_HS device endpoint-4 DMA address register
    volatile uint32_t    OTG_HS_DTXFSTS3;      // [Read-only] OTG_HS device IN endpoint transmit FIFO status register
    reserved_t<1>        _14;
    volatile uint32_t    OTG_HS_DIEPCTL4;      // OTG device endpoint-4 control register
    reserved_t<1>        _15;
    volatile uint32_t    OTG_HS_DIEPINT4;      // OTG device endpoint-4 interrupt register
    reserved_t<1>        _16;
    volatile uint32_t    OTG_HS_DIEPTSIZ4;     // [Read-write] OTG_HS device endpoint transfer size register
    volatile uint32_t    OTG_HS_DIEPDMA5;      // [Read-write] OTG_HS device endpoint-5 DMA address register
    volatile uint32_t    OTG_HS_DTXFSTS4;      // [Read-only] OTG_HS device IN endpoint transmit FIFO status register
    reserved_t<1>        _17;
    volatile uint32_t    OTG_HS_DIEPCTL5;      // OTG device endpoint-5 control register
    volatile uint32_t    OTG_HS_DTXFSTS6;      // [Read-write] OTG_HS device IN endpoint transmit FIFO status register
    volatile uint32_t    OTG_HS_DIEPINT5;      // OTG device endpoint-5 interrupt register
    volatile uint32_t    OTG_HS_DTXFSTS7;      // [Read-write] OTG_HS device IN endpoint transmit FIFO status register
    volatile uint32_t    OTG_HS_DIEPTSIZ5;     // [Read-write] OTG_HS device endpoint transfer size register
    reserved_t<1>        _18;
    volatile uint32_t    OTG_HS_DTXFSTS5;      // [Read-only] OTG_HS device IN endpoint transmit FIFO status register
    reserved_t<1>        _19;
    volatile uint32_t    OTG_HS_DIEPCTL6;      // OTG device endpoint-6 control register
    reserved_t<1>        _20;
    volatile uint32_t    OTG_HS_DIEPINT6;      // OTG device endpoint-6 interrupt register
    reserved_t<5>        _21;
    volatile uint32_t    OTG_HS_DIEPCTL7;      // OTG device endpoint-7 control register
    reserved_t<1>        _22;
    volatile uint32_t    OTG_HS_DIEPINT7;      // OTG device endpoint-7 interrupt register
    reserved_t<69>       _23;
    volatile uint32_t    OTG_HS_DOEPCTL0;      // OTG_HS device control OUT endpoint 0 control register
    reserved_t<1>        _24;
    volatile uint32_t    OTG_HS_DOEPINT0;      // [Read-write] OTG_HS device endpoint-0 interrupt register
    reserved_t<1>        _25;
    volatile uint32_t    OTG_HS_DOEPTSIZ0;     // [Read-write] OTG_HS device endpoint-0 transfer size register
    reserved_t<3>        _26;
    volatile uint32_t    OTG_HS_DOEPCTL1;      // OTG device endpoint-1 control register
    reserved_t<1>        _27;
    volatile uint32_t    OTG_HS_DOEPINT1;      // [Read-write] OTG_HS device endpoint-1 interrupt register
    reserved_t<1>        _28;
    volatile uint32_t    OTG_HS_DOEPTSIZ1;     // [Read-write] OTG_HS device endpoint-1 transfer size register
    reserved_t<3>        _29;
    volatile uint32_t    OTG_HS_DOEPCTL2;      // OTG device endpoint-2 control register
    reserved_t<1>        _30;
    volatile uint32_t    OTG_HS_DOEPINT2;      // [Read-write] OTG_HS device endpoint-2 interrupt register
    reserved_t<1>        _31;
    volatile uint32_t    OTG_HS_DOEPTSIZ2;     // [Read-write] OTG_HS device endpoint-2 transfer size register
    reserved_t<3>        _32;
    volatile uint32_t    OTG_HS_DOEPCTL3;      // OTG device endpoint-3 control register
    reserved_t<1>        _33;
    volatile uint32_t    OTG_HS_DOEPINT3;      // [Read-write] OTG_HS device endpoint-3 interrupt register
    reserved_t<1>        _34;
    volatile uint32_t    OTG_HS_DOEPTSIZ3;     // [Read-write] OTG_HS device endpoint-3 transfer size register
    reserved_t<3>        _35;
    volatile uint32_t    OTG_HS_DOEPCTL4;      // OTG device endpoint-4 control register
    reserved_t<1>        _36;
    volatile uint32_t    OTG_HS_DOEPINT4;      // [Read-write] OTG_HS device endpoint-4 interrupt register
    reserved_t<1>        _37;
    volatile uint32_t    OTG_HS_DOEPTSIZ4;     // [Read-write] OTG_HS device endpoint-4 transfer size register
    reserved_t<3>        _38;
    volatile uint32_t    OTG_HS_DOEPCTL5;      // OTG device endpoint-5 control register
    reserved_t<1>        _39;
    volatile uint32_t    OTG_HS_DOEPINT5;      // [Read-write] OTG_HS device endpoint-5 interrupt register
    reserved_t<1>        _40;
    volatile uint32_t    OTG_HS_DOEPTSIZ5;     // [Read-write] OTG_HS device endpoint-5 transfer size register
    reserved_t<3>        _41;
    volatile uint32_t    OTG_HS_DOEPCTL6;      // OTG device endpoint-6 control register
    reserved_t<1>        _42;
    volatile uint32_t    OTG_HS_DOEPINT6;      // [Read-write] OTG_HS device endpoint-6 interrupt register
    reserved_t<1>        _43;
    volatile uint32_t    OTG_HS_DOEPTSIZ6;     // [Read-write] OTG_HS device endpoint-6 transfer size register
    reserved_t<3>        _44;
    volatile uint32_t    OTG_HS_DOEPCTL7;      // OTG device endpoint-7 control register
    reserved_t<1>        _45;
    volatile uint32_t    OTG_HS_DOEPINT7;      // [Read-write] OTG_HS device endpoint-7 interrupt register
    reserved_t<1>        _46;
    volatile uint32_t    OTG_HS_DOEPTSIZ7;     // [Read-write] OTG_HS device endpoint-7 transfer size register

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DCFG_DSPD =                // Device speed (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DCFG_NZLSOHSK = 0x4;       // Nonzero-length status OUT handshake
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DCFG_DAD =                 // Device address (7 bits)
        bit_field_t<4, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DCFG_PFIVL =               // Periodic (micro)frame interval (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DCFG_PERSCHIVL =           // Periodic scheduling interval (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    static const uint32_t OTG_HS_DCFG_RESET_VALUE = 0x2200000;

    static constexpr uint32_t OTG_HS_DCTL_RWUSIG = 0x1;         // Remote wakeup signaling, Read-write
    static constexpr uint32_t OTG_HS_DCTL_SDIS = 0x2;           // Soft disconnect, Read-write
    static constexpr uint32_t OTG_HS_DCTL_GINSTS = 0x4;         // Global IN NAK status, Read-only
    static constexpr uint32_t OTG_HS_DCTL_GONSTS = 0x8;         // Global OUT NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DCTL_TCTL =                // Test control (3 bits), Read-write
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t OTG_HS_DCTL_SGINAK = 0x80;        // Set global IN NAK, Write-only
    static constexpr uint32_t OTG_HS_DCTL_CGINAK = 0x100;       // Clear global IN NAK, Write-only
    static constexpr uint32_t OTG_HS_DCTL_SGONAK = 0x200;       // Set global OUT NAK, Write-only
    static constexpr uint32_t OTG_HS_DCTL_CGONAK = 0x400;       // Clear global OUT NAK, Write-only
    static constexpr uint32_t OTG_HS_DCTL_POPRGDNE = 0x800;     // Power-on programming done, Read-write
    static const uint32_t OTG_HS_DCTL_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DSTS_SUSPSTS = 0x1;        // Suspend status
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DSTS_ENUMSPD =             // Enumerated speed (2 bits)
        bit_field_t<1, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DSTS_EERR = 0x8;           // Erratic error
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DSTS_FNSOF =               // Frame number of the received SOF (14 bits)
        bit_field_t<8, 0x3fff>::value<X>();
    static const uint32_t OTG_HS_DSTS_RESET_VALUE = 0x10;

    static constexpr uint32_t OTG_HS_DIEPMSK_XFRCM = 0x1;          // Transfer completed interrupt mask
    static constexpr uint32_t OTG_HS_DIEPMSK_EPDM = 0x2;           // Endpoint disabled interrupt mask
    static constexpr uint32_t OTG_HS_DIEPMSK_TOM = 0x8;            // Timeout condition mask (nonisochronous endpoints)
    static constexpr uint32_t OTG_HS_DIEPMSK_ITTXFEMSK = 0x10;     // IN token received when TxFIFO empty mask
    static constexpr uint32_t OTG_HS_DIEPMSK_INEPNMM = 0x20;       // IN token received with EP mismatch mask
    static constexpr uint32_t OTG_HS_DIEPMSK_INEPNEM = 0x40;       // IN endpoint NAK effective mask
    static constexpr uint32_t OTG_HS_DIEPMSK_TXFURM = 0x100;       // FIFO underrun mask
    static constexpr uint32_t OTG_HS_DIEPMSK_BIM = 0x200;          // BNA interrupt mask
    static const uint32_t OTG_HS_DIEPMSK_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DOEPMSK_XFRCM = 0x1;          // Transfer completed interrupt mask
    static constexpr uint32_t OTG_HS_DOEPMSK_EPDM = 0x2;           // Endpoint disabled interrupt mask
    static constexpr uint32_t OTG_HS_DOEPMSK_STUPM = 0x8;          // SETUP phase done mask
    static constexpr uint32_t OTG_HS_DOEPMSK_OTEPDM = 0x10;        // OUT token received when endpoint disabled mask
    static constexpr uint32_t OTG_HS_DOEPMSK_B2BSTUP = 0x40;       // Back-to-back SETUP packets received mask
    static constexpr uint32_t OTG_HS_DOEPMSK_OPEM = 0x100;         // OUT packet error mask
    static constexpr uint32_t OTG_HS_DOEPMSK_BOIM = 0x200;         // BNA interrupt mask
    static const uint32_t OTG_HS_DOEPMSK_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DAINT_IEPINT =              // IN endpoint interrupt bits (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DAINT_OEPINT =              // OUT endpoint interrupt bits (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DAINT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DAINTMSK_IEPM =                // IN EP interrupt mask bits (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DAINTMSK_OEPM =                // OUT EP interrupt mask bits (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DAINTMSK_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DVBUSDIS_VBUSDT =              // Device VBUS discharge time (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DVBUSDIS_RESET_VALUE = 0x17d7;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DVBUSPULSE_DVBUSP =              // Device VBUS pulsing time (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t OTG_HS_DVBUSPULSE_RESET_VALUE = 0x5b8;

    static constexpr uint32_t OTG_HS_DTHRCTL_NONISOTHREN = 0x1;    // Nonisochronous IN endpoints threshold enable
    static constexpr uint32_t OTG_HS_DTHRCTL_ISOTHREN = 0x2;       // ISO IN endpoint threshold enable
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DTHRCTL_TXTHRLEN =            // Transmit threshold length (9 bits)
        bit_field_t<2, 0x1ff>::value<X>();
    static constexpr uint32_t OTG_HS_DTHRCTL_RXTHREN = 0x10000;    // Receive threshold enable
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DTHRCTL_RXTHRLEN =            // Receive threshold length (9 bits)
        bit_field_t<17, 0x1ff>::value<X>();
    static constexpr uint32_t OTG_HS_DTHRCTL_ARPEN = 0x8000000;    // Arbiter parking enable
    static const uint32_t OTG_HS_DTHRCTL_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPEMPMSK_INEPTXFEM =           // IN EP Tx FIFO empty interrupt mask bits (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DIEPEMPMSK_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DEACHINT_IEP1INT = 0x2;        // IN endpoint 1interrupt bit
    static constexpr uint32_t OTG_HS_DEACHINT_OEP1INT = 0x20000;    // OUT endpoint 1 interrupt bit
    static const uint32_t OTG_HS_DEACHINT_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DEACHINTMSK_IEP1INTM = 0x2;       // IN Endpoint 1 interrupt mask bit
    static constexpr uint32_t OTG_HS_DEACHINTMSK_OEP1INTM = 0x20000;   // OUT Endpoint 1 interrupt mask bit
    static const uint32_t OTG_HS_DEACHINTMSK_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL0_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL0_USBAEP = 0x8000;      // USB active endpoint, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL0_EONUM_DPID = 0x10000; // Even/odd frame, Read-only
    static constexpr uint32_t OTG_HS_DIEPCTL0_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL0_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL0_Stall = 0x200000;     // STALL handshake, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL0_TXFNUM =              // TxFIFO number (4 bits), Read-write
        bit_field_t<22, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL0_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL0_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL0_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL0_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL0_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL0_EPENA = 0x80000000;   // Endpoint enable, Read-write
    static const uint32_t OTG_HS_DIEPCTL0_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DIEPINT0_XFRC = 0x1;           // Transfer completed interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT0_EPDISD = 0x2;         // Endpoint disabled interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT0_TOC = 0x8;            // Timeout condition, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT0_ITTXFE = 0x10;        // IN token received when TxFIFO is empty, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT0_INEPNE = 0x40;        // IN endpoint NAK effective, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT0_TXFE = 0x80;          // Transmit FIFO empty, Read-only
    static constexpr uint32_t OTG_HS_DIEPINT0_TXFIFOUDRN = 0x100;   // Transmit Fifo Underrun, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT0_BNA = 0x200;          // Buffer not available interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT0_PKTDRPSTS = 0x800;    // Packet dropped status, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT0_BERR = 0x1000;        // Babble error interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT0_NAK = 0x2000;         // NAK interrupt, Read-write
    static const uint32_t OTG_HS_DIEPINT0_RESET_VALUE = 0x80;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ0_XFRSIZ =              // Transfer size (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ0_PKTCNT =              // Packet count (2 bits)
        bit_field_t<19, 0x3>::value<X>();
    static const uint32_t OTG_HS_DIEPTSIZ0_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_DIEPDMA1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DTXFSTS0_INEPTFSAV =           // IN endpoint TxFIFO space avail (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DTXFSTS0_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL1_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL1_USBAEP = 0x8000;      // USB active endpoint, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL1_EONUM_DPID = 0x10000; // Even/odd frame, Read-only
    static constexpr uint32_t OTG_HS_DIEPCTL1_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL1_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL1_Stall = 0x200000;     // STALL handshake, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL1_TXFNUM =              // TxFIFO number (4 bits), Read-write
        bit_field_t<22, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL1_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL1_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL1_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL1_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL1_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL1_EPENA = 0x80000000;   // Endpoint enable, Read-write
    static const uint32_t OTG_HS_DIEPCTL1_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DIEPINT1_XFRC = 0x1;           // Transfer completed interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT1_EPDISD = 0x2;         // Endpoint disabled interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT1_TOC = 0x8;            // Timeout condition, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT1_ITTXFE = 0x10;        // IN token received when TxFIFO is empty, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT1_INEPNE = 0x40;        // IN endpoint NAK effective, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT1_TXFE = 0x80;          // Transmit FIFO empty, Read-only
    static constexpr uint32_t OTG_HS_DIEPINT1_TXFIFOUDRN = 0x100;   // Transmit Fifo Underrun, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT1_BNA = 0x200;          // Buffer not available interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT1_PKTDRPSTS = 0x800;    // Packet dropped status, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT1_BERR = 0x1000;        // Babble error interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT1_NAK = 0x2000;         // NAK interrupt, Read-write
    static const uint32_t OTG_HS_DIEPINT1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ1_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ1_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ1_MCNT =                // Multi count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_DIEPTSIZ1_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_DIEPDMA2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DTXFSTS1_INEPTFSAV =           // IN endpoint TxFIFO space avail (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DTXFSTS1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL2_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL2_USBAEP = 0x8000;      // USB active endpoint, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL2_EONUM_DPID = 0x10000; // Even/odd frame, Read-only
    static constexpr uint32_t OTG_HS_DIEPCTL2_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL2_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL2_Stall = 0x200000;     // STALL handshake, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL2_TXFNUM =              // TxFIFO number (4 bits), Read-write
        bit_field_t<22, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL2_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL2_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL2_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL2_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL2_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL2_EPENA = 0x80000000;   // Endpoint enable, Read-write
    static const uint32_t OTG_HS_DIEPCTL2_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DIEPINT2_XFRC = 0x1;           // Transfer completed interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT2_EPDISD = 0x2;         // Endpoint disabled interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT2_TOC = 0x8;            // Timeout condition, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT2_ITTXFE = 0x10;        // IN token received when TxFIFO is empty, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT2_INEPNE = 0x40;        // IN endpoint NAK effective, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT2_TXFE = 0x80;          // Transmit FIFO empty, Read-only
    static constexpr uint32_t OTG_HS_DIEPINT2_TXFIFOUDRN = 0x100;   // Transmit Fifo Underrun, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT2_BNA = 0x200;          // Buffer not available interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT2_PKTDRPSTS = 0x800;    // Packet dropped status, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT2_BERR = 0x1000;        // Babble error interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT2_NAK = 0x2000;         // NAK interrupt, Read-write
    static const uint32_t OTG_HS_DIEPINT2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ2_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ2_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ2_MCNT =                // Multi count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_DIEPTSIZ2_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_DIEPDMA3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DTXFSTS2_INEPTFSAV =           // IN endpoint TxFIFO space avail (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DTXFSTS2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL3_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL3_USBAEP = 0x8000;      // USB active endpoint, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL3_EONUM_DPID = 0x10000; // Even/odd frame, Read-only
    static constexpr uint32_t OTG_HS_DIEPCTL3_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL3_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL3_Stall = 0x200000;     // STALL handshake, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL3_TXFNUM =              // TxFIFO number (4 bits), Read-write
        bit_field_t<22, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL3_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL3_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL3_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL3_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL3_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL3_EPENA = 0x80000000;   // Endpoint enable, Read-write
    static const uint32_t OTG_HS_DIEPCTL3_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DIEPINT3_XFRC = 0x1;           // Transfer completed interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT3_EPDISD = 0x2;         // Endpoint disabled interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT3_TOC = 0x8;            // Timeout condition, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT3_ITTXFE = 0x10;        // IN token received when TxFIFO is empty, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT3_INEPNE = 0x40;        // IN endpoint NAK effective, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT3_TXFE = 0x80;          // Transmit FIFO empty, Read-only
    static constexpr uint32_t OTG_HS_DIEPINT3_TXFIFOUDRN = 0x100;   // Transmit Fifo Underrun, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT3_BNA = 0x200;          // Buffer not available interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT3_PKTDRPSTS = 0x800;    // Packet dropped status, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT3_BERR = 0x1000;        // Babble error interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT3_NAK = 0x2000;         // NAK interrupt, Read-write
    static const uint32_t OTG_HS_DIEPINT3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ3_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ3_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ3_MCNT =                // Multi count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_DIEPTSIZ3_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_DIEPDMA4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DTXFSTS3_INEPTFSAV =           // IN endpoint TxFIFO space avail (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DTXFSTS3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL4_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL4_USBAEP = 0x8000;      // USB active endpoint, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL4_EONUM_DPID = 0x10000; // Even/odd frame, Read-only
    static constexpr uint32_t OTG_HS_DIEPCTL4_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL4_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL4_Stall = 0x200000;     // STALL handshake, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL4_TXFNUM =              // TxFIFO number (4 bits), Read-write
        bit_field_t<22, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL4_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL4_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL4_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL4_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL4_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL4_EPENA = 0x80000000;   // Endpoint enable, Read-write
    static const uint32_t OTG_HS_DIEPCTL4_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DIEPINT4_XFRC = 0x1;           // Transfer completed interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT4_EPDISD = 0x2;         // Endpoint disabled interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT4_TOC = 0x8;            // Timeout condition, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT4_ITTXFE = 0x10;        // IN token received when TxFIFO is empty, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT4_INEPNE = 0x40;        // IN endpoint NAK effective, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT4_TXFE = 0x80;          // Transmit FIFO empty, Read-only
    static constexpr uint32_t OTG_HS_DIEPINT4_TXFIFOUDRN = 0x100;   // Transmit Fifo Underrun, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT4_BNA = 0x200;          // Buffer not available interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT4_PKTDRPSTS = 0x800;    // Packet dropped status, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT4_BERR = 0x1000;        // Babble error interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT4_NAK = 0x2000;         // NAK interrupt, Read-write
    static const uint32_t OTG_HS_DIEPINT4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ4_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ4_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ4_MCNT =                // Multi count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_DIEPTSIZ4_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_DIEPDMA5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DTXFSTS4_INEPTFSAV =           // IN endpoint TxFIFO space avail (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DTXFSTS4_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DIEPCTL5_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL5_EONUM_DPID = 0x10000; // Even/odd frame, Read-only
    static constexpr uint32_t OTG_HS_DIEPCTL5_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL5_EPENA = 0x80000000;   // Endpoint enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL5_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL5_MCNT =                // Multi count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL5_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL5_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL5_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL5_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL5_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL5_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL5_Stall = 0x200000;     // STALL handshake, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL5_TXFNUM =              // TxFIFO number (4 bits), Read-write
        bit_field_t<22, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL5_USBAEP = 0x8000;      // USB active endpoint, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL5_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    static const uint32_t OTG_HS_DIEPCTL5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DTXFSTS6_INEPTFSAV =           // IN endpoint TxFIFO space avail (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DTXFSTS6_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DIEPINT5_BERR = 0x1000;        // Babble error interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT5_BNA = 0x200;          // Buffer not available interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT5_EPDISD = 0x2;         // Endpoint disabled interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT5_INEPNE = 0x40;        // IN endpoint NAK effective, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT5_ITTXFE = 0x10;        // IN token received when TxFIFO is empty, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPINT5_MCNT =                // Multi count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPINT5_NAK = 0x2000;         // NAK interrupt, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPINT5_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPINT5_PKTDRPSTS = 0x800;    // Packet dropped status, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT5_TOC = 0x8;            // Timeout condition, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT5_TXFE = 0x80;          // Transmit FIFO empty, Read-only
    static constexpr uint32_t OTG_HS_DIEPINT5_TXFIFOUDRN = 0x100;   // Transmit Fifo Underrun, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT5_XFRC = 0x1;           // Transfer completed interrupt, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPINT5_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    static const uint32_t OTG_HS_DIEPINT5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DTXFSTS7_INEPTFSAV =           // IN endpoint TxFIFO space avail (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DTXFSTS7_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ5_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ5_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ5_MCNT =                // Multi count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_DIEPTSIZ5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DTXFSTS5_INEPTFSAV =           // IN endpoint TxFIFO space avail (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DTXFSTS5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL6_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL6_USBAEP = 0x8000;      // USB active endpoint, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL6_EONUM_DPID = 0x10000; // Even/odd frame, Read-only
    static constexpr uint32_t OTG_HS_DIEPCTL6_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL6_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL6_Stall = 0x200000;     // STALL handshake, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL6_TXFNUM =              // TxFIFO number (4 bits), Read-write
        bit_field_t<22, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL6_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL6_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL6_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL6_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL6_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL6_EPENA = 0x80000000;   // Endpoint enable, Read-write
    static const uint32_t OTG_HS_DIEPCTL6_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DIEPINT6_XFRC = 0x1;           // Transfer completed interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT6_EPDISD = 0x2;         // Endpoint disabled interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT6_TOC = 0x8;            // Timeout condition, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT6_ITTXFE = 0x10;        // IN token received when TxFIFO is empty, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT6_INEPNE = 0x40;        // IN endpoint NAK effective, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT6_TXFE = 0x80;          // Transmit FIFO empty, Read-only
    static constexpr uint32_t OTG_HS_DIEPINT6_TXFIFOUDRN = 0x100;   // Transmit Fifo Underrun, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT6_BNA = 0x200;          // Buffer not available interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT6_PKTDRPSTS = 0x800;    // Packet dropped status, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT6_BERR = 0x1000;        // Babble error interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT6_NAK = 0x2000;         // NAK interrupt, Read-write
    static const uint32_t OTG_HS_DIEPINT6_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL7_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL7_USBAEP = 0x8000;      // USB active endpoint, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL7_EONUM_DPID = 0x10000; // Even/odd frame, Read-only
    static constexpr uint32_t OTG_HS_DIEPCTL7_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL7_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL7_Stall = 0x200000;     // STALL handshake, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL7_TXFNUM =              // TxFIFO number (4 bits), Read-write
        bit_field_t<22, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL7_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL7_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL7_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL7_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL7_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL7_EPENA = 0x80000000;   // Endpoint enable, Read-write
    static const uint32_t OTG_HS_DIEPCTL7_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DIEPINT7_XFRC = 0x1;           // Transfer completed interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT7_EPDISD = 0x2;         // Endpoint disabled interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT7_TOC = 0x8;            // Timeout condition, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT7_ITTXFE = 0x10;        // IN token received when TxFIFO is empty, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT7_INEPNE = 0x40;        // IN endpoint NAK effective, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT7_TXFE = 0x80;          // Transmit FIFO empty, Read-only
    static constexpr uint32_t OTG_HS_DIEPINT7_TXFIFOUDRN = 0x100;   // Transmit Fifo Underrun, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT7_BNA = 0x200;          // Buffer not available interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT7_PKTDRPSTS = 0x800;    // Packet dropped status, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT7_BERR = 0x1000;        // Babble error interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT7_NAK = 0x2000;         // NAK interrupt, Read-write
    static const uint32_t OTG_HS_DIEPINT7_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL0_MPSIZ =               // Maximum packet size (2 bits), Read-only
        bit_field_t<0, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL0_USBAEP = 0x8000;      // USB active endpoint, Read-only
    static constexpr uint32_t OTG_HS_DOEPCTL0_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL0_EPTYP =               // Endpoint type (2 bits), Read-only
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL0_SNPM = 0x100000;      // Snoop mode, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL0_Stall = 0x200000;     // STALL handshake, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL0_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL0_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL0_EPDIS = 0x40000000;   // Endpoint disable, Read-only
    static constexpr uint32_t OTG_HS_DOEPCTL0_EPENA = 0x80000000;   // Endpoint enable, Write-only
    static const uint32_t OTG_HS_DOEPCTL0_RESET_VALUE = 0x8000;

    static constexpr uint32_t OTG_HS_DOEPINT0_XFRC = 0x1;           // Transfer completed interrupt
    static constexpr uint32_t OTG_HS_DOEPINT0_EPDISD = 0x2;         // Endpoint disabled interrupt
    static constexpr uint32_t OTG_HS_DOEPINT0_STUP = 0x8;           // SETUP phase done
    static constexpr uint32_t OTG_HS_DOEPINT0_OTEPDIS = 0x10;       // OUT token received when endpoint disabled
    static constexpr uint32_t OTG_HS_DOEPINT0_B2BSTUP = 0x40;       // Back-to-back SETUP packets received
    static constexpr uint32_t OTG_HS_DOEPINT0_NYET = 0x4000;        // NYET interrupt
    static const uint32_t OTG_HS_DOEPINT0_RESET_VALUE = 0x80;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ0_XFRSIZ =              // Transfer size (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPTSIZ0_PKTCNT = 0x80000;     // Packet count
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ0_STUPCNT =             // SETUP packet count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_DOEPTSIZ0_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL1_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL1_USBAEP = 0x8000;      // USB active endpoint, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL1_EONUM_DPID = 0x10000; // Even odd frame/Endpoint data PID, Read-only
    static constexpr uint32_t OTG_HS_DOEPCTL1_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL1_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL1_SNPM = 0x100000;      // Snoop mode, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL1_Stall = 0x200000;     // STALL handshake, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL1_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL1_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL1_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID/Set even frame, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL1_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL1_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL1_EPENA = 0x80000000;   // Endpoint enable, Read-write
    static const uint32_t OTG_HS_DOEPCTL1_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DOEPINT1_XFRC = 0x1;           // Transfer completed interrupt
    static constexpr uint32_t OTG_HS_DOEPINT1_EPDISD = 0x2;         // Endpoint disabled interrupt
    static constexpr uint32_t OTG_HS_DOEPINT1_STUP = 0x8;           // SETUP phase done
    static constexpr uint32_t OTG_HS_DOEPINT1_OTEPDIS = 0x10;       // OUT token received when endpoint disabled
    static constexpr uint32_t OTG_HS_DOEPINT1_B2BSTUP = 0x40;       // Back-to-back SETUP packets received
    static constexpr uint32_t OTG_HS_DOEPINT1_NYET = 0x4000;        // NYET interrupt
    static const uint32_t OTG_HS_DOEPINT1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ1_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ1_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ1_RXDPID_STUPCNT =      // Received data PID/SETUP packet count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_DOEPTSIZ1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL2_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL2_USBAEP = 0x8000;      // USB active endpoint, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL2_EONUM_DPID = 0x10000; // Even odd frame/Endpoint data PID, Read-only
    static constexpr uint32_t OTG_HS_DOEPCTL2_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL2_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL2_SNPM = 0x100000;      // Snoop mode, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL2_Stall = 0x200000;     // STALL handshake, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL2_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL2_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL2_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID/Set even frame, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL2_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL2_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL2_EPENA = 0x80000000;   // Endpoint enable, Read-write
    static const uint32_t OTG_HS_DOEPCTL2_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DOEPINT2_XFRC = 0x1;           // Transfer completed interrupt
    static constexpr uint32_t OTG_HS_DOEPINT2_EPDISD = 0x2;         // Endpoint disabled interrupt
    static constexpr uint32_t OTG_HS_DOEPINT2_STUP = 0x8;           // SETUP phase done
    static constexpr uint32_t OTG_HS_DOEPINT2_OTEPDIS = 0x10;       // OUT token received when endpoint disabled
    static constexpr uint32_t OTG_HS_DOEPINT2_B2BSTUP = 0x40;       // Back-to-back SETUP packets received
    static constexpr uint32_t OTG_HS_DOEPINT2_NYET = 0x4000;        // NYET interrupt
    static const uint32_t OTG_HS_DOEPINT2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ2_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ2_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ2_RXDPID_STUPCNT =      // Received data PID/SETUP packet count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_DOEPTSIZ2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL3_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL3_USBAEP = 0x8000;      // USB active endpoint, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL3_EONUM_DPID = 0x10000; // Even odd frame/Endpoint data PID, Read-only
    static constexpr uint32_t OTG_HS_DOEPCTL3_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL3_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL3_SNPM = 0x100000;      // Snoop mode, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL3_Stall = 0x200000;     // STALL handshake, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL3_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL3_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL3_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID/Set even frame, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL3_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL3_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL3_EPENA = 0x80000000;   // Endpoint enable, Read-write
    static const uint32_t OTG_HS_DOEPCTL3_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DOEPINT3_XFRC = 0x1;           // Transfer completed interrupt
    static constexpr uint32_t OTG_HS_DOEPINT3_EPDISD = 0x2;         // Endpoint disabled interrupt
    static constexpr uint32_t OTG_HS_DOEPINT3_STUP = 0x8;           // SETUP phase done
    static constexpr uint32_t OTG_HS_DOEPINT3_OTEPDIS = 0x10;       // OUT token received when endpoint disabled
    static constexpr uint32_t OTG_HS_DOEPINT3_B2BSTUP = 0x40;       // Back-to-back SETUP packets received
    static constexpr uint32_t OTG_HS_DOEPINT3_NYET = 0x4000;        // NYET interrupt
    static const uint32_t OTG_HS_DOEPINT3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ3_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ3_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ3_RXDPID_STUPCNT =      // Received data PID/SETUP packet count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_DOEPTSIZ3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL4_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL4_USBAEP = 0x8000;      // USB active endpoint, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL4_EONUM_DPID = 0x10000; // Even odd frame/Endpoint data PID, Read-only
    static constexpr uint32_t OTG_HS_DOEPCTL4_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL4_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL4_SNPM = 0x100000;      // Snoop mode, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL4_Stall = 0x200000;     // STALL handshake, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL4_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL4_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL4_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID/Set even frame, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL4_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL4_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL4_EPENA = 0x80000000;   // Endpoint enable, Read-write
    static const uint32_t OTG_HS_DOEPCTL4_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DOEPINT4_XFRC = 0x1;           // Transfer completed interrupt
    static constexpr uint32_t OTG_HS_DOEPINT4_EPDISD = 0x2;         // Endpoint disabled interrupt
    static constexpr uint32_t OTG_HS_DOEPINT4_STUP = 0x8;           // SETUP phase done
    static constexpr uint32_t OTG_HS_DOEPINT4_OTEPDIS = 0x10;       // OUT token received when endpoint disabled
    static constexpr uint32_t OTG_HS_DOEPINT4_B2BSTUP = 0x40;       // Back-to-back SETUP packets received
    static constexpr uint32_t OTG_HS_DOEPINT4_NYET = 0x4000;        // NYET interrupt
    static const uint32_t OTG_HS_DOEPINT4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ4_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ4_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ4_RXDPID_STUPCNT =      // Received data PID/SETUP packet count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_DOEPTSIZ4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL5_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL5_USBAEP = 0x8000;      // USB active endpoint, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL5_EONUM_DPID = 0x10000; // Even odd frame/Endpoint data PID, Read-only
    static constexpr uint32_t OTG_HS_DOEPCTL5_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL5_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL5_SNPM = 0x100000;      // Snoop mode, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL5_Stall = 0x200000;     // STALL handshake, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL5_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL5_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL5_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID/Set even frame, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL5_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL5_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL5_EPENA = 0x80000000;   // Endpoint enable, Read-write
    static const uint32_t OTG_HS_DOEPCTL5_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DOEPINT5_XFRC = 0x1;           // Transfer completed interrupt
    static constexpr uint32_t OTG_HS_DOEPINT5_EPDISD = 0x2;         // Endpoint disabled interrupt
    static constexpr uint32_t OTG_HS_DOEPINT5_STUP = 0x8;           // SETUP phase done
    static constexpr uint32_t OTG_HS_DOEPINT5_OTEPDIS = 0x10;       // OUT token received when endpoint disabled
    static constexpr uint32_t OTG_HS_DOEPINT5_B2BSTUP = 0x40;       // Back-to-back SETUP packets received
    static constexpr uint32_t OTG_HS_DOEPINT5_NYET = 0x4000;        // NYET interrupt
    static const uint32_t OTG_HS_DOEPINT5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ5_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ5_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ5_RXDPID_STUPCNT =      // Received data PID/SETUP packet count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_DOEPTSIZ5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL6_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL6_USBAEP = 0x8000;      // USB active endpoint, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL6_EONUM_DPID = 0x10000; // Even odd frame/Endpoint data PID, Read-only
    static constexpr uint32_t OTG_HS_DOEPCTL6_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL6_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL6_SNPM = 0x100000;      // Snoop mode, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL6_Stall = 0x200000;     // STALL handshake, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL6_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL6_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL6_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID/Set even frame, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL6_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL6_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL6_EPENA = 0x80000000;   // Endpoint enable, Read-write
    static const uint32_t OTG_HS_DOEPCTL6_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DOEPINT6_XFRC = 0x1;           // Transfer completed interrupt
    static constexpr uint32_t OTG_HS_DOEPINT6_EPDISD = 0x2;         // Endpoint disabled interrupt
    static constexpr uint32_t OTG_HS_DOEPINT6_STUP = 0x8;           // SETUP phase done
    static constexpr uint32_t OTG_HS_DOEPINT6_OTEPDIS = 0x10;       // OUT token received when endpoint disabled
    static constexpr uint32_t OTG_HS_DOEPINT6_B2BSTUP = 0x40;       // Back-to-back SETUP packets received
    static constexpr uint32_t OTG_HS_DOEPINT6_NYET = 0x4000;        // NYET interrupt
    static const uint32_t OTG_HS_DOEPINT6_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ6_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ6_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ6_RXDPID_STUPCNT =      // Received data PID/SETUP packet count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_DOEPTSIZ6_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL7_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL7_USBAEP = 0x8000;      // USB active endpoint, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL7_EONUM_DPID = 0x10000; // Even odd frame/Endpoint data PID, Read-only
    static constexpr uint32_t OTG_HS_DOEPCTL7_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL7_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL7_SNPM = 0x100000;      // Snoop mode, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL7_Stall = 0x200000;     // STALL handshake, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL7_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL7_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL7_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID/Set even frame, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL7_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL7_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL7_EPENA = 0x80000000;   // Endpoint enable, Read-write
    static const uint32_t OTG_HS_DOEPCTL7_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DOEPINT7_XFRC = 0x1;           // Transfer completed interrupt
    static constexpr uint32_t OTG_HS_DOEPINT7_EPDISD = 0x2;         // Endpoint disabled interrupt
    static constexpr uint32_t OTG_HS_DOEPINT7_STUP = 0x8;           // SETUP phase done
    static constexpr uint32_t OTG_HS_DOEPINT7_OTEPDIS = 0x10;       // OUT token received when endpoint disabled
    static constexpr uint32_t OTG_HS_DOEPINT7_B2BSTUP = 0x40;       // Back-to-back SETUP packets received
    static constexpr uint32_t OTG_HS_DOEPINT7_NYET = 0x4000;        // NYET interrupt
    static const uint32_t OTG_HS_DOEPINT7_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ7_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ7_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ7_RXDPID_STUPCNT =      // Received data PID/SETUP packet count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_DOEPTSIZ7_RESET_VALUE = 0x0;
};

static otg2_hs_device_t& OTG2_HS_DEVICE = *reinterpret_cast<otg2_hs_device_t*>(0x40080800);

#define HAVE_PERIPHERAL_OTG2_HS_DEVICE


////
//
//    USB 1 on the go high speed
//
////

struct otg1_hs_pwrclk_t
{
    volatile uint32_t    OTG_HS_PCGCR;         // [Read-write] Power and clock gating control register

    static constexpr uint32_t OTG_HS_PCGCR_STPPCLK = 0x1;        // Stop PHY clock
    static constexpr uint32_t OTG_HS_PCGCR_GATEHCLK = 0x2;       // Gate HCLK
    static constexpr uint32_t OTG_HS_PCGCR_PHYSUSP = 0x10;       // PHY suspended
    static const uint32_t OTG_HS_PCGCR_RESET_VALUE = 0x0;
};

static otg1_hs_pwrclk_t& OTG1_HS_PWRCLK = *reinterpret_cast<otg1_hs_pwrclk_t*>(0x40040e00);

#define HAVE_PERIPHERAL_OTG1_HS_PWRCLK


////
//
//    USB 1 on the go high speed
//
////

struct otg2_hs_pwrclk_t
{
    volatile uint32_t    OTG_HS_PCGCR;         // [Read-write] Power and clock gating control register

    static constexpr uint32_t OTG_HS_PCGCR_STPPCLK = 0x1;        // Stop PHY clock
    static constexpr uint32_t OTG_HS_PCGCR_GATEHCLK = 0x2;       // Gate HCLK
    static constexpr uint32_t OTG_HS_PCGCR_PHYSUSP = 0x10;       // PHY suspended
    static const uint32_t OTG_HS_PCGCR_RESET_VALUE = 0x0;
};

static otg2_hs_pwrclk_t& OTG2_HS_PWRCLK = *reinterpret_cast<otg2_hs_pwrclk_t*>(0x40080e00);

#define HAVE_PERIPHERAL_OTG2_HS_PWRCLK


////
//
//    Ethernet: DMA mode register (DMA)
//
////

struct ethernet_dma_t
{
    volatile uint32_t    DMAMR;                // DMA mode register
    volatile uint32_t    DMASBMR;              // System bus mode register
    volatile uint32_t    DMAISR;               // [Read-only] Interrupt status register
    volatile uint32_t    DMADSR;               // [Read-only] Debug status register
    reserved_t<60>       _0;
    volatile uint32_t    DMACCR;               // [Read-write] Channel control register
    volatile uint32_t    DMACTxCR;             // [Read-write] Channel transmit control register
    volatile uint32_t    DMACRxCR;             // [Read-write] Channel receive control register
    reserved_t<2>        _1;
    volatile uint32_t    DMACTxDLAR;           // [Read-write] Channel Tx descriptor list address register
    reserved_t<1>        _2;
    volatile uint32_t    DMACRxDLAR;           // [Read-write] Channel Rx descriptor list address register
    volatile uint32_t    DMACTxDTPR;           // [Read-write] Channel Tx descriptor tail pointer register
    reserved_t<1>        _3;
    volatile uint32_t    DMACRxDTPR;           // [Read-write] Channel Rx descriptor tail pointer register
    volatile uint32_t    DMACTxRLR;            // [Read-write] Channel Tx descriptor ring length register
    volatile uint32_t    DMACRxRLR;            // [Read-write] Channel Rx descriptor ring length register
    volatile uint32_t    DMACIER;              // [Read-write] Channel interrupt enable register
    volatile uint32_t    DMACRxIWTR;           // [Read-write] Channel Rx interrupt watchdog timer register
    reserved_t<2>        _4;
    volatile uint32_t    DMACCATxDR;           // [Read-only] Channel current application transmit descriptor register
    reserved_t<1>        _5;
    volatile uint32_t    DMACCARxDR;           // [Read-only] Channel current application receive descriptor register
    reserved_t<1>        _6;
    volatile uint32_t    DMACCATxBR;           // [Read-only] Channel current application transmit buffer register
    reserved_t<1>        _7;
    volatile uint32_t    DMACCARxBR;           // [Read-only] Channel current application receive buffer register
    volatile uint32_t    DMACSR;               // Channel status register
    reserved_t<2>        _8;
    volatile uint32_t    DMACMFCR;             // [Read-only] Channel missed frame count register

    static constexpr uint32_t DMAMR_SWR = 0x1;            // Software Reset, Read-write
    static constexpr uint32_t DMAMR_DA = 0x2;             // DMA Tx or Rx Arbitration Scheme, Read-only
    static constexpr uint32_t DMAMR_TXPR = 0x800;         // Transmit priority, Read-only
    template<uint32_t X>
    static constexpr uint32_t DMAMR_PR =                  // Priority ratio (3 bits), Read-only
        bit_field_t<12, 0x7>::value<X>();
    static constexpr uint32_t DMAMR_INTM = 0x10000;       // Interrupt Mode, Read-write
    static const uint32_t DMAMR_RESET_VALUE = 0x0;

    static constexpr uint32_t DMASBMR_FB = 0x1;             // Fixed Burst Length, Read-write
    static constexpr uint32_t DMASBMR_AAL = 0x1000;         // Address-Aligned Beats, Read-write
    static constexpr uint32_t DMASBMR_MB = 0x4000;          // Mixed Burst, Read-only
    static constexpr uint32_t DMASBMR_RB = 0x8000;          // Rebuild INCRx Burst, Read-only
    static const uint32_t DMASBMR_RESET_VALUE = 0x1010000;

    static constexpr uint32_t DMAISR_DC0IS = 0x1;          // DMA Channel Interrupt Status
    static constexpr uint32_t DMAISR_MTLIS = 0x10000;      // MTL Interrupt Status
    static constexpr uint32_t DMAISR_MACIS = 0x20000;      // MAC Interrupt Status
    static const uint32_t DMAISR_RESET_VALUE = 0x0;

    static constexpr uint32_t DMADSR_AXWHSTS = 0x1;        // AHB Master Write Channel
    template<uint32_t X>
    static constexpr uint32_t DMADSR_RPS0 =                // DMA Channel Receive Process State (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DMADSR_TPS0 =                // DMA Channel Transmit Process State (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    static const uint32_t DMADSR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DMACCR_MSS =                 // Maximum Segment Size (14 bits)
        bit_field_t<0, 0x3fff>::value<X>();
    static constexpr uint32_t DMACCR_PBLX8 = 0x10000;      // 8xPBL mode
    template<uint32_t X>
    static constexpr uint32_t DMACCR_DSL =                 // Descriptor Skip Length (3 bits)
        bit_field_t<18, 0x7>::value<X>();
    static const uint32_t DMACCR_RESET_VALUE = 0x0;

    static constexpr uint32_t DMACTxCR_ST = 0x1;             // Start or Stop Transmission Command
    static constexpr uint32_t DMACTxCR_OSF = 0x10;           // Operate on Second Packet
    static constexpr uint32_t DMACTxCR_TSE = 0x1000;         // TCP Segmentation Enabled
    template<uint32_t X>
    static constexpr uint32_t DMACTxCR_TXPBL =               // Transmit Programmable Burst Length (6 bits)
        bit_field_t<16, 0x3f>::value<X>();
    static const uint32_t DMACTxCR_RESET_VALUE = 0x0;

    static constexpr uint32_t DMACRxCR_SR = 0x1;             // Start or Stop Receive Command
    template<uint32_t X>
    static constexpr uint32_t DMACRxCR_RBSZ =                // Receive Buffer size (14 bits)
        bit_field_t<1, 0x3fff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DMACRxCR_RXPBL =               // RXPBL (6 bits)
        bit_field_t<16, 0x3f>::value<X>();
    static constexpr uint32_t DMACRxCR_RPF = 0x80000000;     // DMA Rx Channel Packet Flush
    static const uint32_t DMACRxCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DMACTxDLAR_TDESLA =              // Start of Transmit List (30 bits)
        bit_field_t<2, 0x3fffffff>::value<X>();
    static const uint32_t DMACTxDLAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DMACRxDLAR_RDESLA =              // Start of Receive List (30 bits)
        bit_field_t<2, 0x3fffffff>::value<X>();
    static const uint32_t DMACRxDLAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DMACTxDTPR_TDT =                 // Transmit Descriptor Tail Pointer (30 bits)
        bit_field_t<2, 0x3fffffff>::value<X>();
    static const uint32_t DMACTxDTPR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DMACRxDTPR_RDT =                 // Receive Descriptor Tail Pointer (30 bits)
        bit_field_t<2, 0x3fffffff>::value<X>();
    static const uint32_t DMACRxDTPR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DMACTxRLR_TDRL =                // Transmit Descriptor Ring Length (10 bits)
        bit_field_t<0, 0x3ff>::value<X>();
    static const uint32_t DMACTxRLR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DMACRxRLR_RDRL =                // Receive Descriptor Ring Length (10 bits)
        bit_field_t<0, 0x3ff>::value<X>();
    static const uint32_t DMACRxRLR_RESET_VALUE = 0x0;

    static constexpr uint32_t DMACIER_TIE = 0x1;            // Transmit Interrupt Enable
    static constexpr uint32_t DMACIER_TXSE = 0x2;           // Transmit Stopped Enable
    static constexpr uint32_t DMACIER_TBUE = 0x4;           // Transmit Buffer Unavailable Enable
    static constexpr uint32_t DMACIER_RIE = 0x40;           // Receive Interrupt Enable
    static constexpr uint32_t DMACIER_RBUE = 0x80;          // Receive Buffer Unavailable Enable
    static constexpr uint32_t DMACIER_RSE = 0x100;          // Receive Stopped Enable
    static constexpr uint32_t DMACIER_RWTE = 0x200;         // Receive Watchdog Timeout Enable
    static constexpr uint32_t DMACIER_ETIE = 0x400;         // Early Transmit Interrupt Enable
    static constexpr uint32_t DMACIER_ERIE = 0x800;         // Early Receive Interrupt Enable
    static constexpr uint32_t DMACIER_FBEE = 0x1000;        // Fatal Bus Error Enable
    static constexpr uint32_t DMACIER_CDEE = 0x2000;        // Context Descriptor Error Enable
    static constexpr uint32_t DMACIER_AIE = 0x4000;         // Abnormal Interrupt Summary Enable
    static constexpr uint32_t DMACIER_NIE = 0x8000;         // Normal Interrupt Summary Enable
    static const uint32_t DMACIER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DMACRxIWTR_RWT =                 // Receive Interrupt Watchdog Timer Count (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t DMACRxIWTR_RESET_VALUE = 0x0;


    static const uint32_t DMACCATxDR_RESET_VALUE = 0x0;


    static const uint32_t DMACCARxDR_RESET_VALUE = 0x0;


    static const uint32_t DMACCATxBR_RESET_VALUE = 0x0;


    static const uint32_t DMACCARxBR_RESET_VALUE = 0x0;

    static constexpr uint32_t DMACSR_TI = 0x1;             // Transmit Interrupt, Read-write
    static constexpr uint32_t DMACSR_TPS = 0x2;            // Transmit Process Stopped, Read-write
    static constexpr uint32_t DMACSR_TBU = 0x4;            // Transmit Buffer Unavailable, Read-write
    static constexpr uint32_t DMACSR_RI = 0x40;            // Receive Interrupt, Read-write
    static constexpr uint32_t DMACSR_RBU = 0x80;           // Receive Buffer Unavailable, Read-write
    static constexpr uint32_t DMACSR_RPS = 0x100;          // Receive Process Stopped, Read-write
    static constexpr uint32_t DMACSR_RWT = 0x200;          // Receive Watchdog Timeout, Read-write
    static constexpr uint32_t DMACSR_ET = 0x400;           // Early Transmit Interrupt, Read-write
    static constexpr uint32_t DMACSR_ER = 0x800;           // Early Receive Interrupt, Read-write
    static constexpr uint32_t DMACSR_FBE = 0x1000;         // Fatal Bus Error, Read-write
    static constexpr uint32_t DMACSR_CDE = 0x2000;         // Context Descriptor Error, Read-write
    static constexpr uint32_t DMACSR_AIS = 0x4000;         // Abnormal Interrupt Summary, Read-write
    static constexpr uint32_t DMACSR_NIS = 0x8000;         // Normal Interrupt Summary, Read-write
    template<uint32_t X>
    static constexpr uint32_t DMACSR_TEB =                 // Tx DMA Error Bits (3 bits), Read-only
        bit_field_t<16, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DMACSR_REB =                 // Rx DMA Error Bits (3 bits), Read-only
        bit_field_t<19, 0x7>::value<X>();
    static const uint32_t DMACSR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DMACMFCR_MFC =                 // Dropped Packet Counters (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t DMACMFCR_MFCO = 0x8000;        // Overflow status of the MFC Counter
    static const uint32_t DMACMFCR_RESET_VALUE = 0x0;
};

static ethernet_dma_t& ETHERNET_DMA = *reinterpret_cast<ethernet_dma_t*>(0x40029000);

#define HAVE_PERIPHERAL_ETHERNET_DMA


////
//
//    Ethernet: MTL mode register (MTL)
//
////

struct ethernet_mtl_t
{
    volatile uint32_t    MTLOMR;               // [Read-write] Operating mode Register
    reserved_t<7>        _0;
    volatile uint32_t    MTLISR;               // [Read-only] Interrupt status Register
    reserved_t<55>       _1;
    volatile uint32_t    MTLTxQOMR;            // Tx queue operating mode Register
    volatile uint32_t    MTLTxQUR;             // [Read-only] Tx queue underflow register
    volatile uint32_t    MTLTxQDR;             // [Read-only] Tx queue debug Register
    reserved_t<8>        _2;
    volatile uint32_t    MTLQICSR;             // [Read-write] Queue interrupt control status Register
    volatile uint32_t    MTLRxQOMR;            // Rx queue operating mode register
    volatile uint32_t    MTLRxQMPOCR;          // [Read-only] Rx queue missed packet and overflow counter register
    volatile uint32_t    MTLRxQDR;             // [Read-only] Rx queue debug register

    static constexpr uint32_t MTLOMR_DTXSTS = 0x2;         // DTXSTS
    static constexpr uint32_t MTLOMR_CNTPRST = 0x100;      // CNTPRST
    static constexpr uint32_t MTLOMR_CNTCLR = 0x200;       // CNTCLR
    static const uint32_t MTLOMR_RESET_VALUE = 0x0;

    static constexpr uint32_t MTLISR_Q0IS = 0x1;           // Queue interrupt status
    static const uint32_t MTLISR_RESET_VALUE = 0x0;

    static constexpr uint32_t MTLTxQOMR_FTQ = 0x1;            // Flush Transmit Queue, Read-write
    static constexpr uint32_t MTLTxQOMR_TSF = 0x2;            // Transmit Store and Forward, Read-write
    template<uint32_t X>
    static constexpr uint32_t MTLTxQOMR_TXQEN =               // Transmit Queue Enable (2 bits), Read-only
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MTLTxQOMR_TTC =                 // Transmit Threshold Control (3 bits), Read-write
        bit_field_t<4, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MTLTxQOMR_TQS =                 // Transmit Queue Size (3 bits), Read-write
        bit_field_t<16, 0x7>::value<X>();
    static const uint32_t MTLTxQOMR_RESET_VALUE = 0x70008;

    template<uint32_t X>
    static constexpr uint32_t MTLTxQUR_UFFRMCNT =            // Underflow Packet Counter (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t MTLTxQUR_UFCNTOVF = 0x800;     // UFCNTOVF
    static const uint32_t MTLTxQUR_RESET_VALUE = 0x0;

    static constexpr uint32_t MTLTxQDR_TXQPAUSED = 0x1;      // TXQPAUSED
    template<uint32_t X>
    static constexpr uint32_t MTLTxQDR_TRCSTS =              // TRCSTS (2 bits)
        bit_field_t<1, 0x3>::value<X>();
    static constexpr uint32_t MTLTxQDR_TWCSTS = 0x8;         // TWCSTS
    static constexpr uint32_t MTLTxQDR_TXQSTS = 0x10;        // TXQSTS
    static constexpr uint32_t MTLTxQDR_TXSTSFSTS = 0x20;     // TXSTSFSTS
    template<uint32_t X>
    static constexpr uint32_t MTLTxQDR_PTXQ =                // PTXQ (3 bits)
        bit_field_t<16, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MTLTxQDR_STXSTSF =             // STXSTSF (3 bits)
        bit_field_t<20, 0x7>::value<X>();
    static const uint32_t MTLTxQDR_RESET_VALUE = 0x0;

    static constexpr uint32_t MTLQICSR_TXUNFIS = 0x1;        // TXUNFIS
    static constexpr uint32_t MTLQICSR_TXUIE = 0x100;        // TXUIE
    static constexpr uint32_t MTLQICSR_RXOVFIS = 0x10000;    // RXOVFIS
    static constexpr uint32_t MTLQICSR_RXOIE = 0x1000000;    // RXOIE
    static const uint32_t MTLQICSR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t MTLRxQOMR_RTC =                 // RTC (2 bits), Read-write
        bit_field_t<0, 0x3>::value<X>();
    static constexpr uint32_t MTLRxQOMR_FUP = 0x8;            // FUP, Read-write
    static constexpr uint32_t MTLRxQOMR_FEP = 0x10;           // FEP, Read-write
    static constexpr uint32_t MTLRxQOMR_RSF = 0x20;           // RSF, Read-write
    static constexpr uint32_t MTLRxQOMR_DIS_TCP_EF = 0x40;    // DIS_TCP_EF, Read-write
    static constexpr uint32_t MTLRxQOMR_EHFC = 0x80;          // EHFC, Read-write
    template<uint32_t X>
    static constexpr uint32_t MTLRxQOMR_RFA =                 // RFA (3 bits), Read-write
        bit_field_t<8, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MTLRxQOMR_RFD =                 // RFD (3 bits), Read-write
        bit_field_t<14, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MTLRxQOMR_RQS =                 // RQS (3 bits), Read-only
        bit_field_t<20, 0x7>::value<X>();
    static const uint32_t MTLRxQOMR_RESET_VALUE = 0x700000;

    template<uint32_t X>
    static constexpr uint32_t MTLRxQMPOCR_OVFPKTCNT =           // OVFPKTCNT (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t MTLRxQMPOCR_OVFCNTOVF = 0x800;    // OVFCNTOVF
    template<uint32_t X>
    static constexpr uint32_t MTLRxQMPOCR_MISPKTCNT =           // MISPKTCNT (11 bits)
        bit_field_t<16, 0x7ff>::value<X>();
    static constexpr uint32_t MTLRxQMPOCR_MISCNTOVF = 0x8000000;// MISCNTOVF
    static const uint32_t MTLRxQMPOCR_RESET_VALUE = 0x0;

    static constexpr uint32_t MTLRxQDR_RWCSTS = 0x1;         // RWCSTS
    template<uint32_t X>
    static constexpr uint32_t MTLRxQDR_RRCSTS =              // RRCSTS (2 bits)
        bit_field_t<1, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MTLRxQDR_RXQSTS =              // RXQSTS (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MTLRxQDR_PRXQ =                // PRXQ (14 bits)
        bit_field_t<16, 0x3fff>::value<X>();
    static const uint32_t MTLRxQDR_RESET_VALUE = 0x0;
};

static ethernet_mtl_t& ETHERNET_MTL = *reinterpret_cast<ethernet_mtl_t*>(0x40028c00);

#define HAVE_PERIPHERAL_ETHERNET_MTL


////
//
//    Ethernet: media access control (MAC)
//
////

struct ethernet_mac_t
{
    volatile uint32_t    MACCR;                // [Read-write] Operating mode configuration register
    volatile uint32_t    MACECR;               // [Read-write] Extended operating mode configuration register
    volatile uint32_t    MACPFR;               // [Read-write] Packet filtering control register
    volatile uint32_t    MACWTR;               // [Read-write] Watchdog timeout register
    volatile uint32_t    MACHT0R;              // [Read-write] Hash Table 0 register
    volatile uint32_t    MACHT1R;              // [Read-write] Hash Table 1 register
    reserved_t<14>       _0;
    volatile uint32_t    MACVTR;               // [Read-write] VLAN tag register
    reserved_t<1>        _1;
    volatile uint32_t    MACVHTR;              // [Read-write] VLAN Hash table register
    reserved_t<1>        _2;
    volatile uint32_t    MACVIR;               // [Read-write] VLAN inclusion register
    volatile uint32_t    MACIVIR;              // [Read-write] Inner VLAN inclusion register
    reserved_t<2>        _3;
    volatile uint32_t    MACQTxFCR;            // [Read-write] Tx Queue flow control register
    reserved_t<7>        _4;
    volatile uint32_t    MACRxFCR;             // [Read-write] Rx flow control register
    reserved_t<7>        _5;
    volatile uint32_t    MACISR;               // [Read-only] Interrupt status register
    volatile uint32_t    MACIER;               // [Read-write] Interrupt enable register
    volatile uint32_t    MACRxTxSR;            // [Read-only] Rx Tx status register
    reserved_t<1>        _6;
    volatile uint32_t    MACPCSR;              // PMT control status register
    volatile uint32_t    MACRWKPFR;            // [Read-write] Remove wakeup packet filter register
    reserved_t<2>        _7;
    volatile uint32_t    MACLCSR;              // LPI control status register
    volatile uint32_t    MACLTCR;              // [Read-write] LPI timers control register
    volatile uint32_t    MACLETR;              // [Read-write] LPI entry timer register
    volatile uint32_t    MAC1USTCR;            // [Read-write] 1-microsecond-tick counter register
    reserved_t<12>       _8;
    volatile uint32_t    MACVR;                // [Read-only] Version register
    volatile uint32_t    MACDR;                // [Read-only] Debug register
    reserved_t<2>        _9;
    volatile uint32_t    MACHWF1R;             // [Read-only] HW feature 1 register
    volatile uint32_t    MACHWF2R;             // [Read-only] HW feature 2 register
    reserved_t<54>       _10;
    volatile uint32_t    MACMDIOAR;            // [Read-write] MDIO address register
    volatile uint32_t    MACMDIODR;            // [Read-write] MDIO data register
    reserved_t<62>       _11;
    volatile uint32_t    MACA0HR;              // Address 0 high register
    volatile uint32_t    MACA0LR;              // [Read-write] Address 0 low register
    volatile uint32_t    MACA1HR;              // [Read-write] Address 1 high register
    volatile uint32_t    MACA1LR;              // [Read-write] Address 1 low register
    volatile uint32_t    MACA2HR;              // [Read-write] Address 2 high register
    volatile uint32_t    MACA2LR;              // [Read-write] Address 2 low register
    volatile uint32_t    MACA3HR;              // [Read-write] Address 3 high register
    volatile uint32_t    MACA3LR;              // [Read-write] Address 3 low register
    reserved_t<248>      _12;
    volatile uint32_t    MMC_CONTROL;          // [Read-write] MMC control register
    volatile uint32_t    MMC_RX_INTERRUPT;     // [Read-only] MMC Rx interrupt register
    volatile uint32_t    MMC_TX_INTERRUPT;     // [Read-only] MMC Tx interrupt register
    volatile uint32_t    MMC_RX_INTERRUPT_MASK;// MMC Rx interrupt mask register
    volatile uint32_t    MMC_TX_INTERRUPT_MASK;// MMC Tx interrupt mask register
    reserved_t<14>       _13;
    volatile uint32_t    TX_SINGLE_COLLISION_GOOD_PACKETS;// [Read-only] Tx single collision good packets register
    volatile uint32_t    TX_MULTIPLE_COLLISION_GOOD_PACKETS;// [Read-only] Tx multiple collision good packets register
    reserved_t<5>        _14;
    volatile uint32_t    TX_PACKET_COUNT_GOOD; // [Read-only] Tx packet count good register
    reserved_t<10>       _15;
    volatile uint32_t    RX_CRC_ERROR_PACKETS; // [Read-only] Rx CRC error packets register
    volatile uint32_t    RX_ALIGNMENT_ERROR_PACKETS;// [Read-only] Rx alignment error packets register
    reserved_t<10>       _16;
    volatile uint32_t    RX_UNICAST_PACKETS_GOOD;// [Read-only] Rx unicast packets good register
    reserved_t<9>        _17;
    volatile uint32_t    TX_LPI_USEC_CNTR;     // [Read-only] Tx LPI microsecond timer register
    volatile uint32_t    TX_LPI_TRAN_CNTR;     // [Read-only] Tx LPI transition counter register
    volatile uint32_t    RX_LPI_USEC_CNTR;     // [Read-only] Rx LPI microsecond counter register
    volatile uint32_t    RX_LPI_TRAN_CNTR;     // [Read-only] Rx LPI transition counter register
    reserved_t<65>       _18;
    volatile uint32_t    MACL3L4C0R;           // [Read-write] L3 and L4 control 0 register
    volatile uint32_t    MACL4A0R;             // [Read-write] Layer4 address filter 0 register
    reserved_t<2>        _19;
    volatile uint32_t    MACL3A00R;            // [Read-write] MACL3A00R
    volatile uint32_t    MACL3A10R;            // [Read-write] Layer3 address 1 filter 0 register
    volatile uint32_t    MACL3A20;             // [Read-write] Layer3 Address 2 filter 0 register
    volatile uint32_t    MACL3A30;             // [Read-write] Layer3 Address 3 filter 0 register
    reserved_t<4>        _20;
    volatile uint32_t    MACL3L4C1R;           // [Read-write] L3 and L4 control 1 register
    volatile uint32_t    MACL4A1R;             // [Read-write] Layer 4 address filter 1 register
    reserved_t<2>        _21;
    volatile uint32_t    MACL3A01R;            // [Read-write] Layer3 address 0 filter 1 Register
    volatile uint32_t    MACL3A11R;            // [Read-write] Layer3 address 1 filter 1 register
    volatile uint32_t    MACL3A21R;            // [Read-write] Layer3 address 2 filter 1 Register
    volatile uint32_t    MACL3A31R;            // [Read-write] Layer3 address 3 filter 1 register
    reserved_t<100>      _22;
    volatile uint32_t    MACARPAR;             // [Read-write] ARP address register
    reserved_t<7>        _23;
    volatile uint32_t    MACTSCR;              // Timestamp control Register
    volatile uint32_t    MACSSIR;              // [Read-write] Sub-second increment register
    volatile uint32_t    MACSTSR;              // [Read-only] System time seconds register
    volatile uint32_t    MACSTNR;              // [Read-only] System time nanoseconds register
    volatile uint32_t    MACSTSUR;             // [Read-write] System time seconds update register
    volatile uint32_t    MACSTNUR;             // [Read-write] System time nanoseconds update register
    volatile uint32_t    MACTSAR;              // [Read-write] Timestamp addend register
    reserved_t<1>        _24;
    volatile uint32_t    MACTSSR;              // [Read-only] Timestamp status register
    reserved_t<3>        _25;
    volatile uint32_t    MACTxTSSNR;           // [Read-only] Tx timestamp status nanoseconds register
    volatile uint32_t    MACTxTSSSR;           // [Read-only] Tx timestamp status seconds register
    reserved_t<2>        _26;
    volatile uint32_t    MACACR;               // [Read-write] Auxiliary control register
    reserved_t<1>        _27;
    volatile uint32_t    MACATSNR;             // [Read-only] Auxiliary timestamp nanoseconds register
    volatile uint32_t    MACATSSR;             // [Read-only] Auxiliary timestamp seconds register
    volatile uint32_t    MACTSIACR;            // [Read-write] Timestamp Ingress asymmetric correction register
    volatile uint32_t    MACTSEACR;            // [Read-write] Timestamp Egress asymmetric correction register
    volatile uint32_t    MACTSICNR;            // [Read-write] Timestamp Ingress correction nanosecond register
    volatile uint32_t    MACTSECNR;            // [Read-write] Timestamp Egress correction nanosecond register
    reserved_t<4>        _28;
    volatile uint32_t    MACPPSCR;             // [Read-write] PPS control register
    reserved_t<3>        _29;
    volatile uint32_t    MACPPSTTSR;           // [Read-write] PPS target time seconds register
    volatile uint32_t    MACPPSTTNR;           // [Read-write] PPS target time nanoseconds register
    volatile uint32_t    MACPPSIR;             // [Read-write] PPS interval register
    volatile uint32_t    MACPPSWR;             // [Read-write] PPS width register
    reserved_t<12>       _30;
    volatile uint32_t    MACPOCR;              // [Read-write] PTP Offload control register
    volatile uint32_t    MACSPI0R;             // [Read-write] PTP Source Port Identity 0 Register
    volatile uint32_t    MACSPI1R;             // [Read-write] PTP Source port identity 1 register
    volatile uint32_t    MACSPI2R;             // [Read-write] PTP Source port identity 2 register
    volatile uint32_t    MACLMIR;              // [Read-write] Log message interval register

    static constexpr uint32_t MACCR_RE = 0x1;             // Receiver Enable
    static constexpr uint32_t MACCR_TE = 0x2;             // TE
    template<uint32_t X>
    static constexpr uint32_t MACCR_PRELEN =              // PRELEN (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t MACCR_DC = 0x10;            // DC
    template<uint32_t X>
    static constexpr uint32_t MACCR_BL =                  // BL (2 bits)
        bit_field_t<5, 0x3>::value<X>();
    static constexpr uint32_t MACCR_DR = 0x100;           // DR
    static constexpr uint32_t MACCR_DCRS = 0x200;         // DCRS
    static constexpr uint32_t MACCR_DO = 0x400;           // DO
    static constexpr uint32_t MACCR_ECRSFD = 0x800;       // ECRSFD
    static constexpr uint32_t MACCR_LM = 0x1000;          // LM
    static constexpr uint32_t MACCR_DM = 0x2000;          // DM
    static constexpr uint32_t MACCR_FES = 0x4000;         // FES
    static constexpr uint32_t MACCR_JE = 0x10000;         // JE
    static constexpr uint32_t MACCR_JD = 0x20000;         // JD
    static constexpr uint32_t MACCR_WD = 0x80000;         // WD
    static constexpr uint32_t MACCR_ACS = 0x100000;       // ACS
    static constexpr uint32_t MACCR_CST = 0x200000;       // CST
    static constexpr uint32_t MACCR_S2KP = 0x400000;      // S2KP
    static constexpr uint32_t MACCR_GPSLCE = 0x800000;    // GPSLCE
    template<uint32_t X>
    static constexpr uint32_t MACCR_IPG =                 // IPG (3 bits)
        bit_field_t<24, 0x7>::value<X>();
    static constexpr uint32_t MACCR_IPC = 0x8000000;      // IPC
    template<uint32_t X>
    static constexpr uint32_t MACCR_SARC =                // SARC (3 bits)
        bit_field_t<28, 0x7>::value<X>();
    static constexpr uint32_t MACCR_ARPEN = 0x80000000;   // ARPEN
    static const uint32_t MACCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t MACECR_GPSL =                // GPSL (14 bits)
        bit_field_t<0, 0x3fff>::value<X>();
    static constexpr uint32_t MACECR_DCRCC = 0x10000;      // DCRCC
    static constexpr uint32_t MACECR_SPEN = 0x20000;       // SPEN
    static constexpr uint32_t MACECR_USP = 0x40000;        // USP
    static constexpr uint32_t MACECR_EIPGEN = 0x1000000;   // EIPGEN
    template<uint32_t X>
    static constexpr uint32_t MACECR_EIPG =                // EIPG (5 bits)
        bit_field_t<25, 0x1f>::value<X>();
    static const uint32_t MACECR_RESET_VALUE = 0x0;

    static constexpr uint32_t MACPFR_PR = 0x1;             // PR
    static constexpr uint32_t MACPFR_HUC = 0x2;            // HUC
    static constexpr uint32_t MACPFR_HMC = 0x4;            // HMC
    static constexpr uint32_t MACPFR_DAIF = 0x8;           // DAIF
    static constexpr uint32_t MACPFR_PM = 0x10;            // PM
    static constexpr uint32_t MACPFR_DBF = 0x20;           // DBF
    template<uint32_t X>
    static constexpr uint32_t MACPFR_PCF =                 // PCF (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t MACPFR_SAIF = 0x100;         // SAIF
    static constexpr uint32_t MACPFR_SAF = 0x200;          // SAF
    static constexpr uint32_t MACPFR_HPF = 0x400;          // HPF
    static constexpr uint32_t MACPFR_VTFE = 0x10000;       // VTFE
    static constexpr uint32_t MACPFR_IPFE = 0x100000;      // IPFE
    static constexpr uint32_t MACPFR_DNTU = 0x200000;      // DNTU
    static constexpr uint32_t MACPFR_RA = 0x80000000;      // RA
    static const uint32_t MACPFR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t MACWTR_WTO =                 // WTO (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static constexpr uint32_t MACWTR_PWE = 0x100;          // PWE
    static const uint32_t MACWTR_RESET_VALUE = 0x0;


    static const uint32_t MACHT0R_RESET_VALUE = 0x0;


    static const uint32_t MACHT1R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t MACVTR_VL =                  // VL (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static constexpr uint32_t MACVTR_ETV = 0x10000;        // ETV
    static constexpr uint32_t MACVTR_VTIM = 0x20000;       // VTIM
    static constexpr uint32_t MACVTR_ESVL = 0x40000;       // ESVL
    static constexpr uint32_t MACVTR_ERSVLM = 0x80000;     // ERSVLM
    static constexpr uint32_t MACVTR_DOVLTC = 0x100000;    // DOVLTC
    template<uint32_t X>
    static constexpr uint32_t MACVTR_EVLS =                // EVLS (2 bits)
        bit_field_t<21, 0x3>::value<X>();
    static constexpr uint32_t MACVTR_EVLRXS = 0x1000000;   // EVLRXS
    static constexpr uint32_t MACVTR_VTHM = 0x2000000;     // VTHM
    static constexpr uint32_t MACVTR_EDVLP = 0x4000000;    // EDVLP
    static constexpr uint32_t MACVTR_ERIVLT = 0x8000000;   // ERIVLT
    template<uint32_t X>
    static constexpr uint32_t MACVTR_EIVLS =               // EIVLS (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    static constexpr uint32_t MACVTR_EIVLRXS = 0x80000000; // EIVLRXS
    static const uint32_t MACVTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t MACVHTR_VLHT =                // VLHT (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t MACVHTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t MACVIR_VLT =                 // VLT (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MACVIR_VLC =                 // VLC (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    static constexpr uint32_t MACVIR_VLP = 0x40000;        // VLP
    static constexpr uint32_t MACVIR_CSVL = 0x80000;       // CSVL
    static constexpr uint32_t MACVIR_VLTI = 0x100000;      // VLTI
    static const uint32_t MACVIR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t MACIVIR_VLT =                 // VLT (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MACIVIR_VLC =                 // VLC (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    static constexpr uint32_t MACIVIR_VLP = 0x40000;        // VLP
    static constexpr uint32_t MACIVIR_CSVL = 0x80000;       // CSVL
    static constexpr uint32_t MACIVIR_VLTI = 0x100000;      // VLTI
    static const uint32_t MACIVIR_RESET_VALUE = 0x0;

    static constexpr uint32_t MACQTxFCR_FCB_BPA = 0x1;        // FCB_BPA
    static constexpr uint32_t MACQTxFCR_TFE = 0x2;            // TFE
    template<uint32_t X>
    static constexpr uint32_t MACQTxFCR_PLT =                 // PLT (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t MACQTxFCR_DZPQ = 0x80;          // DZPQ
    template<uint32_t X>
    static constexpr uint32_t MACQTxFCR_PT =                  // PT (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t MACQTxFCR_RESET_VALUE = 0x0;

    static constexpr uint32_t MACRxFCR_RFE = 0x1;            // RFE
    static constexpr uint32_t MACRxFCR_UP = 0x2;             // UP
    static const uint32_t MACRxFCR_RESET_VALUE = 0x0;

    static constexpr uint32_t MACISR_PHYIS = 0x8;          // PHYIS
    static constexpr uint32_t MACISR_PMTIS = 0x10;         // PMTIS
    static constexpr uint32_t MACISR_LPIIS = 0x20;         // LPIIS
    static constexpr uint32_t MACISR_MMCIS = 0x100;        // MMCIS
    static constexpr uint32_t MACISR_MMCRXIS = 0x200;      // MMCRXIS
    static constexpr uint32_t MACISR_MMCTXIS = 0x400;      // MMCTXIS
    static constexpr uint32_t MACISR_TSIS = 0x1000;        // TSIS
    static constexpr uint32_t MACISR_TXSTSIS = 0x2000;     // TXSTSIS
    static constexpr uint32_t MACISR_RXSTSIS = 0x4000;     // RXSTSIS
    static const uint32_t MACISR_RESET_VALUE = 0x0;

    static constexpr uint32_t MACIER_PHYIE = 0x8;          // PHYIE
    static constexpr uint32_t MACIER_PMTIE = 0x10;         // PMTIE
    static constexpr uint32_t MACIER_LPIIE = 0x20;         // LPIIE
    static constexpr uint32_t MACIER_TSIE = 0x1000;        // TSIE
    static constexpr uint32_t MACIER_TXSTSIE = 0x2000;     // TXSTSIE
    static constexpr uint32_t MACIER_RXSTSIE = 0x4000;     // RXSTSIE
    static const uint32_t MACIER_RESET_VALUE = 0x0;

    static constexpr uint32_t MACRxTxSR_TJT = 0x1;            // TJT
    static constexpr uint32_t MACRxTxSR_NCARR = 0x2;          // NCARR
    static constexpr uint32_t MACRxTxSR_LCARR = 0x4;          // LCARR
    static constexpr uint32_t MACRxTxSR_EXDEF = 0x8;          // EXDEF
    static constexpr uint32_t MACRxTxSR_LCOL = 0x10;          // LCOL
    static constexpr uint32_t MACRxTxSR_EXCOL = 0x20;         // LCOL
    static constexpr uint32_t MACRxTxSR_RWT = 0x100;          // RWT
    static const uint32_t MACRxTxSR_RESET_VALUE = 0x0;

    static constexpr uint32_t MACPCSR_PWRDWN = 0x1;         // PWRDWN, Read-write
    static constexpr uint32_t MACPCSR_MGKPKTEN = 0x2;       // MGKPKTEN, Read-write
    static constexpr uint32_t MACPCSR_RWKPKTEN = 0x4;       // RWKPKTEN, Read-write
    static constexpr uint32_t MACPCSR_MGKPRCVD = 0x20;      // MGKPRCVD, Read-only
    static constexpr uint32_t MACPCSR_RWKPRCVD = 0x40;      // RWKPRCVD, Read-only
    static constexpr uint32_t MACPCSR_GLBLUCAST = 0x200;    // GLBLUCAST, Read-write
    static constexpr uint32_t MACPCSR_RWKPFE = 0x400;       // RWKPFE, Read-write
    template<uint32_t X>
    static constexpr uint32_t MACPCSR_RWKPTR =              // RWKPTR (5 bits), Read-write
        bit_field_t<24, 0x1f>::value<X>();
    static constexpr uint32_t MACPCSR_RWKFILTRST = 0x80000000;// RWKFILTRST, Read-write
    static const uint32_t MACPCSR_RESET_VALUE = 0x0;


    static const uint32_t MACRWKPFR_RESET_VALUE = 0x0;

    static constexpr uint32_t MACLCSR_TLPIEN = 0x1;         // TLPIEN, Read-only
    static constexpr uint32_t MACLCSR_TLPIEX = 0x2;         // TLPIEX, Read-only
    static constexpr uint32_t MACLCSR_RLPIEN = 0x4;         // RLPIEN, Read-only
    static constexpr uint32_t MACLCSR_RLPIEX = 0x8;         // RLPIEX, Read-only
    static constexpr uint32_t MACLCSR_TLPIST = 0x100;       // TLPIST, Read-only
    static constexpr uint32_t MACLCSR_RLPIST = 0x200;       // RLPIST, Read-only
    static constexpr uint32_t MACLCSR_LPIEN = 0x10000;      // LPIEN, Read-write
    static constexpr uint32_t MACLCSR_PLS = 0x20000;        // PLS, Read-write
    static constexpr uint32_t MACLCSR_PLSEN = 0x40000;      // PLSEN, Read-write
    static constexpr uint32_t MACLCSR_LPITXA = 0x80000;     // LPITXA, Read-write
    static constexpr uint32_t MACLCSR_LPITE = 0x100000;     // LPITE, Read-write
    static const uint32_t MACLCSR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t MACLTCR_TWT =                 // TWT (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MACLTCR_LST =                 // LST (10 bits)
        bit_field_t<16, 0x3ff>::value<X>();
    static const uint32_t MACLTCR_RESET_VALUE = 0x3e80000;

    template<uint32_t X>
    static constexpr uint32_t MACLETR_LPIET =               // LPIET (17 bits)
        bit_field_t<0, 0x1ffff>::value<X>();
    static const uint32_t MACLETR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t MAC1USTCR_TIC_1US_CNTR =        // TIC_1US_CNTR (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t MAC1USTCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t MACVR_SNPSVER =             // SNPSVER (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MACVR_USERVER =             // USERVER (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static const uint32_t MACVR_RESET_VALUE = 0x3041;

    static constexpr uint32_t MACDR_RPESTS = 0x1;         // RPESTS
    template<uint32_t X>
    static constexpr uint32_t MACDR_RFCFCSTS =            // RFCFCSTS (2 bits)
        bit_field_t<1, 0x3>::value<X>();
    static constexpr uint32_t MACDR_TPESTS = 0x10000;     // TPESTS
    template<uint32_t X>
    static constexpr uint32_t MACDR_TFCSTS =              // TFCSTS (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    static const uint32_t MACDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t MACHWF1R_RXFIFOSIZE =          // RXFIFOSIZE (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MACHWF1R_TXFIFOSIZE =          // TXFIFOSIZE (5 bits)
        bit_field_t<6, 0x1f>::value<X>();
    static constexpr uint32_t MACHWF1R_OSTEN = 0x800;        // OSTEN
    static constexpr uint32_t MACHWF1R_PTOEN = 0x1000;       // PTOEN
    static constexpr uint32_t MACHWF1R_ADVTHWORD = 0x2000;   // ADVTHWORD
    template<uint32_t X>
    static constexpr uint32_t MACHWF1R_ADDR64 =              // ADDR64 (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t MACHWF1R_DCBEN = 0x10000;      // DCBEN
    static constexpr uint32_t MACHWF1R_SPHEN = 0x20000;      // SPHEN
    static constexpr uint32_t MACHWF1R_TSOEN = 0x40000;      // TSOEN
    static constexpr uint32_t MACHWF1R_DBGMEMA = 0x80000;    // DBGMEMA
    static constexpr uint32_t MACHWF1R_AVSEL = 0x100000;     // AVSEL
    template<uint32_t X>
    static constexpr uint32_t MACHWF1R_HASHTBLSZ =           // HASHTBLSZ (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MACHWF1R_L3L4FNUM =            // L3L4FNUM (4 bits)
        bit_field_t<27, 0xf>::value<X>();
    static const uint32_t MACHWF1R_RESET_VALUE = 0x11841904;

    template<uint32_t X>
    static constexpr uint32_t MACHWF2R_RXQCNT =              // RXQCNT (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MACHWF2R_TXQCNT =              // TXQCNT (4 bits)
        bit_field_t<6, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MACHWF2R_RXCHCNT =             // RXCHCNT (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MACHWF2R_TXCHCNT =             // TXCHCNT (4 bits)
        bit_field_t<18, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MACHWF2R_PPSOUTNUM =           // PPSOUTNUM (3 bits)
        bit_field_t<24, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MACHWF2R_AUXSNAPNUM =          // AUXSNAPNUM (3 bits)
        bit_field_t<28, 0x7>::value<X>();
    static const uint32_t MACHWF2R_RESET_VALUE = 0x41000000;

    static constexpr uint32_t MACMDIOAR_MB = 0x1;             // MB
    static constexpr uint32_t MACMDIOAR_C45E = 0x2;           // C45E
    template<uint32_t X>
    static constexpr uint32_t MACMDIOAR_GOC =                 // GOC (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t MACMDIOAR_SKAP = 0x10;          // SKAP
    template<uint32_t X>
    static constexpr uint32_t MACMDIOAR_CR =                  // CR (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MACMDIOAR_NTC =                 // NTC (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MACMDIOAR_RDA =                 // RDA (5 bits)
        bit_field_t<16, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MACMDIOAR_PA =                  // PA (5 bits)
        bit_field_t<21, 0x1f>::value<X>();
    static constexpr uint32_t MACMDIOAR_BTB = 0x4000000;      // BTB
    static constexpr uint32_t MACMDIOAR_PSE = 0x8000000;      // PSE
    static const uint32_t MACMDIOAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t MACMDIODR_MD =                  // MD (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MACMDIODR_RA =                  // RA (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t MACMDIODR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t MACA0HR_ADDRHI =              // ADDRHI (16 bits), Read-write
        bit_field_t<0, 0xffff>::value<X>();
    static constexpr uint32_t MACA0HR_AE = 0x80000000;      // AE, Read-only
    static const uint32_t MACA0HR_RESET_VALUE = 0x8000ffff;


    static const uint32_t MACA0LR_RESET_VALUE = 0xffffffff;

    template<uint32_t X>
    static constexpr uint32_t MACA1HR_ADDRHI =              // ADDRHI (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MACA1HR_MBC =                 // MBC (6 bits)
        bit_field_t<24, 0x3f>::value<X>();
    static constexpr uint32_t MACA1HR_SA = 0x40000000;      // SA
    static constexpr uint32_t MACA1HR_AE = 0x80000000;      // AE
    static const uint32_t MACA1HR_RESET_VALUE = 0xffff;


    static const uint32_t MACA1LR_RESET_VALUE = 0xffffffff;

    template<uint32_t X>
    static constexpr uint32_t MACA2HR_ADDRHI =              // ADDRHI (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MACA2HR_MBC =                 // MBC (6 bits)
        bit_field_t<24, 0x3f>::value<X>();
    static constexpr uint32_t MACA2HR_SA = 0x40000000;      // SA
    static constexpr uint32_t MACA2HR_AE = 0x80000000;      // AE
    static const uint32_t MACA2HR_RESET_VALUE = 0xffff;


    static const uint32_t MACA2LR_RESET_VALUE = 0xffffffff;

    template<uint32_t X>
    static constexpr uint32_t MACA3HR_ADDRHI =              // ADDRHI (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MACA3HR_MBC =                 // MBC (6 bits)
        bit_field_t<24, 0x3f>::value<X>();
    static constexpr uint32_t MACA3HR_SA = 0x40000000;      // SA
    static constexpr uint32_t MACA3HR_AE = 0x80000000;      // AE
    static const uint32_t MACA3HR_RESET_VALUE = 0xffff;


    static const uint32_t MACA3LR_RESET_VALUE = 0xffffffff;

    static constexpr uint32_t MMC_CONTROL_CNTRST = 0x1;         // CNTRST
    static constexpr uint32_t MMC_CONTROL_CNTSTOPRO = 0x2;      // CNTSTOPRO
    static constexpr uint32_t MMC_CONTROL_RSTONRD = 0x4;        // RSTONRD
    static constexpr uint32_t MMC_CONTROL_CNTFREEZ = 0x8;       // CNTFREEZ
    static constexpr uint32_t MMC_CONTROL_CNTPRST = 0x10;       // CNTPRST
    static constexpr uint32_t MMC_CONTROL_CNTPRSTLVL = 0x20;    // CNTPRSTLVL
    static constexpr uint32_t MMC_CONTROL_UCDBC = 0x100;        // UCDBC
    static const uint32_t MMC_CONTROL_RESET_VALUE = 0x0;

    static constexpr uint32_t MMC_RX_INTERRUPT_RXCRCERPIS = 0x20;    // RXCRCERPIS
    static constexpr uint32_t MMC_RX_INTERRUPT_RXALGNERPIS = 0x40;   // RXALGNERPIS
    static constexpr uint32_t MMC_RX_INTERRUPT_RXUCGPIS = 0x20000;   // RXUCGPIS
    static constexpr uint32_t MMC_RX_INTERRUPT_RXLPIUSCIS = 0x4000000;// RXLPIUSCIS
    static constexpr uint32_t MMC_RX_INTERRUPT_RXLPITRCIS = 0x8000000;// RXLPITRCIS
    static const uint32_t MMC_RX_INTERRUPT_RESET_VALUE = 0x0;

    static constexpr uint32_t MMC_TX_INTERRUPT_TXSCOLGPIS = 0x4000;  // TXSCOLGPIS
    static constexpr uint32_t MMC_TX_INTERRUPT_TXMCOLGPIS = 0x8000;  // TXMCOLGPIS
    static constexpr uint32_t MMC_TX_INTERRUPT_TXGPKTIS = 0x200000;  // TXGPKTIS
    static constexpr uint32_t MMC_TX_INTERRUPT_TXLPIUSCIS = 0x4000000;// TXLPIUSCIS
    static constexpr uint32_t MMC_TX_INTERRUPT_TXLPITRCIS = 0x8000000;// TXLPITRCIS
    static const uint32_t MMC_TX_INTERRUPT_RESET_VALUE = 0x0;

    static constexpr uint32_t MMC_RX_INTERRUPT_MASK_RXCRCERPIM = 0x20;    // RXCRCERPIM, Read-write
    static constexpr uint32_t MMC_RX_INTERRUPT_MASK_RXALGNERPIM = 0x40;   // RXALGNERPIM, Read-write
    static constexpr uint32_t MMC_RX_INTERRUPT_MASK_RXUCGPIM = 0x20000;   // RXUCGPIM, Read-write
    static constexpr uint32_t MMC_RX_INTERRUPT_MASK_RXLPIUSCIM = 0x4000000;// RXLPIUSCIM, Read-write
    static constexpr uint32_t MMC_RX_INTERRUPT_MASK_RXLPITRCIM = 0x8000000;// RXLPITRCIM, Read-only
    static const uint32_t MMC_RX_INTERRUPT_MASK_RESET_VALUE = 0x0;

    static constexpr uint32_t MMC_TX_INTERRUPT_MASK_TXSCOLGPIM = 0x4000;  // TXSCOLGPIM, Read-write
    static constexpr uint32_t MMC_TX_INTERRUPT_MASK_TXMCOLGPIM = 0x8000;  // TXMCOLGPIM, Read-write
    static constexpr uint32_t MMC_TX_INTERRUPT_MASK_TXGPKTIM = 0x200000;  // TXGPKTIM, Read-write
    static constexpr uint32_t MMC_TX_INTERRUPT_MASK_TXLPIUSCIM = 0x4000000;// TXLPIUSCIM, Read-write
    static constexpr uint32_t MMC_TX_INTERRUPT_MASK_TXLPITRCIM = 0x8000000;// TXLPITRCIM, Read-only
    static const uint32_t MMC_TX_INTERRUPT_MASK_RESET_VALUE = 0x0;


    static const uint32_t TX_SINGLE_COLLISION_GOOD_PACKETS_RESET_VALUE = 0x0;


    static const uint32_t TX_MULTIPLE_COLLISION_GOOD_PACKETS_RESET_VALUE = 0x0;


    static const uint32_t TX_PACKET_COUNT_GOOD_RESET_VALUE = 0x0;


    static const uint32_t RX_CRC_ERROR_PACKETS_RESET_VALUE = 0x0;


    static const uint32_t RX_ALIGNMENT_ERROR_PACKETS_RESET_VALUE = 0x0;


    static const uint32_t RX_UNICAST_PACKETS_GOOD_RESET_VALUE = 0x0;


    static const uint32_t TX_LPI_USEC_CNTR_RESET_VALUE = 0x0;


    static const uint32_t TX_LPI_TRAN_CNTR_RESET_VALUE = 0x0;


    static const uint32_t RX_LPI_USEC_CNTR_RESET_VALUE = 0x0;


    static const uint32_t RX_LPI_TRAN_CNTR_RESET_VALUE = 0x0;

    static constexpr uint32_t MACL3L4C0R_L3PEN0 = 0x1;         // L3PEN0
    static constexpr uint32_t MACL3L4C0R_L3SAM0 = 0x4;         // L3SAM0
    static constexpr uint32_t MACL3L4C0R_L3SAIM0 = 0x8;        // L3SAIM0
    static constexpr uint32_t MACL3L4C0R_L3DAM0 = 0x10;        // L3DAM0
    static constexpr uint32_t MACL3L4C0R_L3DAIM0 = 0x20;       // L3DAIM0
    template<uint32_t X>
    static constexpr uint32_t MACL3L4C0R_L3HSBM0 =             // L3HSBM0 (5 bits)
        bit_field_t<6, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MACL3L4C0R_L3HDBM0 =             // L3HDBM0 (5 bits)
        bit_field_t<11, 0x1f>::value<X>();
    static constexpr uint32_t MACL3L4C0R_L4PEN0 = 0x10000;     // L4PEN0
    static constexpr uint32_t MACL3L4C0R_L4SPM0 = 0x40000;     // L4SPM0
    static constexpr uint32_t MACL3L4C0R_L4SPIM0 = 0x80000;    // L4SPIM0
    static constexpr uint32_t MACL3L4C0R_L4DPM0 = 0x100000;    // L4DPM0
    static constexpr uint32_t MACL3L4C0R_L4DPIM0 = 0x200000;   // L4DPIM0
    static const uint32_t MACL3L4C0R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t MACL4A0R_L4SP0 =               // L4SP0 (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MACL4A0R_L4DP0 =               // L4DP0 (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t MACL4A0R_RESET_VALUE = 0x0;


    static const uint32_t MACL3A00R_RESET_VALUE = 0x0;


    static const uint32_t MACL3A10R_RESET_VALUE = 0x0;


    static const uint32_t MACL3A20_RESET_VALUE = 0x0;


    static const uint32_t MACL3A30_RESET_VALUE = 0x0;

    static constexpr uint32_t MACL3L4C1R_L3PEN1 = 0x1;         // L3PEN1
    static constexpr uint32_t MACL3L4C1R_L3SAM1 = 0x4;         // L3SAM1
    static constexpr uint32_t MACL3L4C1R_L3SAIM1 = 0x8;        // L3SAIM1
    static constexpr uint32_t MACL3L4C1R_L3DAM1 = 0x10;        // L3DAM1
    static constexpr uint32_t MACL3L4C1R_L3DAIM1 = 0x20;       // L3DAIM1
    template<uint32_t X>
    static constexpr uint32_t MACL3L4C1R_L3HSBM1 =             // L3HSBM1 (5 bits)
        bit_field_t<6, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MACL3L4C1R_L3HDBM1 =             // L3HDBM1 (5 bits)
        bit_field_t<11, 0x1f>::value<X>();
    static constexpr uint32_t MACL3L4C1R_L4PEN1 = 0x10000;     // L4PEN1
    static constexpr uint32_t MACL3L4C1R_L4SPM1 = 0x40000;     // L4SPM1
    static constexpr uint32_t MACL3L4C1R_L4SPIM1 = 0x80000;    // L4SPIM1
    static constexpr uint32_t MACL3L4C1R_L4DPM1 = 0x100000;    // L4DPM1
    static constexpr uint32_t MACL3L4C1R_L4DPIM1 = 0x200000;   // L4DPIM1
    static const uint32_t MACL3L4C1R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t MACL4A1R_L4SP1 =               // L4SP1 (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MACL4A1R_L4DP1 =               // L4DP1 (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t MACL4A1R_RESET_VALUE = 0x0;


    static const uint32_t MACL3A01R_RESET_VALUE = 0x0;


    static const uint32_t MACL3A11R_RESET_VALUE = 0x0;


    static const uint32_t MACL3A21R_RESET_VALUE = 0x0;


    static const uint32_t MACL3A31R_RESET_VALUE = 0x0;


    static const uint32_t MACARPAR_RESET_VALUE = 0x0;

    static constexpr uint32_t MACTSCR_TSENA = 0x1;          // TSENA, Read-write
    static constexpr uint32_t MACTSCR_TSCFUPDT = 0x2;       // TSCFUPDT, Read-write
    static constexpr uint32_t MACTSCR_TSINIT = 0x4;         // TSINIT, Read-write
    static constexpr uint32_t MACTSCR_TSUPDT = 0x8;         // TSUPDT, Read-write
    static constexpr uint32_t MACTSCR_TSADDREG = 0x20;      // TSADDREG, Read-write
    static constexpr uint32_t MACTSCR_TSENALL = 0x100;      // TSENALL, Read-write
    static constexpr uint32_t MACTSCR_TSCTRLSSR = 0x200;    // TSCTRLSSR, Read-write
    static constexpr uint32_t MACTSCR_TSVER2ENA = 0x400;    // TSVER2ENA, Read-write
    static constexpr uint32_t MACTSCR_TSIPENA = 0x800;      // TSIPENA, Read-write
    static constexpr uint32_t MACTSCR_TSIPV6ENA = 0x1000;   // TSIPV6ENA, Read-write
    static constexpr uint32_t MACTSCR_TSIPV4ENA = 0x2000;   // TSIPV4ENA, Read-write
    static constexpr uint32_t MACTSCR_TSEVNTENA = 0x4000;   // TSEVNTENA, Read-write
    static constexpr uint32_t MACTSCR_TSMSTRENA = 0x8000;   // TSMSTRENA, Read-write
    template<uint32_t X>
    static constexpr uint32_t MACTSCR_SNAPTYPSEL =          // SNAPTYPSEL (2 bits), Read-write
        bit_field_t<16, 0x3>::value<X>();
    static constexpr uint32_t MACTSCR_TSENMACADDR = 0x40000;// TSENMACADDR, Read-write
    static constexpr uint32_t MACTSCR_CSC = 0x80000;        // CSC, Read-only
    static constexpr uint32_t MACTSCR_TXTSSTSM = 0x1000000; // TXTSSTSM, Read-write
    static const uint32_t MACTSCR_RESET_VALUE = 0x200;

    template<uint32_t X>
    static constexpr uint32_t MACSSIR_SNSINC =              // SNSINC (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MACSSIR_SSINC =               // SSINC (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static const uint32_t MACSSIR_RESET_VALUE = 0x0;


    static const uint32_t MACSTSR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t MACSTNR_TSSS =                // TSSS (31 bits)
        bit_field_t<0, 0x7fffffff>::value<X>();
    static const uint32_t MACSTNR_RESET_VALUE = 0x0;


    static const uint32_t MACSTSUR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t MACSTNUR_TSSS =                // TSSS (31 bits)
        bit_field_t<0, 0x7fffffff>::value<X>();
    static constexpr uint32_t MACSTNUR_ADDSUB = 0x80000000;  // ADDSUB
    static const uint32_t MACSTNUR_RESET_VALUE = 0x0;


    static const uint32_t MACTSAR_RESET_VALUE = 0x0;

    static constexpr uint32_t MACTSSR_TSSOVF = 0x1;         // TSSOVF
    static constexpr uint32_t MACTSSR_TSTARGT0 = 0x2;       // TSTARGT0
    static constexpr uint32_t MACTSSR_AUXTSTRIG = 0x4;      // AUXTSTRIG
    static constexpr uint32_t MACTSSR_TSTRGTERR0 = 0x8;     // TSTRGTERR0
    static constexpr uint32_t MACTSSR_TXTSSIS = 0x8000;     // TXTSSIS
    template<uint32_t X>
    static constexpr uint32_t MACTSSR_ATSSTN =              // ATSSTN (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    static constexpr uint32_t MACTSSR_ATSSTM = 0x1000000;   // ATSSTM
    template<uint32_t X>
    static constexpr uint32_t MACTSSR_ATSNS =               // ATSNS (5 bits)
        bit_field_t<25, 0x1f>::value<X>();
    static const uint32_t MACTSSR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t MACTxTSSNR_TXTSSLO =             // TXTSSLO (31 bits)
        bit_field_t<0, 0x7fffffff>::value<X>();
    static constexpr uint32_t MACTxTSSNR_TXTSSMIS = 0x80000000;// TXTSSMIS
    static const uint32_t MACTxTSSNR_RESET_VALUE = 0x0;


    static const uint32_t MACTxTSSSR_RESET_VALUE = 0x0;

    static constexpr uint32_t MACACR_ATSFC = 0x1;          // ATSFC
    static constexpr uint32_t MACACR_ATSEN0 = 0x10;        // ATSEN0
    static constexpr uint32_t MACACR_ATSEN1 = 0x20;        // ATSEN1
    static constexpr uint32_t MACACR_ATSEN2 = 0x40;        // ATSEN2
    static constexpr uint32_t MACACR_ATSEN3 = 0x80;        // ATSEN3
    static const uint32_t MACACR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t MACATSNR_AUXTSLO =             // AUXTSLO (31 bits)
        bit_field_t<0, 0x7fffffff>::value<X>();
    static const uint32_t MACATSNR_RESET_VALUE = 0x0;


    static const uint32_t MACATSSR_RESET_VALUE = 0x0;


    static const uint32_t MACTSIACR_RESET_VALUE = 0x0;


    static const uint32_t MACTSEACR_RESET_VALUE = 0x0;


    static const uint32_t MACTSICNR_RESET_VALUE = 0x0;


    static const uint32_t MACTSECNR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t MACPPSCR_PPSCTRL =             // PPSCTRL (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static constexpr uint32_t MACPPSCR_PPSEN0 = 0x10;        // PPSEN0
    template<uint32_t X>
    static constexpr uint32_t MACPPSCR_TRGTMODSEL0 =         // TRGTMODSEL0 (2 bits)
        bit_field_t<5, 0x3>::value<X>();
    static const uint32_t MACPPSCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t MACPPSTTSR_TSTRH0 =              // TSTRH0 (31 bits)
        bit_field_t<0, 0x7fffffff>::value<X>();
    static const uint32_t MACPPSTTSR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t MACPPSTTNR_TTSL0 =               // TTSL0 (31 bits)
        bit_field_t<0, 0x7fffffff>::value<X>();
    static constexpr uint32_t MACPPSTTNR_TRGTBUSY0 = 0x80000000;// TRGTBUSY0
    static const uint32_t MACPPSTTNR_RESET_VALUE = 0x0;


    static const uint32_t MACPPSIR_RESET_VALUE = 0x0;


    static const uint32_t MACPPSWR_RESET_VALUE = 0x0;

    static constexpr uint32_t MACPOCR_PTOEN = 0x1;          // PTOEN
    static constexpr uint32_t MACPOCR_ASYNCEN = 0x2;        // ASYNCEN
    static constexpr uint32_t MACPOCR_APDREQEN = 0x4;       // APDREQEN
    static constexpr uint32_t MACPOCR_ASYNCTRIG = 0x10;     // ASYNCTRIG
    static constexpr uint32_t MACPOCR_APDREQTRIG = 0x20;    // APDREQTRIG
    static constexpr uint32_t MACPOCR_DRRDIS = 0x40;        // DRRDIS
    template<uint32_t X>
    static constexpr uint32_t MACPOCR_DN =                  // DN (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static const uint32_t MACPOCR_RESET_VALUE = 0x0;


    static const uint32_t MACSPI0R_RESET_VALUE = 0x0;


    static const uint32_t MACSPI1R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t MACSPI2R_SPI2 =                // SPI2 (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t MACSPI2R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t MACLMIR_LSI =                 // LSI (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MACLMIR_DRSYNCR =             // DRSYNCR (3 bits)
        bit_field_t<8, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MACLMIR_LMPDRI =              // LMPDRI (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t MACLMIR_RESET_VALUE = 0x0;

    static constexpr uint8_t ETH = 61; // Ethernet global interrupt
};

static ethernet_mac_t& ETHERNET_MAC = *reinterpret_cast<ethernet_mac_t*>(0x40028000);

#define HAVE_PERIPHERAL_ETHERNET_MAC


////
//
//    DMA controller
//
////

struct dma1_t
{
    volatile uint32_t    LISR;                 // [Read-only] low interrupt status register
    volatile uint32_t    HISR;                 // [Read-only] high interrupt status register
    volatile uint32_t    LIFCR;                // [Read-write] low interrupt flag clear register
    volatile uint32_t    HIFCR;                // [Read-write] high interrupt flag clear register
    volatile uint32_t    S0CR;                 // [Read-write] stream x configuration register
    volatile uint32_t    S0NDTR;               // [Read-write] stream x number of data register
    volatile uint32_t    S0PAR;                // [Read-write] stream x peripheral address register
    volatile uint32_t    S0M0AR;               // [Read-write] stream x memory 0 address register
    volatile uint32_t    S0M1AR;               // [Read-write] stream x memory 1 address register
    volatile uint32_t    S0FCR;                // stream x FIFO control register
    volatile uint32_t    S1CR;                 // [Read-write] stream x configuration register
    volatile uint32_t    S1NDTR;               // [Read-write] stream x number of data register
    volatile uint32_t    S1PAR;                // [Read-write] stream x peripheral address register
    volatile uint32_t    S1M0AR;               // [Read-write] stream x memory 0 address register
    volatile uint32_t    S1M1AR;               // [Read-write] stream x memory 1 address register
    volatile uint32_t    S1FCR;                // stream x FIFO control register
    volatile uint32_t    S2CR;                 // [Read-write] stream x configuration register
    volatile uint32_t    S2NDTR;               // [Read-write] stream x number of data register
    volatile uint32_t    S2PAR;                // [Read-write] stream x peripheral address register
    volatile uint32_t    S2M0AR;               // [Read-write] stream x memory 0 address register
    volatile uint32_t    S2M1AR;               // [Read-write] stream x memory 1 address register
    volatile uint32_t    S2FCR;                // stream x FIFO control register
    volatile uint32_t    S3CR;                 // [Read-write] stream x configuration register
    volatile uint32_t    S3NDTR;               // [Read-write] stream x number of data register
    volatile uint32_t    S3PAR;                // [Read-write] stream x peripheral address register
    volatile uint32_t    S3M0AR;               // [Read-write] stream x memory 0 address register
    volatile uint32_t    S3M1AR;               // [Read-write] stream x memory 1 address register
    volatile uint32_t    S3FCR;                // stream x FIFO control register
    volatile uint32_t    S4CR;                 // [Read-write] stream x configuration register
    volatile uint32_t    S4NDTR;               // [Read-write] stream x number of data register
    volatile uint32_t    S4PAR;                // [Read-write] stream x peripheral address register
    volatile uint32_t    S4M0AR;               // [Read-write] stream x memory 0 address register
    volatile uint32_t    S4M1AR;               // [Read-write] stream x memory 1 address register
    volatile uint32_t    S4FCR;                // stream x FIFO control register
    volatile uint32_t    S5CR;                 // [Read-write] stream x configuration register
    volatile uint32_t    S5NDTR;               // [Read-write] stream x number of data register
    volatile uint32_t    S5PAR;                // [Read-write] stream x peripheral address register
    volatile uint32_t    S5M0AR;               // [Read-write] stream x memory 0 address register
    volatile uint32_t    S5M1AR;               // [Read-write] stream x memory 1 address register
    volatile uint32_t    S5FCR;                // stream x FIFO control register
    volatile uint32_t    S6CR;                 // [Read-write] stream x configuration register
    volatile uint32_t    S6NDTR;               // [Read-write] stream x number of data register
    volatile uint32_t    S6PAR;                // [Read-write] stream x peripheral address register
    volatile uint32_t    S6M0AR;               // [Read-write] stream x memory 0 address register
    volatile uint32_t    S6M1AR;               // [Read-write] stream x memory 1 address register
    volatile uint32_t    S6FCR;                // stream x FIFO control register
    volatile uint32_t    S7CR;                 // [Read-write] stream x configuration register
    volatile uint32_t    S7NDTR;               // [Read-write] stream x number of data register
    volatile uint32_t    S7PAR;                // [Read-write] stream x peripheral address register
    volatile uint32_t    S7M0AR;               // [Read-write] stream x memory 0 address register
    volatile uint32_t    S7M1AR;               // [Read-write] stream x memory 1 address register
    volatile uint32_t    S7FCR;                // stream x FIFO control register

    static constexpr uint32_t LISR_TCIF3 = 0x8000000;    // Stream x transfer complete interrupt flag (x = 3..0)
    static constexpr uint32_t LISR_HTIF3 = 0x4000000;    // Stream x half transfer interrupt flag (x=3..0)
    static constexpr uint32_t LISR_TEIF3 = 0x2000000;    // Stream x transfer error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_DMEIF3 = 0x1000000;   // Stream x direct mode error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_FEIF3 = 0x400000;     // Stream x FIFO error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_TCIF2 = 0x200000;     // Stream x transfer complete interrupt flag (x = 3..0)
    static constexpr uint32_t LISR_HTIF2 = 0x100000;     // Stream x half transfer interrupt flag (x=3..0)
    static constexpr uint32_t LISR_TEIF2 = 0x80000;      // Stream x transfer error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_DMEIF2 = 0x40000;     // Stream x direct mode error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_FEIF2 = 0x10000;      // Stream x FIFO error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_TCIF1 = 0x800;        // Stream x transfer complete interrupt flag (x = 3..0)
    static constexpr uint32_t LISR_HTIF1 = 0x400;        // Stream x half transfer interrupt flag (x=3..0)
    static constexpr uint32_t LISR_TEIF1 = 0x200;        // Stream x transfer error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_DMEIF1 = 0x100;       // Stream x direct mode error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_FEIF1 = 0x40;         // Stream x FIFO error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_TCIF0 = 0x20;         // Stream x transfer complete interrupt flag (x = 3..0)
    static constexpr uint32_t LISR_HTIF0 = 0x10;         // Stream x half transfer interrupt flag (x=3..0)
    static constexpr uint32_t LISR_TEIF0 = 0x8;          // Stream x transfer error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_DMEIF0 = 0x4;         // Stream x direct mode error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_FEIF0 = 0x1;          // Stream x FIFO error interrupt flag (x=3..0)
    static const uint32_t LISR_RESET_VALUE = 0x0;

    static constexpr uint32_t HISR_TCIF7 = 0x8000000;    // Stream x transfer complete interrupt flag (x=7..4)
    static constexpr uint32_t HISR_HTIF7 = 0x4000000;    // Stream x half transfer interrupt flag (x=7..4)
    static constexpr uint32_t HISR_TEIF7 = 0x2000000;    // Stream x transfer error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_DMEIF7 = 0x1000000;   // Stream x direct mode error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_FEIF7 = 0x400000;     // Stream x FIFO error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_TCIF6 = 0x200000;     // Stream x transfer complete interrupt flag (x=7..4)
    static constexpr uint32_t HISR_HTIF6 = 0x100000;     // Stream x half transfer interrupt flag (x=7..4)
    static constexpr uint32_t HISR_TEIF6 = 0x80000;      // Stream x transfer error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_DMEIF6 = 0x40000;     // Stream x direct mode error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_FEIF6 = 0x10000;      // Stream x FIFO error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_TCIF5 = 0x800;        // Stream x transfer complete interrupt flag (x=7..4)
    static constexpr uint32_t HISR_HTIF5 = 0x400;        // Stream x half transfer interrupt flag (x=7..4)
    static constexpr uint32_t HISR_TEIF5 = 0x200;        // Stream x transfer error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_DMEIF5 = 0x100;       // Stream x direct mode error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_FEIF5 = 0x40;         // Stream x FIFO error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_TCIF4 = 0x20;         // Stream x transfer complete interrupt flag (x=7..4)
    static constexpr uint32_t HISR_HTIF4 = 0x10;         // Stream x half transfer interrupt flag (x=7..4)
    static constexpr uint32_t HISR_TEIF4 = 0x8;          // Stream x transfer error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_DMEIF4 = 0x4;         // Stream x direct mode error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_FEIF4 = 0x1;          // Stream x FIFO error interrupt flag (x=7..4)
    static const uint32_t HISR_RESET_VALUE = 0x0;

    static constexpr uint32_t LIFCR_CTCIF3 = 0x8000000;   // Stream x clear transfer complete interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CHTIF3 = 0x4000000;   // Stream x clear half transfer interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CTEIF3 = 0x2000000;   // Stream x clear transfer error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CDMEIF3 = 0x1000000;  // Stream x clear direct mode error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CFEIF3 = 0x400000;    // Stream x clear FIFO error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CTCIF2 = 0x200000;    // Stream x clear transfer complete interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CHTIF2 = 0x100000;    // Stream x clear half transfer interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CTEIF2 = 0x80000;     // Stream x clear transfer error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CDMEIF2 = 0x40000;    // Stream x clear direct mode error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CFEIF2 = 0x10000;     // Stream x clear FIFO error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CTCIF1 = 0x800;       // Stream x clear transfer complete interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CHTIF1 = 0x400;       // Stream x clear half transfer interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CTEIF1 = 0x200;       // Stream x clear transfer error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CDMEIF1 = 0x100;      // Stream x clear direct mode error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CFEIF1 = 0x40;        // Stream x clear FIFO error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CTCIF0 = 0x20;        // Stream x clear transfer complete interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CHTIF0 = 0x10;        // Stream x clear half transfer interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CTEIF0 = 0x8;         // Stream x clear transfer error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CDMEIF0 = 0x4;        // Stream x clear direct mode error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CFEIF0 = 0x1;         // Stream x clear FIFO error interrupt flag (x = 3..0)
    static const uint32_t LIFCR_RESET_VALUE = 0x0;

    static constexpr uint32_t HIFCR_CTCIF7 = 0x8000000;   // Stream x clear transfer complete interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CHTIF7 = 0x4000000;   // Stream x clear half transfer interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CTEIF7 = 0x2000000;   // Stream x clear transfer error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CDMEIF7 = 0x1000000;  // Stream x clear direct mode error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CFEIF7 = 0x400000;    // Stream x clear FIFO error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CTCIF6 = 0x200000;    // Stream x clear transfer complete interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CHTIF6 = 0x100000;    // Stream x clear half transfer interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CTEIF6 = 0x80000;     // Stream x clear transfer error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CDMEIF6 = 0x40000;    // Stream x clear direct mode error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CFEIF6 = 0x10000;     // Stream x clear FIFO error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CTCIF5 = 0x800;       // Stream x clear transfer complete interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CHTIF5 = 0x400;       // Stream x clear half transfer interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CTEIF5 = 0x200;       // Stream x clear transfer error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CDMEIF5 = 0x100;      // Stream x clear direct mode error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CFEIF5 = 0x40;        // Stream x clear FIFO error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CTCIF4 = 0x20;        // Stream x clear transfer complete interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CHTIF4 = 0x10;        // Stream x clear half transfer interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CTEIF4 = 0x8;         // Stream x clear transfer error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CDMEIF4 = 0x4;        // Stream x clear direct mode error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CFEIF4 = 0x1;         // Stream x clear FIFO error interrupt flag (x = 7..4)
    static const uint32_t HIFCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t S0CR_MBURST =              // Memory burst transfer configuration (2 bits)
        bit_field_t<23, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S0CR_PBURST =              // Peripheral burst transfer configuration (2 bits)
        bit_field_t<21, 0x3>::value<X>();
    static constexpr uint32_t S0CR_CT = 0x80000;         // Current target (only in double buffer mode)
    static constexpr uint32_t S0CR_DBM = 0x40000;        // Double buffer mode
    template<uint32_t X>
    static constexpr uint32_t S0CR_PL =                  // Priority level (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    static constexpr uint32_t S0CR_PINCOS = 0x8000;      // Peripheral increment offset size
    template<uint32_t X>
    static constexpr uint32_t S0CR_MSIZE =               // Memory data size (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S0CR_PSIZE =               // Peripheral data size (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    static constexpr uint32_t S0CR_MINC = 0x400;         // Memory increment mode
    static constexpr uint32_t S0CR_PINC = 0x200;         // Peripheral increment mode
    static constexpr uint32_t S0CR_CIRC = 0x100;         // Circular mode
    template<uint32_t X>
    static constexpr uint32_t S0CR_DIR =                 // Data transfer direction (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t S0CR_PFCTRL = 0x20;        // Peripheral flow controller
    static constexpr uint32_t S0CR_TCIE = 0x10;          // Transfer complete interrupt enable
    static constexpr uint32_t S0CR_HTIE = 0x8;           // Half transfer interrupt enable
    static constexpr uint32_t S0CR_TEIE = 0x4;           // Transfer error interrupt enable
    static constexpr uint32_t S0CR_DMEIE = 0x2;          // Direct mode error interrupt enable
    static constexpr uint32_t S0CR_EN = 0x1;             // Stream enable / flag stream ready when read low
    static const uint32_t S0CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t S0NDTR_NDT =                 // Number of data items to transfer (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t S0NDTR_RESET_VALUE = 0x0;


    static const uint32_t S0PAR_RESET_VALUE = 0x0;


    static const uint32_t S0M0AR_RESET_VALUE = 0x0;


    static const uint32_t S0M1AR_RESET_VALUE = 0x0;

    static constexpr uint32_t S0FCR_FEIE = 0x80;          // FIFO error interrupt enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S0FCR_FS =                  // FIFO status (3 bits), Read-only
        bit_field_t<3, 0x7>::value<X>();
    static constexpr uint32_t S0FCR_DMDIS = 0x4;          // Direct mode disable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S0FCR_FTH =                 // FIFO threshold selection (2 bits), Read-write
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t S0FCR_RESET_VALUE = 0x21;

    template<uint32_t X>
    static constexpr uint32_t S1CR_MBURST =              // Memory burst transfer configuration (2 bits)
        bit_field_t<23, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S1CR_PBURST =              // Peripheral burst transfer configuration (2 bits)
        bit_field_t<21, 0x3>::value<X>();
    static constexpr uint32_t S1CR_ACK = 0x100000;       // ACK
    static constexpr uint32_t S1CR_CT = 0x80000;         // Current target (only in double buffer mode)
    static constexpr uint32_t S1CR_DBM = 0x40000;        // Double buffer mode
    template<uint32_t X>
    static constexpr uint32_t S1CR_PL =                  // Priority level (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    static constexpr uint32_t S1CR_PINCOS = 0x8000;      // Peripheral increment offset size
    template<uint32_t X>
    static constexpr uint32_t S1CR_MSIZE =               // Memory data size (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S1CR_PSIZE =               // Peripheral data size (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    static constexpr uint32_t S1CR_MINC = 0x400;         // Memory increment mode
    static constexpr uint32_t S1CR_PINC = 0x200;         // Peripheral increment mode
    static constexpr uint32_t S1CR_CIRC = 0x100;         // Circular mode
    template<uint32_t X>
    static constexpr uint32_t S1CR_DIR =                 // Data transfer direction (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t S1CR_PFCTRL = 0x20;        // Peripheral flow controller
    static constexpr uint32_t S1CR_TCIE = 0x10;          // Transfer complete interrupt enable
    static constexpr uint32_t S1CR_HTIE = 0x8;           // Half transfer interrupt enable
    static constexpr uint32_t S1CR_TEIE = 0x4;           // Transfer error interrupt enable
    static constexpr uint32_t S1CR_DMEIE = 0x2;          // Direct mode error interrupt enable
    static constexpr uint32_t S1CR_EN = 0x1;             // Stream enable / flag stream ready when read low
    static const uint32_t S1CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t S1NDTR_NDT =                 // Number of data items to transfer (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t S1NDTR_RESET_VALUE = 0x0;


    static const uint32_t S1PAR_RESET_VALUE = 0x0;


    static const uint32_t S1M0AR_RESET_VALUE = 0x0;


    static const uint32_t S1M1AR_RESET_VALUE = 0x0;

    static constexpr uint32_t S1FCR_FEIE = 0x80;          // FIFO error interrupt enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S1FCR_FS =                  // FIFO status (3 bits), Read-only
        bit_field_t<3, 0x7>::value<X>();
    static constexpr uint32_t S1FCR_DMDIS = 0x4;          // Direct mode disable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S1FCR_FTH =                 // FIFO threshold selection (2 bits), Read-write
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t S1FCR_RESET_VALUE = 0x21;

    template<uint32_t X>
    static constexpr uint32_t S2CR_MBURST =              // Memory burst transfer configuration (2 bits)
        bit_field_t<23, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S2CR_PBURST =              // Peripheral burst transfer configuration (2 bits)
        bit_field_t<21, 0x3>::value<X>();
    static constexpr uint32_t S2CR_ACK = 0x100000;       // ACK
    static constexpr uint32_t S2CR_CT = 0x80000;         // Current target (only in double buffer mode)
    static constexpr uint32_t S2CR_DBM = 0x40000;        // Double buffer mode
    template<uint32_t X>
    static constexpr uint32_t S2CR_PL =                  // Priority level (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    static constexpr uint32_t S2CR_PINCOS = 0x8000;      // Peripheral increment offset size
    template<uint32_t X>
    static constexpr uint32_t S2CR_MSIZE =               // Memory data size (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S2CR_PSIZE =               // Peripheral data size (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    static constexpr uint32_t S2CR_MINC = 0x400;         // Memory increment mode
    static constexpr uint32_t S2CR_PINC = 0x200;         // Peripheral increment mode
    static constexpr uint32_t S2CR_CIRC = 0x100;         // Circular mode
    template<uint32_t X>
    static constexpr uint32_t S2CR_DIR =                 // Data transfer direction (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t S2CR_PFCTRL = 0x20;        // Peripheral flow controller
    static constexpr uint32_t S2CR_TCIE = 0x10;          // Transfer complete interrupt enable
    static constexpr uint32_t S2CR_HTIE = 0x8;           // Half transfer interrupt enable
    static constexpr uint32_t S2CR_TEIE = 0x4;           // Transfer error interrupt enable
    static constexpr uint32_t S2CR_DMEIE = 0x2;          // Direct mode error interrupt enable
    static constexpr uint32_t S2CR_EN = 0x1;             // Stream enable / flag stream ready when read low
    static const uint32_t S2CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t S2NDTR_NDT =                 // Number of data items to transfer (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t S2NDTR_RESET_VALUE = 0x0;


    static const uint32_t S2PAR_RESET_VALUE = 0x0;


    static const uint32_t S2M0AR_RESET_VALUE = 0x0;


    static const uint32_t S2M1AR_RESET_VALUE = 0x0;

    static constexpr uint32_t S2FCR_FEIE = 0x80;          // FIFO error interrupt enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S2FCR_FS =                  // FIFO status (3 bits), Read-only
        bit_field_t<3, 0x7>::value<X>();
    static constexpr uint32_t S2FCR_DMDIS = 0x4;          // Direct mode disable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S2FCR_FTH =                 // FIFO threshold selection (2 bits), Read-write
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t S2FCR_RESET_VALUE = 0x21;

    template<uint32_t X>
    static constexpr uint32_t S3CR_MBURST =              // Memory burst transfer configuration (2 bits)
        bit_field_t<23, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S3CR_PBURST =              // Peripheral burst transfer configuration (2 bits)
        bit_field_t<21, 0x3>::value<X>();
    static constexpr uint32_t S3CR_ACK = 0x100000;       // ACK
    static constexpr uint32_t S3CR_CT = 0x80000;         // Current target (only in double buffer mode)
    static constexpr uint32_t S3CR_DBM = 0x40000;        // Double buffer mode
    template<uint32_t X>
    static constexpr uint32_t S3CR_PL =                  // Priority level (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    static constexpr uint32_t S3CR_PINCOS = 0x8000;      // Peripheral increment offset size
    template<uint32_t X>
    static constexpr uint32_t S3CR_MSIZE =               // Memory data size (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S3CR_PSIZE =               // Peripheral data size (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    static constexpr uint32_t S3CR_MINC = 0x400;         // Memory increment mode
    static constexpr uint32_t S3CR_PINC = 0x200;         // Peripheral increment mode
    static constexpr uint32_t S3CR_CIRC = 0x100;         // Circular mode
    template<uint32_t X>
    static constexpr uint32_t S3CR_DIR =                 // Data transfer direction (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t S3CR_PFCTRL = 0x20;        // Peripheral flow controller
    static constexpr uint32_t S3CR_TCIE = 0x10;          // Transfer complete interrupt enable
    static constexpr uint32_t S3CR_HTIE = 0x8;           // Half transfer interrupt enable
    static constexpr uint32_t S3CR_TEIE = 0x4;           // Transfer error interrupt enable
    static constexpr uint32_t S3CR_DMEIE = 0x2;          // Direct mode error interrupt enable
    static constexpr uint32_t S3CR_EN = 0x1;             // Stream enable / flag stream ready when read low
    static const uint32_t S3CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t S3NDTR_NDT =                 // Number of data items to transfer (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t S3NDTR_RESET_VALUE = 0x0;


    static const uint32_t S3PAR_RESET_VALUE = 0x0;


    static const uint32_t S3M0AR_RESET_VALUE = 0x0;


    static const uint32_t S3M1AR_RESET_VALUE = 0x0;

    static constexpr uint32_t S3FCR_FEIE = 0x80;          // FIFO error interrupt enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S3FCR_FS =                  // FIFO status (3 bits), Read-only
        bit_field_t<3, 0x7>::value<X>();
    static constexpr uint32_t S3FCR_DMDIS = 0x4;          // Direct mode disable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S3FCR_FTH =                 // FIFO threshold selection (2 bits), Read-write
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t S3FCR_RESET_VALUE = 0x21;

    template<uint32_t X>
    static constexpr uint32_t S4CR_MBURST =              // Memory burst transfer configuration (2 bits)
        bit_field_t<23, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S4CR_PBURST =              // Peripheral burst transfer configuration (2 bits)
        bit_field_t<21, 0x3>::value<X>();
    static constexpr uint32_t S4CR_ACK = 0x100000;       // ACK
    static constexpr uint32_t S4CR_CT = 0x80000;         // Current target (only in double buffer mode)
    static constexpr uint32_t S4CR_DBM = 0x40000;        // Double buffer mode
    template<uint32_t X>
    static constexpr uint32_t S4CR_PL =                  // Priority level (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    static constexpr uint32_t S4CR_PINCOS = 0x8000;      // Peripheral increment offset size
    template<uint32_t X>
    static constexpr uint32_t S4CR_MSIZE =               // Memory data size (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S4CR_PSIZE =               // Peripheral data size (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    static constexpr uint32_t S4CR_MINC = 0x400;         // Memory increment mode
    static constexpr uint32_t S4CR_PINC = 0x200;         // Peripheral increment mode
    static constexpr uint32_t S4CR_CIRC = 0x100;         // Circular mode
    template<uint32_t X>
    static constexpr uint32_t S4CR_DIR =                 // Data transfer direction (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t S4CR_PFCTRL = 0x20;        // Peripheral flow controller
    static constexpr uint32_t S4CR_TCIE = 0x10;          // Transfer complete interrupt enable
    static constexpr uint32_t S4CR_HTIE = 0x8;           // Half transfer interrupt enable
    static constexpr uint32_t S4CR_TEIE = 0x4;           // Transfer error interrupt enable
    static constexpr uint32_t S4CR_DMEIE = 0x2;          // Direct mode error interrupt enable
    static constexpr uint32_t S4CR_EN = 0x1;             // Stream enable / flag stream ready when read low
    static const uint32_t S4CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t S4NDTR_NDT =                 // Number of data items to transfer (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t S4NDTR_RESET_VALUE = 0x0;


    static const uint32_t S4PAR_RESET_VALUE = 0x0;


    static const uint32_t S4M0AR_RESET_VALUE = 0x0;


    static const uint32_t S4M1AR_RESET_VALUE = 0x0;

    static constexpr uint32_t S4FCR_FEIE = 0x80;          // FIFO error interrupt enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S4FCR_FS =                  // FIFO status (3 bits), Read-only
        bit_field_t<3, 0x7>::value<X>();
    static constexpr uint32_t S4FCR_DMDIS = 0x4;          // Direct mode disable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S4FCR_FTH =                 // FIFO threshold selection (2 bits), Read-write
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t S4FCR_RESET_VALUE = 0x21;

    template<uint32_t X>
    static constexpr uint32_t S5CR_MBURST =              // Memory burst transfer configuration (2 bits)
        bit_field_t<23, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S5CR_PBURST =              // Peripheral burst transfer configuration (2 bits)
        bit_field_t<21, 0x3>::value<X>();
    static constexpr uint32_t S5CR_ACK = 0x100000;       // ACK
    static constexpr uint32_t S5CR_CT = 0x80000;         // Current target (only in double buffer mode)
    static constexpr uint32_t S5CR_DBM = 0x40000;        // Double buffer mode
    template<uint32_t X>
    static constexpr uint32_t S5CR_PL =                  // Priority level (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    static constexpr uint32_t S5CR_PINCOS = 0x8000;      // Peripheral increment offset size
    template<uint32_t X>
    static constexpr uint32_t S5CR_MSIZE =               // Memory data size (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S5CR_PSIZE =               // Peripheral data size (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    static constexpr uint32_t S5CR_MINC = 0x400;         // Memory increment mode
    static constexpr uint32_t S5CR_PINC = 0x200;         // Peripheral increment mode
    static constexpr uint32_t S5CR_CIRC = 0x100;         // Circular mode
    template<uint32_t X>
    static constexpr uint32_t S5CR_DIR =                 // Data transfer direction (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t S5CR_PFCTRL = 0x20;        // Peripheral flow controller
    static constexpr uint32_t S5CR_TCIE = 0x10;          // Transfer complete interrupt enable
    static constexpr uint32_t S5CR_HTIE = 0x8;           // Half transfer interrupt enable
    static constexpr uint32_t S5CR_TEIE = 0x4;           // Transfer error interrupt enable
    static constexpr uint32_t S5CR_DMEIE = 0x2;          // Direct mode error interrupt enable
    static constexpr uint32_t S5CR_EN = 0x1;             // Stream enable / flag stream ready when read low
    static const uint32_t S5CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t S5NDTR_NDT =                 // Number of data items to transfer (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t S5NDTR_RESET_VALUE = 0x0;


    static const uint32_t S5PAR_RESET_VALUE = 0x0;


    static const uint32_t S5M0AR_RESET_VALUE = 0x0;


    static const uint32_t S5M1AR_RESET_VALUE = 0x0;

    static constexpr uint32_t S5FCR_FEIE = 0x80;          // FIFO error interrupt enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S5FCR_FS =                  // FIFO status (3 bits), Read-only
        bit_field_t<3, 0x7>::value<X>();
    static constexpr uint32_t S5FCR_DMDIS = 0x4;          // Direct mode disable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S5FCR_FTH =                 // FIFO threshold selection (2 bits), Read-write
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t S5FCR_RESET_VALUE = 0x21;

    template<uint32_t X>
    static constexpr uint32_t S6CR_MBURST =              // Memory burst transfer configuration (2 bits)
        bit_field_t<23, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S6CR_PBURST =              // Peripheral burst transfer configuration (2 bits)
        bit_field_t<21, 0x3>::value<X>();
    static constexpr uint32_t S6CR_ACK = 0x100000;       // ACK
    static constexpr uint32_t S6CR_CT = 0x80000;         // Current target (only in double buffer mode)
    static constexpr uint32_t S6CR_DBM = 0x40000;        // Double buffer mode
    template<uint32_t X>
    static constexpr uint32_t S6CR_PL =                  // Priority level (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    static constexpr uint32_t S6CR_PINCOS = 0x8000;      // Peripheral increment offset size
    template<uint32_t X>
    static constexpr uint32_t S6CR_MSIZE =               // Memory data size (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S6CR_PSIZE =               // Peripheral data size (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    static constexpr uint32_t S6CR_MINC = 0x400;         // Memory increment mode
    static constexpr uint32_t S6CR_PINC = 0x200;         // Peripheral increment mode
    static constexpr uint32_t S6CR_CIRC = 0x100;         // Circular mode
    template<uint32_t X>
    static constexpr uint32_t S6CR_DIR =                 // Data transfer direction (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t S6CR_PFCTRL = 0x20;        // Peripheral flow controller
    static constexpr uint32_t S6CR_TCIE = 0x10;          // Transfer complete interrupt enable
    static constexpr uint32_t S6CR_HTIE = 0x8;           // Half transfer interrupt enable
    static constexpr uint32_t S6CR_TEIE = 0x4;           // Transfer error interrupt enable
    static constexpr uint32_t S6CR_DMEIE = 0x2;          // Direct mode error interrupt enable
    static constexpr uint32_t S6CR_EN = 0x1;             // Stream enable / flag stream ready when read low
    static const uint32_t S6CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t S6NDTR_NDT =                 // Number of data items to transfer (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t S6NDTR_RESET_VALUE = 0x0;


    static const uint32_t S6PAR_RESET_VALUE = 0x0;


    static const uint32_t S6M0AR_RESET_VALUE = 0x0;


    static const uint32_t S6M1AR_RESET_VALUE = 0x0;

    static constexpr uint32_t S6FCR_FEIE = 0x80;          // FIFO error interrupt enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S6FCR_FS =                  // FIFO status (3 bits), Read-only
        bit_field_t<3, 0x7>::value<X>();
    static constexpr uint32_t S6FCR_DMDIS = 0x4;          // Direct mode disable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S6FCR_FTH =                 // FIFO threshold selection (2 bits), Read-write
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t S6FCR_RESET_VALUE = 0x21;

    template<uint32_t X>
    static constexpr uint32_t S7CR_MBURST =              // Memory burst transfer configuration (2 bits)
        bit_field_t<23, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S7CR_PBURST =              // Peripheral burst transfer configuration (2 bits)
        bit_field_t<21, 0x3>::value<X>();
    static constexpr uint32_t S7CR_ACK = 0x100000;       // ACK
    static constexpr uint32_t S7CR_CT = 0x80000;         // Current target (only in double buffer mode)
    static constexpr uint32_t S7CR_DBM = 0x40000;        // Double buffer mode
    template<uint32_t X>
    static constexpr uint32_t S7CR_PL =                  // Priority level (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    static constexpr uint32_t S7CR_PINCOS = 0x8000;      // Peripheral increment offset size
    template<uint32_t X>
    static constexpr uint32_t S7CR_MSIZE =               // Memory data size (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S7CR_PSIZE =               // Peripheral data size (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    static constexpr uint32_t S7CR_MINC = 0x400;         // Memory increment mode
    static constexpr uint32_t S7CR_PINC = 0x200;         // Peripheral increment mode
    static constexpr uint32_t S7CR_CIRC = 0x100;         // Circular mode
    template<uint32_t X>
    static constexpr uint32_t S7CR_DIR =                 // Data transfer direction (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t S7CR_PFCTRL = 0x20;        // Peripheral flow controller
    static constexpr uint32_t S7CR_TCIE = 0x10;          // Transfer complete interrupt enable
    static constexpr uint32_t S7CR_HTIE = 0x8;           // Half transfer interrupt enable
    static constexpr uint32_t S7CR_TEIE = 0x4;           // Transfer error interrupt enable
    static constexpr uint32_t S7CR_DMEIE = 0x2;          // Direct mode error interrupt enable
    static constexpr uint32_t S7CR_EN = 0x1;             // Stream enable / flag stream ready when read low
    static const uint32_t S7CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t S7NDTR_NDT =                 // Number of data items to transfer (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t S7NDTR_RESET_VALUE = 0x0;


    static const uint32_t S7PAR_RESET_VALUE = 0x0;


    static const uint32_t S7M0AR_RESET_VALUE = 0x0;


    static const uint32_t S7M1AR_RESET_VALUE = 0x0;

    static constexpr uint32_t S7FCR_FEIE = 0x80;          // FIFO error interrupt enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S7FCR_FS =                  // FIFO status (3 bits), Read-only
        bit_field_t<3, 0x7>::value<X>();
    static constexpr uint32_t S7FCR_DMDIS = 0x4;          // Direct mode disable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S7FCR_FTH =                 // FIFO threshold selection (2 bits), Read-write
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t S7FCR_RESET_VALUE = 0x21;

    static constexpr uint8_t DMA1_STR7 = 47; // DMA1 Stream7
    static constexpr uint8_t DMA_STR0 = 11; // DMA1 Stream0
    static constexpr uint8_t DMA_STR1 = 12; // DMA1 Stream1
};

static dma1_t& DMA1 = *reinterpret_cast<dma1_t*>(0x40020000);

#define HAVE_PERIPHERAL_DMA1


////
//
//    DMA controller
//
////

struct dma2_t
{
    volatile uint32_t    LISR;                 // [Read-only] low interrupt status register
    volatile uint32_t    HISR;                 // [Read-only] high interrupt status register
    volatile uint32_t    LIFCR;                // [Read-write] low interrupt flag clear register
    volatile uint32_t    HIFCR;                // [Read-write] high interrupt flag clear register
    volatile uint32_t    S0CR;                 // [Read-write] stream x configuration register
    volatile uint32_t    S0NDTR;               // [Read-write] stream x number of data register
    volatile uint32_t    S0PAR;                // [Read-write] stream x peripheral address register
    volatile uint32_t    S0M0AR;               // [Read-write] stream x memory 0 address register
    volatile uint32_t    S0M1AR;               // [Read-write] stream x memory 1 address register
    volatile uint32_t    S0FCR;                // stream x FIFO control register
    volatile uint32_t    S1CR;                 // [Read-write] stream x configuration register
    volatile uint32_t    S1NDTR;               // [Read-write] stream x number of data register
    volatile uint32_t    S1PAR;                // [Read-write] stream x peripheral address register
    volatile uint32_t    S1M0AR;               // [Read-write] stream x memory 0 address register
    volatile uint32_t    S1M1AR;               // [Read-write] stream x memory 1 address register
    volatile uint32_t    S1FCR;                // stream x FIFO control register
    volatile uint32_t    S2CR;                 // [Read-write] stream x configuration register
    volatile uint32_t    S2NDTR;               // [Read-write] stream x number of data register
    volatile uint32_t    S2PAR;                // [Read-write] stream x peripheral address register
    volatile uint32_t    S2M0AR;               // [Read-write] stream x memory 0 address register
    volatile uint32_t    S2M1AR;               // [Read-write] stream x memory 1 address register
    volatile uint32_t    S2FCR;                // stream x FIFO control register
    volatile uint32_t    S3CR;                 // [Read-write] stream x configuration register
    volatile uint32_t    S3NDTR;               // [Read-write] stream x number of data register
    volatile uint32_t    S3PAR;                // [Read-write] stream x peripheral address register
    volatile uint32_t    S3M0AR;               // [Read-write] stream x memory 0 address register
    volatile uint32_t    S3M1AR;               // [Read-write] stream x memory 1 address register
    volatile uint32_t    S3FCR;                // stream x FIFO control register
    volatile uint32_t    S4CR;                 // [Read-write] stream x configuration register
    volatile uint32_t    S4NDTR;               // [Read-write] stream x number of data register
    volatile uint32_t    S4PAR;                // [Read-write] stream x peripheral address register
    volatile uint32_t    S4M0AR;               // [Read-write] stream x memory 0 address register
    volatile uint32_t    S4M1AR;               // [Read-write] stream x memory 1 address register
    volatile uint32_t    S4FCR;                // stream x FIFO control register
    volatile uint32_t    S5CR;                 // [Read-write] stream x configuration register
    volatile uint32_t    S5NDTR;               // [Read-write] stream x number of data register
    volatile uint32_t    S5PAR;                // [Read-write] stream x peripheral address register
    volatile uint32_t    S5M0AR;               // [Read-write] stream x memory 0 address register
    volatile uint32_t    S5M1AR;               // [Read-write] stream x memory 1 address register
    volatile uint32_t    S5FCR;                // stream x FIFO control register
    volatile uint32_t    S6CR;                 // [Read-write] stream x configuration register
    volatile uint32_t    S6NDTR;               // [Read-write] stream x number of data register
    volatile uint32_t    S6PAR;                // [Read-write] stream x peripheral address register
    volatile uint32_t    S6M0AR;               // [Read-write] stream x memory 0 address register
    volatile uint32_t    S6M1AR;               // [Read-write] stream x memory 1 address register
    volatile uint32_t    S6FCR;                // stream x FIFO control register
    volatile uint32_t    S7CR;                 // [Read-write] stream x configuration register
    volatile uint32_t    S7NDTR;               // [Read-write] stream x number of data register
    volatile uint32_t    S7PAR;                // [Read-write] stream x peripheral address register
    volatile uint32_t    S7M0AR;               // [Read-write] stream x memory 0 address register
    volatile uint32_t    S7M1AR;               // [Read-write] stream x memory 1 address register
    volatile uint32_t    S7FCR;                // stream x FIFO control register

    static constexpr uint32_t LISR_TCIF3 = 0x8000000;    // Stream x transfer complete interrupt flag (x = 3..0)
    static constexpr uint32_t LISR_HTIF3 = 0x4000000;    // Stream x half transfer interrupt flag (x=3..0)
    static constexpr uint32_t LISR_TEIF3 = 0x2000000;    // Stream x transfer error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_DMEIF3 = 0x1000000;   // Stream x direct mode error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_FEIF3 = 0x400000;     // Stream x FIFO error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_TCIF2 = 0x200000;     // Stream x transfer complete interrupt flag (x = 3..0)
    static constexpr uint32_t LISR_HTIF2 = 0x100000;     // Stream x half transfer interrupt flag (x=3..0)
    static constexpr uint32_t LISR_TEIF2 = 0x80000;      // Stream x transfer error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_DMEIF2 = 0x40000;     // Stream x direct mode error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_FEIF2 = 0x10000;      // Stream x FIFO error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_TCIF1 = 0x800;        // Stream x transfer complete interrupt flag (x = 3..0)
    static constexpr uint32_t LISR_HTIF1 = 0x400;        // Stream x half transfer interrupt flag (x=3..0)
    static constexpr uint32_t LISR_TEIF1 = 0x200;        // Stream x transfer error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_DMEIF1 = 0x100;       // Stream x direct mode error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_FEIF1 = 0x40;         // Stream x FIFO error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_TCIF0 = 0x20;         // Stream x transfer complete interrupt flag (x = 3..0)
    static constexpr uint32_t LISR_HTIF0 = 0x10;         // Stream x half transfer interrupt flag (x=3..0)
    static constexpr uint32_t LISR_TEIF0 = 0x8;          // Stream x transfer error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_DMEIF0 = 0x4;         // Stream x direct mode error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_FEIF0 = 0x1;          // Stream x FIFO error interrupt flag (x=3..0)
    static const uint32_t LISR_RESET_VALUE = 0x0;

    static constexpr uint32_t HISR_TCIF7 = 0x8000000;    // Stream x transfer complete interrupt flag (x=7..4)
    static constexpr uint32_t HISR_HTIF7 = 0x4000000;    // Stream x half transfer interrupt flag (x=7..4)
    static constexpr uint32_t HISR_TEIF7 = 0x2000000;    // Stream x transfer error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_DMEIF7 = 0x1000000;   // Stream x direct mode error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_FEIF7 = 0x400000;     // Stream x FIFO error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_TCIF6 = 0x200000;     // Stream x transfer complete interrupt flag (x=7..4)
    static constexpr uint32_t HISR_HTIF6 = 0x100000;     // Stream x half transfer interrupt flag (x=7..4)
    static constexpr uint32_t HISR_TEIF6 = 0x80000;      // Stream x transfer error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_DMEIF6 = 0x40000;     // Stream x direct mode error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_FEIF6 = 0x10000;      // Stream x FIFO error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_TCIF5 = 0x800;        // Stream x transfer complete interrupt flag (x=7..4)
    static constexpr uint32_t HISR_HTIF5 = 0x400;        // Stream x half transfer interrupt flag (x=7..4)
    static constexpr uint32_t HISR_TEIF5 = 0x200;        // Stream x transfer error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_DMEIF5 = 0x100;       // Stream x direct mode error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_FEIF5 = 0x40;         // Stream x FIFO error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_TCIF4 = 0x20;         // Stream x transfer complete interrupt flag (x=7..4)
    static constexpr uint32_t HISR_HTIF4 = 0x10;         // Stream x half transfer interrupt flag (x=7..4)
    static constexpr uint32_t HISR_TEIF4 = 0x8;          // Stream x transfer error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_DMEIF4 = 0x4;         // Stream x direct mode error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_FEIF4 = 0x1;          // Stream x FIFO error interrupt flag (x=7..4)
    static const uint32_t HISR_RESET_VALUE = 0x0;

    static constexpr uint32_t LIFCR_CTCIF3 = 0x8000000;   // Stream x clear transfer complete interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CHTIF3 = 0x4000000;   // Stream x clear half transfer interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CTEIF3 = 0x2000000;   // Stream x clear transfer error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CDMEIF3 = 0x1000000;  // Stream x clear direct mode error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CFEIF3 = 0x400000;    // Stream x clear FIFO error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CTCIF2 = 0x200000;    // Stream x clear transfer complete interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CHTIF2 = 0x100000;    // Stream x clear half transfer interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CTEIF2 = 0x80000;     // Stream x clear transfer error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CDMEIF2 = 0x40000;    // Stream x clear direct mode error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CFEIF2 = 0x10000;     // Stream x clear FIFO error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CTCIF1 = 0x800;       // Stream x clear transfer complete interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CHTIF1 = 0x400;       // Stream x clear half transfer interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CTEIF1 = 0x200;       // Stream x clear transfer error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CDMEIF1 = 0x100;      // Stream x clear direct mode error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CFEIF1 = 0x40;        // Stream x clear FIFO error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CTCIF0 = 0x20;        // Stream x clear transfer complete interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CHTIF0 = 0x10;        // Stream x clear half transfer interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CTEIF0 = 0x8;         // Stream x clear transfer error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CDMEIF0 = 0x4;        // Stream x clear direct mode error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CFEIF0 = 0x1;         // Stream x clear FIFO error interrupt flag (x = 3..0)
    static const uint32_t LIFCR_RESET_VALUE = 0x0;

    static constexpr uint32_t HIFCR_CTCIF7 = 0x8000000;   // Stream x clear transfer complete interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CHTIF7 = 0x4000000;   // Stream x clear half transfer interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CTEIF7 = 0x2000000;   // Stream x clear transfer error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CDMEIF7 = 0x1000000;  // Stream x clear direct mode error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CFEIF7 = 0x400000;    // Stream x clear FIFO error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CTCIF6 = 0x200000;    // Stream x clear transfer complete interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CHTIF6 = 0x100000;    // Stream x clear half transfer interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CTEIF6 = 0x80000;     // Stream x clear transfer error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CDMEIF6 = 0x40000;    // Stream x clear direct mode error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CFEIF6 = 0x10000;     // Stream x clear FIFO error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CTCIF5 = 0x800;       // Stream x clear transfer complete interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CHTIF5 = 0x400;       // Stream x clear half transfer interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CTEIF5 = 0x200;       // Stream x clear transfer error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CDMEIF5 = 0x100;      // Stream x clear direct mode error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CFEIF5 = 0x40;        // Stream x clear FIFO error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CTCIF4 = 0x20;        // Stream x clear transfer complete interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CHTIF4 = 0x10;        // Stream x clear half transfer interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CTEIF4 = 0x8;         // Stream x clear transfer error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CDMEIF4 = 0x4;        // Stream x clear direct mode error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CFEIF4 = 0x1;         // Stream x clear FIFO error interrupt flag (x = 7..4)
    static const uint32_t HIFCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t S0CR_MBURST =              // Memory burst transfer configuration (2 bits)
        bit_field_t<23, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S0CR_PBURST =              // Peripheral burst transfer configuration (2 bits)
        bit_field_t<21, 0x3>::value<X>();
    static constexpr uint32_t S0CR_CT = 0x80000;         // Current target (only in double buffer mode)
    static constexpr uint32_t S0CR_DBM = 0x40000;        // Double buffer mode
    template<uint32_t X>
    static constexpr uint32_t S0CR_PL =                  // Priority level (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    static constexpr uint32_t S0CR_PINCOS = 0x8000;      // Peripheral increment offset size
    template<uint32_t X>
    static constexpr uint32_t S0CR_MSIZE =               // Memory data size (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S0CR_PSIZE =               // Peripheral data size (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    static constexpr uint32_t S0CR_MINC = 0x400;         // Memory increment mode
    static constexpr uint32_t S0CR_PINC = 0x200;         // Peripheral increment mode
    static constexpr uint32_t S0CR_CIRC = 0x100;         // Circular mode
    template<uint32_t X>
    static constexpr uint32_t S0CR_DIR =                 // Data transfer direction (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t S0CR_PFCTRL = 0x20;        // Peripheral flow controller
    static constexpr uint32_t S0CR_TCIE = 0x10;          // Transfer complete interrupt enable
    static constexpr uint32_t S0CR_HTIE = 0x8;           // Half transfer interrupt enable
    static constexpr uint32_t S0CR_TEIE = 0x4;           // Transfer error interrupt enable
    static constexpr uint32_t S0CR_DMEIE = 0x2;          // Direct mode error interrupt enable
    static constexpr uint32_t S0CR_EN = 0x1;             // Stream enable / flag stream ready when read low
    static const uint32_t S0CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t S0NDTR_NDT =                 // Number of data items to transfer (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t S0NDTR_RESET_VALUE = 0x0;


    static const uint32_t S0PAR_RESET_VALUE = 0x0;


    static const uint32_t S0M0AR_RESET_VALUE = 0x0;


    static const uint32_t S0M1AR_RESET_VALUE = 0x0;

    static constexpr uint32_t S0FCR_FEIE = 0x80;          // FIFO error interrupt enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S0FCR_FS =                  // FIFO status (3 bits), Read-only
        bit_field_t<3, 0x7>::value<X>();
    static constexpr uint32_t S0FCR_DMDIS = 0x4;          // Direct mode disable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S0FCR_FTH =                 // FIFO threshold selection (2 bits), Read-write
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t S0FCR_RESET_VALUE = 0x21;

    template<uint32_t X>
    static constexpr uint32_t S1CR_MBURST =              // Memory burst transfer configuration (2 bits)
        bit_field_t<23, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S1CR_PBURST =              // Peripheral burst transfer configuration (2 bits)
        bit_field_t<21, 0x3>::value<X>();
    static constexpr uint32_t S1CR_ACK = 0x100000;       // ACK
    static constexpr uint32_t S1CR_CT = 0x80000;         // Current target (only in double buffer mode)
    static constexpr uint32_t S1CR_DBM = 0x40000;        // Double buffer mode
    template<uint32_t X>
    static constexpr uint32_t S1CR_PL =                  // Priority level (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    static constexpr uint32_t S1CR_PINCOS = 0x8000;      // Peripheral increment offset size
    template<uint32_t X>
    static constexpr uint32_t S1CR_MSIZE =               // Memory data size (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S1CR_PSIZE =               // Peripheral data size (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    static constexpr uint32_t S1CR_MINC = 0x400;         // Memory increment mode
    static constexpr uint32_t S1CR_PINC = 0x200;         // Peripheral increment mode
    static constexpr uint32_t S1CR_CIRC = 0x100;         // Circular mode
    template<uint32_t X>
    static constexpr uint32_t S1CR_DIR =                 // Data transfer direction (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t S1CR_PFCTRL = 0x20;        // Peripheral flow controller
    static constexpr uint32_t S1CR_TCIE = 0x10;          // Transfer complete interrupt enable
    static constexpr uint32_t S1CR_HTIE = 0x8;           // Half transfer interrupt enable
    static constexpr uint32_t S1CR_TEIE = 0x4;           // Transfer error interrupt enable
    static constexpr uint32_t S1CR_DMEIE = 0x2;          // Direct mode error interrupt enable
    static constexpr uint32_t S1CR_EN = 0x1;             // Stream enable / flag stream ready when read low
    static const uint32_t S1CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t S1NDTR_NDT =                 // Number of data items to transfer (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t S1NDTR_RESET_VALUE = 0x0;


    static const uint32_t S1PAR_RESET_VALUE = 0x0;


    static const uint32_t S1M0AR_RESET_VALUE = 0x0;


    static const uint32_t S1M1AR_RESET_VALUE = 0x0;

    static constexpr uint32_t S1FCR_FEIE = 0x80;          // FIFO error interrupt enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S1FCR_FS =                  // FIFO status (3 bits), Read-only
        bit_field_t<3, 0x7>::value<X>();
    static constexpr uint32_t S1FCR_DMDIS = 0x4;          // Direct mode disable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S1FCR_FTH =                 // FIFO threshold selection (2 bits), Read-write
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t S1FCR_RESET_VALUE = 0x21;

    template<uint32_t X>
    static constexpr uint32_t S2CR_MBURST =              // Memory burst transfer configuration (2 bits)
        bit_field_t<23, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S2CR_PBURST =              // Peripheral burst transfer configuration (2 bits)
        bit_field_t<21, 0x3>::value<X>();
    static constexpr uint32_t S2CR_ACK = 0x100000;       // ACK
    static constexpr uint32_t S2CR_CT = 0x80000;         // Current target (only in double buffer mode)
    static constexpr uint32_t S2CR_DBM = 0x40000;        // Double buffer mode
    template<uint32_t X>
    static constexpr uint32_t S2CR_PL =                  // Priority level (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    static constexpr uint32_t S2CR_PINCOS = 0x8000;      // Peripheral increment offset size
    template<uint32_t X>
    static constexpr uint32_t S2CR_MSIZE =               // Memory data size (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S2CR_PSIZE =               // Peripheral data size (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    static constexpr uint32_t S2CR_MINC = 0x400;         // Memory increment mode
    static constexpr uint32_t S2CR_PINC = 0x200;         // Peripheral increment mode
    static constexpr uint32_t S2CR_CIRC = 0x100;         // Circular mode
    template<uint32_t X>
    static constexpr uint32_t S2CR_DIR =                 // Data transfer direction (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t S2CR_PFCTRL = 0x20;        // Peripheral flow controller
    static constexpr uint32_t S2CR_TCIE = 0x10;          // Transfer complete interrupt enable
    static constexpr uint32_t S2CR_HTIE = 0x8;           // Half transfer interrupt enable
    static constexpr uint32_t S2CR_TEIE = 0x4;           // Transfer error interrupt enable
    static constexpr uint32_t S2CR_DMEIE = 0x2;          // Direct mode error interrupt enable
    static constexpr uint32_t S2CR_EN = 0x1;             // Stream enable / flag stream ready when read low
    static const uint32_t S2CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t S2NDTR_NDT =                 // Number of data items to transfer (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t S2NDTR_RESET_VALUE = 0x0;


    static const uint32_t S2PAR_RESET_VALUE = 0x0;


    static const uint32_t S2M0AR_RESET_VALUE = 0x0;


    static const uint32_t S2M1AR_RESET_VALUE = 0x0;

    static constexpr uint32_t S2FCR_FEIE = 0x80;          // FIFO error interrupt enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S2FCR_FS =                  // FIFO status (3 bits), Read-only
        bit_field_t<3, 0x7>::value<X>();
    static constexpr uint32_t S2FCR_DMDIS = 0x4;          // Direct mode disable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S2FCR_FTH =                 // FIFO threshold selection (2 bits), Read-write
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t S2FCR_RESET_VALUE = 0x21;

    template<uint32_t X>
    static constexpr uint32_t S3CR_MBURST =              // Memory burst transfer configuration (2 bits)
        bit_field_t<23, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S3CR_PBURST =              // Peripheral burst transfer configuration (2 bits)
        bit_field_t<21, 0x3>::value<X>();
    static constexpr uint32_t S3CR_ACK = 0x100000;       // ACK
    static constexpr uint32_t S3CR_CT = 0x80000;         // Current target (only in double buffer mode)
    static constexpr uint32_t S3CR_DBM = 0x40000;        // Double buffer mode
    template<uint32_t X>
    static constexpr uint32_t S3CR_PL =                  // Priority level (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    static constexpr uint32_t S3CR_PINCOS = 0x8000;      // Peripheral increment offset size
    template<uint32_t X>
    static constexpr uint32_t S3CR_MSIZE =               // Memory data size (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S3CR_PSIZE =               // Peripheral data size (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    static constexpr uint32_t S3CR_MINC = 0x400;         // Memory increment mode
    static constexpr uint32_t S3CR_PINC = 0x200;         // Peripheral increment mode
    static constexpr uint32_t S3CR_CIRC = 0x100;         // Circular mode
    template<uint32_t X>
    static constexpr uint32_t S3CR_DIR =                 // Data transfer direction (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t S3CR_PFCTRL = 0x20;        // Peripheral flow controller
    static constexpr uint32_t S3CR_TCIE = 0x10;          // Transfer complete interrupt enable
    static constexpr uint32_t S3CR_HTIE = 0x8;           // Half transfer interrupt enable
    static constexpr uint32_t S3CR_TEIE = 0x4;           // Transfer error interrupt enable
    static constexpr uint32_t S3CR_DMEIE = 0x2;          // Direct mode error interrupt enable
    static constexpr uint32_t S3CR_EN = 0x1;             // Stream enable / flag stream ready when read low
    static const uint32_t S3CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t S3NDTR_NDT =                 // Number of data items to transfer (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t S3NDTR_RESET_VALUE = 0x0;


    static const uint32_t S3PAR_RESET_VALUE = 0x0;


    static const uint32_t S3M0AR_RESET_VALUE = 0x0;


    static const uint32_t S3M1AR_RESET_VALUE = 0x0;

    static constexpr uint32_t S3FCR_FEIE = 0x80;          // FIFO error interrupt enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S3FCR_FS =                  // FIFO status (3 bits), Read-only
        bit_field_t<3, 0x7>::value<X>();
    static constexpr uint32_t S3FCR_DMDIS = 0x4;          // Direct mode disable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S3FCR_FTH =                 // FIFO threshold selection (2 bits), Read-write
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t S3FCR_RESET_VALUE = 0x21;

    template<uint32_t X>
    static constexpr uint32_t S4CR_MBURST =              // Memory burst transfer configuration (2 bits)
        bit_field_t<23, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S4CR_PBURST =              // Peripheral burst transfer configuration (2 bits)
        bit_field_t<21, 0x3>::value<X>();
    static constexpr uint32_t S4CR_ACK = 0x100000;       // ACK
    static constexpr uint32_t S4CR_CT = 0x80000;         // Current target (only in double buffer mode)
    static constexpr uint32_t S4CR_DBM = 0x40000;        // Double buffer mode
    template<uint32_t X>
    static constexpr uint32_t S4CR_PL =                  // Priority level (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    static constexpr uint32_t S4CR_PINCOS = 0x8000;      // Peripheral increment offset size
    template<uint32_t X>
    static constexpr uint32_t S4CR_MSIZE =               // Memory data size (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S4CR_PSIZE =               // Peripheral data size (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    static constexpr uint32_t S4CR_MINC = 0x400;         // Memory increment mode
    static constexpr uint32_t S4CR_PINC = 0x200;         // Peripheral increment mode
    static constexpr uint32_t S4CR_CIRC = 0x100;         // Circular mode
    template<uint32_t X>
    static constexpr uint32_t S4CR_DIR =                 // Data transfer direction (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t S4CR_PFCTRL = 0x20;        // Peripheral flow controller
    static constexpr uint32_t S4CR_TCIE = 0x10;          // Transfer complete interrupt enable
    static constexpr uint32_t S4CR_HTIE = 0x8;           // Half transfer interrupt enable
    static constexpr uint32_t S4CR_TEIE = 0x4;           // Transfer error interrupt enable
    static constexpr uint32_t S4CR_DMEIE = 0x2;          // Direct mode error interrupt enable
    static constexpr uint32_t S4CR_EN = 0x1;             // Stream enable / flag stream ready when read low
    static const uint32_t S4CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t S4NDTR_NDT =                 // Number of data items to transfer (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t S4NDTR_RESET_VALUE = 0x0;


    static const uint32_t S4PAR_RESET_VALUE = 0x0;


    static const uint32_t S4M0AR_RESET_VALUE = 0x0;


    static const uint32_t S4M1AR_RESET_VALUE = 0x0;

    static constexpr uint32_t S4FCR_FEIE = 0x80;          // FIFO error interrupt enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S4FCR_FS =                  // FIFO status (3 bits), Read-only
        bit_field_t<3, 0x7>::value<X>();
    static constexpr uint32_t S4FCR_DMDIS = 0x4;          // Direct mode disable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S4FCR_FTH =                 // FIFO threshold selection (2 bits), Read-write
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t S4FCR_RESET_VALUE = 0x21;

    template<uint32_t X>
    static constexpr uint32_t S5CR_MBURST =              // Memory burst transfer configuration (2 bits)
        bit_field_t<23, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S5CR_PBURST =              // Peripheral burst transfer configuration (2 bits)
        bit_field_t<21, 0x3>::value<X>();
    static constexpr uint32_t S5CR_ACK = 0x100000;       // ACK
    static constexpr uint32_t S5CR_CT = 0x80000;         // Current target (only in double buffer mode)
    static constexpr uint32_t S5CR_DBM = 0x40000;        // Double buffer mode
    template<uint32_t X>
    static constexpr uint32_t S5CR_PL =                  // Priority level (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    static constexpr uint32_t S5CR_PINCOS = 0x8000;      // Peripheral increment offset size
    template<uint32_t X>
    static constexpr uint32_t S5CR_MSIZE =               // Memory data size (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S5CR_PSIZE =               // Peripheral data size (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    static constexpr uint32_t S5CR_MINC = 0x400;         // Memory increment mode
    static constexpr uint32_t S5CR_PINC = 0x200;         // Peripheral increment mode
    static constexpr uint32_t S5CR_CIRC = 0x100;         // Circular mode
    template<uint32_t X>
    static constexpr uint32_t S5CR_DIR =                 // Data transfer direction (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t S5CR_PFCTRL = 0x20;        // Peripheral flow controller
    static constexpr uint32_t S5CR_TCIE = 0x10;          // Transfer complete interrupt enable
    static constexpr uint32_t S5CR_HTIE = 0x8;           // Half transfer interrupt enable
    static constexpr uint32_t S5CR_TEIE = 0x4;           // Transfer error interrupt enable
    static constexpr uint32_t S5CR_DMEIE = 0x2;          // Direct mode error interrupt enable
    static constexpr uint32_t S5CR_EN = 0x1;             // Stream enable / flag stream ready when read low
    static const uint32_t S5CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t S5NDTR_NDT =                 // Number of data items to transfer (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t S5NDTR_RESET_VALUE = 0x0;


    static const uint32_t S5PAR_RESET_VALUE = 0x0;


    static const uint32_t S5M0AR_RESET_VALUE = 0x0;


    static const uint32_t S5M1AR_RESET_VALUE = 0x0;

    static constexpr uint32_t S5FCR_FEIE = 0x80;          // FIFO error interrupt enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S5FCR_FS =                  // FIFO status (3 bits), Read-only
        bit_field_t<3, 0x7>::value<X>();
    static constexpr uint32_t S5FCR_DMDIS = 0x4;          // Direct mode disable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S5FCR_FTH =                 // FIFO threshold selection (2 bits), Read-write
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t S5FCR_RESET_VALUE = 0x21;

    template<uint32_t X>
    static constexpr uint32_t S6CR_MBURST =              // Memory burst transfer configuration (2 bits)
        bit_field_t<23, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S6CR_PBURST =              // Peripheral burst transfer configuration (2 bits)
        bit_field_t<21, 0x3>::value<X>();
    static constexpr uint32_t S6CR_ACK = 0x100000;       // ACK
    static constexpr uint32_t S6CR_CT = 0x80000;         // Current target (only in double buffer mode)
    static constexpr uint32_t S6CR_DBM = 0x40000;        // Double buffer mode
    template<uint32_t X>
    static constexpr uint32_t S6CR_PL =                  // Priority level (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    static constexpr uint32_t S6CR_PINCOS = 0x8000;      // Peripheral increment offset size
    template<uint32_t X>
    static constexpr uint32_t S6CR_MSIZE =               // Memory data size (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S6CR_PSIZE =               // Peripheral data size (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    static constexpr uint32_t S6CR_MINC = 0x400;         // Memory increment mode
    static constexpr uint32_t S6CR_PINC = 0x200;         // Peripheral increment mode
    static constexpr uint32_t S6CR_CIRC = 0x100;         // Circular mode
    template<uint32_t X>
    static constexpr uint32_t S6CR_DIR =                 // Data transfer direction (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t S6CR_PFCTRL = 0x20;        // Peripheral flow controller
    static constexpr uint32_t S6CR_TCIE = 0x10;          // Transfer complete interrupt enable
    static constexpr uint32_t S6CR_HTIE = 0x8;           // Half transfer interrupt enable
    static constexpr uint32_t S6CR_TEIE = 0x4;           // Transfer error interrupt enable
    static constexpr uint32_t S6CR_DMEIE = 0x2;          // Direct mode error interrupt enable
    static constexpr uint32_t S6CR_EN = 0x1;             // Stream enable / flag stream ready when read low
    static const uint32_t S6CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t S6NDTR_NDT =                 // Number of data items to transfer (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t S6NDTR_RESET_VALUE = 0x0;


    static const uint32_t S6PAR_RESET_VALUE = 0x0;


    static const uint32_t S6M0AR_RESET_VALUE = 0x0;


    static const uint32_t S6M1AR_RESET_VALUE = 0x0;

    static constexpr uint32_t S6FCR_FEIE = 0x80;          // FIFO error interrupt enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S6FCR_FS =                  // FIFO status (3 bits), Read-only
        bit_field_t<3, 0x7>::value<X>();
    static constexpr uint32_t S6FCR_DMDIS = 0x4;          // Direct mode disable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S6FCR_FTH =                 // FIFO threshold selection (2 bits), Read-write
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t S6FCR_RESET_VALUE = 0x21;

    template<uint32_t X>
    static constexpr uint32_t S7CR_MBURST =              // Memory burst transfer configuration (2 bits)
        bit_field_t<23, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S7CR_PBURST =              // Peripheral burst transfer configuration (2 bits)
        bit_field_t<21, 0x3>::value<X>();
    static constexpr uint32_t S7CR_ACK = 0x100000;       // ACK
    static constexpr uint32_t S7CR_CT = 0x80000;         // Current target (only in double buffer mode)
    static constexpr uint32_t S7CR_DBM = 0x40000;        // Double buffer mode
    template<uint32_t X>
    static constexpr uint32_t S7CR_PL =                  // Priority level (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    static constexpr uint32_t S7CR_PINCOS = 0x8000;      // Peripheral increment offset size
    template<uint32_t X>
    static constexpr uint32_t S7CR_MSIZE =               // Memory data size (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S7CR_PSIZE =               // Peripheral data size (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    static constexpr uint32_t S7CR_MINC = 0x400;         // Memory increment mode
    static constexpr uint32_t S7CR_PINC = 0x200;         // Peripheral increment mode
    static constexpr uint32_t S7CR_CIRC = 0x100;         // Circular mode
    template<uint32_t X>
    static constexpr uint32_t S7CR_DIR =                 // Data transfer direction (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t S7CR_PFCTRL = 0x20;        // Peripheral flow controller
    static constexpr uint32_t S7CR_TCIE = 0x10;          // Transfer complete interrupt enable
    static constexpr uint32_t S7CR_HTIE = 0x8;           // Half transfer interrupt enable
    static constexpr uint32_t S7CR_TEIE = 0x4;           // Transfer error interrupt enable
    static constexpr uint32_t S7CR_DMEIE = 0x2;          // Direct mode error interrupt enable
    static constexpr uint32_t S7CR_EN = 0x1;             // Stream enable / flag stream ready when read low
    static const uint32_t S7CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t S7NDTR_NDT =                 // Number of data items to transfer (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t S7NDTR_RESET_VALUE = 0x0;


    static const uint32_t S7PAR_RESET_VALUE = 0x0;


    static const uint32_t S7M0AR_RESET_VALUE = 0x0;


    static const uint32_t S7M1AR_RESET_VALUE = 0x0;

    static constexpr uint32_t S7FCR_FEIE = 0x80;          // FIFO error interrupt enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S7FCR_FS =                  // FIFO status (3 bits), Read-only
        bit_field_t<3, 0x7>::value<X>();
    static constexpr uint32_t S7FCR_DMDIS = 0x4;          // Direct mode disable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S7FCR_FTH =                 // FIFO threshold selection (2 bits), Read-write
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t S7FCR_RESET_VALUE = 0x21;

    static constexpr uint8_t DMA2_STR0 = 56; // DMA2 Stream0 interrupt
    static constexpr uint8_t DMA2_STR1 = 57; // DMA2 Stream1 interrupt
    static constexpr uint8_t DMA2_STR2 = 58; // DMA2 Stream2 interrupt
    static constexpr uint8_t DMA2_STR3 = 59; // DMA2 Stream3 interrupt
    static constexpr uint8_t DMA2_STR4 = 60; // DMA2 Stream4 interrupt
    static constexpr uint8_t DMA2_STR5 = 68; // DMA2 Stream5 interrupt
    static constexpr uint8_t DMA2_STR6 = 69; // DMA2 Stream6 interrupt
    static constexpr uint8_t DMA2_STR7 = 70; // DMA2 Stream7 interrupt
    static constexpr uint8_t DMA_STR2 = 13; // DMA1 Stream2
    static constexpr uint8_t DMA_STR3 = 14; // DMA1 Stream3
    static constexpr uint8_t DMA_STR4 = 15; // DMA1 Stream4
    static constexpr uint8_t DMA_STR5 = 16; // DMA1 Stream5
    static constexpr uint8_t DMA_STR6 = 17; // DMA1 Stream6
};

static dma2_t& DMA2 = *reinterpret_cast<dma2_t*>(0x40020400);

#define HAVE_PERIPHERAL_DMA2


////
//
//    High Resolution Timer: Master Timers
//
////

struct hrtim_master_t
{
    volatile uint32_t    MCR;                  // [Read-write] Master Timer Control Register
    volatile uint32_t    MISR;                 // [Read-only] Master Timer Interrupt Status Register
    volatile uint32_t    MICR;                 // [Write-only] Master Timer Interrupt Clear Register
    volatile uint32_t    MDIER4;               // [Read-write] MDIER4
    volatile uint32_t    MCNTR;                // [Read-write] Master Timer Counter Register
    volatile uint32_t    MPER;                 // [Read-write] Master Timer Period Register
    volatile uint32_t    MREP;                 // [Read-write] Master Timer Repetition Register
    volatile uint32_t    MCMP1R;               // [Read-write] Master Timer Compare 1 Register
    reserved_t<1>        _0;
    volatile uint32_t    MCMP2R;               // [Read-write] Master Timer Compare 2 Register
    volatile uint32_t    MCMP3R;               // [Read-write] Master Timer Compare 3 Register
    volatile uint32_t    MCMP4R;               // [Read-write] Master Timer Compare 4 Register

    template<uint32_t X>
    static constexpr uint32_t MCR_BRSTDMA =             // Burst DMA Update (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    static constexpr uint32_t MCR_MREPU = 0x20000000;   // Master Timer Repetition update
    static constexpr uint32_t MCR_PREEN = 0x8000000;    // Preload enable
    template<uint32_t X>
    static constexpr uint32_t MCR_DACSYNC =             // AC Synchronization (2 bits)
        bit_field_t<25, 0x3>::value<X>();
    static constexpr uint32_t MCR_TECEN = 0x200000;     // Timer E counter enable
    static constexpr uint32_t MCR_TDCEN = 0x100000;     // Timer D counter enable
    static constexpr uint32_t MCR_TCCEN = 0x80000;      // Timer C counter enable
    static constexpr uint32_t MCR_TBCEN = 0x40000;      // Timer B counter enable
    static constexpr uint32_t MCR_TACEN = 0x20000;      // Timer A counter enable
    static constexpr uint32_t MCR_MCEN = 0x10000;       // Master Counter enable
    template<uint32_t X>
    static constexpr uint32_t MCR_SYNC_SRC =            // Synchronization source (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MCR_SYNC_OUT =            // Synchronization output (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    static constexpr uint32_t MCR_SYNCSTRTM = 0x800;    // Synchronization Starts Master
    static constexpr uint32_t MCR_SYNCRSTM = 0x400;     // Synchronization Resets Master
    template<uint32_t X>
    static constexpr uint32_t MCR_SYNC_IN =             // ynchronization input (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t MCR_HALF = 0x20;          // Half mode enable
    static constexpr uint32_t MCR_RETRIG = 0x10;        // Master Re-triggerable mode
    static constexpr uint32_t MCR_CONT = 0x8;           // Master Continuous mode
    template<uint32_t X>
    static constexpr uint32_t MCR_CK_PSC =              // HRTIM Master Clock prescaler (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t MCR_RESET_VALUE = 0x0;

    static constexpr uint32_t MISR_MUPD = 0x40;          // Master Update Interrupt Flag
    static constexpr uint32_t MISR_SYNC = 0x20;          // Sync Input Interrupt Flag
    static constexpr uint32_t MISR_MREP = 0x10;          // Master Repetition Interrupt Flag
    static constexpr uint32_t MISR_MCMP4 = 0x8;          // Master Compare 4 Interrupt Flag
    static constexpr uint32_t MISR_MCMP3 = 0x4;          // Master Compare 3 Interrupt Flag
    static constexpr uint32_t MISR_MCMP2 = 0x2;          // Master Compare 2 Interrupt Flag
    static constexpr uint32_t MISR_MCMP1 = 0x1;          // Master Compare 1 Interrupt Flag
    static const uint32_t MISR_RESET_VALUE = 0x0;

    static constexpr uint32_t MICR_MUPDC = 0x40;         // Master update Interrupt flag clear
    static constexpr uint32_t MICR_SYNCC = 0x20;         // Sync Input Interrupt flag clear
    static constexpr uint32_t MICR_MREPC = 0x10;         // Repetition Interrupt flag clear
    static constexpr uint32_t MICR_MCMP4C = 0x8;         // Master Compare 4 Interrupt flag clear
    static constexpr uint32_t MICR_MCMP3C = 0x4;         // Master Compare 3 Interrupt flag clear
    static constexpr uint32_t MICR_MCMP2C = 0x2;         // Master Compare 2 Interrupt flag clear
    static constexpr uint32_t MICR_MCMP1C = 0x1;         // Master Compare 1 Interrupt flag clear
    static const uint32_t MICR_RESET_VALUE = 0x0;

    static constexpr uint32_t MDIER4_MUPDDE = 0x400000;    // MUPDDE
    static constexpr uint32_t MDIER4_SYNCDE = 0x200000;    // SYNCDE
    static constexpr uint32_t MDIER4_MREPDE = 0x100000;    // MREPDE
    static constexpr uint32_t MDIER4_MCMP4DE = 0x80000;    // MCMP4DE
    static constexpr uint32_t MDIER4_MCMP3DE = 0x40000;    // MCMP3DE
    static constexpr uint32_t MDIER4_MCMP2DE = 0x20000;    // MCMP2DE
    static constexpr uint32_t MDIER4_MCMP1DE = 0x10000;    // MCMP1DE
    static constexpr uint32_t MDIER4_MUPDIE = 0x40;        // MUPDIE
    static constexpr uint32_t MDIER4_SYNCIE = 0x20;        // SYNCIE
    static constexpr uint32_t MDIER4_MREPIE = 0x10;        // MREPIE
    static constexpr uint32_t MDIER4_MCMP4IE = 0x8;        // MCMP4IE
    static constexpr uint32_t MDIER4_MCMP3IE = 0x4;        // MCMP3IE
    static constexpr uint32_t MDIER4_MCMP2IE = 0x2;        // MCMP2IE
    static constexpr uint32_t MDIER4_MCMP1IE = 0x1;        // MCMP1IE
    static const uint32_t MDIER4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t MCNTR_MCNT =                // Counter value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t MCNTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t MPER_MPER =                // Master Timer Period value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t MPER_RESET_VALUE = 0xffff;

    template<uint32_t X>
    static constexpr uint32_t MREP_MREP =                // Master Timer Repetition counter value (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t MREP_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t MCMP1R_MCMP1 =               // Master Timer Compare 1 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t MCMP1R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t MCMP2R_MCMP2 =               // Master Timer Compare 2 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t MCMP2R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t MCMP3R_MCMP3 =               // Master Timer Compare 3 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t MCMP3R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t MCMP4R_MCMP4 =               // Master Timer Compare 4 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t MCMP4R_RESET_VALUE = 0x0;
};

static hrtim_master_t& HRTIM_MASTER = *reinterpret_cast<hrtim_master_t*>(0x40017400);

#define HAVE_PERIPHERAL_HRTIM_MASTER


////
//
//    High Resolution Timer: TIMA
//
////

struct hrtim_tima_t
{
    volatile uint32_t    TIMACR;               // [Read-write] Timerx Control Register
    volatile uint32_t    TIMAISR;              // [Read-only] Timerx Interrupt Status Register
    volatile uint32_t    TIMAICR;              // [Write-only] Timerx Interrupt Clear Register
    volatile uint32_t    TIMADIER5;            // [Read-write] TIMxDIER5
    volatile uint32_t    CNTAR;                // [Read-write] Timerx Counter Register
    volatile uint32_t    PERAR;                // [Read-write] Timerx Period Register
    volatile uint32_t    REPAR;                // [Read-write] Timerx Repetition Register
    volatile uint32_t    CMP1AR;               // [Read-write] Timerx Compare 1 Register
    volatile uint32_t    CMP1CAR;              // [Read-write] Timerx Compare 1 Compound Register
    volatile uint32_t    CMP2AR;               // [Read-write] Timerx Compare 2 Register
    volatile uint32_t    CMP3AR;               // [Read-write] Timerx Compare 3 Register
    volatile uint32_t    CMP4AR;               // [Read-write] Timerx Compare 4 Register
    volatile uint32_t    CPT1AR;               // [Read-only] Timerx Capture 1 Register
    volatile uint32_t    CPT2AR;               // [Read-only] Timerx Capture 2 Register
    volatile uint32_t    DTAR;                 // [Read-write] Timerx Deadtime Register
    volatile uint32_t    SETA1R;               // [Read-write] Timerx Output1 Set Register
    volatile uint32_t    RSTA1R;               // [Read-write] Timerx Output1 Reset Register
    volatile uint32_t    SETA2R;               // [Read-write] Timerx Output2 Set Register
    volatile uint32_t    RSTA2R;               // [Read-write] Timerx Output2 Reset Register
    volatile uint32_t    EEFAR1;               // [Read-write] Timerx External Event Filtering Register 1
    volatile uint32_t    EEFAR2;               // [Read-write] Timerx External Event Filtering Register 2
    volatile uint32_t    RSTAR;                // [Read-write] TimerA Reset Register
    volatile uint32_t    CHPAR;                // [Read-write] Timerx Chopper Register
    volatile uint32_t    CPT1ACR;              // [Read-write] Timerx Capture 2 Control Register
    volatile uint32_t    CPT2ACR;              // [Read-write] CPT2xCR
    volatile uint32_t    OUTAR;                // [Read-write] Timerx Output Register
    volatile uint32_t    FLTAR;                // [Read-write] Timerx Fault Register

    template<uint32_t X>
    static constexpr uint32_t TIMACR_UPDGAT =              // Update Gating (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    static constexpr uint32_t TIMACR_PREEN = 0x8000000;    // Preload enable
    template<uint32_t X>
    static constexpr uint32_t TIMACR_DACSYNC =             // AC Synchronization (2 bits)
        bit_field_t<25, 0x3>::value<X>();
    static constexpr uint32_t TIMACR_MSTU = 0x1000000;     // Master Timer update
    static constexpr uint32_t TIMACR_TEU = 0x800000;       // TEU
    static constexpr uint32_t TIMACR_TDU = 0x400000;       // TDU
    static constexpr uint32_t TIMACR_TCU = 0x200000;       // TCU
    static constexpr uint32_t TIMACR_TBU = 0x100000;       // TBU
    static constexpr uint32_t TIMACR_TxRSTU = 0x40000;     // Timerx reset update
    static constexpr uint32_t TIMACR_TxREPU = 0x20000;     // Timer x Repetition update
    template<uint32_t X>
    static constexpr uint32_t TIMACR_DELCMP4 =             // Delayed CMP4 mode (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TIMACR_DELCMP2 =             // Delayed CMP2 mode (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    static constexpr uint32_t TIMACR_SYNCSTRTx = 0x800;    // Synchronization Starts Timer x
    static constexpr uint32_t TIMACR_SYNCRSTx = 0x400;     // Synchronization Resets Timer x
    static constexpr uint32_t TIMACR_PSHPLL = 0x40;        // Push-Pull mode enable
    static constexpr uint32_t TIMACR_HALF = 0x20;          // Half mode enable
    static constexpr uint32_t TIMACR_RETRIG = 0x10;        // Re-triggerable mode
    static constexpr uint32_t TIMACR_CONT = 0x8;           // Continuous mode
    template<uint32_t X>
    static constexpr uint32_t TIMACR_CK_PSCx =             // HRTIM Timer x Clock prescaler (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t TIMACR_RESET_VALUE = 0x0;

    static constexpr uint32_t TIMAISR_O2STAT = 0x80000;     // Output 2 State
    static constexpr uint32_t TIMAISR_O1STAT = 0x40000;     // Output 1 State
    static constexpr uint32_t TIMAISR_IPPSTAT = 0x20000;    // Idle Push Pull Status
    static constexpr uint32_t TIMAISR_CPPSTAT = 0x10000;    // Current Push Pull Status
    static constexpr uint32_t TIMAISR_DLYPRT = 0x4000;      // Delayed Protection Flag
    static constexpr uint32_t TIMAISR_RST = 0x2000;         // Reset Interrupt Flag
    static constexpr uint32_t TIMAISR_RSTx2 = 0x1000;       // Output 2 Reset Interrupt Flag
    static constexpr uint32_t TIMAISR_SETx2 = 0x800;        // Output 2 Set Interrupt Flag
    static constexpr uint32_t TIMAISR_RSTx1 = 0x400;        // Output 1 Reset Interrupt Flag
    static constexpr uint32_t TIMAISR_SETx1 = 0x200;        // Output 1 Set Interrupt Flag
    static constexpr uint32_t TIMAISR_CPT2 = 0x100;         // Capture2 Interrupt Flag
    static constexpr uint32_t TIMAISR_CPT1 = 0x80;          // Capture1 Interrupt Flag
    static constexpr uint32_t TIMAISR_UPD = 0x40;           // Update Interrupt Flag
    static constexpr uint32_t TIMAISR_REP = 0x10;           // Repetition Interrupt Flag
    static constexpr uint32_t TIMAISR_CMP4 = 0x8;           // Compare 4 Interrupt Flag
    static constexpr uint32_t TIMAISR_CMP3 = 0x4;           // Compare 3 Interrupt Flag
    static constexpr uint32_t TIMAISR_CMP2 = 0x2;           // Compare 2 Interrupt Flag
    static constexpr uint32_t TIMAISR_CMP1 = 0x1;           // Compare 1 Interrupt Flag
    static const uint32_t TIMAISR_RESET_VALUE = 0x0;

    static constexpr uint32_t TIMAICR_DLYPRTC = 0x4000;     // Delayed Protection Flag Clear
    static constexpr uint32_t TIMAICR_RSTC = 0x2000;        // Reset Interrupt flag Clear
    static constexpr uint32_t TIMAICR_RSTx2C = 0x1000;      // Output 2 Reset flag Clear
    static constexpr uint32_t TIMAICR_SET2xC = 0x800;       // Output 2 Set flag Clear
    static constexpr uint32_t TIMAICR_RSTx1C = 0x400;       // Output 1 Reset flag Clear
    static constexpr uint32_t TIMAICR_SET1xC = 0x200;       // Output 1 Set flag Clear
    static constexpr uint32_t TIMAICR_CPT2C = 0x100;        // Capture2 Interrupt flag Clear
    static constexpr uint32_t TIMAICR_CPT1C = 0x80;         // Capture1 Interrupt flag Clear
    static constexpr uint32_t TIMAICR_UPDC = 0x40;          // Update Interrupt flag Clear
    static constexpr uint32_t TIMAICR_REPC = 0x10;          // Repetition Interrupt flag Clear
    static constexpr uint32_t TIMAICR_CMP4C = 0x8;          // Compare 4 Interrupt flag Clear
    static constexpr uint32_t TIMAICR_CMP3C = 0x4;          // Compare 3 Interrupt flag Clear
    static constexpr uint32_t TIMAICR_CMP2C = 0x2;          // Compare 2 Interrupt flag Clear
    static constexpr uint32_t TIMAICR_CMP1C = 0x1;          // Compare 1 Interrupt flag Clear
    static const uint32_t TIMAICR_RESET_VALUE = 0x0;

    static constexpr uint32_t TIMADIER5_DLYPRTDE = 0x40000000;// DLYPRTDE
    static constexpr uint32_t TIMADIER5_RSTDE = 0x20000000;   // RSTDE
    static constexpr uint32_t TIMADIER5_RSTx2DE = 0x10000000; // RSTx2DE
    static constexpr uint32_t TIMADIER5_SETx2DE = 0x8000000;  // SETx2DE
    static constexpr uint32_t TIMADIER5_RSTx1DE = 0x4000000;  // RSTx1DE
    static constexpr uint32_t TIMADIER5_SET1xDE = 0x2000000;  // SET1xDE
    static constexpr uint32_t TIMADIER5_CPT2DE = 0x1000000;   // CPT2DE
    static constexpr uint32_t TIMADIER5_CPT1DE = 0x800000;    // CPT1DE
    static constexpr uint32_t TIMADIER5_UPDDE = 0x400000;     // UPDDE
    static constexpr uint32_t TIMADIER5_REPDE = 0x100000;     // REPDE
    static constexpr uint32_t TIMADIER5_CMP4DE = 0x80000;     // CMP4DE
    static constexpr uint32_t TIMADIER5_CMP3DE = 0x40000;     // CMP3DE
    static constexpr uint32_t TIMADIER5_CMP2DE = 0x20000;     // CMP2DE
    static constexpr uint32_t TIMADIER5_CMP1DE = 0x10000;     // CMP1DE
    static constexpr uint32_t TIMADIER5_DLYPRTIE = 0x4000;    // DLYPRTIE
    static constexpr uint32_t TIMADIER5_RSTIE = 0x2000;       // RSTIE
    static constexpr uint32_t TIMADIER5_RSTx2IE = 0x1000;     // RSTx2IE
    static constexpr uint32_t TIMADIER5_SETx2IE = 0x800;      // SETx2IE
    static constexpr uint32_t TIMADIER5_RSTx1IE = 0x400;      // RSTx1IE
    static constexpr uint32_t TIMADIER5_SET1xIE = 0x200;      // SET1xIE
    static constexpr uint32_t TIMADIER5_CPT2IE = 0x100;       // CPT2IE
    static constexpr uint32_t TIMADIER5_CPT1IE = 0x80;        // CPT1IE
    static constexpr uint32_t TIMADIER5_UPDIE = 0x40;         // UPDIE
    static constexpr uint32_t TIMADIER5_REPIE = 0x10;         // REPIE
    static constexpr uint32_t TIMADIER5_CMP4IE = 0x8;         // CMP4IE
    static constexpr uint32_t TIMADIER5_CMP3IE = 0x4;         // CMP3IE
    static constexpr uint32_t TIMADIER5_CMP2IE = 0x2;         // CMP2IE
    static constexpr uint32_t TIMADIER5_CMP1IE = 0x1;         // CMP1IE
    static const uint32_t TIMADIER5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CNTAR_CNTx =                // Timerx Counter value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CNTAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PERAR_PERx =                // Timerx Period value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t PERAR_RESET_VALUE = 0xffff;

    template<uint32_t X>
    static constexpr uint32_t REPAR_REPx =                // Timerx Repetition counter value (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t REPAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CMP1AR_CMP1x =               // Timerx Compare 1 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CMP1AR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CMP1CAR_REPx =                // Timerx Repetition value (aliased from HRTIM_REPx register) (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CMP1CAR_CMP1x =               // Timerx Compare 1 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CMP1CAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CMP2AR_CMP2x =               // Timerx Compare 2 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CMP2AR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CMP3AR_CMP3x =               // Timerx Compare 3 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CMP3AR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CMP4AR_CMP4x =               // Timerx Compare 4 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CMP4AR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CPT1AR_CPT1x =               // Timerx Capture 1 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CPT1AR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CPT2AR_CPT2x =               // Timerx Capture 2 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CPT2AR_RESET_VALUE = 0x0;

    static constexpr uint32_t DTAR_DTFLKx = 0x80000000;  // Deadtime Falling Lock
    static constexpr uint32_t DTAR_DTFSLKx = 0x40000000; // Deadtime Falling Sign Lock
    static constexpr uint32_t DTAR_SDTFx = 0x2000000;    // Sign Deadtime Falling value
    template<uint32_t X>
    static constexpr uint32_t DTAR_DTFx =                // Deadtime Falling value (9 bits)
        bit_field_t<16, 0x1ff>::value<X>();
    static constexpr uint32_t DTAR_DTRLKx = 0x8000;      // Deadtime Rising Lock
    static constexpr uint32_t DTAR_DTRSLKx = 0x4000;     // Deadtime Rising Sign Lock
    template<uint32_t X>
    static constexpr uint32_t DTAR_DTPRSC =              // Deadtime Prescaler (3 bits)
        bit_field_t<10, 0x7>::value<X>();
    static constexpr uint32_t DTAR_SDTRx = 0x200;        // Sign Deadtime Rising value
    template<uint32_t X>
    static constexpr uint32_t DTAR_DTRx =                // Deadtime Rising value (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static const uint32_t DTAR_RESET_VALUE = 0x0;

    static constexpr uint32_t SETA1R_UPDATE = 0x80000000;  // Registers update (transfer preload to active)
    static constexpr uint32_t SETA1R_EXTEVNT10 = 0x40000000;// External Event 10
    static constexpr uint32_t SETA1R_EXTEVNT9 = 0x20000000;// External Event 9
    static constexpr uint32_t SETA1R_EXTEVNT8 = 0x10000000;// External Event 8
    static constexpr uint32_t SETA1R_EXTEVNT7 = 0x8000000; // External Event 7
    static constexpr uint32_t SETA1R_EXTEVNT6 = 0x4000000; // External Event 6
    static constexpr uint32_t SETA1R_EXTEVNT5 = 0x2000000; // External Event 5
    static constexpr uint32_t SETA1R_EXTEVNT4 = 0x1000000; // External Event 4
    static constexpr uint32_t SETA1R_EXTEVNT3 = 0x800000;  // External Event 3
    static constexpr uint32_t SETA1R_EXTEVNT2 = 0x400000;  // External Event 2
    static constexpr uint32_t SETA1R_EXTEVNT1 = 0x200000;  // External Event 1
    static constexpr uint32_t SETA1R_TIMEVNT9 = 0x100000;  // Timer Event 9
    static constexpr uint32_t SETA1R_TIMEVNT8 = 0x80000;   // Timer Event 8
    static constexpr uint32_t SETA1R_TIMEVNT7 = 0x40000;   // Timer Event 7
    static constexpr uint32_t SETA1R_TIMEVNT6 = 0x20000;   // Timer Event 6
    static constexpr uint32_t SETA1R_TIMEVNT5 = 0x10000;   // Timer Event 5
    static constexpr uint32_t SETA1R_TIMEVNT4 = 0x8000;    // Timer Event 4
    static constexpr uint32_t SETA1R_TIMEVNT3 = 0x4000;    // Timer Event 3
    static constexpr uint32_t SETA1R_TIMEVNT2 = 0x2000;    // Timer Event 2
    static constexpr uint32_t SETA1R_TIMEVNT1 = 0x1000;    // Timer Event 1
    static constexpr uint32_t SETA1R_MSTCMP4 = 0x800;      // Master Compare 4
    static constexpr uint32_t SETA1R_MSTCMP3 = 0x400;      // Master Compare 3
    static constexpr uint32_t SETA1R_MSTCMP2 = 0x200;      // Master Compare 2
    static constexpr uint32_t SETA1R_MSTCMP1 = 0x100;      // Master Compare 1
    static constexpr uint32_t SETA1R_MSTPER = 0x80;        // Master Period
    static constexpr uint32_t SETA1R_CMP4 = 0x40;          // Timer A compare 4
    static constexpr uint32_t SETA1R_CMP3 = 0x20;          // Timer A compare 3
    static constexpr uint32_t SETA1R_CMP2 = 0x10;          // Timer A compare 2
    static constexpr uint32_t SETA1R_CMP1 = 0x8;           // Timer A compare 1
    static constexpr uint32_t SETA1R_PER = 0x4;            // Timer A Period
    static constexpr uint32_t SETA1R_RESYNC = 0x2;         // Timer A resynchronizaton
    static constexpr uint32_t SETA1R_SST = 0x1;            // Software Set trigger
    static const uint32_t SETA1R_RESET_VALUE = 0x0;

    static constexpr uint32_t RSTA1R_UPDATE = 0x80000000;  // UPDATE
    static constexpr uint32_t RSTA1R_EXTEVNT10 = 0x40000000;// EXTEVNT10
    static constexpr uint32_t RSTA1R_EXTEVNT9 = 0x20000000;// EXTEVNT9
    static constexpr uint32_t RSTA1R_EXTEVNT8 = 0x10000000;// EXTEVNT8
    static constexpr uint32_t RSTA1R_EXTEVNT7 = 0x8000000; // EXTEVNT7
    static constexpr uint32_t RSTA1R_EXTEVNT6 = 0x4000000; // EXTEVNT6
    static constexpr uint32_t RSTA1R_EXTEVNT5 = 0x2000000; // EXTEVNT5
    static constexpr uint32_t RSTA1R_EXTEVNT4 = 0x1000000; // EXTEVNT4
    static constexpr uint32_t RSTA1R_EXTEVNT3 = 0x800000;  // EXTEVNT3
    static constexpr uint32_t RSTA1R_EXTEVNT2 = 0x400000;  // EXTEVNT2
    static constexpr uint32_t RSTA1R_EXTEVNT1 = 0x200000;  // EXTEVNT1
    static constexpr uint32_t RSTA1R_TIMEVNT9 = 0x100000;  // TIMEVNT9
    static constexpr uint32_t RSTA1R_TIMEVNT8 = 0x80000;   // TIMEVNT8
    static constexpr uint32_t RSTA1R_TIMEVNT7 = 0x40000;   // TIMEVNT7
    static constexpr uint32_t RSTA1R_TIMEVNT6 = 0x20000;   // TIMEVNT6
    static constexpr uint32_t RSTA1R_TIMEVNT5 = 0x10000;   // TIMEVNT5
    static constexpr uint32_t RSTA1R_TIMEVNT4 = 0x8000;    // TIMEVNT4
    static constexpr uint32_t RSTA1R_TIMEVNT3 = 0x4000;    // TIMEVNT3
    static constexpr uint32_t RSTA1R_TIMEVNT2 = 0x2000;    // TIMEVNT2
    static constexpr uint32_t RSTA1R_TIMEVNT1 = 0x1000;    // TIMEVNT1
    static constexpr uint32_t RSTA1R_MSTCMP4 = 0x800;      // MSTCMP4
    static constexpr uint32_t RSTA1R_MSTCMP3 = 0x400;      // MSTCMP3
    static constexpr uint32_t RSTA1R_MSTCMP2 = 0x200;      // MSTCMP2
    static constexpr uint32_t RSTA1R_MSTCMP1 = 0x100;      // MSTCMP1
    static constexpr uint32_t RSTA1R_MSTPER = 0x80;        // MSTPER
    static constexpr uint32_t RSTA1R_CMP4 = 0x40;          // CMP4
    static constexpr uint32_t RSTA1R_CMP3 = 0x20;          // CMP3
    static constexpr uint32_t RSTA1R_CMP2 = 0x10;          // CMP2
    static constexpr uint32_t RSTA1R_CMP1 = 0x8;           // CMP1
    static constexpr uint32_t RSTA1R_PER = 0x4;            // PER
    static constexpr uint32_t RSTA1R_RESYNC = 0x2;         // RESYNC
    static constexpr uint32_t RSTA1R_SRT = 0x1;            // SRT
    static const uint32_t RSTA1R_RESET_VALUE = 0x0;

    static constexpr uint32_t SETA2R_UPDATE = 0x80000000;  // UPDATE
    static constexpr uint32_t SETA2R_EXTEVNT10 = 0x40000000;// EXTEVNT10
    static constexpr uint32_t SETA2R_EXTEVNT9 = 0x20000000;// EXTEVNT9
    static constexpr uint32_t SETA2R_EXTEVNT8 = 0x10000000;// EXTEVNT8
    static constexpr uint32_t SETA2R_EXTEVNT7 = 0x8000000; // EXTEVNT7
    static constexpr uint32_t SETA2R_EXTEVNT6 = 0x4000000; // EXTEVNT6
    static constexpr uint32_t SETA2R_EXTEVNT5 = 0x2000000; // EXTEVNT5
    static constexpr uint32_t SETA2R_EXTEVNT4 = 0x1000000; // EXTEVNT4
    static constexpr uint32_t SETA2R_EXTEVNT3 = 0x800000;  // EXTEVNT3
    static constexpr uint32_t SETA2R_EXTEVNT2 = 0x400000;  // EXTEVNT2
    static constexpr uint32_t SETA2R_EXTEVNT1 = 0x200000;  // EXTEVNT1
    static constexpr uint32_t SETA2R_TIMEVNT9 = 0x100000;  // TIMEVNT9
    static constexpr uint32_t SETA2R_TIMEVNT8 = 0x80000;   // TIMEVNT8
    static constexpr uint32_t SETA2R_TIMEVNT7 = 0x40000;   // TIMEVNT7
    static constexpr uint32_t SETA2R_TIMEVNT6 = 0x20000;   // TIMEVNT6
    static constexpr uint32_t SETA2R_TIMEVNT5 = 0x10000;   // TIMEVNT5
    static constexpr uint32_t SETA2R_TIMEVNT4 = 0x8000;    // TIMEVNT4
    static constexpr uint32_t SETA2R_TIMEVNT3 = 0x4000;    // TIMEVNT3
    static constexpr uint32_t SETA2R_TIMEVNT2 = 0x2000;    // TIMEVNT2
    static constexpr uint32_t SETA2R_TIMEVNT1 = 0x1000;    // TIMEVNT1
    static constexpr uint32_t SETA2R_MSTCMP4 = 0x800;      // MSTCMP4
    static constexpr uint32_t SETA2R_MSTCMP3 = 0x400;      // MSTCMP3
    static constexpr uint32_t SETA2R_MSTCMP2 = 0x200;      // MSTCMP2
    static constexpr uint32_t SETA2R_MSTCMP1 = 0x100;      // MSTCMP1
    static constexpr uint32_t SETA2R_MSTPER = 0x80;        // MSTPER
    static constexpr uint32_t SETA2R_CMP4 = 0x40;          // CMP4
    static constexpr uint32_t SETA2R_CMP3 = 0x20;          // CMP3
    static constexpr uint32_t SETA2R_CMP2 = 0x10;          // CMP2
    static constexpr uint32_t SETA2R_CMP1 = 0x8;           // CMP1
    static constexpr uint32_t SETA2R_PER = 0x4;            // PER
    static constexpr uint32_t SETA2R_RESYNC = 0x2;         // RESYNC
    static constexpr uint32_t SETA2R_SST = 0x1;            // SST
    static const uint32_t SETA2R_RESET_VALUE = 0x0;

    static constexpr uint32_t RSTA2R_UPDATE = 0x80000000;  // UPDATE
    static constexpr uint32_t RSTA2R_EXTEVNT10 = 0x40000000;// EXTEVNT10
    static constexpr uint32_t RSTA2R_EXTEVNT9 = 0x20000000;// EXTEVNT9
    static constexpr uint32_t RSTA2R_EXTEVNT8 = 0x10000000;// EXTEVNT8
    static constexpr uint32_t RSTA2R_EXTEVNT7 = 0x8000000; // EXTEVNT7
    static constexpr uint32_t RSTA2R_EXTEVNT6 = 0x4000000; // EXTEVNT6
    static constexpr uint32_t RSTA2R_EXTEVNT5 = 0x2000000; // EXTEVNT5
    static constexpr uint32_t RSTA2R_EXTEVNT4 = 0x1000000; // EXTEVNT4
    static constexpr uint32_t RSTA2R_EXTEVNT3 = 0x800000;  // EXTEVNT3
    static constexpr uint32_t RSTA2R_EXTEVNT2 = 0x400000;  // EXTEVNT2
    static constexpr uint32_t RSTA2R_EXTEVNT1 = 0x200000;  // EXTEVNT1
    static constexpr uint32_t RSTA2R_TIMEVNT9 = 0x100000;  // TIMEVNT9
    static constexpr uint32_t RSTA2R_TIMEVNT8 = 0x80000;   // TIMEVNT8
    static constexpr uint32_t RSTA2R_TIMEVNT7 = 0x40000;   // TIMEVNT7
    static constexpr uint32_t RSTA2R_TIMEVNT6 = 0x20000;   // TIMEVNT6
    static constexpr uint32_t RSTA2R_TIMEVNT5 = 0x10000;   // TIMEVNT5
    static constexpr uint32_t RSTA2R_TIMEVNT4 = 0x8000;    // TIMEVNT4
    static constexpr uint32_t RSTA2R_TIMEVNT3 = 0x4000;    // TIMEVNT3
    static constexpr uint32_t RSTA2R_TIMEVNT2 = 0x2000;    // TIMEVNT2
    static constexpr uint32_t RSTA2R_TIMEVNT1 = 0x1000;    // TIMEVNT1
    static constexpr uint32_t RSTA2R_MSTCMP4 = 0x800;      // MSTCMP4
    static constexpr uint32_t RSTA2R_MSTCMP3 = 0x400;      // MSTCMP3
    static constexpr uint32_t RSTA2R_MSTCMP2 = 0x200;      // MSTCMP2
    static constexpr uint32_t RSTA2R_MSTCMP1 = 0x100;      // MSTCMP1
    static constexpr uint32_t RSTA2R_MSTPER = 0x80;        // MSTPER
    static constexpr uint32_t RSTA2R_CMP4 = 0x40;          // CMP4
    static constexpr uint32_t RSTA2R_CMP3 = 0x20;          // CMP3
    static constexpr uint32_t RSTA2R_CMP2 = 0x10;          // CMP2
    static constexpr uint32_t RSTA2R_CMP1 = 0x8;           // CMP1
    static constexpr uint32_t RSTA2R_PER = 0x4;            // PER
    static constexpr uint32_t RSTA2R_RESYNC = 0x2;         // RESYNC
    static constexpr uint32_t RSTA2R_SRT = 0x1;            // SRT
    static const uint32_t RSTA2R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t EEFAR1_EE5FLTR =             // External Event 5 filter (4 bits)
        bit_field_t<25, 0xf>::value<X>();
    static constexpr uint32_t EEFAR1_EE5LTCH = 0x1000000;  // External Event 5 latch
    template<uint32_t X>
    static constexpr uint32_t EEFAR1_EE4FLTR =             // External Event 4 filter (4 bits)
        bit_field_t<19, 0xf>::value<X>();
    static constexpr uint32_t EEFAR1_EE4LTCH = 0x40000;    // External Event 4 latch
    template<uint32_t X>
    static constexpr uint32_t EEFAR1_EE3FLTR =             // External Event 3 filter (4 bits)
        bit_field_t<13, 0xf>::value<X>();
    static constexpr uint32_t EEFAR1_EE3LTCH = 0x1000;     // External Event 3 latch
    template<uint32_t X>
    static constexpr uint32_t EEFAR1_EE2FLTR =             // External Event 2 filter (4 bits)
        bit_field_t<7, 0xf>::value<X>();
    static constexpr uint32_t EEFAR1_EE2LTCH = 0x40;       // External Event 2 latch
    template<uint32_t X>
    static constexpr uint32_t EEFAR1_EE1FLTR =             // External Event 1 filter (4 bits)
        bit_field_t<1, 0xf>::value<X>();
    static constexpr uint32_t EEFAR1_EE1LTCH = 0x1;        // External Event 1 latch
    static const uint32_t EEFAR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t EEFAR2_EE10FLTR =            // External Event 10 filter (4 bits)
        bit_field_t<25, 0xf>::value<X>();
    static constexpr uint32_t EEFAR2_EE10LTCH = 0x1000000; // External Event 10 latch
    template<uint32_t X>
    static constexpr uint32_t EEFAR2_EE9FLTR =             // External Event 9 filter (4 bits)
        bit_field_t<19, 0xf>::value<X>();
    static constexpr uint32_t EEFAR2_EE9LTCH = 0x40000;    // External Event 9 latch
    template<uint32_t X>
    static constexpr uint32_t EEFAR2_EE8FLTR =             // External Event 8 filter (4 bits)
        bit_field_t<13, 0xf>::value<X>();
    static constexpr uint32_t EEFAR2_EE8LTCH = 0x1000;     // External Event 8 latch
    template<uint32_t X>
    static constexpr uint32_t EEFAR2_EE7FLTR =             // External Event 7 filter (4 bits)
        bit_field_t<7, 0xf>::value<X>();
    static constexpr uint32_t EEFAR2_EE7LTCH = 0x40;       // External Event 7 latch
    template<uint32_t X>
    static constexpr uint32_t EEFAR2_EE6FLTR =             // External Event 6 filter (4 bits)
        bit_field_t<1, 0xf>::value<X>();
    static constexpr uint32_t EEFAR2_EE6LTCH = 0x1;        // External Event 6 latch
    static const uint32_t EEFAR2_RESET_VALUE = 0x0;

    static constexpr uint32_t RSTAR_TIMECMP4 = 0x40000000;// Timer E Compare 4
    static constexpr uint32_t RSTAR_TIMECMP2 = 0x20000000;// Timer E Compare 2
    static constexpr uint32_t RSTAR_TIMECMP1 = 0x10000000;// Timer E Compare 1
    static constexpr uint32_t RSTAR_TIMDCMP4 = 0x8000000; // Timer D Compare 4
    static constexpr uint32_t RSTAR_TIMDCMP2 = 0x4000000; // Timer D Compare 2
    static constexpr uint32_t RSTAR_TIMDCMP1 = 0x2000000; // Timer D Compare 1
    static constexpr uint32_t RSTAR_TIMCCMP4 = 0x1000000; // Timer C Compare 4
    static constexpr uint32_t RSTAR_TIMCCMP2 = 0x800000;  // Timer C Compare 2
    static constexpr uint32_t RSTAR_TIMCCMP1 = 0x400000;  // Timer C Compare 1
    static constexpr uint32_t RSTAR_TIMBCMP4 = 0x200000;  // Timer B Compare 4
    static constexpr uint32_t RSTAR_TIMBCMP2 = 0x100000;  // Timer B Compare 2
    static constexpr uint32_t RSTAR_TIMBCMP1 = 0x80000;   // Timer B Compare 1
    static constexpr uint32_t RSTAR_EXTEVNT10 = 0x40000;  // External Event 10
    static constexpr uint32_t RSTAR_EXTEVNT9 = 0x20000;   // External Event 9
    static constexpr uint32_t RSTAR_EXTEVNT8 = 0x10000;   // External Event 8
    static constexpr uint32_t RSTAR_EXTEVNT7 = 0x8000;    // External Event 7
    static constexpr uint32_t RSTAR_EXTEVNT6 = 0x4000;    // External Event 6
    static constexpr uint32_t RSTAR_EXTEVNT5 = 0x2000;    // External Event 5
    static constexpr uint32_t RSTAR_EXTEVNT4 = 0x1000;    // External Event 4
    static constexpr uint32_t RSTAR_EXTEVNT3 = 0x800;     // External Event 3
    static constexpr uint32_t RSTAR_EXTEVNT2 = 0x400;     // External Event 2
    static constexpr uint32_t RSTAR_EXTEVNT1 = 0x200;     // External Event 1
    static constexpr uint32_t RSTAR_MSTCMP4 = 0x100;      // Master compare 4
    static constexpr uint32_t RSTAR_MSTCMP3 = 0x80;       // Master compare 3
    static constexpr uint32_t RSTAR_MSTCMP2 = 0x40;       // Master compare 2
    static constexpr uint32_t RSTAR_MSTCMP1 = 0x20;       // Master compare 1
    static constexpr uint32_t RSTAR_MSTPER = 0x10;        // Master timer Period
    static constexpr uint32_t RSTAR_CMP4 = 0x8;           // Timer A compare 4 reset
    static constexpr uint32_t RSTAR_CMP2 = 0x4;           // Timer A compare 2 reset
    static constexpr uint32_t RSTAR_UPDT = 0x2;           // Timer A Update reset
    static const uint32_t RSTAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHPAR_STRTPW =              // STRTPW (4 bits)
        bit_field_t<7, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHPAR_CHPDTY =              // Timerx chopper duty cycle value (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHPAR_CHPFRQ =              // Timerx carrier frequency value (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t CHPAR_RESET_VALUE = 0x0;

    static constexpr uint32_t CPT1ACR_TECMP2 = 0x80000000;  // Timer E Compare 2
    static constexpr uint32_t CPT1ACR_TECMP1 = 0x40000000;  // Timer E Compare 1
    static constexpr uint32_t CPT1ACR_TE1RST = 0x20000000;  // Timer E output 1 Reset
    static constexpr uint32_t CPT1ACR_TE1SET = 0x10000000;  // Timer E output 1 Set
    static constexpr uint32_t CPT1ACR_TDCMP2 = 0x8000000;   // Timer D Compare 2
    static constexpr uint32_t CPT1ACR_TDCMP1 = 0x4000000;   // Timer D Compare 1
    static constexpr uint32_t CPT1ACR_TD1RST = 0x2000000;   // Timer D output 1 Reset
    static constexpr uint32_t CPT1ACR_TD1SET = 0x1000000;   // Timer D output 1 Set
    static constexpr uint32_t CPT1ACR_TCCMP2 = 0x800000;    // Timer C Compare 2
    static constexpr uint32_t CPT1ACR_TCCMP1 = 0x400000;    // Timer C Compare 1
    static constexpr uint32_t CPT1ACR_TC1RST = 0x200000;    // Timer C output 1 Reset
    static constexpr uint32_t CPT1ACR_TC1SET = 0x100000;    // Timer C output 1 Set
    static constexpr uint32_t CPT1ACR_TBCMP2 = 0x80000;     // Timer B Compare 2
    static constexpr uint32_t CPT1ACR_TBCMP1 = 0x40000;     // Timer B Compare 1
    static constexpr uint32_t CPT1ACR_TB1RST = 0x20000;     // Timer B output 1 Reset
    static constexpr uint32_t CPT1ACR_TB1SET = 0x10000;     // Timer B output 1 Set
    static constexpr uint32_t CPT1ACR_EXEV10CPT = 0x800;    // External Event 10 Capture
    static constexpr uint32_t CPT1ACR_EXEV9CPT = 0x400;     // External Event 9 Capture
    static constexpr uint32_t CPT1ACR_EXEV8CPT = 0x200;     // External Event 8 Capture
    static constexpr uint32_t CPT1ACR_EXEV7CPT = 0x100;     // External Event 7 Capture
    static constexpr uint32_t CPT1ACR_EXEV6CPT = 0x80;      // External Event 6 Capture
    static constexpr uint32_t CPT1ACR_EXEV5CPT = 0x40;      // External Event 5 Capture
    static constexpr uint32_t CPT1ACR_EXEV4CPT = 0x20;      // External Event 4 Capture
    static constexpr uint32_t CPT1ACR_EXEV3CPT = 0x10;      // External Event 3 Capture
    static constexpr uint32_t CPT1ACR_EXEV2CPT = 0x8;       // External Event 2 Capture
    static constexpr uint32_t CPT1ACR_EXEV1CPT = 0x4;       // External Event 1 Capture
    static constexpr uint32_t CPT1ACR_UDPCPT = 0x2;         // Update Capture
    static constexpr uint32_t CPT1ACR_SWCPT = 0x1;          // Software Capture
    static const uint32_t CPT1ACR_RESET_VALUE = 0x0;

    static constexpr uint32_t CPT2ACR_TECMP2 = 0x80000000;  // Timer E Compare 2
    static constexpr uint32_t CPT2ACR_TECMP1 = 0x40000000;  // Timer E Compare 1
    static constexpr uint32_t CPT2ACR_TE1RST = 0x20000000;  // Timer E output 1 Reset
    static constexpr uint32_t CPT2ACR_TE1SET = 0x10000000;  // Timer E output 1 Set
    static constexpr uint32_t CPT2ACR_TDCMP2 = 0x8000000;   // Timer D Compare 2
    static constexpr uint32_t CPT2ACR_TDCMP1 = 0x4000000;   // Timer D Compare 1
    static constexpr uint32_t CPT2ACR_TD1RST = 0x2000000;   // Timer D output 1 Reset
    static constexpr uint32_t CPT2ACR_TD1SET = 0x1000000;   // Timer D output 1 Set
    static constexpr uint32_t CPT2ACR_TCCMP2 = 0x800000;    // Timer C Compare 2
    static constexpr uint32_t CPT2ACR_TCCMP1 = 0x400000;    // Timer C Compare 1
    static constexpr uint32_t CPT2ACR_TC1RST = 0x200000;    // Timer C output 1 Reset
    static constexpr uint32_t CPT2ACR_TC1SET = 0x100000;    // Timer C output 1 Set
    static constexpr uint32_t CPT2ACR_TBCMP2 = 0x80000;     // Timer B Compare 2
    static constexpr uint32_t CPT2ACR_TBCMP1 = 0x40000;     // Timer B Compare 1
    static constexpr uint32_t CPT2ACR_TB1RST = 0x20000;     // Timer B output 1 Reset
    static constexpr uint32_t CPT2ACR_TB1SET = 0x10000;     // Timer B output 1 Set
    static constexpr uint32_t CPT2ACR_EXEV10CPT = 0x800;    // External Event 10 Capture
    static constexpr uint32_t CPT2ACR_EXEV9CPT = 0x400;     // External Event 9 Capture
    static constexpr uint32_t CPT2ACR_EXEV8CPT = 0x200;     // External Event 8 Capture
    static constexpr uint32_t CPT2ACR_EXEV7CPT = 0x100;     // External Event 7 Capture
    static constexpr uint32_t CPT2ACR_EXEV6CPT = 0x80;      // External Event 6 Capture
    static constexpr uint32_t CPT2ACR_EXEV5CPT = 0x40;      // External Event 5 Capture
    static constexpr uint32_t CPT2ACR_EXEV4CPT = 0x20;      // External Event 4 Capture
    static constexpr uint32_t CPT2ACR_EXEV3CPT = 0x10;      // External Event 3 Capture
    static constexpr uint32_t CPT2ACR_EXEV2CPT = 0x8;       // External Event 2 Capture
    static constexpr uint32_t CPT2ACR_EXEV1CPT = 0x4;       // External Event 1 Capture
    static constexpr uint32_t CPT2ACR_UDPCPT = 0x2;         // Update Capture
    static constexpr uint32_t CPT2ACR_SWCPT = 0x1;          // Software Capture
    static const uint32_t CPT2ACR_RESET_VALUE = 0x0;

    static constexpr uint32_t OUTAR_DIDL2 = 0x800000;     // Output 2 Deadtime upon burst mode Idle entry
    static constexpr uint32_t OUTAR_CHP2 = 0x400000;      // Output 2 Chopper enable
    template<uint32_t X>
    static constexpr uint32_t OUTAR_FAULT2 =              // Output 2 Fault state (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    static constexpr uint32_t OUTAR_IDLES2 = 0x80000;     // Output 2 Idle State
    static constexpr uint32_t OUTAR_IDLEM2 = 0x40000;     // Output 2 Idle mode
    static constexpr uint32_t OUTAR_POL2 = 0x20000;       // Output 2 polarity
    template<uint32_t X>
    static constexpr uint32_t OUTAR_DLYPRT =              // Delayed Protection (3 bits)
        bit_field_t<10, 0x7>::value<X>();
    static constexpr uint32_t OUTAR_DLYPRTEN = 0x200;     // Delayed Protection Enable
    static constexpr uint32_t OUTAR_DTEN = 0x100;         // Deadtime enable
    static constexpr uint32_t OUTAR_DIDL1 = 0x80;         // Output 1 Deadtime upon burst mode Idle entry
    static constexpr uint32_t OUTAR_CHP1 = 0x40;          // Output 1 Chopper enable
    template<uint32_t X>
    static constexpr uint32_t OUTAR_FAULT1 =              // Output 1 Fault state (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static constexpr uint32_t OUTAR_IDLES1 = 0x8;         // Output 1 Idle State
    static constexpr uint32_t OUTAR_IDLEM1 = 0x4;         // Output 1 Idle mode
    static constexpr uint32_t OUTAR_POL1 = 0x2;           // Output 1 polarity
    static const uint32_t OUTAR_RESET_VALUE = 0x0;

    static constexpr uint32_t FLTAR_FLTLCK = 0x80000000;  // Fault sources Lock
    static constexpr uint32_t FLTAR_FLT5EN = 0x10;        // Fault 5 enable
    static constexpr uint32_t FLTAR_FLT4EN = 0x8;         // Fault 4 enable
    static constexpr uint32_t FLTAR_FLT3EN = 0x4;         // Fault 3 enable
    static constexpr uint32_t FLTAR_FLT2EN = 0x2;         // Fault 2 enable
    static constexpr uint32_t FLTAR_FLT1EN = 0x1;         // Fault 1 enable
    static const uint32_t FLTAR_RESET_VALUE = 0x0;

    static constexpr uint8_t HRTIM1_FLT = 109; // HRTIM1 fault interrupt
    static constexpr uint8_t HRTIM1_MST = 103; // HRTIM1 master timer interrupt
};

static hrtim_tima_t& HRTIM_TIMA = *reinterpret_cast<hrtim_tima_t*>(0x40017480);

#define HAVE_PERIPHERAL_HRTIM_TIMA


////
//
//    High Resolution Timer: TIMB
//
////

struct hrtim_timb_t
{
    volatile uint32_t    TIMBCR;               // [Read-write] Timerx Control Register
    volatile uint32_t    TIMBISR;              // [Read-only] Timerx Interrupt Status Register
    volatile uint32_t    TIMBICR;              // [Write-only] Timerx Interrupt Clear Register
    volatile uint32_t    TIMBDIER5;            // [Read-write] TIMxDIER5
    volatile uint32_t    CNTR;                 // [Read-write] Timerx Counter Register
    volatile uint32_t    PERBR;                // [Read-write] Timerx Period Register
    volatile uint32_t    REPBR;                // [Read-write] Timerx Repetition Register
    volatile uint32_t    CMP1BR;               // [Read-write] Timerx Compare 1 Register
    volatile uint32_t    CMP1CBR;              // [Read-write] Timerx Compare 1 Compound Register
    volatile uint32_t    CMP2BR;               // [Read-write] Timerx Compare 2 Register
    volatile uint32_t    CMP3BR;               // [Read-write] Timerx Compare 3 Register
    volatile uint32_t    CMP4BR;               // [Read-write] Timerx Compare 4 Register
    volatile uint32_t    CPT1BR;               // [Read-only] Timerx Capture 1 Register
    volatile uint32_t    CPT2BR;               // [Read-only] Timerx Capture 2 Register
    volatile uint32_t    DTBR;                 // [Read-write] Timerx Deadtime Register
    volatile uint32_t    SETB1R;               // [Read-write] Timerx Output1 Set Register
    volatile uint32_t    RSTB1R;               // [Read-write] Timerx Output1 Reset Register
    volatile uint32_t    SETB2R;               // [Read-write] Timerx Output2 Set Register
    volatile uint32_t    RSTB2R;               // [Read-write] Timerx Output2 Reset Register
    volatile uint32_t    EEFBR1;               // [Read-write] Timerx External Event Filtering Register 1
    volatile uint32_t    EEFBR2;               // [Read-write] Timerx External Event Filtering Register 2
    volatile uint32_t    RSTBR;                // [Read-write] TimerA Reset Register
    volatile uint32_t    CHPBR;                // [Read-write] Timerx Chopper Register
    volatile uint32_t    CPT1BCR;              // [Read-write] Timerx Capture 2 Control Register
    volatile uint32_t    CPT2BCR;              // [Read-write] CPT2xCR
    volatile uint32_t    OUTBR;                // [Read-write] Timerx Output Register
    volatile uint32_t    FLTBR;                // [Read-write] Timerx Fault Register

    template<uint32_t X>
    static constexpr uint32_t TIMBCR_UPDGAT =              // Update Gating (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    static constexpr uint32_t TIMBCR_PREEN = 0x8000000;    // Preload enable
    template<uint32_t X>
    static constexpr uint32_t TIMBCR_DACSYNC =             // AC Synchronization (2 bits)
        bit_field_t<25, 0x3>::value<X>();
    static constexpr uint32_t TIMBCR_MSTU = 0x1000000;     // Master Timer update
    static constexpr uint32_t TIMBCR_TEU = 0x800000;       // TEU
    static constexpr uint32_t TIMBCR_TDU = 0x400000;       // TDU
    static constexpr uint32_t TIMBCR_TCU = 0x200000;       // TCU
    static constexpr uint32_t TIMBCR_TBU = 0x100000;       // TBU
    static constexpr uint32_t TIMBCR_TxRSTU = 0x40000;     // Timerx reset update
    static constexpr uint32_t TIMBCR_TxREPU = 0x20000;     // Timer x Repetition update
    template<uint32_t X>
    static constexpr uint32_t TIMBCR_DELCMP4 =             // Delayed CMP4 mode (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TIMBCR_DELCMP2 =             // Delayed CMP2 mode (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    static constexpr uint32_t TIMBCR_SYNCSTRTx = 0x800;    // Synchronization Starts Timer x
    static constexpr uint32_t TIMBCR_SYNCRSTx = 0x400;     // Synchronization Resets Timer x
    static constexpr uint32_t TIMBCR_PSHPLL = 0x40;        // Push-Pull mode enable
    static constexpr uint32_t TIMBCR_HALF = 0x20;          // Half mode enable
    static constexpr uint32_t TIMBCR_RETRIG = 0x10;        // Re-triggerable mode
    static constexpr uint32_t TIMBCR_CONT = 0x8;           // Continuous mode
    template<uint32_t X>
    static constexpr uint32_t TIMBCR_CK_PSCx =             // HRTIM Timer x Clock prescaler (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t TIMBCR_RESET_VALUE = 0x0;

    static constexpr uint32_t TIMBISR_O2STAT = 0x80000;     // Output 2 State
    static constexpr uint32_t TIMBISR_O1STAT = 0x40000;     // Output 1 State
    static constexpr uint32_t TIMBISR_IPPSTAT = 0x20000;    // Idle Push Pull Status
    static constexpr uint32_t TIMBISR_CPPSTAT = 0x10000;    // Current Push Pull Status
    static constexpr uint32_t TIMBISR_DLYPRT = 0x4000;      // Delayed Protection Flag
    static constexpr uint32_t TIMBISR_RST = 0x2000;         // Reset Interrupt Flag
    static constexpr uint32_t TIMBISR_RSTx2 = 0x1000;       // Output 2 Reset Interrupt Flag
    static constexpr uint32_t TIMBISR_SETx2 = 0x800;        // Output 2 Set Interrupt Flag
    static constexpr uint32_t TIMBISR_RSTx1 = 0x400;        // Output 1 Reset Interrupt Flag
    static constexpr uint32_t TIMBISR_SETx1 = 0x200;        // Output 1 Set Interrupt Flag
    static constexpr uint32_t TIMBISR_CPT2 = 0x100;         // Capture2 Interrupt Flag
    static constexpr uint32_t TIMBISR_CPT1 = 0x80;          // Capture1 Interrupt Flag
    static constexpr uint32_t TIMBISR_UPD = 0x40;           // Update Interrupt Flag
    static constexpr uint32_t TIMBISR_REP = 0x10;           // Repetition Interrupt Flag
    static constexpr uint32_t TIMBISR_CMP4 = 0x8;           // Compare 4 Interrupt Flag
    static constexpr uint32_t TIMBISR_CMP3 = 0x4;           // Compare 3 Interrupt Flag
    static constexpr uint32_t TIMBISR_CMP2 = 0x2;           // Compare 2 Interrupt Flag
    static constexpr uint32_t TIMBISR_CMP1 = 0x1;           // Compare 1 Interrupt Flag
    static const uint32_t TIMBISR_RESET_VALUE = 0x0;

    static constexpr uint32_t TIMBICR_DLYPRTC = 0x4000;     // Delayed Protection Flag Clear
    static constexpr uint32_t TIMBICR_RSTC = 0x2000;        // Reset Interrupt flag Clear
    static constexpr uint32_t TIMBICR_RSTx2C = 0x1000;      // Output 2 Reset flag Clear
    static constexpr uint32_t TIMBICR_SET2xC = 0x800;       // Output 2 Set flag Clear
    static constexpr uint32_t TIMBICR_RSTx1C = 0x400;       // Output 1 Reset flag Clear
    static constexpr uint32_t TIMBICR_SET1xC = 0x200;       // Output 1 Set flag Clear
    static constexpr uint32_t TIMBICR_CPT2C = 0x100;        // Capture2 Interrupt flag Clear
    static constexpr uint32_t TIMBICR_CPT1C = 0x80;         // Capture1 Interrupt flag Clear
    static constexpr uint32_t TIMBICR_UPDC = 0x40;          // Update Interrupt flag Clear
    static constexpr uint32_t TIMBICR_REPC = 0x10;          // Repetition Interrupt flag Clear
    static constexpr uint32_t TIMBICR_CMP4C = 0x8;          // Compare 4 Interrupt flag Clear
    static constexpr uint32_t TIMBICR_CMP3C = 0x4;          // Compare 3 Interrupt flag Clear
    static constexpr uint32_t TIMBICR_CMP2C = 0x2;          // Compare 2 Interrupt flag Clear
    static constexpr uint32_t TIMBICR_CMP1C = 0x1;          // Compare 1 Interrupt flag Clear
    static const uint32_t TIMBICR_RESET_VALUE = 0x0;

    static constexpr uint32_t TIMBDIER5_DLYPRTDE = 0x40000000;// DLYPRTDE
    static constexpr uint32_t TIMBDIER5_RSTDE = 0x20000000;   // RSTDE
    static constexpr uint32_t TIMBDIER5_RSTx2DE = 0x10000000; // RSTx2DE
    static constexpr uint32_t TIMBDIER5_SETx2DE = 0x8000000;  // SETx2DE
    static constexpr uint32_t TIMBDIER5_RSTx1DE = 0x4000000;  // RSTx1DE
    static constexpr uint32_t TIMBDIER5_SET1xDE = 0x2000000;  // SET1xDE
    static constexpr uint32_t TIMBDIER5_CPT2DE = 0x1000000;   // CPT2DE
    static constexpr uint32_t TIMBDIER5_CPT1DE = 0x800000;    // CPT1DE
    static constexpr uint32_t TIMBDIER5_UPDDE = 0x400000;     // UPDDE
    static constexpr uint32_t TIMBDIER5_REPDE = 0x100000;     // REPDE
    static constexpr uint32_t TIMBDIER5_CMP4DE = 0x80000;     // CMP4DE
    static constexpr uint32_t TIMBDIER5_CMP3DE = 0x40000;     // CMP3DE
    static constexpr uint32_t TIMBDIER5_CMP2DE = 0x20000;     // CMP2DE
    static constexpr uint32_t TIMBDIER5_CMP1DE = 0x10000;     // CMP1DE
    static constexpr uint32_t TIMBDIER5_DLYPRTIE = 0x4000;    // DLYPRTIE
    static constexpr uint32_t TIMBDIER5_RSTIE = 0x2000;       // RSTIE
    static constexpr uint32_t TIMBDIER5_RSTx2IE = 0x1000;     // RSTx2IE
    static constexpr uint32_t TIMBDIER5_SETx2IE = 0x800;      // SETx2IE
    static constexpr uint32_t TIMBDIER5_RSTx1IE = 0x400;      // RSTx1IE
    static constexpr uint32_t TIMBDIER5_SET1xIE = 0x200;      // SET1xIE
    static constexpr uint32_t TIMBDIER5_CPT2IE = 0x100;       // CPT2IE
    static constexpr uint32_t TIMBDIER5_CPT1IE = 0x80;        // CPT1IE
    static constexpr uint32_t TIMBDIER5_UPDIE = 0x40;         // UPDIE
    static constexpr uint32_t TIMBDIER5_REPIE = 0x10;         // REPIE
    static constexpr uint32_t TIMBDIER5_CMP4IE = 0x8;         // CMP4IE
    static constexpr uint32_t TIMBDIER5_CMP3IE = 0x4;         // CMP3IE
    static constexpr uint32_t TIMBDIER5_CMP2IE = 0x2;         // CMP2IE
    static constexpr uint32_t TIMBDIER5_CMP1IE = 0x1;         // CMP1IE
    static const uint32_t TIMBDIER5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CNTR_CNTx =                // Timerx Counter value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CNTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PERBR_PERx =                // Timerx Period value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t PERBR_RESET_VALUE = 0xffff;

    template<uint32_t X>
    static constexpr uint32_t REPBR_REPx =                // Timerx Repetition counter value (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t REPBR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CMP1BR_CMP1x =               // Timerx Compare 1 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CMP1BR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CMP1CBR_REPx =                // Timerx Repetition value (aliased from HRTIM_REPx register) (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CMP1CBR_CMP1x =               // Timerx Compare 1 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CMP1CBR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CMP2BR_CMP2x =               // Timerx Compare 2 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CMP2BR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CMP3BR_CMP3x =               // Timerx Compare 3 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CMP3BR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CMP4BR_CMP4x =               // Timerx Compare 4 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CMP4BR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CPT1BR_CPT1x =               // Timerx Capture 1 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CPT1BR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CPT2BR_CPT2x =               // Timerx Capture 2 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CPT2BR_RESET_VALUE = 0x0;

    static constexpr uint32_t DTBR_DTFLKx = 0x80000000;  // Deadtime Falling Lock
    static constexpr uint32_t DTBR_DTFSLKx = 0x40000000; // Deadtime Falling Sign Lock
    static constexpr uint32_t DTBR_SDTFx = 0x2000000;    // Sign Deadtime Falling value
    template<uint32_t X>
    static constexpr uint32_t DTBR_DTFx =                // Deadtime Falling value (9 bits)
        bit_field_t<16, 0x1ff>::value<X>();
    static constexpr uint32_t DTBR_DTRLKx = 0x8000;      // Deadtime Rising Lock
    static constexpr uint32_t DTBR_DTRSLKx = 0x4000;     // Deadtime Rising Sign Lock
    template<uint32_t X>
    static constexpr uint32_t DTBR_DTPRSC =              // Deadtime Prescaler (3 bits)
        bit_field_t<10, 0x7>::value<X>();
    static constexpr uint32_t DTBR_SDTRx = 0x200;        // Sign Deadtime Rising value
    template<uint32_t X>
    static constexpr uint32_t DTBR_DTRx =                // Deadtime Rising value (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static const uint32_t DTBR_RESET_VALUE = 0x0;

    static constexpr uint32_t SETB1R_UPDATE = 0x80000000;  // Registers update (transfer preload to active)
    static constexpr uint32_t SETB1R_EXTEVNT10 = 0x40000000;// External Event 10
    static constexpr uint32_t SETB1R_EXTEVNT9 = 0x20000000;// External Event 9
    static constexpr uint32_t SETB1R_EXTEVNT8 = 0x10000000;// External Event 8
    static constexpr uint32_t SETB1R_EXTEVNT7 = 0x8000000; // External Event 7
    static constexpr uint32_t SETB1R_EXTEVNT6 = 0x4000000; // External Event 6
    static constexpr uint32_t SETB1R_EXTEVNT5 = 0x2000000; // External Event 5
    static constexpr uint32_t SETB1R_EXTEVNT4 = 0x1000000; // External Event 4
    static constexpr uint32_t SETB1R_EXTEVNT3 = 0x800000;  // External Event 3
    static constexpr uint32_t SETB1R_EXTEVNT2 = 0x400000;  // External Event 2
    static constexpr uint32_t SETB1R_EXTEVNT1 = 0x200000;  // External Event 1
    static constexpr uint32_t SETB1R_TIMEVNT9 = 0x100000;  // Timer Event 9
    static constexpr uint32_t SETB1R_TIMEVNT8 = 0x80000;   // Timer Event 8
    static constexpr uint32_t SETB1R_TIMEVNT7 = 0x40000;   // Timer Event 7
    static constexpr uint32_t SETB1R_TIMEVNT6 = 0x20000;   // Timer Event 6
    static constexpr uint32_t SETB1R_TIMEVNT5 = 0x10000;   // Timer Event 5
    static constexpr uint32_t SETB1R_TIMEVNT4 = 0x8000;    // Timer Event 4
    static constexpr uint32_t SETB1R_TIMEVNT3 = 0x4000;    // Timer Event 3
    static constexpr uint32_t SETB1R_TIMEVNT2 = 0x2000;    // Timer Event 2
    static constexpr uint32_t SETB1R_TIMEVNT1 = 0x1000;    // Timer Event 1
    static constexpr uint32_t SETB1R_MSTCMP4 = 0x800;      // Master Compare 4
    static constexpr uint32_t SETB1R_MSTCMP3 = 0x400;      // Master Compare 3
    static constexpr uint32_t SETB1R_MSTCMP2 = 0x200;      // Master Compare 2
    static constexpr uint32_t SETB1R_MSTCMP1 = 0x100;      // Master Compare 1
    static constexpr uint32_t SETB1R_MSTPER = 0x80;        // Master Period
    static constexpr uint32_t SETB1R_CMP4 = 0x40;          // Timer A compare 4
    static constexpr uint32_t SETB1R_CMP3 = 0x20;          // Timer A compare 3
    static constexpr uint32_t SETB1R_CMP2 = 0x10;          // Timer A compare 2
    static constexpr uint32_t SETB1R_CMP1 = 0x8;           // Timer A compare 1
    static constexpr uint32_t SETB1R_PER = 0x4;            // Timer A Period
    static constexpr uint32_t SETB1R_RESYNC = 0x2;         // Timer A resynchronizaton
    static constexpr uint32_t SETB1R_SST = 0x1;            // Software Set trigger
    static const uint32_t SETB1R_RESET_VALUE = 0x0;

    static constexpr uint32_t RSTB1R_UPDATE = 0x80000000;  // UPDATE
    static constexpr uint32_t RSTB1R_EXTEVNT10 = 0x40000000;// EXTEVNT10
    static constexpr uint32_t RSTB1R_EXTEVNT9 = 0x20000000;// EXTEVNT9
    static constexpr uint32_t RSTB1R_EXTEVNT8 = 0x10000000;// EXTEVNT8
    static constexpr uint32_t RSTB1R_EXTEVNT7 = 0x8000000; // EXTEVNT7
    static constexpr uint32_t RSTB1R_EXTEVNT6 = 0x4000000; // EXTEVNT6
    static constexpr uint32_t RSTB1R_EXTEVNT5 = 0x2000000; // EXTEVNT5
    static constexpr uint32_t RSTB1R_EXTEVNT4 = 0x1000000; // EXTEVNT4
    static constexpr uint32_t RSTB1R_EXTEVNT3 = 0x800000;  // EXTEVNT3
    static constexpr uint32_t RSTB1R_EXTEVNT2 = 0x400000;  // EXTEVNT2
    static constexpr uint32_t RSTB1R_EXTEVNT1 = 0x200000;  // EXTEVNT1
    static constexpr uint32_t RSTB1R_TIMEVNT9 = 0x100000;  // TIMEVNT9
    static constexpr uint32_t RSTB1R_TIMEVNT8 = 0x80000;   // TIMEVNT8
    static constexpr uint32_t RSTB1R_TIMEVNT7 = 0x40000;   // TIMEVNT7
    static constexpr uint32_t RSTB1R_TIMEVNT6 = 0x20000;   // TIMEVNT6
    static constexpr uint32_t RSTB1R_TIMEVNT5 = 0x10000;   // TIMEVNT5
    static constexpr uint32_t RSTB1R_TIMEVNT4 = 0x8000;    // TIMEVNT4
    static constexpr uint32_t RSTB1R_TIMEVNT3 = 0x4000;    // TIMEVNT3
    static constexpr uint32_t RSTB1R_TIMEVNT2 = 0x2000;    // TIMEVNT2
    static constexpr uint32_t RSTB1R_TIMEVNT1 = 0x1000;    // TIMEVNT1
    static constexpr uint32_t RSTB1R_MSTCMP4 = 0x800;      // MSTCMP4
    static constexpr uint32_t RSTB1R_MSTCMP3 = 0x400;      // MSTCMP3
    static constexpr uint32_t RSTB1R_MSTCMP2 = 0x200;      // MSTCMP2
    static constexpr uint32_t RSTB1R_MSTCMP1 = 0x100;      // MSTCMP1
    static constexpr uint32_t RSTB1R_MSTPER = 0x80;        // MSTPER
    static constexpr uint32_t RSTB1R_CMP4 = 0x40;          // CMP4
    static constexpr uint32_t RSTB1R_CMP3 = 0x20;          // CMP3
    static constexpr uint32_t RSTB1R_CMP2 = 0x10;          // CMP2
    static constexpr uint32_t RSTB1R_CMP1 = 0x8;           // CMP1
    static constexpr uint32_t RSTB1R_PER = 0x4;            // PER
    static constexpr uint32_t RSTB1R_RESYNC = 0x2;         // RESYNC
    static constexpr uint32_t RSTB1R_SRT = 0x1;            // SRT
    static const uint32_t RSTB1R_RESET_VALUE = 0x0;

    static constexpr uint32_t SETB2R_UPDATE = 0x80000000;  // UPDATE
    static constexpr uint32_t SETB2R_EXTEVNT10 = 0x40000000;// EXTEVNT10
    static constexpr uint32_t SETB2R_EXTEVNT9 = 0x20000000;// EXTEVNT9
    static constexpr uint32_t SETB2R_EXTEVNT8 = 0x10000000;// EXTEVNT8
    static constexpr uint32_t SETB2R_EXTEVNT7 = 0x8000000; // EXTEVNT7
    static constexpr uint32_t SETB2R_EXTEVNT6 = 0x4000000; // EXTEVNT6
    static constexpr uint32_t SETB2R_EXTEVNT5 = 0x2000000; // EXTEVNT5
    static constexpr uint32_t SETB2R_EXTEVNT4 = 0x1000000; // EXTEVNT4
    static constexpr uint32_t SETB2R_EXTEVNT3 = 0x800000;  // EXTEVNT3
    static constexpr uint32_t SETB2R_EXTEVNT2 = 0x400000;  // EXTEVNT2
    static constexpr uint32_t SETB2R_EXTEVNT1 = 0x200000;  // EXTEVNT1
    static constexpr uint32_t SETB2R_TIMEVNT9 = 0x100000;  // TIMEVNT9
    static constexpr uint32_t SETB2R_TIMEVNT8 = 0x80000;   // TIMEVNT8
    static constexpr uint32_t SETB2R_TIMEVNT7 = 0x40000;   // TIMEVNT7
    static constexpr uint32_t SETB2R_TIMEVNT6 = 0x20000;   // TIMEVNT6
    static constexpr uint32_t SETB2R_TIMEVNT5 = 0x10000;   // TIMEVNT5
    static constexpr uint32_t SETB2R_TIMEVNT4 = 0x8000;    // TIMEVNT4
    static constexpr uint32_t SETB2R_TIMEVNT3 = 0x4000;    // TIMEVNT3
    static constexpr uint32_t SETB2R_TIMEVNT2 = 0x2000;    // TIMEVNT2
    static constexpr uint32_t SETB2R_TIMEVNT1 = 0x1000;    // TIMEVNT1
    static constexpr uint32_t SETB2R_MSTCMP4 = 0x800;      // MSTCMP4
    static constexpr uint32_t SETB2R_MSTCMP3 = 0x400;      // MSTCMP3
    static constexpr uint32_t SETB2R_MSTCMP2 = 0x200;      // MSTCMP2
    static constexpr uint32_t SETB2R_MSTCMP1 = 0x100;      // MSTCMP1
    static constexpr uint32_t SETB2R_MSTPER = 0x80;        // MSTPER
    static constexpr uint32_t SETB2R_CMP4 = 0x40;          // CMP4
    static constexpr uint32_t SETB2R_CMP3 = 0x20;          // CMP3
    static constexpr uint32_t SETB2R_CMP2 = 0x10;          // CMP2
    static constexpr uint32_t SETB2R_CMP1 = 0x8;           // CMP1
    static constexpr uint32_t SETB2R_PER = 0x4;            // PER
    static constexpr uint32_t SETB2R_RESYNC = 0x2;         // RESYNC
    static constexpr uint32_t SETB2R_SST = 0x1;            // SST
    static const uint32_t SETB2R_RESET_VALUE = 0x0;

    static constexpr uint32_t RSTB2R_UPDATE = 0x80000000;  // UPDATE
    static constexpr uint32_t RSTB2R_EXTEVNT10 = 0x40000000;// EXTEVNT10
    static constexpr uint32_t RSTB2R_EXTEVNT9 = 0x20000000;// EXTEVNT9
    static constexpr uint32_t RSTB2R_EXTEVNT8 = 0x10000000;// EXTEVNT8
    static constexpr uint32_t RSTB2R_EXTEVNT7 = 0x8000000; // EXTEVNT7
    static constexpr uint32_t RSTB2R_EXTEVNT6 = 0x4000000; // EXTEVNT6
    static constexpr uint32_t RSTB2R_EXTEVNT5 = 0x2000000; // EXTEVNT5
    static constexpr uint32_t RSTB2R_EXTEVNT4 = 0x1000000; // EXTEVNT4
    static constexpr uint32_t RSTB2R_EXTEVNT3 = 0x800000;  // EXTEVNT3
    static constexpr uint32_t RSTB2R_EXTEVNT2 = 0x400000;  // EXTEVNT2
    static constexpr uint32_t RSTB2R_EXTEVNT1 = 0x200000;  // EXTEVNT1
    static constexpr uint32_t RSTB2R_TIMEVNT9 = 0x100000;  // TIMEVNT9
    static constexpr uint32_t RSTB2R_TIMEVNT8 = 0x80000;   // TIMEVNT8
    static constexpr uint32_t RSTB2R_TIMEVNT7 = 0x40000;   // TIMEVNT7
    static constexpr uint32_t RSTB2R_TIMEVNT6 = 0x20000;   // TIMEVNT6
    static constexpr uint32_t RSTB2R_TIMEVNT5 = 0x10000;   // TIMEVNT5
    static constexpr uint32_t RSTB2R_TIMEVNT4 = 0x8000;    // TIMEVNT4
    static constexpr uint32_t RSTB2R_TIMEVNT3 = 0x4000;    // TIMEVNT3
    static constexpr uint32_t RSTB2R_TIMEVNT2 = 0x2000;    // TIMEVNT2
    static constexpr uint32_t RSTB2R_TIMEVNT1 = 0x1000;    // TIMEVNT1
    static constexpr uint32_t RSTB2R_MSTCMP4 = 0x800;      // MSTCMP4
    static constexpr uint32_t RSTB2R_MSTCMP3 = 0x400;      // MSTCMP3
    static constexpr uint32_t RSTB2R_MSTCMP2 = 0x200;      // MSTCMP2
    static constexpr uint32_t RSTB2R_MSTCMP1 = 0x100;      // MSTCMP1
    static constexpr uint32_t RSTB2R_MSTPER = 0x80;        // MSTPER
    static constexpr uint32_t RSTB2R_CMP4 = 0x40;          // CMP4
    static constexpr uint32_t RSTB2R_CMP3 = 0x20;          // CMP3
    static constexpr uint32_t RSTB2R_CMP2 = 0x10;          // CMP2
    static constexpr uint32_t RSTB2R_CMP1 = 0x8;           // CMP1
    static constexpr uint32_t RSTB2R_PER = 0x4;            // PER
    static constexpr uint32_t RSTB2R_RESYNC = 0x2;         // RESYNC
    static constexpr uint32_t RSTB2R_SRT = 0x1;            // SRT
    static const uint32_t RSTB2R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t EEFBR1_EE5FLTR =             // External Event 5 filter (4 bits)
        bit_field_t<25, 0xf>::value<X>();
    static constexpr uint32_t EEFBR1_EE5LTCH = 0x1000000;  // External Event 5 latch
    template<uint32_t X>
    static constexpr uint32_t EEFBR1_EE4FLTR =             // External Event 4 filter (4 bits)
        bit_field_t<19, 0xf>::value<X>();
    static constexpr uint32_t EEFBR1_EE4LTCH = 0x40000;    // External Event 4 latch
    template<uint32_t X>
    static constexpr uint32_t EEFBR1_EE3FLTR =             // External Event 3 filter (4 bits)
        bit_field_t<13, 0xf>::value<X>();
    static constexpr uint32_t EEFBR1_EE3LTCH = 0x1000;     // External Event 3 latch
    template<uint32_t X>
    static constexpr uint32_t EEFBR1_EE2FLTR =             // External Event 2 filter (4 bits)
        bit_field_t<7, 0xf>::value<X>();
    static constexpr uint32_t EEFBR1_EE2LTCH = 0x40;       // External Event 2 latch
    template<uint32_t X>
    static constexpr uint32_t EEFBR1_EE1FLTR =             // External Event 1 filter (4 bits)
        bit_field_t<1, 0xf>::value<X>();
    static constexpr uint32_t EEFBR1_EE1LTCH = 0x1;        // External Event 1 latch
    static const uint32_t EEFBR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t EEFBR2_EE10FLTR =            // External Event 10 filter (4 bits)
        bit_field_t<25, 0xf>::value<X>();
    static constexpr uint32_t EEFBR2_EE10LTCH = 0x1000000; // External Event 10 latch
    template<uint32_t X>
    static constexpr uint32_t EEFBR2_EE9FLTR =             // External Event 9 filter (4 bits)
        bit_field_t<19, 0xf>::value<X>();
    static constexpr uint32_t EEFBR2_EE9LTCH = 0x40000;    // External Event 9 latch
    template<uint32_t X>
    static constexpr uint32_t EEFBR2_EE8FLTR =             // External Event 8 filter (4 bits)
        bit_field_t<13, 0xf>::value<X>();
    static constexpr uint32_t EEFBR2_EE8LTCH = 0x1000;     // External Event 8 latch
    template<uint32_t X>
    static constexpr uint32_t EEFBR2_EE7FLTR =             // External Event 7 filter (4 bits)
        bit_field_t<7, 0xf>::value<X>();
    static constexpr uint32_t EEFBR2_EE7LTCH = 0x40;       // External Event 7 latch
    template<uint32_t X>
    static constexpr uint32_t EEFBR2_EE6FLTR =             // External Event 6 filter (4 bits)
        bit_field_t<1, 0xf>::value<X>();
    static constexpr uint32_t EEFBR2_EE6LTCH = 0x1;        // External Event 6 latch
    static const uint32_t EEFBR2_RESET_VALUE = 0x0;

    static constexpr uint32_t RSTBR_TIMECMP4 = 0x40000000;// Timer E Compare 4
    static constexpr uint32_t RSTBR_TIMECMP2 = 0x20000000;// Timer E Compare 2
    static constexpr uint32_t RSTBR_TIMECMP1 = 0x10000000;// Timer E Compare 1
    static constexpr uint32_t RSTBR_TIMDCMP4 = 0x8000000; // Timer D Compare 4
    static constexpr uint32_t RSTBR_TIMDCMP2 = 0x4000000; // Timer D Compare 2
    static constexpr uint32_t RSTBR_TIMDCMP1 = 0x2000000; // Timer D Compare 1
    static constexpr uint32_t RSTBR_TIMCCMP4 = 0x1000000; // Timer C Compare 4
    static constexpr uint32_t RSTBR_TIMCCMP2 = 0x800000;  // Timer C Compare 2
    static constexpr uint32_t RSTBR_TIMCCMP1 = 0x400000;  // Timer C Compare 1
    static constexpr uint32_t RSTBR_TIMACMP4 = 0x200000;  // Timer A Compare 4
    static constexpr uint32_t RSTBR_TIMACMP2 = 0x100000;  // Timer A Compare 2
    static constexpr uint32_t RSTBR_TIMACMP1 = 0x80000;   // Timer A Compare 1
    static constexpr uint32_t RSTBR_EXTEVNT10 = 0x40000;  // External Event 10
    static constexpr uint32_t RSTBR_EXTEVNT9 = 0x20000;   // External Event 9
    static constexpr uint32_t RSTBR_EXTEVNT8 = 0x10000;   // External Event 8
    static constexpr uint32_t RSTBR_EXTEVNT7 = 0x8000;    // External Event 7
    static constexpr uint32_t RSTBR_EXTEVNT6 = 0x4000;    // External Event 6
    static constexpr uint32_t RSTBR_EXTEVNT5 = 0x2000;    // External Event 5
    static constexpr uint32_t RSTBR_EXTEVNT4 = 0x1000;    // External Event 4
    static constexpr uint32_t RSTBR_EXTEVNT3 = 0x800;     // External Event 3
    static constexpr uint32_t RSTBR_EXTEVNT2 = 0x400;     // External Event 2
    static constexpr uint32_t RSTBR_EXTEVNT1 = 0x200;     // External Event 1
    static constexpr uint32_t RSTBR_MSTCMP4 = 0x100;      // Master compare 4
    static constexpr uint32_t RSTBR_MSTCMP3 = 0x80;       // Master compare 3
    static constexpr uint32_t RSTBR_MSTCMP2 = 0x40;       // Master compare 2
    static constexpr uint32_t RSTBR_MSTCMP1 = 0x20;       // Master compare 1
    static constexpr uint32_t RSTBR_MSTPER = 0x10;        // Master timer Period
    static constexpr uint32_t RSTBR_CMP4 = 0x8;           // Timer A compare 4 reset
    static constexpr uint32_t RSTBR_CMP2 = 0x4;           // Timer A compare 2 reset
    static constexpr uint32_t RSTBR_UPDT = 0x2;           // Timer A Update reset
    static const uint32_t RSTBR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHPBR_STRTPW =              // STRTPW (4 bits)
        bit_field_t<7, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHPBR_CHPDTY =              // Timerx chopper duty cycle value (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHPBR_CHPFRQ =              // Timerx carrier frequency value (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t CHPBR_RESET_VALUE = 0x0;

    static constexpr uint32_t CPT1BCR_TECMP2 = 0x80000000;  // Timer E Compare 2
    static constexpr uint32_t CPT1BCR_TECMP1 = 0x40000000;  // Timer E Compare 1
    static constexpr uint32_t CPT1BCR_TE1RST = 0x20000000;  // Timer E output 1 Reset
    static constexpr uint32_t CPT1BCR_TE1SET = 0x10000000;  // Timer E output 1 Set
    static constexpr uint32_t CPT1BCR_TDCMP2 = 0x8000000;   // Timer D Compare 2
    static constexpr uint32_t CPT1BCR_TDCMP1 = 0x4000000;   // Timer D Compare 1
    static constexpr uint32_t CPT1BCR_TD1RST = 0x2000000;   // Timer D output 1 Reset
    static constexpr uint32_t CPT1BCR_TD1SET = 0x1000000;   // Timer D output 1 Set
    static constexpr uint32_t CPT1BCR_TCCMP2 = 0x800000;    // Timer C Compare 2
    static constexpr uint32_t CPT1BCR_TCCMP1 = 0x400000;    // Timer C Compare 1
    static constexpr uint32_t CPT1BCR_TC1RST = 0x200000;    // Timer C output 1 Reset
    static constexpr uint32_t CPT1BCR_TC1SET = 0x100000;    // Timer C output 1 Set
    static constexpr uint32_t CPT1BCR_TACMP2 = 0x8000;      // Timer A Compare 2
    static constexpr uint32_t CPT1BCR_TACMP1 = 0x4000;      // Timer A Compare 1
    static constexpr uint32_t CPT1BCR_TA1RST = 0x2000;      // Timer A output 1 Reset
    static constexpr uint32_t CPT1BCR_TA1SET = 0x1000;      // Timer A output 1 Set
    static constexpr uint32_t CPT1BCR_EXEV10CPT = 0x800;    // External Event 10 Capture
    static constexpr uint32_t CPT1BCR_EXEV9CPT = 0x400;     // External Event 9 Capture
    static constexpr uint32_t CPT1BCR_EXEV8CPT = 0x200;     // External Event 8 Capture
    static constexpr uint32_t CPT1BCR_EXEV7CPT = 0x100;     // External Event 7 Capture
    static constexpr uint32_t CPT1BCR_EXEV6CPT = 0x80;      // External Event 6 Capture
    static constexpr uint32_t CPT1BCR_EXEV5CPT = 0x40;      // External Event 5 Capture
    static constexpr uint32_t CPT1BCR_EXEV4CPT = 0x20;      // External Event 4 Capture
    static constexpr uint32_t CPT1BCR_EXEV3CPT = 0x10;      // External Event 3 Capture
    static constexpr uint32_t CPT1BCR_EXEV2CPT = 0x8;       // External Event 2 Capture
    static constexpr uint32_t CPT1BCR_EXEV1CPT = 0x4;       // External Event 1 Capture
    static constexpr uint32_t CPT1BCR_UDPCPT = 0x2;         // Update Capture
    static constexpr uint32_t CPT1BCR_SWCPT = 0x1;          // Software Capture
    static const uint32_t CPT1BCR_RESET_VALUE = 0x0;

    static constexpr uint32_t CPT2BCR_TECMP2 = 0x80000000;  // Timer E Compare 2
    static constexpr uint32_t CPT2BCR_TECMP1 = 0x40000000;  // Timer E Compare 1
    static constexpr uint32_t CPT2BCR_TE1RST = 0x20000000;  // Timer E output 1 Reset
    static constexpr uint32_t CPT2BCR_TE1SET = 0x10000000;  // Timer E output 1 Set
    static constexpr uint32_t CPT2BCR_TDCMP2 = 0x8000000;   // Timer D Compare 2
    static constexpr uint32_t CPT2BCR_TDCMP1 = 0x4000000;   // Timer D Compare 1
    static constexpr uint32_t CPT2BCR_TD1RST = 0x2000000;   // Timer D output 1 Reset
    static constexpr uint32_t CPT2BCR_TD1SET = 0x1000000;   // Timer D output 1 Set
    static constexpr uint32_t CPT2BCR_TCCMP2 = 0x800000;    // Timer C Compare 2
    static constexpr uint32_t CPT2BCR_TCCMP1 = 0x400000;    // Timer C Compare 1
    static constexpr uint32_t CPT2BCR_TC1RST = 0x200000;    // Timer C output 1 Reset
    static constexpr uint32_t CPT2BCR_TC1SET = 0x100000;    // Timer C output 1 Set
    static constexpr uint32_t CPT2BCR_TACMP2 = 0x8000;      // Timer A Compare 2
    static constexpr uint32_t CPT2BCR_TACMP1 = 0x4000;      // Timer A Compare 1
    static constexpr uint32_t CPT2BCR_TA1RST = 0x2000;      // Timer A output 1 Reset
    static constexpr uint32_t CPT2BCR_TA1SET = 0x1000;      // Timer A output 1 Set
    static constexpr uint32_t CPT2BCR_EXEV10CPT = 0x800;    // External Event 10 Capture
    static constexpr uint32_t CPT2BCR_EXEV9CPT = 0x400;     // External Event 9 Capture
    static constexpr uint32_t CPT2BCR_EXEV8CPT = 0x200;     // External Event 8 Capture
    static constexpr uint32_t CPT2BCR_EXEV7CPT = 0x100;     // External Event 7 Capture
    static constexpr uint32_t CPT2BCR_EXEV6CPT = 0x80;      // External Event 6 Capture
    static constexpr uint32_t CPT2BCR_EXEV5CPT = 0x40;      // External Event 5 Capture
    static constexpr uint32_t CPT2BCR_EXEV4CPT = 0x20;      // External Event 4 Capture
    static constexpr uint32_t CPT2BCR_EXEV3CPT = 0x10;      // External Event 3 Capture
    static constexpr uint32_t CPT2BCR_EXEV2CPT = 0x8;       // External Event 2 Capture
    static constexpr uint32_t CPT2BCR_EXEV1CPT = 0x4;       // External Event 1 Capture
    static constexpr uint32_t CPT2BCR_UDPCPT = 0x2;         // Update Capture
    static constexpr uint32_t CPT2BCR_SWCPT = 0x1;          // Software Capture
    static const uint32_t CPT2BCR_RESET_VALUE = 0x0;

    static constexpr uint32_t OUTBR_DIDL2 = 0x800000;     // Output 2 Deadtime upon burst mode Idle entry
    static constexpr uint32_t OUTBR_CHP2 = 0x400000;      // Output 2 Chopper enable
    template<uint32_t X>
    static constexpr uint32_t OUTBR_FAULT2 =              // Output 2 Fault state (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    static constexpr uint32_t OUTBR_IDLES2 = 0x80000;     // Output 2 Idle State
    static constexpr uint32_t OUTBR_IDLEM2 = 0x40000;     // Output 2 Idle mode
    static constexpr uint32_t OUTBR_POL2 = 0x20000;       // Output 2 polarity
    template<uint32_t X>
    static constexpr uint32_t OUTBR_DLYPRT =              // Delayed Protection (3 bits)
        bit_field_t<10, 0x7>::value<X>();
    static constexpr uint32_t OUTBR_DLYPRTEN = 0x200;     // Delayed Protection Enable
    static constexpr uint32_t OUTBR_DTEN = 0x100;         // Deadtime enable
    static constexpr uint32_t OUTBR_DIDL1 = 0x80;         // Output 1 Deadtime upon burst mode Idle entry
    static constexpr uint32_t OUTBR_CHP1 = 0x40;          // Output 1 Chopper enable
    template<uint32_t X>
    static constexpr uint32_t OUTBR_FAULT1 =              // Output 1 Fault state (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static constexpr uint32_t OUTBR_IDLES1 = 0x8;         // Output 1 Idle State
    static constexpr uint32_t OUTBR_IDLEM1 = 0x4;         // Output 1 Idle mode
    static constexpr uint32_t OUTBR_POL1 = 0x2;           // Output 1 polarity
    static const uint32_t OUTBR_RESET_VALUE = 0x0;

    static constexpr uint32_t FLTBR_FLTLCK = 0x80000000;  // Fault sources Lock
    static constexpr uint32_t FLTBR_FLT5EN = 0x10;        // Fault 5 enable
    static constexpr uint32_t FLTBR_FLT4EN = 0x8;         // Fault 4 enable
    static constexpr uint32_t FLTBR_FLT3EN = 0x4;         // Fault 3 enable
    static constexpr uint32_t FLTBR_FLT2EN = 0x2;         // Fault 2 enable
    static constexpr uint32_t FLTBR_FLT1EN = 0x1;         // Fault 1 enable
    static const uint32_t FLTBR_RESET_VALUE = 0x0;

    static constexpr uint8_t HRTIM1_TIMA = 104; // HRTIM1 timer A interrupt
};

static hrtim_timb_t& HRTIM_TIMB = *reinterpret_cast<hrtim_timb_t*>(0x40017500);

#define HAVE_PERIPHERAL_HRTIM_TIMB


////
//
//    High Resolution Timer: TIMC
//
////

struct hrtim_timc_t
{
    volatile uint32_t    TIMCCR;               // [Read-write] Timerx Control Register
    volatile uint32_t    TIMCISR;              // [Read-only] Timerx Interrupt Status Register
    volatile uint32_t    TIMCICR;              // [Write-only] Timerx Interrupt Clear Register
    volatile uint32_t    TIMCDIER5;            // [Read-write] TIMxDIER5
    volatile uint32_t    CNTCR;                // [Read-write] Timerx Counter Register
    volatile uint32_t    PERCR;                // [Read-write] Timerx Period Register
    volatile uint32_t    REPCR;                // [Read-write] Timerx Repetition Register
    volatile uint32_t    CMP1CR;               // [Read-write] Timerx Compare 1 Register
    volatile uint32_t    CMP1CCR;              // [Read-write] Timerx Compare 1 Compound Register
    volatile uint32_t    CMP2CR;               // [Read-write] Timerx Compare 2 Register
    volatile uint32_t    CMP3CR;               // [Read-write] Timerx Compare 3 Register
    volatile uint32_t    CMP4CR;               // [Read-write] Timerx Compare 4 Register
    volatile uint32_t    CPT1CR;               // [Read-only] Timerx Capture 1 Register
    volatile uint32_t    CPT2CR;               // [Read-only] Timerx Capture 2 Register
    volatile uint32_t    DTCR;                 // [Read-write] Timerx Deadtime Register
    volatile uint32_t    SETC1R;               // [Read-write] Timerx Output1 Set Register
    volatile uint32_t    RSTC1R;               // [Read-write] Timerx Output1 Reset Register
    volatile uint32_t    SETC2R;               // [Read-write] Timerx Output2 Set Register
    volatile uint32_t    RSTC2R;               // [Read-write] Timerx Output2 Reset Register
    volatile uint32_t    EEFCR1;               // [Read-write] Timerx External Event Filtering Register 1
    volatile uint32_t    EEFCR2;               // [Read-write] Timerx External Event Filtering Register 2
    volatile uint32_t    RSTCR;                // [Read-write] TimerA Reset Register
    volatile uint32_t    CHPCR;                // [Read-write] Timerx Chopper Register
    volatile uint32_t    CPT1CCR;              // [Read-write] Timerx Capture 2 Control Register
    volatile uint32_t    CPT2CCR;              // [Read-write] CPT2xCR
    volatile uint32_t    OUTCR;                // [Read-write] Timerx Output Register
    volatile uint32_t    FLTCR;                // [Read-write] Timerx Fault Register

    template<uint32_t X>
    static constexpr uint32_t TIMCCR_UPDGAT =              // Update Gating (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    static constexpr uint32_t TIMCCR_PREEN = 0x8000000;    // Preload enable
    template<uint32_t X>
    static constexpr uint32_t TIMCCR_DACSYNC =             // AC Synchronization (2 bits)
        bit_field_t<25, 0x3>::value<X>();
    static constexpr uint32_t TIMCCR_MSTU = 0x1000000;     // Master Timer update
    static constexpr uint32_t TIMCCR_TEU = 0x800000;       // TEU
    static constexpr uint32_t TIMCCR_TDU = 0x400000;       // TDU
    static constexpr uint32_t TIMCCR_TCU = 0x200000;       // TCU
    static constexpr uint32_t TIMCCR_TBU = 0x100000;       // TBU
    static constexpr uint32_t TIMCCR_TxRSTU = 0x40000;     // Timerx reset update
    static constexpr uint32_t TIMCCR_TxREPU = 0x20000;     // Timer x Repetition update
    template<uint32_t X>
    static constexpr uint32_t TIMCCR_DELCMP4 =             // Delayed CMP4 mode (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TIMCCR_DELCMP2 =             // Delayed CMP2 mode (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    static constexpr uint32_t TIMCCR_SYNCSTRTx = 0x800;    // Synchronization Starts Timer x
    static constexpr uint32_t TIMCCR_SYNCRSTx = 0x400;     // Synchronization Resets Timer x
    static constexpr uint32_t TIMCCR_PSHPLL = 0x40;        // Push-Pull mode enable
    static constexpr uint32_t TIMCCR_HALF = 0x20;          // Half mode enable
    static constexpr uint32_t TIMCCR_RETRIG = 0x10;        // Re-triggerable mode
    static constexpr uint32_t TIMCCR_CONT = 0x8;           // Continuous mode
    template<uint32_t X>
    static constexpr uint32_t TIMCCR_CK_PSCx =             // HRTIM Timer x Clock prescaler (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t TIMCCR_RESET_VALUE = 0x0;

    static constexpr uint32_t TIMCISR_O2STAT = 0x80000;     // Output 2 State
    static constexpr uint32_t TIMCISR_O1STAT = 0x40000;     // Output 1 State
    static constexpr uint32_t TIMCISR_IPPSTAT = 0x20000;    // Idle Push Pull Status
    static constexpr uint32_t TIMCISR_CPPSTAT = 0x10000;    // Current Push Pull Status
    static constexpr uint32_t TIMCISR_DLYPRT = 0x4000;      // Delayed Protection Flag
    static constexpr uint32_t TIMCISR_RST = 0x2000;         // Reset Interrupt Flag
    static constexpr uint32_t TIMCISR_RSTx2 = 0x1000;       // Output 2 Reset Interrupt Flag
    static constexpr uint32_t TIMCISR_SETx2 = 0x800;        // Output 2 Set Interrupt Flag
    static constexpr uint32_t TIMCISR_RSTx1 = 0x400;        // Output 1 Reset Interrupt Flag
    static constexpr uint32_t TIMCISR_SETx1 = 0x200;        // Output 1 Set Interrupt Flag
    static constexpr uint32_t TIMCISR_CPT2 = 0x100;         // Capture2 Interrupt Flag
    static constexpr uint32_t TIMCISR_CPT1 = 0x80;          // Capture1 Interrupt Flag
    static constexpr uint32_t TIMCISR_UPD = 0x40;           // Update Interrupt Flag
    static constexpr uint32_t TIMCISR_REP = 0x10;           // Repetition Interrupt Flag
    static constexpr uint32_t TIMCISR_CMP4 = 0x8;           // Compare 4 Interrupt Flag
    static constexpr uint32_t TIMCISR_CMP3 = 0x4;           // Compare 3 Interrupt Flag
    static constexpr uint32_t TIMCISR_CMP2 = 0x2;           // Compare 2 Interrupt Flag
    static constexpr uint32_t TIMCISR_CMP1 = 0x1;           // Compare 1 Interrupt Flag
    static const uint32_t TIMCISR_RESET_VALUE = 0x0;

    static constexpr uint32_t TIMCICR_DLYPRTC = 0x4000;     // Delayed Protection Flag Clear
    static constexpr uint32_t TIMCICR_RSTC = 0x2000;        // Reset Interrupt flag Clear
    static constexpr uint32_t TIMCICR_RSTx2C = 0x1000;      // Output 2 Reset flag Clear
    static constexpr uint32_t TIMCICR_SET2xC = 0x800;       // Output 2 Set flag Clear
    static constexpr uint32_t TIMCICR_RSTx1C = 0x400;       // Output 1 Reset flag Clear
    static constexpr uint32_t TIMCICR_SET1xC = 0x200;       // Output 1 Set flag Clear
    static constexpr uint32_t TIMCICR_CPT2C = 0x100;        // Capture2 Interrupt flag Clear
    static constexpr uint32_t TIMCICR_CPT1C = 0x80;         // Capture1 Interrupt flag Clear
    static constexpr uint32_t TIMCICR_UPDC = 0x40;          // Update Interrupt flag Clear
    static constexpr uint32_t TIMCICR_REPC = 0x10;          // Repetition Interrupt flag Clear
    static constexpr uint32_t TIMCICR_CMP4C = 0x8;          // Compare 4 Interrupt flag Clear
    static constexpr uint32_t TIMCICR_CMP3C = 0x4;          // Compare 3 Interrupt flag Clear
    static constexpr uint32_t TIMCICR_CMP2C = 0x2;          // Compare 2 Interrupt flag Clear
    static constexpr uint32_t TIMCICR_CMP1C = 0x1;          // Compare 1 Interrupt flag Clear
    static const uint32_t TIMCICR_RESET_VALUE = 0x0;

    static constexpr uint32_t TIMCDIER5_DLYPRTDE = 0x40000000;// DLYPRTDE
    static constexpr uint32_t TIMCDIER5_RSTDE = 0x20000000;   // RSTDE
    static constexpr uint32_t TIMCDIER5_RSTx2DE = 0x10000000; // RSTx2DE
    static constexpr uint32_t TIMCDIER5_SETx2DE = 0x8000000;  // SETx2DE
    static constexpr uint32_t TIMCDIER5_RSTx1DE = 0x4000000;  // RSTx1DE
    static constexpr uint32_t TIMCDIER5_SET1xDE = 0x2000000;  // SET1xDE
    static constexpr uint32_t TIMCDIER5_CPT2DE = 0x1000000;   // CPT2DE
    static constexpr uint32_t TIMCDIER5_CPT1DE = 0x800000;    // CPT1DE
    static constexpr uint32_t TIMCDIER5_UPDDE = 0x400000;     // UPDDE
    static constexpr uint32_t TIMCDIER5_REPDE = 0x100000;     // REPDE
    static constexpr uint32_t TIMCDIER5_CMP4DE = 0x80000;     // CMP4DE
    static constexpr uint32_t TIMCDIER5_CMP3DE = 0x40000;     // CMP3DE
    static constexpr uint32_t TIMCDIER5_CMP2DE = 0x20000;     // CMP2DE
    static constexpr uint32_t TIMCDIER5_CMP1DE = 0x10000;     // CMP1DE
    static constexpr uint32_t TIMCDIER5_DLYPRTIE = 0x4000;    // DLYPRTIE
    static constexpr uint32_t TIMCDIER5_RSTIE = 0x2000;       // RSTIE
    static constexpr uint32_t TIMCDIER5_RSTx2IE = 0x1000;     // RSTx2IE
    static constexpr uint32_t TIMCDIER5_SETx2IE = 0x800;      // SETx2IE
    static constexpr uint32_t TIMCDIER5_RSTx1IE = 0x400;      // RSTx1IE
    static constexpr uint32_t TIMCDIER5_SET1xIE = 0x200;      // SET1xIE
    static constexpr uint32_t TIMCDIER5_CPT2IE = 0x100;       // CPT2IE
    static constexpr uint32_t TIMCDIER5_CPT1IE = 0x80;        // CPT1IE
    static constexpr uint32_t TIMCDIER5_UPDIE = 0x40;         // UPDIE
    static constexpr uint32_t TIMCDIER5_REPIE = 0x10;         // REPIE
    static constexpr uint32_t TIMCDIER5_CMP4IE = 0x8;         // CMP4IE
    static constexpr uint32_t TIMCDIER5_CMP3IE = 0x4;         // CMP3IE
    static constexpr uint32_t TIMCDIER5_CMP2IE = 0x2;         // CMP2IE
    static constexpr uint32_t TIMCDIER5_CMP1IE = 0x1;         // CMP1IE
    static const uint32_t TIMCDIER5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CNTCR_CNTx =                // Timerx Counter value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CNTCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PERCR_PERx =                // Timerx Period value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t PERCR_RESET_VALUE = 0xffff;

    template<uint32_t X>
    static constexpr uint32_t REPCR_REPx =                // Timerx Repetition counter value (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t REPCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CMP1CR_CMP1x =               // Timerx Compare 1 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CMP1CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CMP1CCR_REPx =                // Timerx Repetition value (aliased from HRTIM_REPx register) (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CMP1CCR_CMP1x =               // Timerx Compare 1 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CMP1CCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CMP2CR_CMP2x =               // Timerx Compare 2 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CMP2CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CMP3CR_CMP3x =               // Timerx Compare 3 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CMP3CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CMP4CR_CMP4x =               // Timerx Compare 4 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CMP4CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CPT1CR_CPT1x =               // Timerx Capture 1 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CPT1CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CPT2CR_CPT2x =               // Timerx Capture 2 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CPT2CR_RESET_VALUE = 0x0;

    static constexpr uint32_t DTCR_DTFLKx = 0x80000000;  // Deadtime Falling Lock
    static constexpr uint32_t DTCR_DTFSLKx = 0x40000000; // Deadtime Falling Sign Lock
    static constexpr uint32_t DTCR_SDTFx = 0x2000000;    // Sign Deadtime Falling value
    template<uint32_t X>
    static constexpr uint32_t DTCR_DTFx =                // Deadtime Falling value (9 bits)
        bit_field_t<16, 0x1ff>::value<X>();
    static constexpr uint32_t DTCR_DTRLKx = 0x8000;      // Deadtime Rising Lock
    static constexpr uint32_t DTCR_DTRSLKx = 0x4000;     // Deadtime Rising Sign Lock
    template<uint32_t X>
    static constexpr uint32_t DTCR_DTPRSC =              // Deadtime Prescaler (3 bits)
        bit_field_t<10, 0x7>::value<X>();
    static constexpr uint32_t DTCR_SDTRx = 0x200;        // Sign Deadtime Rising value
    template<uint32_t X>
    static constexpr uint32_t DTCR_DTRx =                // Deadtime Rising value (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static const uint32_t DTCR_RESET_VALUE = 0x0;

    static constexpr uint32_t SETC1R_UPDATE = 0x80000000;  // Registers update (transfer preload to active)
    static constexpr uint32_t SETC1R_EXTEVNT10 = 0x40000000;// External Event 10
    static constexpr uint32_t SETC1R_EXTEVNT9 = 0x20000000;// External Event 9
    static constexpr uint32_t SETC1R_EXTEVNT8 = 0x10000000;// External Event 8
    static constexpr uint32_t SETC1R_EXTEVNT7 = 0x8000000; // External Event 7
    static constexpr uint32_t SETC1R_EXTEVNT6 = 0x4000000; // External Event 6
    static constexpr uint32_t SETC1R_EXTEVNT5 = 0x2000000; // External Event 5
    static constexpr uint32_t SETC1R_EXTEVNT4 = 0x1000000; // External Event 4
    static constexpr uint32_t SETC1R_EXTEVNT3 = 0x800000;  // External Event 3
    static constexpr uint32_t SETC1R_EXTEVNT2 = 0x400000;  // External Event 2
    static constexpr uint32_t SETC1R_EXTEVNT1 = 0x200000;  // External Event 1
    static constexpr uint32_t SETC1R_TIMEVNT9 = 0x100000;  // Timer Event 9
    static constexpr uint32_t SETC1R_TIMEVNT8 = 0x80000;   // Timer Event 8
    static constexpr uint32_t SETC1R_TIMEVNT7 = 0x40000;   // Timer Event 7
    static constexpr uint32_t SETC1R_TIMEVNT6 = 0x20000;   // Timer Event 6
    static constexpr uint32_t SETC1R_TIMEVNT5 = 0x10000;   // Timer Event 5
    static constexpr uint32_t SETC1R_TIMEVNT4 = 0x8000;    // Timer Event 4
    static constexpr uint32_t SETC1R_TIMEVNT3 = 0x4000;    // Timer Event 3
    static constexpr uint32_t SETC1R_TIMEVNT2 = 0x2000;    // Timer Event 2
    static constexpr uint32_t SETC1R_TIMEVNT1 = 0x1000;    // Timer Event 1
    static constexpr uint32_t SETC1R_MSTCMP4 = 0x800;      // Master Compare 4
    static constexpr uint32_t SETC1R_MSTCMP3 = 0x400;      // Master Compare 3
    static constexpr uint32_t SETC1R_MSTCMP2 = 0x200;      // Master Compare 2
    static constexpr uint32_t SETC1R_MSTCMP1 = 0x100;      // Master Compare 1
    static constexpr uint32_t SETC1R_MSTPER = 0x80;        // Master Period
    static constexpr uint32_t SETC1R_CMP4 = 0x40;          // Timer A compare 4
    static constexpr uint32_t SETC1R_CMP3 = 0x20;          // Timer A compare 3
    static constexpr uint32_t SETC1R_CMP2 = 0x10;          // Timer A compare 2
    static constexpr uint32_t SETC1R_CMP1 = 0x8;           // Timer A compare 1
    static constexpr uint32_t SETC1R_PER = 0x4;            // Timer A Period
    static constexpr uint32_t SETC1R_RESYNC = 0x2;         // Timer A resynchronizaton
    static constexpr uint32_t SETC1R_SST = 0x1;            // Software Set trigger
    static const uint32_t SETC1R_RESET_VALUE = 0x0;

    static constexpr uint32_t RSTC1R_UPDATE = 0x80000000;  // UPDATE
    static constexpr uint32_t RSTC1R_EXTEVNT10 = 0x40000000;// EXTEVNT10
    static constexpr uint32_t RSTC1R_EXTEVNT9 = 0x20000000;// EXTEVNT9
    static constexpr uint32_t RSTC1R_EXTEVNT8 = 0x10000000;// EXTEVNT8
    static constexpr uint32_t RSTC1R_EXTEVNT7 = 0x8000000; // EXTEVNT7
    static constexpr uint32_t RSTC1R_EXTEVNT6 = 0x4000000; // EXTEVNT6
    static constexpr uint32_t RSTC1R_EXTEVNT5 = 0x2000000; // EXTEVNT5
    static constexpr uint32_t RSTC1R_EXTEVNT4 = 0x1000000; // EXTEVNT4
    static constexpr uint32_t RSTC1R_EXTEVNT3 = 0x800000;  // EXTEVNT3
    static constexpr uint32_t RSTC1R_EXTEVNT2 = 0x400000;  // EXTEVNT2
    static constexpr uint32_t RSTC1R_EXTEVNT1 = 0x200000;  // EXTEVNT1
    static constexpr uint32_t RSTC1R_TIMEVNT9 = 0x100000;  // TIMEVNT9
    static constexpr uint32_t RSTC1R_TIMEVNT8 = 0x80000;   // TIMEVNT8
    static constexpr uint32_t RSTC1R_TIMEVNT7 = 0x40000;   // TIMEVNT7
    static constexpr uint32_t RSTC1R_TIMEVNT6 = 0x20000;   // TIMEVNT6
    static constexpr uint32_t RSTC1R_TIMEVNT5 = 0x10000;   // TIMEVNT5
    static constexpr uint32_t RSTC1R_TIMEVNT4 = 0x8000;    // TIMEVNT4
    static constexpr uint32_t RSTC1R_TIMEVNT3 = 0x4000;    // TIMEVNT3
    static constexpr uint32_t RSTC1R_TIMEVNT2 = 0x2000;    // TIMEVNT2
    static constexpr uint32_t RSTC1R_TIMEVNT1 = 0x1000;    // TIMEVNT1
    static constexpr uint32_t RSTC1R_MSTCMP4 = 0x800;      // MSTCMP4
    static constexpr uint32_t RSTC1R_MSTCMP3 = 0x400;      // MSTCMP3
    static constexpr uint32_t RSTC1R_MSTCMP2 = 0x200;      // MSTCMP2
    static constexpr uint32_t RSTC1R_MSTCMP1 = 0x100;      // MSTCMP1
    static constexpr uint32_t RSTC1R_MSTPER = 0x80;        // MSTPER
    static constexpr uint32_t RSTC1R_CMP4 = 0x40;          // CMP4
    static constexpr uint32_t RSTC1R_CMP3 = 0x20;          // CMP3
    static constexpr uint32_t RSTC1R_CMP2 = 0x10;          // CMP2
    static constexpr uint32_t RSTC1R_CMP1 = 0x8;           // CMP1
    static constexpr uint32_t RSTC1R_PER = 0x4;            // PER
    static constexpr uint32_t RSTC1R_RESYNC = 0x2;         // RESYNC
    static constexpr uint32_t RSTC1R_SRT = 0x1;            // SRT
    static const uint32_t RSTC1R_RESET_VALUE = 0x0;

    static constexpr uint32_t SETC2R_UPDATE = 0x80000000;  // UPDATE
    static constexpr uint32_t SETC2R_EXTEVNT10 = 0x40000000;// EXTEVNT10
    static constexpr uint32_t SETC2R_EXTEVNT9 = 0x20000000;// EXTEVNT9
    static constexpr uint32_t SETC2R_EXTEVNT8 = 0x10000000;// EXTEVNT8
    static constexpr uint32_t SETC2R_EXTEVNT7 = 0x8000000; // EXTEVNT7
    static constexpr uint32_t SETC2R_EXTEVNT6 = 0x4000000; // EXTEVNT6
    static constexpr uint32_t SETC2R_EXTEVNT5 = 0x2000000; // EXTEVNT5
    static constexpr uint32_t SETC2R_EXTEVNT4 = 0x1000000; // EXTEVNT4
    static constexpr uint32_t SETC2R_EXTEVNT3 = 0x800000;  // EXTEVNT3
    static constexpr uint32_t SETC2R_EXTEVNT2 = 0x400000;  // EXTEVNT2
    static constexpr uint32_t SETC2R_EXTEVNT1 = 0x200000;  // EXTEVNT1
    static constexpr uint32_t SETC2R_TIMEVNT9 = 0x100000;  // TIMEVNT9
    static constexpr uint32_t SETC2R_TIMEVNT8 = 0x80000;   // TIMEVNT8
    static constexpr uint32_t SETC2R_TIMEVNT7 = 0x40000;   // TIMEVNT7
    static constexpr uint32_t SETC2R_TIMEVNT6 = 0x20000;   // TIMEVNT6
    static constexpr uint32_t SETC2R_TIMEVNT5 = 0x10000;   // TIMEVNT5
    static constexpr uint32_t SETC2R_TIMEVNT4 = 0x8000;    // TIMEVNT4
    static constexpr uint32_t SETC2R_TIMEVNT3 = 0x4000;    // TIMEVNT3
    static constexpr uint32_t SETC2R_TIMEVNT2 = 0x2000;    // TIMEVNT2
    static constexpr uint32_t SETC2R_TIMEVNT1 = 0x1000;    // TIMEVNT1
    static constexpr uint32_t SETC2R_MSTCMP4 = 0x800;      // MSTCMP4
    static constexpr uint32_t SETC2R_MSTCMP3 = 0x400;      // MSTCMP3
    static constexpr uint32_t SETC2R_MSTCMP2 = 0x200;      // MSTCMP2
    static constexpr uint32_t SETC2R_MSTCMP1 = 0x100;      // MSTCMP1
    static constexpr uint32_t SETC2R_MSTPER = 0x80;        // MSTPER
    static constexpr uint32_t SETC2R_CMP4 = 0x40;          // CMP4
    static constexpr uint32_t SETC2R_CMP3 = 0x20;          // CMP3
    static constexpr uint32_t SETC2R_CMP2 = 0x10;          // CMP2
    static constexpr uint32_t SETC2R_CMP1 = 0x8;           // CMP1
    static constexpr uint32_t SETC2R_PER = 0x4;            // PER
    static constexpr uint32_t SETC2R_RESYNC = 0x2;         // RESYNC
    static constexpr uint32_t SETC2R_SST = 0x1;            // SST
    static const uint32_t SETC2R_RESET_VALUE = 0x0;

    static constexpr uint32_t RSTC2R_UPDATE = 0x80000000;  // UPDATE
    static constexpr uint32_t RSTC2R_EXTEVNT10 = 0x40000000;// EXTEVNT10
    static constexpr uint32_t RSTC2R_EXTEVNT9 = 0x20000000;// EXTEVNT9
    static constexpr uint32_t RSTC2R_EXTEVNT8 = 0x10000000;// EXTEVNT8
    static constexpr uint32_t RSTC2R_EXTEVNT7 = 0x8000000; // EXTEVNT7
    static constexpr uint32_t RSTC2R_EXTEVNT6 = 0x4000000; // EXTEVNT6
    static constexpr uint32_t RSTC2R_EXTEVNT5 = 0x2000000; // EXTEVNT5
    static constexpr uint32_t RSTC2R_EXTEVNT4 = 0x1000000; // EXTEVNT4
    static constexpr uint32_t RSTC2R_EXTEVNT3 = 0x800000;  // EXTEVNT3
    static constexpr uint32_t RSTC2R_EXTEVNT2 = 0x400000;  // EXTEVNT2
    static constexpr uint32_t RSTC2R_EXTEVNT1 = 0x200000;  // EXTEVNT1
    static constexpr uint32_t RSTC2R_TIMEVNT9 = 0x100000;  // TIMEVNT9
    static constexpr uint32_t RSTC2R_TIMEVNT8 = 0x80000;   // TIMEVNT8
    static constexpr uint32_t RSTC2R_TIMEVNT7 = 0x40000;   // TIMEVNT7
    static constexpr uint32_t RSTC2R_TIMEVNT6 = 0x20000;   // TIMEVNT6
    static constexpr uint32_t RSTC2R_TIMEVNT5 = 0x10000;   // TIMEVNT5
    static constexpr uint32_t RSTC2R_TIMEVNT4 = 0x8000;    // TIMEVNT4
    static constexpr uint32_t RSTC2R_TIMEVNT3 = 0x4000;    // TIMEVNT3
    static constexpr uint32_t RSTC2R_TIMEVNT2 = 0x2000;    // TIMEVNT2
    static constexpr uint32_t RSTC2R_TIMEVNT1 = 0x1000;    // TIMEVNT1
    static constexpr uint32_t RSTC2R_MSTCMP4 = 0x800;      // MSTCMP4
    static constexpr uint32_t RSTC2R_MSTCMP3 = 0x400;      // MSTCMP3
    static constexpr uint32_t RSTC2R_MSTCMP2 = 0x200;      // MSTCMP2
    static constexpr uint32_t RSTC2R_MSTCMP1 = 0x100;      // MSTCMP1
    static constexpr uint32_t RSTC2R_MSTPER = 0x80;        // MSTPER
    static constexpr uint32_t RSTC2R_CMP4 = 0x40;          // CMP4
    static constexpr uint32_t RSTC2R_CMP3 = 0x20;          // CMP3
    static constexpr uint32_t RSTC2R_CMP2 = 0x10;          // CMP2
    static constexpr uint32_t RSTC2R_CMP1 = 0x8;           // CMP1
    static constexpr uint32_t RSTC2R_PER = 0x4;            // PER
    static constexpr uint32_t RSTC2R_RESYNC = 0x2;         // RESYNC
    static constexpr uint32_t RSTC2R_SRT = 0x1;            // SRT
    static const uint32_t RSTC2R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t EEFCR1_EE5FLTR =             // External Event 5 filter (4 bits)
        bit_field_t<25, 0xf>::value<X>();
    static constexpr uint32_t EEFCR1_EE5LTCH = 0x1000000;  // External Event 5 latch
    template<uint32_t X>
    static constexpr uint32_t EEFCR1_EE4FLTR =             // External Event 4 filter (4 bits)
        bit_field_t<19, 0xf>::value<X>();
    static constexpr uint32_t EEFCR1_EE4LTCH = 0x40000;    // External Event 4 latch
    template<uint32_t X>
    static constexpr uint32_t EEFCR1_EE3FLTR =             // External Event 3 filter (4 bits)
        bit_field_t<13, 0xf>::value<X>();
    static constexpr uint32_t EEFCR1_EE3LTCH = 0x1000;     // External Event 3 latch
    template<uint32_t X>
    static constexpr uint32_t EEFCR1_EE2FLTR =             // External Event 2 filter (4 bits)
        bit_field_t<7, 0xf>::value<X>();
    static constexpr uint32_t EEFCR1_EE2LTCH = 0x40;       // External Event 2 latch
    template<uint32_t X>
    static constexpr uint32_t EEFCR1_EE1FLTR =             // External Event 1 filter (4 bits)
        bit_field_t<1, 0xf>::value<X>();
    static constexpr uint32_t EEFCR1_EE1LTCH = 0x1;        // External Event 1 latch
    static const uint32_t EEFCR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t EEFCR2_EE10FLTR =            // External Event 10 filter (4 bits)
        bit_field_t<25, 0xf>::value<X>();
    static constexpr uint32_t EEFCR2_EE10LTCH = 0x1000000; // External Event 10 latch
    template<uint32_t X>
    static constexpr uint32_t EEFCR2_EE9FLTR =             // External Event 9 filter (4 bits)
        bit_field_t<19, 0xf>::value<X>();
    static constexpr uint32_t EEFCR2_EE9LTCH = 0x40000;    // External Event 9 latch
    template<uint32_t X>
    static constexpr uint32_t EEFCR2_EE8FLTR =             // External Event 8 filter (4 bits)
        bit_field_t<13, 0xf>::value<X>();
    static constexpr uint32_t EEFCR2_EE8LTCH = 0x1000;     // External Event 8 latch
    template<uint32_t X>
    static constexpr uint32_t EEFCR2_EE7FLTR =             // External Event 7 filter (4 bits)
        bit_field_t<7, 0xf>::value<X>();
    static constexpr uint32_t EEFCR2_EE7LTCH = 0x40;       // External Event 7 latch
    template<uint32_t X>
    static constexpr uint32_t EEFCR2_EE6FLTR =             // External Event 6 filter (4 bits)
        bit_field_t<1, 0xf>::value<X>();
    static constexpr uint32_t EEFCR2_EE6LTCH = 0x1;        // External Event 6 latch
    static const uint32_t EEFCR2_RESET_VALUE = 0x0;

    static constexpr uint32_t RSTCR_TIMECMP4 = 0x40000000;// Timer E Compare 4
    static constexpr uint32_t RSTCR_TIMECMP2 = 0x20000000;// Timer E Compare 2
    static constexpr uint32_t RSTCR_TIMECMP1 = 0x10000000;// Timer E Compare 1
    static constexpr uint32_t RSTCR_TIMDCMP4 = 0x8000000; // Timer D Compare 4
    static constexpr uint32_t RSTCR_TIMDCMP2 = 0x4000000; // Timer D Compare 2
    static constexpr uint32_t RSTCR_TIMDCMP1 = 0x2000000; // Timer D Compare 1
    static constexpr uint32_t RSTCR_TIMBCMP4 = 0x1000000; // Timer B Compare 4
    static constexpr uint32_t RSTCR_TIMBCMP2 = 0x800000;  // Timer B Compare 2
    static constexpr uint32_t RSTCR_TIMBCMP1 = 0x400000;  // Timer B Compare 1
    static constexpr uint32_t RSTCR_TIMACMP4 = 0x200000;  // Timer A Compare 4
    static constexpr uint32_t RSTCR_TIMACMP2 = 0x100000;  // Timer A Compare 2
    static constexpr uint32_t RSTCR_TIMACMP1 = 0x80000;   // Timer A Compare 1
    static constexpr uint32_t RSTCR_EXTEVNT10 = 0x40000;  // External Event 10
    static constexpr uint32_t RSTCR_EXTEVNT9 = 0x20000;   // External Event 9
    static constexpr uint32_t RSTCR_EXTEVNT8 = 0x10000;   // External Event 8
    static constexpr uint32_t RSTCR_EXTEVNT7 = 0x8000;    // External Event 7
    static constexpr uint32_t RSTCR_EXTEVNT6 = 0x4000;    // External Event 6
    static constexpr uint32_t RSTCR_EXTEVNT5 = 0x2000;    // External Event 5
    static constexpr uint32_t RSTCR_EXTEVNT4 = 0x1000;    // External Event 4
    static constexpr uint32_t RSTCR_EXTEVNT3 = 0x800;     // External Event 3
    static constexpr uint32_t RSTCR_EXTEVNT2 = 0x400;     // External Event 2
    static constexpr uint32_t RSTCR_EXTEVNT1 = 0x200;     // External Event 1
    static constexpr uint32_t RSTCR_MSTCMP4 = 0x100;      // Master compare 4
    static constexpr uint32_t RSTCR_MSTCMP3 = 0x80;       // Master compare 3
    static constexpr uint32_t RSTCR_MSTCMP2 = 0x40;       // Master compare 2
    static constexpr uint32_t RSTCR_MSTCMP1 = 0x20;       // Master compare 1
    static constexpr uint32_t RSTCR_MSTPER = 0x10;        // Master timer Period
    static constexpr uint32_t RSTCR_CMP4 = 0x8;           // Timer A compare 4 reset
    static constexpr uint32_t RSTCR_CMP2 = 0x4;           // Timer A compare 2 reset
    static constexpr uint32_t RSTCR_UPDT = 0x2;           // Timer A Update reset
    static const uint32_t RSTCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHPCR_STRTPW =              // STRTPW (4 bits)
        bit_field_t<7, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHPCR_CHPDTY =              // Timerx chopper duty cycle value (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHPCR_CHPFRQ =              // Timerx carrier frequency value (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t CHPCR_RESET_VALUE = 0x0;

    static constexpr uint32_t CPT1CCR_TECMP2 = 0x80000000;  // Timer E Compare 2
    static constexpr uint32_t CPT1CCR_TECMP1 = 0x40000000;  // Timer E Compare 1
    static constexpr uint32_t CPT1CCR_TE1RST = 0x20000000;  // Timer E output 1 Reset
    static constexpr uint32_t CPT1CCR_TE1SET = 0x10000000;  // Timer E output 1 Set
    static constexpr uint32_t CPT1CCR_TDCMP2 = 0x8000000;   // Timer D Compare 2
    static constexpr uint32_t CPT1CCR_TDCMP1 = 0x4000000;   // Timer D Compare 1
    static constexpr uint32_t CPT1CCR_TD1RST = 0x2000000;   // Timer D output 1 Reset
    static constexpr uint32_t CPT1CCR_TD1SET = 0x1000000;   // Timer D output 1 Set
    static constexpr uint32_t CPT1CCR_TBCMP2 = 0x80000;     // Timer B Compare 2
    static constexpr uint32_t CPT1CCR_TBCMP1 = 0x40000;     // Timer B Compare 1
    static constexpr uint32_t CPT1CCR_TB1RST = 0x20000;     // Timer B output 1 Reset
    static constexpr uint32_t CPT1CCR_TB1SET = 0x10000;     // Timer B output 1 Set
    static constexpr uint32_t CPT1CCR_TACMP2 = 0x8000;      // Timer A Compare 2
    static constexpr uint32_t CPT1CCR_TACMP1 = 0x4000;      // Timer A Compare 1
    static constexpr uint32_t CPT1CCR_TA1RST = 0x2000;      // Timer A output 1 Reset
    static constexpr uint32_t CPT1CCR_TA1SET = 0x1000;      // Timer A output 1 Set
    static constexpr uint32_t CPT1CCR_EXEV10CPT = 0x800;    // External Event 10 Capture
    static constexpr uint32_t CPT1CCR_EXEV9CPT = 0x400;     // External Event 9 Capture
    static constexpr uint32_t CPT1CCR_EXEV8CPT = 0x200;     // External Event 8 Capture
    static constexpr uint32_t CPT1CCR_EXEV7CPT = 0x100;     // External Event 7 Capture
    static constexpr uint32_t CPT1CCR_EXEV6CPT = 0x80;      // External Event 6 Capture
    static constexpr uint32_t CPT1CCR_EXEV5CPT = 0x40;      // External Event 5 Capture
    static constexpr uint32_t CPT1CCR_EXEV4CPT = 0x20;      // External Event 4 Capture
    static constexpr uint32_t CPT1CCR_EXEV3CPT = 0x10;      // External Event 3 Capture
    static constexpr uint32_t CPT1CCR_EXEV2CPT = 0x8;       // External Event 2 Capture
    static constexpr uint32_t CPT1CCR_EXEV1CPT = 0x4;       // External Event 1 Capture
    static constexpr uint32_t CPT1CCR_UDPCPT = 0x2;         // Update Capture
    static constexpr uint32_t CPT1CCR_SWCPT = 0x1;          // Software Capture
    static const uint32_t CPT1CCR_RESET_VALUE = 0x0;

    static constexpr uint32_t CPT2CCR_TECMP2 = 0x80000000;  // Timer E Compare 2
    static constexpr uint32_t CPT2CCR_TECMP1 = 0x40000000;  // Timer E Compare 1
    static constexpr uint32_t CPT2CCR_TE1RST = 0x20000000;  // Timer E output 1 Reset
    static constexpr uint32_t CPT2CCR_TE1SET = 0x10000000;  // Timer E output 1 Set
    static constexpr uint32_t CPT2CCR_TDCMP2 = 0x8000000;   // Timer D Compare 2
    static constexpr uint32_t CPT2CCR_TDCMP1 = 0x4000000;   // Timer D Compare 1
    static constexpr uint32_t CPT2CCR_TD1RST = 0x2000000;   // Timer D output 1 Reset
    static constexpr uint32_t CPT2CCR_TD1SET = 0x1000000;   // Timer D output 1 Set
    static constexpr uint32_t CPT2CCR_TBCMP2 = 0x80000;     // Timer B Compare 2
    static constexpr uint32_t CPT2CCR_TBCMP1 = 0x40000;     // Timer B Compare 1
    static constexpr uint32_t CPT2CCR_TB1RST = 0x20000;     // Timer B output 1 Reset
    static constexpr uint32_t CPT2CCR_TB1SET = 0x10000;     // Timer B output 1 Set
    static constexpr uint32_t CPT2CCR_TACMP2 = 0x8000;      // Timer A Compare 2
    static constexpr uint32_t CPT2CCR_TACMP1 = 0x4000;      // Timer A Compare 1
    static constexpr uint32_t CPT2CCR_TA1RST = 0x2000;      // Timer A output 1 Reset
    static constexpr uint32_t CPT2CCR_TA1SET = 0x1000;      // Timer A output 1 Set
    static constexpr uint32_t CPT2CCR_EXEV10CPT = 0x800;    // External Event 10 Capture
    static constexpr uint32_t CPT2CCR_EXEV9CPT = 0x400;     // External Event 9 Capture
    static constexpr uint32_t CPT2CCR_EXEV8CPT = 0x200;     // External Event 8 Capture
    static constexpr uint32_t CPT2CCR_EXEV7CPT = 0x100;     // External Event 7 Capture
    static constexpr uint32_t CPT2CCR_EXEV6CPT = 0x80;      // External Event 6 Capture
    static constexpr uint32_t CPT2CCR_EXEV5CPT = 0x40;      // External Event 5 Capture
    static constexpr uint32_t CPT2CCR_EXEV4CPT = 0x20;      // External Event 4 Capture
    static constexpr uint32_t CPT2CCR_EXEV3CPT = 0x10;      // External Event 3 Capture
    static constexpr uint32_t CPT2CCR_EXEV2CPT = 0x8;       // External Event 2 Capture
    static constexpr uint32_t CPT2CCR_EXEV1CPT = 0x4;       // External Event 1 Capture
    static constexpr uint32_t CPT2CCR_UDPCPT = 0x2;         // Update Capture
    static constexpr uint32_t CPT2CCR_SWCPT = 0x1;          // Software Capture
    static const uint32_t CPT2CCR_RESET_VALUE = 0x0;

    static constexpr uint32_t OUTCR_DIDL2 = 0x800000;     // Output 2 Deadtime upon burst mode Idle entry
    static constexpr uint32_t OUTCR_CHP2 = 0x400000;      // Output 2 Chopper enable
    template<uint32_t X>
    static constexpr uint32_t OUTCR_FAULT2 =              // Output 2 Fault state (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    static constexpr uint32_t OUTCR_IDLES2 = 0x80000;     // Output 2 Idle State
    static constexpr uint32_t OUTCR_IDLEM2 = 0x40000;     // Output 2 Idle mode
    static constexpr uint32_t OUTCR_POL2 = 0x20000;       // Output 2 polarity
    template<uint32_t X>
    static constexpr uint32_t OUTCR_DLYPRT =              // Delayed Protection (3 bits)
        bit_field_t<10, 0x7>::value<X>();
    static constexpr uint32_t OUTCR_DLYPRTEN = 0x200;     // Delayed Protection Enable
    static constexpr uint32_t OUTCR_DTEN = 0x100;         // Deadtime enable
    static constexpr uint32_t OUTCR_DIDL1 = 0x80;         // Output 1 Deadtime upon burst mode Idle entry
    static constexpr uint32_t OUTCR_CHP1 = 0x40;          // Output 1 Chopper enable
    template<uint32_t X>
    static constexpr uint32_t OUTCR_FAULT1 =              // Output 1 Fault state (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static constexpr uint32_t OUTCR_IDLES1 = 0x8;         // Output 1 Idle State
    static constexpr uint32_t OUTCR_IDLEM1 = 0x4;         // Output 1 Idle mode
    static constexpr uint32_t OUTCR_POL1 = 0x2;           // Output 1 polarity
    static const uint32_t OUTCR_RESET_VALUE = 0x0;

    static constexpr uint32_t FLTCR_FLTLCK = 0x80000000;  // Fault sources Lock
    static constexpr uint32_t FLTCR_FLT5EN = 0x10;        // Fault 5 enable
    static constexpr uint32_t FLTCR_FLT4EN = 0x8;         // Fault 4 enable
    static constexpr uint32_t FLTCR_FLT3EN = 0x4;         // Fault 3 enable
    static constexpr uint32_t FLTCR_FLT2EN = 0x2;         // Fault 2 enable
    static constexpr uint32_t FLTCR_FLT1EN = 0x1;         // Fault 1 enable
    static const uint32_t FLTCR_RESET_VALUE = 0x0;

    static constexpr uint8_t HRTIM_TIMB = 105; // HRTIM1 timer B interrupt
};

static hrtim_timc_t& HRTIM_TIMC = *reinterpret_cast<hrtim_timc_t*>(0x40017580);

#define HAVE_PERIPHERAL_HRTIM_TIMC


////
//
//    High Resolution Timer: TIMD
//
////

struct hrtim_timd_t
{
    volatile uint32_t    TIMDCR;               // [Read-write] Timerx Control Register
    volatile uint32_t    TIMDISR;              // [Read-only] Timerx Interrupt Status Register
    volatile uint32_t    TIMDICR;              // [Write-only] Timerx Interrupt Clear Register
    volatile uint32_t    TIMDDIER5;            // [Read-write] TIMxDIER5
    volatile uint32_t    CNTDR;                // [Read-write] Timerx Counter Register
    volatile uint32_t    PERDR;                // [Read-write] Timerx Period Register
    volatile uint32_t    REPDR;                // [Read-write] Timerx Repetition Register
    volatile uint32_t    CMP1DR;               // [Read-write] Timerx Compare 1 Register
    volatile uint32_t    CMP1CDR;              // [Read-write] Timerx Compare 1 Compound Register
    volatile uint32_t    CMP2DR;               // [Read-write] Timerx Compare 2 Register
    volatile uint32_t    CMP3DR;               // [Read-write] Timerx Compare 3 Register
    volatile uint32_t    CMP4DR;               // [Read-write] Timerx Compare 4 Register
    volatile uint32_t    CPT1DR;               // [Read-only] Timerx Capture 1 Register
    volatile uint32_t    CPT2DR;               // [Read-only] Timerx Capture 2 Register
    volatile uint32_t    DTDR;                 // [Read-write] Timerx Deadtime Register
    volatile uint32_t    SETD1R;               // [Read-write] Timerx Output1 Set Register
    volatile uint32_t    RSTD1R;               // [Read-write] Timerx Output1 Reset Register
    volatile uint32_t    SETD2R;               // [Read-write] Timerx Output2 Set Register
    volatile uint32_t    RSTD2R;               // [Read-write] Timerx Output2 Reset Register
    volatile uint32_t    EEFDR1;               // [Read-write] Timerx External Event Filtering Register 1
    volatile uint32_t    EEFDR2;               // [Read-write] Timerx External Event Filtering Register 2
    volatile uint32_t    RSTDR;                // [Read-write] TimerA Reset Register
    volatile uint32_t    CHPDR;                // [Read-write] Timerx Chopper Register
    volatile uint32_t    CPT1DCR;              // [Read-write] Timerx Capture 2 Control Register
    volatile uint32_t    CPT2DCR;              // [Read-write] CPT2xCR
    volatile uint32_t    OUTDR;                // [Read-write] Timerx Output Register
    volatile uint32_t    FLTDR;                // [Read-write] Timerx Fault Register

    template<uint32_t X>
    static constexpr uint32_t TIMDCR_UPDGAT =              // Update Gating (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    static constexpr uint32_t TIMDCR_PREEN = 0x8000000;    // Preload enable
    template<uint32_t X>
    static constexpr uint32_t TIMDCR_DACSYNC =             // AC Synchronization (2 bits)
        bit_field_t<25, 0x3>::value<X>();
    static constexpr uint32_t TIMDCR_MSTU = 0x1000000;     // Master Timer update
    static constexpr uint32_t TIMDCR_TEU = 0x800000;       // TEU
    static constexpr uint32_t TIMDCR_TDU = 0x400000;       // TDU
    static constexpr uint32_t TIMDCR_TCU = 0x200000;       // TCU
    static constexpr uint32_t TIMDCR_TBU = 0x100000;       // TBU
    static constexpr uint32_t TIMDCR_TxRSTU = 0x40000;     // Timerx reset update
    static constexpr uint32_t TIMDCR_TxREPU = 0x20000;     // Timer x Repetition update
    template<uint32_t X>
    static constexpr uint32_t TIMDCR_DELCMP4 =             // Delayed CMP4 mode (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TIMDCR_DELCMP2 =             // Delayed CMP2 mode (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    static constexpr uint32_t TIMDCR_SYNCSTRTx = 0x800;    // Synchronization Starts Timer x
    static constexpr uint32_t TIMDCR_SYNCRSTx = 0x400;     // Synchronization Resets Timer x
    static constexpr uint32_t TIMDCR_PSHPLL = 0x40;        // Push-Pull mode enable
    static constexpr uint32_t TIMDCR_HALF = 0x20;          // Half mode enable
    static constexpr uint32_t TIMDCR_RETRIG = 0x10;        // Re-triggerable mode
    static constexpr uint32_t TIMDCR_CONT = 0x8;           // Continuous mode
    template<uint32_t X>
    static constexpr uint32_t TIMDCR_CK_PSCx =             // HRTIM Timer x Clock prescaler (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t TIMDCR_RESET_VALUE = 0x0;

    static constexpr uint32_t TIMDISR_O2STAT = 0x80000;     // Output 2 State
    static constexpr uint32_t TIMDISR_O1STAT = 0x40000;     // Output 1 State
    static constexpr uint32_t TIMDISR_IPPSTAT = 0x20000;    // Idle Push Pull Status
    static constexpr uint32_t TIMDISR_CPPSTAT = 0x10000;    // Current Push Pull Status
    static constexpr uint32_t TIMDISR_DLYPRT = 0x4000;      // Delayed Protection Flag
    static constexpr uint32_t TIMDISR_RST = 0x2000;         // Reset Interrupt Flag
    static constexpr uint32_t TIMDISR_RSTx2 = 0x1000;       // Output 2 Reset Interrupt Flag
    static constexpr uint32_t TIMDISR_SETx2 = 0x800;        // Output 2 Set Interrupt Flag
    static constexpr uint32_t TIMDISR_RSTx1 = 0x400;        // Output 1 Reset Interrupt Flag
    static constexpr uint32_t TIMDISR_SETx1 = 0x200;        // Output 1 Set Interrupt Flag
    static constexpr uint32_t TIMDISR_CPT2 = 0x100;         // Capture2 Interrupt Flag
    static constexpr uint32_t TIMDISR_CPT1 = 0x80;          // Capture1 Interrupt Flag
    static constexpr uint32_t TIMDISR_UPD = 0x40;           // Update Interrupt Flag
    static constexpr uint32_t TIMDISR_REP = 0x10;           // Repetition Interrupt Flag
    static constexpr uint32_t TIMDISR_CMP4 = 0x8;           // Compare 4 Interrupt Flag
    static constexpr uint32_t TIMDISR_CMP3 = 0x4;           // Compare 3 Interrupt Flag
    static constexpr uint32_t TIMDISR_CMP2 = 0x2;           // Compare 2 Interrupt Flag
    static constexpr uint32_t TIMDISR_CMP1 = 0x1;           // Compare 1 Interrupt Flag
    static const uint32_t TIMDISR_RESET_VALUE = 0x0;

    static constexpr uint32_t TIMDICR_DLYPRTC = 0x4000;     // Delayed Protection Flag Clear
    static constexpr uint32_t TIMDICR_RSTC = 0x2000;        // Reset Interrupt flag Clear
    static constexpr uint32_t TIMDICR_RSTx2C = 0x1000;      // Output 2 Reset flag Clear
    static constexpr uint32_t TIMDICR_SET2xC = 0x800;       // Output 2 Set flag Clear
    static constexpr uint32_t TIMDICR_RSTx1C = 0x400;       // Output 1 Reset flag Clear
    static constexpr uint32_t TIMDICR_SET1xC = 0x200;       // Output 1 Set flag Clear
    static constexpr uint32_t TIMDICR_CPT2C = 0x100;        // Capture2 Interrupt flag Clear
    static constexpr uint32_t TIMDICR_CPT1C = 0x80;         // Capture1 Interrupt flag Clear
    static constexpr uint32_t TIMDICR_UPDC = 0x40;          // Update Interrupt flag Clear
    static constexpr uint32_t TIMDICR_REPC = 0x10;          // Repetition Interrupt flag Clear
    static constexpr uint32_t TIMDICR_CMP4C = 0x8;          // Compare 4 Interrupt flag Clear
    static constexpr uint32_t TIMDICR_CMP3C = 0x4;          // Compare 3 Interrupt flag Clear
    static constexpr uint32_t TIMDICR_CMP2C = 0x2;          // Compare 2 Interrupt flag Clear
    static constexpr uint32_t TIMDICR_CMP1C = 0x1;          // Compare 1 Interrupt flag Clear
    static const uint32_t TIMDICR_RESET_VALUE = 0x0;

    static constexpr uint32_t TIMDDIER5_DLYPRTDE = 0x40000000;// DLYPRTDE
    static constexpr uint32_t TIMDDIER5_RSTDE = 0x20000000;   // RSTDE
    static constexpr uint32_t TIMDDIER5_RSTx2DE = 0x10000000; // RSTx2DE
    static constexpr uint32_t TIMDDIER5_SETx2DE = 0x8000000;  // SETx2DE
    static constexpr uint32_t TIMDDIER5_RSTx1DE = 0x4000000;  // RSTx1DE
    static constexpr uint32_t TIMDDIER5_SET1xDE = 0x2000000;  // SET1xDE
    static constexpr uint32_t TIMDDIER5_CPT2DE = 0x1000000;   // CPT2DE
    static constexpr uint32_t TIMDDIER5_CPT1DE = 0x800000;    // CPT1DE
    static constexpr uint32_t TIMDDIER5_UPDDE = 0x400000;     // UPDDE
    static constexpr uint32_t TIMDDIER5_REPDE = 0x100000;     // REPDE
    static constexpr uint32_t TIMDDIER5_CMP4DE = 0x80000;     // CMP4DE
    static constexpr uint32_t TIMDDIER5_CMP3DE = 0x40000;     // CMP3DE
    static constexpr uint32_t TIMDDIER5_CMP2DE = 0x20000;     // CMP2DE
    static constexpr uint32_t TIMDDIER5_CMP1DE = 0x10000;     // CMP1DE
    static constexpr uint32_t TIMDDIER5_DLYPRTIE = 0x4000;    // DLYPRTIE
    static constexpr uint32_t TIMDDIER5_RSTIE = 0x2000;       // RSTIE
    static constexpr uint32_t TIMDDIER5_RSTx2IE = 0x1000;     // RSTx2IE
    static constexpr uint32_t TIMDDIER5_SETx2IE = 0x800;      // SETx2IE
    static constexpr uint32_t TIMDDIER5_RSTx1IE = 0x400;      // RSTx1IE
    static constexpr uint32_t TIMDDIER5_SET1xIE = 0x200;      // SET1xIE
    static constexpr uint32_t TIMDDIER5_CPT2IE = 0x100;       // CPT2IE
    static constexpr uint32_t TIMDDIER5_CPT1IE = 0x80;        // CPT1IE
    static constexpr uint32_t TIMDDIER5_UPDIE = 0x40;         // UPDIE
    static constexpr uint32_t TIMDDIER5_REPIE = 0x10;         // REPIE
    static constexpr uint32_t TIMDDIER5_CMP4IE = 0x8;         // CMP4IE
    static constexpr uint32_t TIMDDIER5_CMP3IE = 0x4;         // CMP3IE
    static constexpr uint32_t TIMDDIER5_CMP2IE = 0x2;         // CMP2IE
    static constexpr uint32_t TIMDDIER5_CMP1IE = 0x1;         // CMP1IE
    static const uint32_t TIMDDIER5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CNTDR_CNTx =                // Timerx Counter value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CNTDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PERDR_PERx =                // Timerx Period value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t PERDR_RESET_VALUE = 0xffff;

    template<uint32_t X>
    static constexpr uint32_t REPDR_REPx =                // Timerx Repetition counter value (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t REPDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CMP1DR_CMP1x =               // Timerx Compare 1 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CMP1DR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CMP1CDR_REPx =                // Timerx Repetition value (aliased from HRTIM_REPx register) (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CMP1CDR_CMP1x =               // Timerx Compare 1 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CMP1CDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CMP2DR_CMP2x =               // Timerx Compare 2 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CMP2DR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CMP3DR_CMP3x =               // Timerx Compare 3 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CMP3DR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CMP4DR_CMP4x =               // Timerx Compare 4 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CMP4DR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CPT1DR_CPT1x =               // Timerx Capture 1 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CPT1DR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CPT2DR_CPT2x =               // Timerx Capture 2 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CPT2DR_RESET_VALUE = 0x0;

    static constexpr uint32_t DTDR_DTFLKx = 0x80000000;  // Deadtime Falling Lock
    static constexpr uint32_t DTDR_DTFSLKx = 0x40000000; // Deadtime Falling Sign Lock
    static constexpr uint32_t DTDR_SDTFx = 0x2000000;    // Sign Deadtime Falling value
    template<uint32_t X>
    static constexpr uint32_t DTDR_DTFx =                // Deadtime Falling value (9 bits)
        bit_field_t<16, 0x1ff>::value<X>();
    static constexpr uint32_t DTDR_DTRLKx = 0x8000;      // Deadtime Rising Lock
    static constexpr uint32_t DTDR_DTRSLKx = 0x4000;     // Deadtime Rising Sign Lock
    template<uint32_t X>
    static constexpr uint32_t DTDR_DTPRSC =              // Deadtime Prescaler (3 bits)
        bit_field_t<10, 0x7>::value<X>();
    static constexpr uint32_t DTDR_SDTRx = 0x200;        // Sign Deadtime Rising value
    template<uint32_t X>
    static constexpr uint32_t DTDR_DTRx =                // Deadtime Rising value (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static const uint32_t DTDR_RESET_VALUE = 0x0;

    static constexpr uint32_t SETD1R_UPDATE = 0x80000000;  // Registers update (transfer preload to active)
    static constexpr uint32_t SETD1R_EXTEVNT10 = 0x40000000;// External Event 10
    static constexpr uint32_t SETD1R_EXTEVNT9 = 0x20000000;// External Event 9
    static constexpr uint32_t SETD1R_EXTEVNT8 = 0x10000000;// External Event 8
    static constexpr uint32_t SETD1R_EXTEVNT7 = 0x8000000; // External Event 7
    static constexpr uint32_t SETD1R_EXTEVNT6 = 0x4000000; // External Event 6
    static constexpr uint32_t SETD1R_EXTEVNT5 = 0x2000000; // External Event 5
    static constexpr uint32_t SETD1R_EXTEVNT4 = 0x1000000; // External Event 4
    static constexpr uint32_t SETD1R_EXTEVNT3 = 0x800000;  // External Event 3
    static constexpr uint32_t SETD1R_EXTEVNT2 = 0x400000;  // External Event 2
    static constexpr uint32_t SETD1R_EXTEVNT1 = 0x200000;  // External Event 1
    static constexpr uint32_t SETD1R_TIMEVNT9 = 0x100000;  // Timer Event 9
    static constexpr uint32_t SETD1R_TIMEVNT8 = 0x80000;   // Timer Event 8
    static constexpr uint32_t SETD1R_TIMEVNT7 = 0x40000;   // Timer Event 7
    static constexpr uint32_t SETD1R_TIMEVNT6 = 0x20000;   // Timer Event 6
    static constexpr uint32_t SETD1R_TIMEVNT5 = 0x10000;   // Timer Event 5
    static constexpr uint32_t SETD1R_TIMEVNT4 = 0x8000;    // Timer Event 4
    static constexpr uint32_t SETD1R_TIMEVNT3 = 0x4000;    // Timer Event 3
    static constexpr uint32_t SETD1R_TIMEVNT2 = 0x2000;    // Timer Event 2
    static constexpr uint32_t SETD1R_TIMEVNT1 = 0x1000;    // Timer Event 1
    static constexpr uint32_t SETD1R_MSTCMP4 = 0x800;      // Master Compare 4
    static constexpr uint32_t SETD1R_MSTCMP3 = 0x400;      // Master Compare 3
    static constexpr uint32_t SETD1R_MSTCMP2 = 0x200;      // Master Compare 2
    static constexpr uint32_t SETD1R_MSTCMP1 = 0x100;      // Master Compare 1
    static constexpr uint32_t SETD1R_MSTPER = 0x80;        // Master Period
    static constexpr uint32_t SETD1R_CMP4 = 0x40;          // Timer A compare 4
    static constexpr uint32_t SETD1R_CMP3 = 0x20;          // Timer A compare 3
    static constexpr uint32_t SETD1R_CMP2 = 0x10;          // Timer A compare 2
    static constexpr uint32_t SETD1R_CMP1 = 0x8;           // Timer A compare 1
    static constexpr uint32_t SETD1R_PER = 0x4;            // Timer A Period
    static constexpr uint32_t SETD1R_RESYNC = 0x2;         // Timer A resynchronizaton
    static constexpr uint32_t SETD1R_SST = 0x1;            // Software Set trigger
    static const uint32_t SETD1R_RESET_VALUE = 0x0;

    static constexpr uint32_t RSTD1R_UPDATE = 0x80000000;  // UPDATE
    static constexpr uint32_t RSTD1R_EXTEVNT10 = 0x40000000;// EXTEVNT10
    static constexpr uint32_t RSTD1R_EXTEVNT9 = 0x20000000;// EXTEVNT9
    static constexpr uint32_t RSTD1R_EXTEVNT8 = 0x10000000;// EXTEVNT8
    static constexpr uint32_t RSTD1R_EXTEVNT7 = 0x8000000; // EXTEVNT7
    static constexpr uint32_t RSTD1R_EXTEVNT6 = 0x4000000; // EXTEVNT6
    static constexpr uint32_t RSTD1R_EXTEVNT5 = 0x2000000; // EXTEVNT5
    static constexpr uint32_t RSTD1R_EXTEVNT4 = 0x1000000; // EXTEVNT4
    static constexpr uint32_t RSTD1R_EXTEVNT3 = 0x800000;  // EXTEVNT3
    static constexpr uint32_t RSTD1R_EXTEVNT2 = 0x400000;  // EXTEVNT2
    static constexpr uint32_t RSTD1R_EXTEVNT1 = 0x200000;  // EXTEVNT1
    static constexpr uint32_t RSTD1R_TIMEVNT9 = 0x100000;  // TIMEVNT9
    static constexpr uint32_t RSTD1R_TIMEVNT8 = 0x80000;   // TIMEVNT8
    static constexpr uint32_t RSTD1R_TIMEVNT7 = 0x40000;   // TIMEVNT7
    static constexpr uint32_t RSTD1R_TIMEVNT6 = 0x20000;   // TIMEVNT6
    static constexpr uint32_t RSTD1R_TIMEVNT5 = 0x10000;   // TIMEVNT5
    static constexpr uint32_t RSTD1R_TIMEVNT4 = 0x8000;    // TIMEVNT4
    static constexpr uint32_t RSTD1R_TIMEVNT3 = 0x4000;    // TIMEVNT3
    static constexpr uint32_t RSTD1R_TIMEVNT2 = 0x2000;    // TIMEVNT2
    static constexpr uint32_t RSTD1R_TIMEVNT1 = 0x1000;    // TIMEVNT1
    static constexpr uint32_t RSTD1R_MSTCMP4 = 0x800;      // MSTCMP4
    static constexpr uint32_t RSTD1R_MSTCMP3 = 0x400;      // MSTCMP3
    static constexpr uint32_t RSTD1R_MSTCMP2 = 0x200;      // MSTCMP2
    static constexpr uint32_t RSTD1R_MSTCMP1 = 0x100;      // MSTCMP1
    static constexpr uint32_t RSTD1R_MSTPER = 0x80;        // MSTPER
    static constexpr uint32_t RSTD1R_CMP4 = 0x40;          // CMP4
    static constexpr uint32_t RSTD1R_CMP3 = 0x20;          // CMP3
    static constexpr uint32_t RSTD1R_CMP2 = 0x10;          // CMP2
    static constexpr uint32_t RSTD1R_CMP1 = 0x8;           // CMP1
    static constexpr uint32_t RSTD1R_PER = 0x4;            // PER
    static constexpr uint32_t RSTD1R_RESYNC = 0x2;         // RESYNC
    static constexpr uint32_t RSTD1R_SRT = 0x1;            // SRT
    static const uint32_t RSTD1R_RESET_VALUE = 0x0;

    static constexpr uint32_t SETD2R_UPDATE = 0x80000000;  // UPDATE
    static constexpr uint32_t SETD2R_EXTEVNT10 = 0x40000000;// EXTEVNT10
    static constexpr uint32_t SETD2R_EXTEVNT9 = 0x20000000;// EXTEVNT9
    static constexpr uint32_t SETD2R_EXTEVNT8 = 0x10000000;// EXTEVNT8
    static constexpr uint32_t SETD2R_EXTEVNT7 = 0x8000000; // EXTEVNT7
    static constexpr uint32_t SETD2R_EXTEVNT6 = 0x4000000; // EXTEVNT6
    static constexpr uint32_t SETD2R_EXTEVNT5 = 0x2000000; // EXTEVNT5
    static constexpr uint32_t SETD2R_EXTEVNT4 = 0x1000000; // EXTEVNT4
    static constexpr uint32_t SETD2R_EXTEVNT3 = 0x800000;  // EXTEVNT3
    static constexpr uint32_t SETD2R_EXTEVNT2 = 0x400000;  // EXTEVNT2
    static constexpr uint32_t SETD2R_EXTEVNT1 = 0x200000;  // EXTEVNT1
    static constexpr uint32_t SETD2R_TIMEVNT9 = 0x100000;  // TIMEVNT9
    static constexpr uint32_t SETD2R_TIMEVNT8 = 0x80000;   // TIMEVNT8
    static constexpr uint32_t SETD2R_TIMEVNT7 = 0x40000;   // TIMEVNT7
    static constexpr uint32_t SETD2R_TIMEVNT6 = 0x20000;   // TIMEVNT6
    static constexpr uint32_t SETD2R_TIMEVNT5 = 0x10000;   // TIMEVNT5
    static constexpr uint32_t SETD2R_TIMEVNT4 = 0x8000;    // TIMEVNT4
    static constexpr uint32_t SETD2R_TIMEVNT3 = 0x4000;    // TIMEVNT3
    static constexpr uint32_t SETD2R_TIMEVNT2 = 0x2000;    // TIMEVNT2
    static constexpr uint32_t SETD2R_TIMEVNT1 = 0x1000;    // TIMEVNT1
    static constexpr uint32_t SETD2R_MSTCMP4 = 0x800;      // MSTCMP4
    static constexpr uint32_t SETD2R_MSTCMP3 = 0x400;      // MSTCMP3
    static constexpr uint32_t SETD2R_MSTCMP2 = 0x200;      // MSTCMP2
    static constexpr uint32_t SETD2R_MSTCMP1 = 0x100;      // MSTCMP1
    static constexpr uint32_t SETD2R_MSTPER = 0x80;        // MSTPER
    static constexpr uint32_t SETD2R_CMP4 = 0x40;          // CMP4
    static constexpr uint32_t SETD2R_CMP3 = 0x20;          // CMP3
    static constexpr uint32_t SETD2R_CMP2 = 0x10;          // CMP2
    static constexpr uint32_t SETD2R_CMP1 = 0x8;           // CMP1
    static constexpr uint32_t SETD2R_PER = 0x4;            // PER
    static constexpr uint32_t SETD2R_RESYNC = 0x2;         // RESYNC
    static constexpr uint32_t SETD2R_SST = 0x1;            // SST
    static const uint32_t SETD2R_RESET_VALUE = 0x0;

    static constexpr uint32_t RSTD2R_UPDATE = 0x80000000;  // UPDATE
    static constexpr uint32_t RSTD2R_EXTEVNT10 = 0x40000000;// EXTEVNT10
    static constexpr uint32_t RSTD2R_EXTEVNT9 = 0x20000000;// EXTEVNT9
    static constexpr uint32_t RSTD2R_EXTEVNT8 = 0x10000000;// EXTEVNT8
    static constexpr uint32_t RSTD2R_EXTEVNT7 = 0x8000000; // EXTEVNT7
    static constexpr uint32_t RSTD2R_EXTEVNT6 = 0x4000000; // EXTEVNT6
    static constexpr uint32_t RSTD2R_EXTEVNT5 = 0x2000000; // EXTEVNT5
    static constexpr uint32_t RSTD2R_EXTEVNT4 = 0x1000000; // EXTEVNT4
    static constexpr uint32_t RSTD2R_EXTEVNT3 = 0x800000;  // EXTEVNT3
    static constexpr uint32_t RSTD2R_EXTEVNT2 = 0x400000;  // EXTEVNT2
    static constexpr uint32_t RSTD2R_EXTEVNT1 = 0x200000;  // EXTEVNT1
    static constexpr uint32_t RSTD2R_TIMEVNT9 = 0x100000;  // TIMEVNT9
    static constexpr uint32_t RSTD2R_TIMEVNT8 = 0x80000;   // TIMEVNT8
    static constexpr uint32_t RSTD2R_TIMEVNT7 = 0x40000;   // TIMEVNT7
    static constexpr uint32_t RSTD2R_TIMEVNT6 = 0x20000;   // TIMEVNT6
    static constexpr uint32_t RSTD2R_TIMEVNT5 = 0x10000;   // TIMEVNT5
    static constexpr uint32_t RSTD2R_TIMEVNT4 = 0x8000;    // TIMEVNT4
    static constexpr uint32_t RSTD2R_TIMEVNT3 = 0x4000;    // TIMEVNT3
    static constexpr uint32_t RSTD2R_TIMEVNT2 = 0x2000;    // TIMEVNT2
    static constexpr uint32_t RSTD2R_TIMEVNT1 = 0x1000;    // TIMEVNT1
    static constexpr uint32_t RSTD2R_MSTCMP4 = 0x800;      // MSTCMP4
    static constexpr uint32_t RSTD2R_MSTCMP3 = 0x400;      // MSTCMP3
    static constexpr uint32_t RSTD2R_MSTCMP2 = 0x200;      // MSTCMP2
    static constexpr uint32_t RSTD2R_MSTCMP1 = 0x100;      // MSTCMP1
    static constexpr uint32_t RSTD2R_MSTPER = 0x80;        // MSTPER
    static constexpr uint32_t RSTD2R_CMP4 = 0x40;          // CMP4
    static constexpr uint32_t RSTD2R_CMP3 = 0x20;          // CMP3
    static constexpr uint32_t RSTD2R_CMP2 = 0x10;          // CMP2
    static constexpr uint32_t RSTD2R_CMP1 = 0x8;           // CMP1
    static constexpr uint32_t RSTD2R_PER = 0x4;            // PER
    static constexpr uint32_t RSTD2R_RESYNC = 0x2;         // RESYNC
    static constexpr uint32_t RSTD2R_SRT = 0x1;            // SRT
    static const uint32_t RSTD2R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t EEFDR1_EE5FLTR =             // External Event 5 filter (4 bits)
        bit_field_t<25, 0xf>::value<X>();
    static constexpr uint32_t EEFDR1_EE5LTCH = 0x1000000;  // External Event 5 latch
    template<uint32_t X>
    static constexpr uint32_t EEFDR1_EE4FLTR =             // External Event 4 filter (4 bits)
        bit_field_t<19, 0xf>::value<X>();
    static constexpr uint32_t EEFDR1_EE4LTCH = 0x40000;    // External Event 4 latch
    template<uint32_t X>
    static constexpr uint32_t EEFDR1_EE3FLTR =             // External Event 3 filter (4 bits)
        bit_field_t<13, 0xf>::value<X>();
    static constexpr uint32_t EEFDR1_EE3LTCH = 0x1000;     // External Event 3 latch
    template<uint32_t X>
    static constexpr uint32_t EEFDR1_EE2FLTR =             // External Event 2 filter (4 bits)
        bit_field_t<7, 0xf>::value<X>();
    static constexpr uint32_t EEFDR1_EE2LTCH = 0x40;       // External Event 2 latch
    template<uint32_t X>
    static constexpr uint32_t EEFDR1_EE1FLTR =             // External Event 1 filter (4 bits)
        bit_field_t<1, 0xf>::value<X>();
    static constexpr uint32_t EEFDR1_EE1LTCH = 0x1;        // External Event 1 latch
    static const uint32_t EEFDR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t EEFDR2_EE10FLTR =            // External Event 10 filter (4 bits)
        bit_field_t<25, 0xf>::value<X>();
    static constexpr uint32_t EEFDR2_EE10LTCH = 0x1000000; // External Event 10 latch
    template<uint32_t X>
    static constexpr uint32_t EEFDR2_EE9FLTR =             // External Event 9 filter (4 bits)
        bit_field_t<19, 0xf>::value<X>();
    static constexpr uint32_t EEFDR2_EE9LTCH = 0x40000;    // External Event 9 latch
    template<uint32_t X>
    static constexpr uint32_t EEFDR2_EE8FLTR =             // External Event 8 filter (4 bits)
        bit_field_t<13, 0xf>::value<X>();
    static constexpr uint32_t EEFDR2_EE8LTCH = 0x1000;     // External Event 8 latch
    template<uint32_t X>
    static constexpr uint32_t EEFDR2_EE7FLTR =             // External Event 7 filter (4 bits)
        bit_field_t<7, 0xf>::value<X>();
    static constexpr uint32_t EEFDR2_EE7LTCH = 0x40;       // External Event 7 latch
    template<uint32_t X>
    static constexpr uint32_t EEFDR2_EE6FLTR =             // External Event 6 filter (4 bits)
        bit_field_t<1, 0xf>::value<X>();
    static constexpr uint32_t EEFDR2_EE6LTCH = 0x1;        // External Event 6 latch
    static const uint32_t EEFDR2_RESET_VALUE = 0x0;

    static constexpr uint32_t RSTDR_TIMECMP4 = 0x40000000;// Timer E Compare 4
    static constexpr uint32_t RSTDR_TIMECMP2 = 0x20000000;// Timer E Compare 2
    static constexpr uint32_t RSTDR_TIMECMP1 = 0x10000000;// Timer E Compare 1
    static constexpr uint32_t RSTDR_TIMCCMP4 = 0x8000000; // Timer C Compare 4
    static constexpr uint32_t RSTDR_TIMCCMP2 = 0x4000000; // Timer C Compare 2
    static constexpr uint32_t RSTDR_TIMCCMP1 = 0x2000000; // Timer C Compare 1
    static constexpr uint32_t RSTDR_TIMBCMP4 = 0x1000000; // Timer B Compare 4
    static constexpr uint32_t RSTDR_TIMBCMP2 = 0x800000;  // Timer B Compare 2
    static constexpr uint32_t RSTDR_TIMBCMP1 = 0x400000;  // Timer B Compare 1
    static constexpr uint32_t RSTDR_TIMACMP4 = 0x200000;  // Timer A Compare 4
    static constexpr uint32_t RSTDR_TIMACMP2 = 0x100000;  // Timer A Compare 2
    static constexpr uint32_t RSTDR_TIMACMP1 = 0x80000;   // Timer A Compare 1
    static constexpr uint32_t RSTDR_EXTEVNT10 = 0x40000;  // External Event 10
    static constexpr uint32_t RSTDR_EXTEVNT9 = 0x20000;   // External Event 9
    static constexpr uint32_t RSTDR_EXTEVNT8 = 0x10000;   // External Event 8
    static constexpr uint32_t RSTDR_EXTEVNT7 = 0x8000;    // External Event 7
    static constexpr uint32_t RSTDR_EXTEVNT6 = 0x4000;    // External Event 6
    static constexpr uint32_t RSTDR_EXTEVNT5 = 0x2000;    // External Event 5
    static constexpr uint32_t RSTDR_EXTEVNT4 = 0x1000;    // External Event 4
    static constexpr uint32_t RSTDR_EXTEVNT3 = 0x800;     // External Event 3
    static constexpr uint32_t RSTDR_EXTEVNT2 = 0x400;     // External Event 2
    static constexpr uint32_t RSTDR_EXTEVNT1 = 0x200;     // External Event 1
    static constexpr uint32_t RSTDR_MSTCMP4 = 0x100;      // Master compare 4
    static constexpr uint32_t RSTDR_MSTCMP3 = 0x80;       // Master compare 3
    static constexpr uint32_t RSTDR_MSTCMP2 = 0x40;       // Master compare 2
    static constexpr uint32_t RSTDR_MSTCMP1 = 0x20;       // Master compare 1
    static constexpr uint32_t RSTDR_MSTPER = 0x10;        // Master timer Period
    static constexpr uint32_t RSTDR_CMP4 = 0x8;           // Timer A compare 4 reset
    static constexpr uint32_t RSTDR_CMP2 = 0x4;           // Timer A compare 2 reset
    static constexpr uint32_t RSTDR_UPDT = 0x2;           // Timer A Update reset
    static const uint32_t RSTDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHPDR_STRTPW =              // STRTPW (4 bits)
        bit_field_t<7, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHPDR_CHPDTY =              // Timerx chopper duty cycle value (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHPDR_CHPFRQ =              // Timerx carrier frequency value (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t CHPDR_RESET_VALUE = 0x0;

    static constexpr uint32_t CPT1DCR_TECMP2 = 0x80000000;  // Timer E Compare 2
    static constexpr uint32_t CPT1DCR_TECMP1 = 0x40000000;  // Timer E Compare 1
    static constexpr uint32_t CPT1DCR_TE1RST = 0x20000000;  // Timer E output 1 Reset
    static constexpr uint32_t CPT1DCR_TE1SET = 0x10000000;  // Timer E output 1 Set
    static constexpr uint32_t CPT1DCR_TCCMP2 = 0x800000;    // Timer C Compare 2
    static constexpr uint32_t CPT1DCR_TCCMP1 = 0x400000;    // Timer C Compare 1
    static constexpr uint32_t CPT1DCR_TC1RST = 0x200000;    // Timer C output 1 Reset
    static constexpr uint32_t CPT1DCR_TC1SET = 0x100000;    // Timer C output 1 Set
    static constexpr uint32_t CPT1DCR_TBCMP2 = 0x80000;     // Timer B Compare 2
    static constexpr uint32_t CPT1DCR_TBCMP1 = 0x40000;     // Timer B Compare 1
    static constexpr uint32_t CPT1DCR_TB1RST = 0x20000;     // Timer B output 1 Reset
    static constexpr uint32_t CPT1DCR_TB1SET = 0x10000;     // Timer B output 1 Set
    static constexpr uint32_t CPT1DCR_TACMP2 = 0x8000;      // Timer A Compare 2
    static constexpr uint32_t CPT1DCR_TACMP1 = 0x4000;      // Timer A Compare 1
    static constexpr uint32_t CPT1DCR_TA1RST = 0x2000;      // Timer A output 1 Reset
    static constexpr uint32_t CPT1DCR_TA1SET = 0x1000;      // Timer A output 1 Set
    static constexpr uint32_t CPT1DCR_EXEV10CPT = 0x800;    // External Event 10 Capture
    static constexpr uint32_t CPT1DCR_EXEV9CPT = 0x400;     // External Event 9 Capture
    static constexpr uint32_t CPT1DCR_EXEV8CPT = 0x200;     // External Event 8 Capture
    static constexpr uint32_t CPT1DCR_EXEV7CPT = 0x100;     // External Event 7 Capture
    static constexpr uint32_t CPT1DCR_EXEV6CPT = 0x80;      // External Event 6 Capture
    static constexpr uint32_t CPT1DCR_EXEV5CPT = 0x40;      // External Event 5 Capture
    static constexpr uint32_t CPT1DCR_EXEV4CPT = 0x20;      // External Event 4 Capture
    static constexpr uint32_t CPT1DCR_EXEV3CPT = 0x10;      // External Event 3 Capture
    static constexpr uint32_t CPT1DCR_EXEV2CPT = 0x8;       // External Event 2 Capture
    static constexpr uint32_t CPT1DCR_EXEV1CPT = 0x4;       // External Event 1 Capture
    static constexpr uint32_t CPT1DCR_UDPCPT = 0x2;         // Update Capture
    static constexpr uint32_t CPT1DCR_SWCPT = 0x1;          // Software Capture
    static const uint32_t CPT1DCR_RESET_VALUE = 0x0;

    static constexpr uint32_t CPT2DCR_TECMP2 = 0x80000000;  // Timer E Compare 2
    static constexpr uint32_t CPT2DCR_TECMP1 = 0x40000000;  // Timer E Compare 1
    static constexpr uint32_t CPT2DCR_TE1RST = 0x20000000;  // Timer E output 1 Reset
    static constexpr uint32_t CPT2DCR_TE1SET = 0x10000000;  // Timer E output 1 Set
    static constexpr uint32_t CPT2DCR_TCCMP2 = 0x800000;    // Timer C Compare 2
    static constexpr uint32_t CPT2DCR_TCCMP1 = 0x400000;    // Timer C Compare 1
    static constexpr uint32_t CPT2DCR_TC1RST = 0x200000;    // Timer C output 1 Reset
    static constexpr uint32_t CPT2DCR_TC1SET = 0x100000;    // Timer C output 1 Set
    static constexpr uint32_t CPT2DCR_TBCMP2 = 0x80000;     // Timer B Compare 2
    static constexpr uint32_t CPT2DCR_TBCMP1 = 0x40000;     // Timer B Compare 1
    static constexpr uint32_t CPT2DCR_TB1RST = 0x20000;     // Timer B output 1 Reset
    static constexpr uint32_t CPT2DCR_TB1SET = 0x10000;     // Timer B output 1 Set
    static constexpr uint32_t CPT2DCR_TACMP2 = 0x8000;      // Timer A Compare 2
    static constexpr uint32_t CPT2DCR_TACMP1 = 0x4000;      // Timer A Compare 1
    static constexpr uint32_t CPT2DCR_TA1RST = 0x2000;      // Timer A output 1 Reset
    static constexpr uint32_t CPT2DCR_TA1SET = 0x1000;      // Timer A output 1 Set
    static constexpr uint32_t CPT2DCR_EXEV10CPT = 0x800;    // External Event 10 Capture
    static constexpr uint32_t CPT2DCR_EXEV9CPT = 0x400;     // External Event 9 Capture
    static constexpr uint32_t CPT2DCR_EXEV8CPT = 0x200;     // External Event 8 Capture
    static constexpr uint32_t CPT2DCR_EXEV7CPT = 0x100;     // External Event 7 Capture
    static constexpr uint32_t CPT2DCR_EXEV6CPT = 0x80;      // External Event 6 Capture
    static constexpr uint32_t CPT2DCR_EXEV5CPT = 0x40;      // External Event 5 Capture
    static constexpr uint32_t CPT2DCR_EXEV4CPT = 0x20;      // External Event 4 Capture
    static constexpr uint32_t CPT2DCR_EXEV3CPT = 0x10;      // External Event 3 Capture
    static constexpr uint32_t CPT2DCR_EXEV2CPT = 0x8;       // External Event 2 Capture
    static constexpr uint32_t CPT2DCR_EXEV1CPT = 0x4;       // External Event 1 Capture
    static constexpr uint32_t CPT2DCR_UDPCPT = 0x2;         // Update Capture
    static constexpr uint32_t CPT2DCR_SWCPT = 0x1;          // Software Capture
    static const uint32_t CPT2DCR_RESET_VALUE = 0x0;

    static constexpr uint32_t OUTDR_DIDL2 = 0x800000;     // Output 2 Deadtime upon burst mode Idle entry
    static constexpr uint32_t OUTDR_CHP2 = 0x400000;      // Output 2 Chopper enable
    template<uint32_t X>
    static constexpr uint32_t OUTDR_FAULT2 =              // Output 2 Fault state (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    static constexpr uint32_t OUTDR_IDLES2 = 0x80000;     // Output 2 Idle State
    static constexpr uint32_t OUTDR_IDLEM2 = 0x40000;     // Output 2 Idle mode
    static constexpr uint32_t OUTDR_POL2 = 0x20000;       // Output 2 polarity
    template<uint32_t X>
    static constexpr uint32_t OUTDR_DLYPRT =              // Delayed Protection (3 bits)
        bit_field_t<10, 0x7>::value<X>();
    static constexpr uint32_t OUTDR_DLYPRTEN = 0x200;     // Delayed Protection Enable
    static constexpr uint32_t OUTDR_DTEN = 0x100;         // Deadtime enable
    static constexpr uint32_t OUTDR_DIDL1 = 0x80;         // Output 1 Deadtime upon burst mode Idle entry
    static constexpr uint32_t OUTDR_CHP1 = 0x40;          // Output 1 Chopper enable
    template<uint32_t X>
    static constexpr uint32_t OUTDR_FAULT1 =              // Output 1 Fault state (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static constexpr uint32_t OUTDR_IDLES1 = 0x8;         // Output 1 Idle State
    static constexpr uint32_t OUTDR_IDLEM1 = 0x4;         // Output 1 Idle mode
    static constexpr uint32_t OUTDR_POL1 = 0x2;           // Output 1 polarity
    static const uint32_t OUTDR_RESET_VALUE = 0x0;

    static constexpr uint32_t FLTDR_FLTLCK = 0x80000000;  // Fault sources Lock
    static constexpr uint32_t FLTDR_FLT5EN = 0x10;        // Fault 5 enable
    static constexpr uint32_t FLTDR_FLT4EN = 0x8;         // Fault 4 enable
    static constexpr uint32_t FLTDR_FLT3EN = 0x4;         // Fault 3 enable
    static constexpr uint32_t FLTDR_FLT2EN = 0x2;         // Fault 2 enable
    static constexpr uint32_t FLTDR_FLT1EN = 0x1;         // Fault 1 enable
    static const uint32_t FLTDR_RESET_VALUE = 0x0;

    static constexpr uint8_t HRTIM1_TIMC = 106; // HRTIM1 timer C interrupt
};

static hrtim_timd_t& HRTIM_TIMD = *reinterpret_cast<hrtim_timd_t*>(0x40017600);

#define HAVE_PERIPHERAL_HRTIM_TIMD


////
//
//    High Resolution Timer: TIME
//
////

struct hrtim_time_t
{
    volatile uint32_t    TIMECR;               // [Read-write] Timerx Control Register
    volatile uint32_t    TIMEISR;              // [Read-only] Timerx Interrupt Status Register
    volatile uint32_t    TIMEICR;              // [Write-only] Timerx Interrupt Clear Register
    volatile uint32_t    TIMEDIER5;            // [Read-write] TIMxDIER5
    volatile uint32_t    CNTER;                // [Read-write] Timerx Counter Register
    volatile uint32_t    PERER;                // [Read-write] Timerx Period Register
    volatile uint32_t    REPER;                // [Read-write] Timerx Repetition Register
    volatile uint32_t    CMP1ER;               // [Read-write] Timerx Compare 1 Register
    volatile uint32_t    CMP1CER;              // [Read-write] Timerx Compare 1 Compound Register
    volatile uint32_t    CMP2ER;               // [Read-write] Timerx Compare 2 Register
    volatile uint32_t    CMP3ER;               // [Read-write] Timerx Compare 3 Register
    volatile uint32_t    CMP4ER;               // [Read-write] Timerx Compare 4 Register
    volatile uint32_t    CPT1ER;               // [Read-only] Timerx Capture 1 Register
    volatile uint32_t    CPT2ER;               // [Read-only] Timerx Capture 2 Register
    volatile uint32_t    DTER;                 // [Read-write] Timerx Deadtime Register
    volatile uint32_t    SETE1R;               // [Read-write] Timerx Output1 Set Register
    volatile uint32_t    RSTE1R;               // [Read-write] Timerx Output1 Reset Register
    volatile uint32_t    SETE2R;               // [Read-write] Timerx Output2 Set Register
    volatile uint32_t    RSTE2R;               // [Read-write] Timerx Output2 Reset Register
    volatile uint32_t    EEFER1;               // [Read-write] Timerx External Event Filtering Register 1
    volatile uint32_t    EEFER2;               // [Read-write] Timerx External Event Filtering Register 2
    volatile uint32_t    RSTER;                // [Read-write] TimerA Reset Register
    volatile uint32_t    CHPER;                // [Read-write] Timerx Chopper Register
    volatile uint32_t    CPT1ECR;              // [Read-write] Timerx Capture 2 Control Register
    volatile uint32_t    CPT2ECR;              // [Read-write] CPT2xCR
    volatile uint32_t    OUTER;                // [Read-write] Timerx Output Register
    volatile uint32_t    FLTER;                // [Read-write] Timerx Fault Register

    template<uint32_t X>
    static constexpr uint32_t TIMECR_UPDGAT =              // Update Gating (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    static constexpr uint32_t TIMECR_PREEN = 0x8000000;    // Preload enable
    template<uint32_t X>
    static constexpr uint32_t TIMECR_DACSYNC =             // AC Synchronization (2 bits)
        bit_field_t<25, 0x3>::value<X>();
    static constexpr uint32_t TIMECR_MSTU = 0x1000000;     // Master Timer update
    static constexpr uint32_t TIMECR_TEU = 0x800000;       // TEU
    static constexpr uint32_t TIMECR_TDU = 0x400000;       // TDU
    static constexpr uint32_t TIMECR_TCU = 0x200000;       // TCU
    static constexpr uint32_t TIMECR_TBU = 0x100000;       // TBU
    static constexpr uint32_t TIMECR_TxRSTU = 0x40000;     // Timerx reset update
    static constexpr uint32_t TIMECR_TxREPU = 0x20000;     // Timer x Repetition update
    template<uint32_t X>
    static constexpr uint32_t TIMECR_DELCMP4 =             // Delayed CMP4 mode (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TIMECR_DELCMP2 =             // Delayed CMP2 mode (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    static constexpr uint32_t TIMECR_SYNCSTRTx = 0x800;    // Synchronization Starts Timer x
    static constexpr uint32_t TIMECR_SYNCRSTx = 0x400;     // Synchronization Resets Timer x
    static constexpr uint32_t TIMECR_PSHPLL = 0x40;        // Push-Pull mode enable
    static constexpr uint32_t TIMECR_HALF = 0x20;          // Half mode enable
    static constexpr uint32_t TIMECR_RETRIG = 0x10;        // Re-triggerable mode
    static constexpr uint32_t TIMECR_CONT = 0x8;           // Continuous mode
    template<uint32_t X>
    static constexpr uint32_t TIMECR_CK_PSCx =             // HRTIM Timer x Clock prescaler (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t TIMECR_RESET_VALUE = 0x0;

    static constexpr uint32_t TIMEISR_O2STAT = 0x80000;     // Output 2 State
    static constexpr uint32_t TIMEISR_O1STAT = 0x40000;     // Output 1 State
    static constexpr uint32_t TIMEISR_IPPSTAT = 0x20000;    // Idle Push Pull Status
    static constexpr uint32_t TIMEISR_CPPSTAT = 0x10000;    // Current Push Pull Status
    static constexpr uint32_t TIMEISR_DLYPRT = 0x4000;      // Delayed Protection Flag
    static constexpr uint32_t TIMEISR_RST = 0x2000;         // Reset Interrupt Flag
    static constexpr uint32_t TIMEISR_RSTx2 = 0x1000;       // Output 2 Reset Interrupt Flag
    static constexpr uint32_t TIMEISR_SETx2 = 0x800;        // Output 2 Set Interrupt Flag
    static constexpr uint32_t TIMEISR_RSTx1 = 0x400;        // Output 1 Reset Interrupt Flag
    static constexpr uint32_t TIMEISR_SETx1 = 0x200;        // Output 1 Set Interrupt Flag
    static constexpr uint32_t TIMEISR_CPT2 = 0x100;         // Capture2 Interrupt Flag
    static constexpr uint32_t TIMEISR_CPT1 = 0x80;          // Capture1 Interrupt Flag
    static constexpr uint32_t TIMEISR_UPD = 0x40;           // Update Interrupt Flag
    static constexpr uint32_t TIMEISR_REP = 0x10;           // Repetition Interrupt Flag
    static constexpr uint32_t TIMEISR_CMP4 = 0x8;           // Compare 4 Interrupt Flag
    static constexpr uint32_t TIMEISR_CMP3 = 0x4;           // Compare 3 Interrupt Flag
    static constexpr uint32_t TIMEISR_CMP2 = 0x2;           // Compare 2 Interrupt Flag
    static constexpr uint32_t TIMEISR_CMP1 = 0x1;           // Compare 1 Interrupt Flag
    static const uint32_t TIMEISR_RESET_VALUE = 0x0;

    static constexpr uint32_t TIMEICR_DLYPRTC = 0x4000;     // Delayed Protection Flag Clear
    static constexpr uint32_t TIMEICR_RSTC = 0x2000;        // Reset Interrupt flag Clear
    static constexpr uint32_t TIMEICR_RSTx2C = 0x1000;      // Output 2 Reset flag Clear
    static constexpr uint32_t TIMEICR_SET2xC = 0x800;       // Output 2 Set flag Clear
    static constexpr uint32_t TIMEICR_RSTx1C = 0x400;       // Output 1 Reset flag Clear
    static constexpr uint32_t TIMEICR_SET1xC = 0x200;       // Output 1 Set flag Clear
    static constexpr uint32_t TIMEICR_CPT2C = 0x100;        // Capture2 Interrupt flag Clear
    static constexpr uint32_t TIMEICR_CPT1C = 0x80;         // Capture1 Interrupt flag Clear
    static constexpr uint32_t TIMEICR_UPDC = 0x40;          // Update Interrupt flag Clear
    static constexpr uint32_t TIMEICR_REPC = 0x10;          // Repetition Interrupt flag Clear
    static constexpr uint32_t TIMEICR_CMP4C = 0x8;          // Compare 4 Interrupt flag Clear
    static constexpr uint32_t TIMEICR_CMP3C = 0x4;          // Compare 3 Interrupt flag Clear
    static constexpr uint32_t TIMEICR_CMP2C = 0x2;          // Compare 2 Interrupt flag Clear
    static constexpr uint32_t TIMEICR_CMP1C = 0x1;          // Compare 1 Interrupt flag Clear
    static const uint32_t TIMEICR_RESET_VALUE = 0x0;

    static constexpr uint32_t TIMEDIER5_DLYPRTDE = 0x40000000;// DLYPRTDE
    static constexpr uint32_t TIMEDIER5_RSTDE = 0x20000000;   // RSTDE
    static constexpr uint32_t TIMEDIER5_RSTx2DE = 0x10000000; // RSTx2DE
    static constexpr uint32_t TIMEDIER5_SETx2DE = 0x8000000;  // SETx2DE
    static constexpr uint32_t TIMEDIER5_RSTx1DE = 0x4000000;  // RSTx1DE
    static constexpr uint32_t TIMEDIER5_SET1xDE = 0x2000000;  // SET1xDE
    static constexpr uint32_t TIMEDIER5_CPT2DE = 0x1000000;   // CPT2DE
    static constexpr uint32_t TIMEDIER5_CPT1DE = 0x800000;    // CPT1DE
    static constexpr uint32_t TIMEDIER5_UPDDE = 0x400000;     // UPDDE
    static constexpr uint32_t TIMEDIER5_REPDE = 0x100000;     // REPDE
    static constexpr uint32_t TIMEDIER5_CMP4DE = 0x80000;     // CMP4DE
    static constexpr uint32_t TIMEDIER5_CMP3DE = 0x40000;     // CMP3DE
    static constexpr uint32_t TIMEDIER5_CMP2DE = 0x20000;     // CMP2DE
    static constexpr uint32_t TIMEDIER5_CMP1DE = 0x10000;     // CMP1DE
    static constexpr uint32_t TIMEDIER5_DLYPRTIE = 0x4000;    // DLYPRTIE
    static constexpr uint32_t TIMEDIER5_RSTIE = 0x2000;       // RSTIE
    static constexpr uint32_t TIMEDIER5_RSTx2IE = 0x1000;     // RSTx2IE
    static constexpr uint32_t TIMEDIER5_SETx2IE = 0x800;      // SETx2IE
    static constexpr uint32_t TIMEDIER5_RSTx1IE = 0x400;      // RSTx1IE
    static constexpr uint32_t TIMEDIER5_SET1xIE = 0x200;      // SET1xIE
    static constexpr uint32_t TIMEDIER5_CPT2IE = 0x100;       // CPT2IE
    static constexpr uint32_t TIMEDIER5_CPT1IE = 0x80;        // CPT1IE
    static constexpr uint32_t TIMEDIER5_UPDIE = 0x40;         // UPDIE
    static constexpr uint32_t TIMEDIER5_REPIE = 0x10;         // REPIE
    static constexpr uint32_t TIMEDIER5_CMP4IE = 0x8;         // CMP4IE
    static constexpr uint32_t TIMEDIER5_CMP3IE = 0x4;         // CMP3IE
    static constexpr uint32_t TIMEDIER5_CMP2IE = 0x2;         // CMP2IE
    static constexpr uint32_t TIMEDIER5_CMP1IE = 0x1;         // CMP1IE
    static const uint32_t TIMEDIER5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CNTER_CNTx =                // Timerx Counter value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CNTER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PERER_PERx =                // Timerx Period value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t PERER_RESET_VALUE = 0xffff;

    template<uint32_t X>
    static constexpr uint32_t REPER_REPx =                // Timerx Repetition counter value (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t REPER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CMP1ER_CMP1x =               // Timerx Compare 1 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CMP1ER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CMP1CER_REPx =                // Timerx Repetition value (aliased from HRTIM_REPx register) (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CMP1CER_CMP1x =               // Timerx Compare 1 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CMP1CER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CMP2ER_CMP2x =               // Timerx Compare 2 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CMP2ER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CMP3ER_CMP3x =               // Timerx Compare 3 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CMP3ER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CMP4ER_CMP4x =               // Timerx Compare 4 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CMP4ER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CPT1ER_CPT1x =               // Timerx Capture 1 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CPT1ER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CPT2ER_CPT2x =               // Timerx Capture 2 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CPT2ER_RESET_VALUE = 0x0;

    static constexpr uint32_t DTER_DTFLKx = 0x80000000;  // Deadtime Falling Lock
    static constexpr uint32_t DTER_DTFSLKx = 0x40000000; // Deadtime Falling Sign Lock
    static constexpr uint32_t DTER_SDTFx = 0x2000000;    // Sign Deadtime Falling value
    template<uint32_t X>
    static constexpr uint32_t DTER_DTFx =                // Deadtime Falling value (9 bits)
        bit_field_t<16, 0x1ff>::value<X>();
    static constexpr uint32_t DTER_DTRLKx = 0x8000;      // Deadtime Rising Lock
    static constexpr uint32_t DTER_DTRSLKx = 0x4000;     // Deadtime Rising Sign Lock
    template<uint32_t X>
    static constexpr uint32_t DTER_DTPRSC =              // Deadtime Prescaler (3 bits)
        bit_field_t<10, 0x7>::value<X>();
    static constexpr uint32_t DTER_SDTRx = 0x200;        // Sign Deadtime Rising value
    template<uint32_t X>
    static constexpr uint32_t DTER_DTRx =                // Deadtime Rising value (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static const uint32_t DTER_RESET_VALUE = 0x0;

    static constexpr uint32_t SETE1R_UPDATE = 0x80000000;  // Registers update (transfer preload to active)
    static constexpr uint32_t SETE1R_EXTEVNT10 = 0x40000000;// External Event 10
    static constexpr uint32_t SETE1R_EXTEVNT9 = 0x20000000;// External Event 9
    static constexpr uint32_t SETE1R_EXTEVNT8 = 0x10000000;// External Event 8
    static constexpr uint32_t SETE1R_EXTEVNT7 = 0x8000000; // External Event 7
    static constexpr uint32_t SETE1R_EXTEVNT6 = 0x4000000; // External Event 6
    static constexpr uint32_t SETE1R_EXTEVNT5 = 0x2000000; // External Event 5
    static constexpr uint32_t SETE1R_EXTEVNT4 = 0x1000000; // External Event 4
    static constexpr uint32_t SETE1R_EXTEVNT3 = 0x800000;  // External Event 3
    static constexpr uint32_t SETE1R_EXTEVNT2 = 0x400000;  // External Event 2
    static constexpr uint32_t SETE1R_EXTEVNT1 = 0x200000;  // External Event 1
    static constexpr uint32_t SETE1R_TIMEVNT9 = 0x100000;  // Timer Event 9
    static constexpr uint32_t SETE1R_TIMEVNT8 = 0x80000;   // Timer Event 8
    static constexpr uint32_t SETE1R_TIMEVNT7 = 0x40000;   // Timer Event 7
    static constexpr uint32_t SETE1R_TIMEVNT6 = 0x20000;   // Timer Event 6
    static constexpr uint32_t SETE1R_TIMEVNT5 = 0x10000;   // Timer Event 5
    static constexpr uint32_t SETE1R_TIMEVNT4 = 0x8000;    // Timer Event 4
    static constexpr uint32_t SETE1R_TIMEVNT3 = 0x4000;    // Timer Event 3
    static constexpr uint32_t SETE1R_TIMEVNT2 = 0x2000;    // Timer Event 2
    static constexpr uint32_t SETE1R_TIMEVNT1 = 0x1000;    // Timer Event 1
    static constexpr uint32_t SETE1R_MSTCMP4 = 0x800;      // Master Compare 4
    static constexpr uint32_t SETE1R_MSTCMP3 = 0x400;      // Master Compare 3
    static constexpr uint32_t SETE1R_MSTCMP2 = 0x200;      // Master Compare 2
    static constexpr uint32_t SETE1R_MSTCMP1 = 0x100;      // Master Compare 1
    static constexpr uint32_t SETE1R_MSTPER = 0x80;        // Master Period
    static constexpr uint32_t SETE1R_CMP4 = 0x40;          // Timer A compare 4
    static constexpr uint32_t SETE1R_CMP3 = 0x20;          // Timer A compare 3
    static constexpr uint32_t SETE1R_CMP2 = 0x10;          // Timer A compare 2
    static constexpr uint32_t SETE1R_CMP1 = 0x8;           // Timer A compare 1
    static constexpr uint32_t SETE1R_PER = 0x4;            // Timer A Period
    static constexpr uint32_t SETE1R_RESYNC = 0x2;         // Timer A resynchronizaton
    static constexpr uint32_t SETE1R_SST = 0x1;            // Software Set trigger
    static const uint32_t SETE1R_RESET_VALUE = 0x0;

    static constexpr uint32_t RSTE1R_UPDATE = 0x80000000;  // UPDATE
    static constexpr uint32_t RSTE1R_EXTEVNT10 = 0x40000000;// EXTEVNT10
    static constexpr uint32_t RSTE1R_EXTEVNT9 = 0x20000000;// EXTEVNT9
    static constexpr uint32_t RSTE1R_EXTEVNT8 = 0x10000000;// EXTEVNT8
    static constexpr uint32_t RSTE1R_EXTEVNT7 = 0x8000000; // EXTEVNT7
    static constexpr uint32_t RSTE1R_EXTEVNT6 = 0x4000000; // EXTEVNT6
    static constexpr uint32_t RSTE1R_EXTEVNT5 = 0x2000000; // EXTEVNT5
    static constexpr uint32_t RSTE1R_EXTEVNT4 = 0x1000000; // EXTEVNT4
    static constexpr uint32_t RSTE1R_EXTEVNT3 = 0x800000;  // EXTEVNT3
    static constexpr uint32_t RSTE1R_EXTEVNT2 = 0x400000;  // EXTEVNT2
    static constexpr uint32_t RSTE1R_EXTEVNT1 = 0x200000;  // EXTEVNT1
    static constexpr uint32_t RSTE1R_TIMEVNT9 = 0x100000;  // TIMEVNT9
    static constexpr uint32_t RSTE1R_TIMEVNT8 = 0x80000;   // TIMEVNT8
    static constexpr uint32_t RSTE1R_TIMEVNT7 = 0x40000;   // TIMEVNT7
    static constexpr uint32_t RSTE1R_TIMEVNT6 = 0x20000;   // TIMEVNT6
    static constexpr uint32_t RSTE1R_TIMEVNT5 = 0x10000;   // TIMEVNT5
    static constexpr uint32_t RSTE1R_TIMEVNT4 = 0x8000;    // TIMEVNT4
    static constexpr uint32_t RSTE1R_TIMEVNT3 = 0x4000;    // TIMEVNT3
    static constexpr uint32_t RSTE1R_TIMEVNT2 = 0x2000;    // TIMEVNT2
    static constexpr uint32_t RSTE1R_TIMEVNT1 = 0x1000;    // TIMEVNT1
    static constexpr uint32_t RSTE1R_MSTCMP4 = 0x800;      // MSTCMP4
    static constexpr uint32_t RSTE1R_MSTCMP3 = 0x400;      // MSTCMP3
    static constexpr uint32_t RSTE1R_MSTCMP2 = 0x200;      // MSTCMP2
    static constexpr uint32_t RSTE1R_MSTCMP1 = 0x100;      // MSTCMP1
    static constexpr uint32_t RSTE1R_MSTPER = 0x80;        // MSTPER
    static constexpr uint32_t RSTE1R_CMP4 = 0x40;          // CMP4
    static constexpr uint32_t RSTE1R_CMP3 = 0x20;          // CMP3
    static constexpr uint32_t RSTE1R_CMP2 = 0x10;          // CMP2
    static constexpr uint32_t RSTE1R_CMP1 = 0x8;           // CMP1
    static constexpr uint32_t RSTE1R_PER = 0x4;            // PER
    static constexpr uint32_t RSTE1R_RESYNC = 0x2;         // RESYNC
    static constexpr uint32_t RSTE1R_SRT = 0x1;            // SRT
    static const uint32_t RSTE1R_RESET_VALUE = 0x0;

    static constexpr uint32_t SETE2R_UPDATE = 0x80000000;  // UPDATE
    static constexpr uint32_t SETE2R_EXTEVNT10 = 0x40000000;// EXTEVNT10
    static constexpr uint32_t SETE2R_EXTEVNT9 = 0x20000000;// EXTEVNT9
    static constexpr uint32_t SETE2R_EXTEVNT8 = 0x10000000;// EXTEVNT8
    static constexpr uint32_t SETE2R_EXTEVNT7 = 0x8000000; // EXTEVNT7
    static constexpr uint32_t SETE2R_EXTEVNT6 = 0x4000000; // EXTEVNT6
    static constexpr uint32_t SETE2R_EXTEVNT5 = 0x2000000; // EXTEVNT5
    static constexpr uint32_t SETE2R_EXTEVNT4 = 0x1000000; // EXTEVNT4
    static constexpr uint32_t SETE2R_EXTEVNT3 = 0x800000;  // EXTEVNT3
    static constexpr uint32_t SETE2R_EXTEVNT2 = 0x400000;  // EXTEVNT2
    static constexpr uint32_t SETE2R_EXTEVNT1 = 0x200000;  // EXTEVNT1
    static constexpr uint32_t SETE2R_TIMEVNT9 = 0x100000;  // TIMEVNT9
    static constexpr uint32_t SETE2R_TIMEVNT8 = 0x80000;   // TIMEVNT8
    static constexpr uint32_t SETE2R_TIMEVNT7 = 0x40000;   // TIMEVNT7
    static constexpr uint32_t SETE2R_TIMEVNT6 = 0x20000;   // TIMEVNT6
    static constexpr uint32_t SETE2R_TIMEVNT5 = 0x10000;   // TIMEVNT5
    static constexpr uint32_t SETE2R_TIMEVNT4 = 0x8000;    // TIMEVNT4
    static constexpr uint32_t SETE2R_TIMEVNT3 = 0x4000;    // TIMEVNT3
    static constexpr uint32_t SETE2R_TIMEVNT2 = 0x2000;    // TIMEVNT2
    static constexpr uint32_t SETE2R_TIMEVNT1 = 0x1000;    // TIMEVNT1
    static constexpr uint32_t SETE2R_MSTCMP4 = 0x800;      // MSTCMP4
    static constexpr uint32_t SETE2R_MSTCMP3 = 0x400;      // MSTCMP3
    static constexpr uint32_t SETE2R_MSTCMP2 = 0x200;      // MSTCMP2
    static constexpr uint32_t SETE2R_MSTCMP1 = 0x100;      // MSTCMP1
    static constexpr uint32_t SETE2R_MSTPER = 0x80;        // MSTPER
    static constexpr uint32_t SETE2R_CMP4 = 0x40;          // CMP4
    static constexpr uint32_t SETE2R_CMP3 = 0x20;          // CMP3
    static constexpr uint32_t SETE2R_CMP2 = 0x10;          // CMP2
    static constexpr uint32_t SETE2R_CMP1 = 0x8;           // CMP1
    static constexpr uint32_t SETE2R_PER = 0x4;            // PER
    static constexpr uint32_t SETE2R_RESYNC = 0x2;         // RESYNC
    static constexpr uint32_t SETE2R_SST = 0x1;            // SST
    static const uint32_t SETE2R_RESET_VALUE = 0x0;

    static constexpr uint32_t RSTE2R_UPDATE = 0x80000000;  // UPDATE
    static constexpr uint32_t RSTE2R_EXTEVNT10 = 0x40000000;// EXTEVNT10
    static constexpr uint32_t RSTE2R_EXTEVNT9 = 0x20000000;// EXTEVNT9
    static constexpr uint32_t RSTE2R_EXTEVNT8 = 0x10000000;// EXTEVNT8
    static constexpr uint32_t RSTE2R_EXTEVNT7 = 0x8000000; // EXTEVNT7
    static constexpr uint32_t RSTE2R_EXTEVNT6 = 0x4000000; // EXTEVNT6
    static constexpr uint32_t RSTE2R_EXTEVNT5 = 0x2000000; // EXTEVNT5
    static constexpr uint32_t RSTE2R_EXTEVNT4 = 0x1000000; // EXTEVNT4
    static constexpr uint32_t RSTE2R_EXTEVNT3 = 0x800000;  // EXTEVNT3
    static constexpr uint32_t RSTE2R_EXTEVNT2 = 0x400000;  // EXTEVNT2
    static constexpr uint32_t RSTE2R_EXTEVNT1 = 0x200000;  // EXTEVNT1
    static constexpr uint32_t RSTE2R_TIMEVNT9 = 0x100000;  // TIMEVNT9
    static constexpr uint32_t RSTE2R_TIMEVNT8 = 0x80000;   // TIMEVNT8
    static constexpr uint32_t RSTE2R_TIMEVNT7 = 0x40000;   // TIMEVNT7
    static constexpr uint32_t RSTE2R_TIMEVNT6 = 0x20000;   // TIMEVNT6
    static constexpr uint32_t RSTE2R_TIMEVNT5 = 0x10000;   // TIMEVNT5
    static constexpr uint32_t RSTE2R_TIMEVNT4 = 0x8000;    // TIMEVNT4
    static constexpr uint32_t RSTE2R_TIMEVNT3 = 0x4000;    // TIMEVNT3
    static constexpr uint32_t RSTE2R_TIMEVNT2 = 0x2000;    // TIMEVNT2
    static constexpr uint32_t RSTE2R_TIMEVNT1 = 0x1000;    // TIMEVNT1
    static constexpr uint32_t RSTE2R_MSTCMP4 = 0x800;      // MSTCMP4
    static constexpr uint32_t RSTE2R_MSTCMP3 = 0x400;      // MSTCMP3
    static constexpr uint32_t RSTE2R_MSTCMP2 = 0x200;      // MSTCMP2
    static constexpr uint32_t RSTE2R_MSTCMP1 = 0x100;      // MSTCMP1
    static constexpr uint32_t RSTE2R_MSTPER = 0x80;        // MSTPER
    static constexpr uint32_t RSTE2R_CMP4 = 0x40;          // CMP4
    static constexpr uint32_t RSTE2R_CMP3 = 0x20;          // CMP3
    static constexpr uint32_t RSTE2R_CMP2 = 0x10;          // CMP2
    static constexpr uint32_t RSTE2R_CMP1 = 0x8;           // CMP1
    static constexpr uint32_t RSTE2R_PER = 0x4;            // PER
    static constexpr uint32_t RSTE2R_RESYNC = 0x2;         // RESYNC
    static constexpr uint32_t RSTE2R_SRT = 0x1;            // SRT
    static const uint32_t RSTE2R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t EEFER1_EE5FLTR =             // External Event 5 filter (4 bits)
        bit_field_t<25, 0xf>::value<X>();
    static constexpr uint32_t EEFER1_EE5LTCH = 0x1000000;  // External Event 5 latch
    template<uint32_t X>
    static constexpr uint32_t EEFER1_EE4FLTR =             // External Event 4 filter (4 bits)
        bit_field_t<19, 0xf>::value<X>();
    static constexpr uint32_t EEFER1_EE4LTCH = 0x40000;    // External Event 4 latch
    template<uint32_t X>
    static constexpr uint32_t EEFER1_EE3FLTR =             // External Event 3 filter (4 bits)
        bit_field_t<13, 0xf>::value<X>();
    static constexpr uint32_t EEFER1_EE3LTCH = 0x1000;     // External Event 3 latch
    template<uint32_t X>
    static constexpr uint32_t EEFER1_EE2FLTR =             // External Event 2 filter (4 bits)
        bit_field_t<7, 0xf>::value<X>();
    static constexpr uint32_t EEFER1_EE2LTCH = 0x40;       // External Event 2 latch
    template<uint32_t X>
    static constexpr uint32_t EEFER1_EE1FLTR =             // External Event 1 filter (4 bits)
        bit_field_t<1, 0xf>::value<X>();
    static constexpr uint32_t EEFER1_EE1LTCH = 0x1;        // External Event 1 latch
    static const uint32_t EEFER1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t EEFER2_EE10FLTR =            // External Event 10 filter (4 bits)
        bit_field_t<25, 0xf>::value<X>();
    static constexpr uint32_t EEFER2_EE10LTCH = 0x1000000; // External Event 10 latch
    template<uint32_t X>
    static constexpr uint32_t EEFER2_EE9FLTR =             // External Event 9 filter (4 bits)
        bit_field_t<19, 0xf>::value<X>();
    static constexpr uint32_t EEFER2_EE9LTCH = 0x40000;    // External Event 9 latch
    template<uint32_t X>
    static constexpr uint32_t EEFER2_EE8FLTR =             // External Event 8 filter (4 bits)
        bit_field_t<13, 0xf>::value<X>();
    static constexpr uint32_t EEFER2_EE8LTCH = 0x1000;     // External Event 8 latch
    template<uint32_t X>
    static constexpr uint32_t EEFER2_EE7FLTR =             // External Event 7 filter (4 bits)
        bit_field_t<7, 0xf>::value<X>();
    static constexpr uint32_t EEFER2_EE7LTCH = 0x40;       // External Event 7 latch
    template<uint32_t X>
    static constexpr uint32_t EEFER2_EE6FLTR =             // External Event 6 filter (4 bits)
        bit_field_t<1, 0xf>::value<X>();
    static constexpr uint32_t EEFER2_EE6LTCH = 0x1;        // External Event 6 latch
    static const uint32_t EEFER2_RESET_VALUE = 0x0;

    static constexpr uint32_t RSTER_TIMDCMP4 = 0x40000000;// Timer D Compare 4
    static constexpr uint32_t RSTER_TIMDCMP2 = 0x20000000;// Timer D Compare 2
    static constexpr uint32_t RSTER_TIMDCMP1 = 0x10000000;// Timer D Compare 1
    static constexpr uint32_t RSTER_TIMCCMP4 = 0x8000000; // Timer C Compare 4
    static constexpr uint32_t RSTER_TIMCCMP2 = 0x4000000; // Timer C Compare 2
    static constexpr uint32_t RSTER_TIMCCMP1 = 0x2000000; // Timer C Compare 1
    static constexpr uint32_t RSTER_TIMBCMP4 = 0x1000000; // Timer B Compare 4
    static constexpr uint32_t RSTER_TIMBCMP2 = 0x800000;  // Timer B Compare 2
    static constexpr uint32_t RSTER_TIMBCMP1 = 0x400000;  // Timer B Compare 1
    static constexpr uint32_t RSTER_TIMACMP4 = 0x200000;  // Timer A Compare 4
    static constexpr uint32_t RSTER_TIMACMP2 = 0x100000;  // Timer A Compare 2
    static constexpr uint32_t RSTER_TIMACMP1 = 0x80000;   // Timer A Compare 1
    static constexpr uint32_t RSTER_EXTEVNT10 = 0x40000;  // External Event 10
    static constexpr uint32_t RSTER_EXTEVNT9 = 0x20000;   // External Event 9
    static constexpr uint32_t RSTER_EXTEVNT8 = 0x10000;   // External Event 8
    static constexpr uint32_t RSTER_EXTEVNT7 = 0x8000;    // External Event 7
    static constexpr uint32_t RSTER_EXTEVNT6 = 0x4000;    // External Event 6
    static constexpr uint32_t RSTER_EXTEVNT5 = 0x2000;    // External Event 5
    static constexpr uint32_t RSTER_EXTEVNT4 = 0x1000;    // External Event 4
    static constexpr uint32_t RSTER_EXTEVNT3 = 0x800;     // External Event 3
    static constexpr uint32_t RSTER_EXTEVNT2 = 0x400;     // External Event 2
    static constexpr uint32_t RSTER_EXTEVNT1 = 0x200;     // External Event 1
    static constexpr uint32_t RSTER_MSTCMP4 = 0x100;      // Master compare 4
    static constexpr uint32_t RSTER_MSTCMP3 = 0x80;       // Master compare 3
    static constexpr uint32_t RSTER_MSTCMP2 = 0x40;       // Master compare 2
    static constexpr uint32_t RSTER_MSTCMP1 = 0x20;       // Master compare 1
    static constexpr uint32_t RSTER_MSTPER = 0x10;        // Master timer Period
    static constexpr uint32_t RSTER_CMP4 = 0x8;           // Timer A compare 4 reset
    static constexpr uint32_t RSTER_CMP2 = 0x4;           // Timer A compare 2 reset
    static constexpr uint32_t RSTER_UPDT = 0x2;           // Timer A Update reset
    static const uint32_t RSTER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHPER_STRTPW =              // STRTPW (4 bits)
        bit_field_t<7, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHPER_CHPDTY =              // Timerx chopper duty cycle value (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHPER_CHPFRQ =              // Timerx carrier frequency value (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t CHPER_RESET_VALUE = 0x0;

    static constexpr uint32_t CPT1ECR_TDCMP2 = 0x8000000;   // Timer D Compare 2
    static constexpr uint32_t CPT1ECR_TDCMP1 = 0x4000000;   // Timer D Compare 1
    static constexpr uint32_t CPT1ECR_TD1RST = 0x2000000;   // Timer D output 1 Reset
    static constexpr uint32_t CPT1ECR_TD1SET = 0x1000000;   // Timer D output 1 Set
    static constexpr uint32_t CPT1ECR_TCCMP2 = 0x800000;    // Timer C Compare 2
    static constexpr uint32_t CPT1ECR_TCCMP1 = 0x400000;    // Timer C Compare 1
    static constexpr uint32_t CPT1ECR_TC1RST = 0x200000;    // Timer C output 1 Reset
    static constexpr uint32_t CPT1ECR_TC1SET = 0x100000;    // Timer C output 1 Set
    static constexpr uint32_t CPT1ECR_TBCMP2 = 0x80000;     // Timer B Compare 2
    static constexpr uint32_t CPT1ECR_TBCMP1 = 0x40000;     // Timer B Compare 1
    static constexpr uint32_t CPT1ECR_TB1RST = 0x20000;     // Timer B output 1 Reset
    static constexpr uint32_t CPT1ECR_TB1SET = 0x10000;     // Timer B output 1 Set
    static constexpr uint32_t CPT1ECR_TACMP2 = 0x8000;      // Timer A Compare 2
    static constexpr uint32_t CPT1ECR_TACMP1 = 0x4000;      // Timer A Compare 1
    static constexpr uint32_t CPT1ECR_TA1RST = 0x2000;      // Timer A output 1 Reset
    static constexpr uint32_t CPT1ECR_TA1SET = 0x1000;      // Timer A output 1 Set
    static constexpr uint32_t CPT1ECR_EXEV10CPT = 0x800;    // External Event 10 Capture
    static constexpr uint32_t CPT1ECR_EXEV9CPT = 0x400;     // External Event 9 Capture
    static constexpr uint32_t CPT1ECR_EXEV8CPT = 0x200;     // External Event 8 Capture
    static constexpr uint32_t CPT1ECR_EXEV7CPT = 0x100;     // External Event 7 Capture
    static constexpr uint32_t CPT1ECR_EXEV6CPT = 0x80;      // External Event 6 Capture
    static constexpr uint32_t CPT1ECR_EXEV5CPT = 0x40;      // External Event 5 Capture
    static constexpr uint32_t CPT1ECR_EXEV4CPT = 0x20;      // External Event 4 Capture
    static constexpr uint32_t CPT1ECR_EXEV3CPT = 0x10;      // External Event 3 Capture
    static constexpr uint32_t CPT1ECR_EXEV2CPT = 0x8;       // External Event 2 Capture
    static constexpr uint32_t CPT1ECR_EXEV1CPT = 0x4;       // External Event 1 Capture
    static constexpr uint32_t CPT1ECR_UDPCPT = 0x2;         // Update Capture
    static constexpr uint32_t CPT1ECR_SWCPT = 0x1;          // Software Capture
    static const uint32_t CPT1ECR_RESET_VALUE = 0x0;

    static constexpr uint32_t CPT2ECR_TDCMP2 = 0x8000000;   // Timer D Compare 2
    static constexpr uint32_t CPT2ECR_TDCMP1 = 0x4000000;   // Timer D Compare 1
    static constexpr uint32_t CPT2ECR_TD1RST = 0x2000000;   // Timer D output 1 Reset
    static constexpr uint32_t CPT2ECR_TD1SET = 0x1000000;   // Timer D output 1 Set
    static constexpr uint32_t CPT2ECR_TCCMP2 = 0x800000;    // Timer C Compare 2
    static constexpr uint32_t CPT2ECR_TCCMP1 = 0x400000;    // Timer C Compare 1
    static constexpr uint32_t CPT2ECR_TC1RST = 0x200000;    // Timer C output 1 Reset
    static constexpr uint32_t CPT2ECR_TC1SET = 0x100000;    // Timer C output 1 Set
    static constexpr uint32_t CPT2ECR_TBCMP2 = 0x80000;     // Timer B Compare 2
    static constexpr uint32_t CPT2ECR_TBCMP1 = 0x40000;     // Timer B Compare 1
    static constexpr uint32_t CPT2ECR_TB1RST = 0x20000;     // Timer B output 1 Reset
    static constexpr uint32_t CPT2ECR_TB1SET = 0x10000;     // Timer B output 1 Set
    static constexpr uint32_t CPT2ECR_TACMP2 = 0x8000;      // Timer A Compare 2
    static constexpr uint32_t CPT2ECR_TACMP1 = 0x4000;      // Timer A Compare 1
    static constexpr uint32_t CPT2ECR_TA1RST = 0x2000;      // Timer A output 1 Reset
    static constexpr uint32_t CPT2ECR_TA1SET = 0x1000;      // Timer A output 1 Set
    static constexpr uint32_t CPT2ECR_EXEV10CPT = 0x800;    // External Event 10 Capture
    static constexpr uint32_t CPT2ECR_EXEV9CPT = 0x400;     // External Event 9 Capture
    static constexpr uint32_t CPT2ECR_EXEV8CPT = 0x200;     // External Event 8 Capture
    static constexpr uint32_t CPT2ECR_EXEV7CPT = 0x100;     // External Event 7 Capture
    static constexpr uint32_t CPT2ECR_EXEV6CPT = 0x80;      // External Event 6 Capture
    static constexpr uint32_t CPT2ECR_EXEV5CPT = 0x40;      // External Event 5 Capture
    static constexpr uint32_t CPT2ECR_EXEV4CPT = 0x20;      // External Event 4 Capture
    static constexpr uint32_t CPT2ECR_EXEV3CPT = 0x10;      // External Event 3 Capture
    static constexpr uint32_t CPT2ECR_EXEV2CPT = 0x8;       // External Event 2 Capture
    static constexpr uint32_t CPT2ECR_EXEV1CPT = 0x4;       // External Event 1 Capture
    static constexpr uint32_t CPT2ECR_UDPCPT = 0x2;         // Update Capture
    static constexpr uint32_t CPT2ECR_SWCPT = 0x1;          // Software Capture
    static const uint32_t CPT2ECR_RESET_VALUE = 0x0;

    static constexpr uint32_t OUTER_DIDL2 = 0x800000;     // Output 2 Deadtime upon burst mode Idle entry
    static constexpr uint32_t OUTER_CHP2 = 0x400000;      // Output 2 Chopper enable
    template<uint32_t X>
    static constexpr uint32_t OUTER_FAULT2 =              // Output 2 Fault state (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    static constexpr uint32_t OUTER_IDLES2 = 0x80000;     // Output 2 Idle State
    static constexpr uint32_t OUTER_IDLEM2 = 0x40000;     // Output 2 Idle mode
    static constexpr uint32_t OUTER_POL2 = 0x20000;       // Output 2 polarity
    template<uint32_t X>
    static constexpr uint32_t OUTER_DLYPRT =              // Delayed Protection (3 bits)
        bit_field_t<10, 0x7>::value<X>();
    static constexpr uint32_t OUTER_DLYPRTEN = 0x200;     // Delayed Protection Enable
    static constexpr uint32_t OUTER_DTEN = 0x100;         // Deadtime enable
    static constexpr uint32_t OUTER_DIDL1 = 0x80;         // Output 1 Deadtime upon burst mode Idle entry
    static constexpr uint32_t OUTER_CHP1 = 0x40;          // Output 1 Chopper enable
    template<uint32_t X>
    static constexpr uint32_t OUTER_FAULT1 =              // Output 1 Fault state (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static constexpr uint32_t OUTER_IDLES1 = 0x8;         // Output 1 Idle State
    static constexpr uint32_t OUTER_IDLEM1 = 0x4;         // Output 1 Idle mode
    static constexpr uint32_t OUTER_POL1 = 0x2;           // Output 1 polarity
    static const uint32_t OUTER_RESET_VALUE = 0x0;

    static constexpr uint32_t FLTER_FLTLCK = 0x80000000;  // Fault sources Lock
    static constexpr uint32_t FLTER_FLT5EN = 0x10;        // Fault 5 enable
    static constexpr uint32_t FLTER_FLT4EN = 0x8;         // Fault 4 enable
    static constexpr uint32_t FLTER_FLT3EN = 0x4;         // Fault 3 enable
    static constexpr uint32_t FLTER_FLT2EN = 0x2;         // Fault 2 enable
    static constexpr uint32_t FLTER_FLT1EN = 0x1;         // Fault 1 enable
    static const uint32_t FLTER_RESET_VALUE = 0x0;

    static constexpr uint8_t HRTIM1_TIMD = 107; // HRTIM1 timer D interrupt
};

static hrtim_time_t& HRTIM_TIME = *reinterpret_cast<hrtim_time_t*>(0x40017680);

#define HAVE_PERIPHERAL_HRTIM_TIME


////
//
//    High Resolution Timer: Common functions
//
////

struct hrtim_common_t
{
    volatile uint32_t    CR1;                  // [Read-write] Control Register 1
    volatile uint32_t    CR2;                  // [Read-write] Control Register 2
    volatile uint32_t    ISR;                  // Interrupt Status Register
    volatile uint32_t    ICR;                  // Interrupt Clear Register
    volatile uint32_t    IER;                  // [Read-write] Interrupt Enable Register
    volatile uint32_t    OENR;                 // [Write-only] Output Enable Register
    volatile uint32_t    DISR;                 // [Read-write] DISR
    volatile uint32_t    ODSR;                 // [Read-only] Output Disable Status Register
    volatile uint32_t    BMCR;                 // [Read-write] Burst Mode Control Register
    volatile uint32_t    BMTRG;                // [Read-write] BMTRG
    volatile uint32_t    BMCMPR6;              // [Read-write] BMCMPR6
    volatile uint32_t    BMPER;                // [Read-write] Burst Mode Period Register
    volatile uint32_t    EECR1;                // [Read-write] Timer External Event Control Register 1
    volatile uint32_t    EECR2;                // [Read-write] Timer External Event Control Register 2
    volatile uint32_t    EECR3;                // [Read-write] Timer External Event Control Register 3
    volatile uint32_t    ADC1R;                // [Read-write] ADC Trigger 1 Register
    volatile uint32_t    ADC2R;                // [Read-write] ADC Trigger 2 Register
    volatile uint32_t    ADC3R;                // [Read-write] ADC Trigger 3 Register
    volatile uint32_t    ADC4R;                // [Read-write] ADC Trigger 4 Register
    volatile uint32_t    DLLCR;                // [Read-write] DLL Control Register
    volatile uint32_t    FLTINR1;              // [Read-write] HRTIM Fault Input Register 1
    volatile uint32_t    FLTINR2;              // [Read-write] HRTIM Fault Input Register 2
    volatile uint32_t    BDMUPDR;              // [Read-write] BDMUPDR
    volatile uint32_t    BDTxUPR;              // [Read-write] Burst DMA Timerx update Register
    volatile uint32_t    BDMADR;               // [Read-write] Burst DMA Data Register

    template<uint32_t X>
    static constexpr uint32_t CR1_AD4USRC =             // ADC Trigger 4 Update Source (3 bits)
        bit_field_t<25, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR1_AD3USRC =             // ADC Trigger 3 Update Source (3 bits)
        bit_field_t<22, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR1_AD2USRC =             // ADC Trigger 2 Update Source (3 bits)
        bit_field_t<19, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR1_AD1USRC =             // ADC Trigger 1 Update Source (3 bits)
        bit_field_t<16, 0x7>::value<X>();
    static constexpr uint32_t CR1_TEUDIS = 0x20;        // Timer E Update Disable
    static constexpr uint32_t CR1_TDUDIS = 0x10;        // Timer D Update Disable
    static constexpr uint32_t CR1_TCUDIS = 0x8;         // Timer C Update Disable
    static constexpr uint32_t CR1_TBUDIS = 0x4;         // Timer B Update Disable
    static constexpr uint32_t CR1_TAUDIS = 0x2;         // Timer A Update Disable
    static constexpr uint32_t CR1_MUDIS = 0x1;          // Master Update Disable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CR2_TERST = 0x2000;       // Timer E counter software reset
    static constexpr uint32_t CR2_TDRST = 0x1000;       // Timer D counter software reset
    static constexpr uint32_t CR2_TCRST = 0x800;        // Timer C counter software reset
    static constexpr uint32_t CR2_TBRST = 0x400;        // Timer B counter software reset
    static constexpr uint32_t CR2_TARST = 0x200;        // Timer A counter software reset
    static constexpr uint32_t CR2_MRST = 0x100;         // Master Counter software reset
    static constexpr uint32_t CR2_TESWU = 0x20;         // Timer E Software Update
    static constexpr uint32_t CR2_TDSWU = 0x10;         // Timer D Software Update
    static constexpr uint32_t CR2_TCSWU = 0x8;          // Timer C Software Update
    static constexpr uint32_t CR2_TBSWU = 0x4;          // Timer B Software Update
    static constexpr uint32_t CR2_TASWU = 0x2;          // Timer A Software update
    static constexpr uint32_t CR2_MSWU = 0x1;           // Master Timer Software update
    static const uint32_t CR2_RESET_VALUE = 0x0;

    static constexpr uint32_t ISR_BMPER = 0x20000;      // Burst mode Period Interrupt Flag, Read-only
    static constexpr uint32_t ISR_DLLRDY = 0x10000;     // DLL Ready Interrupt Flag, Read-only
    static constexpr uint32_t ISR_SYSFLT = 0x20;        // System Fault Interrupt Flag, Read-write
    static constexpr uint32_t ISR_FLT5 = 0x10;          // Fault 5 Interrupt Flag, Read-only
    static constexpr uint32_t ISR_FLT4 = 0x8;           // Fault 4 Interrupt Flag, Read-only
    static constexpr uint32_t ISR_FLT3 = 0x4;           // Fault 3 Interrupt Flag, Read-only
    static constexpr uint32_t ISR_FLT2 = 0x2;           // Fault 2 Interrupt Flag, Read-only
    static constexpr uint32_t ISR_FLT1 = 0x1;           // Fault 1 Interrupt Flag, Read-only
    static const uint32_t ISR_RESET_VALUE = 0x0;

    static constexpr uint32_t ICR_BMPERC = 0x20000;     // Burst mode period flag Clear, Write-only
    static constexpr uint32_t ICR_DLLRDYC = 0x10000;    // DLL Ready Interrupt flag Clear, Write-only
    static constexpr uint32_t ICR_SYSFLTC = 0x20;       // System Fault Interrupt Flag Clear, Read-write
    static constexpr uint32_t ICR_FLT5C = 0x10;         // Fault 5 Interrupt Flag Clear, Write-only
    static constexpr uint32_t ICR_FLT4C = 0x8;          // Fault 4 Interrupt Flag Clear, Write-only
    static constexpr uint32_t ICR_FLT3C = 0x4;          // Fault 3 Interrupt Flag Clear, Write-only
    static constexpr uint32_t ICR_FLT2C = 0x2;          // Fault 2 Interrupt Flag Clear, Write-only
    static constexpr uint32_t ICR_FLT1C = 0x1;          // Fault 1 Interrupt Flag Clear, Write-only
    static const uint32_t ICR_RESET_VALUE = 0x0;

    static constexpr uint32_t IER_BMPERIE = 0x20000;    // Burst mode period Interrupt Enable
    static constexpr uint32_t IER_DLLRDYIE = 0x10000;   // DLL Ready Interrupt Enable
    static constexpr uint32_t IER_SYSFLTE = 0x20;       // System Fault Interrupt Enable
    static constexpr uint32_t IER_FLT5IE = 0x10;        // Fault 5 Interrupt Enable
    static constexpr uint32_t IER_FLT4IE = 0x8;         // Fault 4 Interrupt Enable
    static constexpr uint32_t IER_FLT3IE = 0x4;         // Fault 3 Interrupt Enable
    static constexpr uint32_t IER_FLT2IE = 0x2;         // Fault 2 Interrupt Enable
    static constexpr uint32_t IER_FLT1IE = 0x1;         // Fault 1 Interrupt Enable
    static const uint32_t IER_RESET_VALUE = 0x0;

    static constexpr uint32_t OENR_TE2OEN = 0x200;       // Timer E Output 2 Enable
    static constexpr uint32_t OENR_TE1OEN = 0x100;       // Timer E Output 1 Enable
    static constexpr uint32_t OENR_TD2OEN = 0x80;        // Timer D Output 2 Enable
    static constexpr uint32_t OENR_TD1OEN = 0x40;        // Timer D Output 1 Enable
    static constexpr uint32_t OENR_TC2OEN = 0x20;        // Timer C Output 2 Enable
    static constexpr uint32_t OENR_TC1OEN = 0x10;        // Timer C Output 1 Enable
    static constexpr uint32_t OENR_TB2OEN = 0x8;         // Timer B Output 2 Enable
    static constexpr uint32_t OENR_TB1OEN = 0x4;         // Timer B Output 1 Enable
    static constexpr uint32_t OENR_TA2OEN = 0x2;         // Timer A Output 2 Enable
    static constexpr uint32_t OENR_TA1OEN = 0x1;         // Timer A Output 1 Enable
    static const uint32_t OENR_RESET_VALUE = 0x0;

    static constexpr uint32_t DISR_TE2ODIS = 0x200;      // TE2ODIS
    static constexpr uint32_t DISR_TE1ODIS = 0x100;      // TE1ODIS
    static constexpr uint32_t DISR_TD2ODIS = 0x80;       // TD2ODIS
    static constexpr uint32_t DISR_TD1ODIS = 0x40;       // TD1ODIS
    static constexpr uint32_t DISR_TC2ODIS = 0x20;       // TC2ODIS
    static constexpr uint32_t DISR_TC1ODIS = 0x10;       // TC1ODIS
    static constexpr uint32_t DISR_TB2ODIS = 0x8;        // TB2ODIS
    static constexpr uint32_t DISR_TB1ODIS = 0x4;        // TB1ODIS
    static constexpr uint32_t DISR_TA2ODIS = 0x2;        // TA2ODIS
    static constexpr uint32_t DISR_TA1ODIS = 0x1;        // TA1ODIS
    static const uint32_t DISR_RESET_VALUE = 0x0;

    static constexpr uint32_t ODSR_TE2ODS = 0x200;       // Timer E Output 2 disable status
    static constexpr uint32_t ODSR_TE1ODS = 0x100;       // Timer E Output 1 disable status
    static constexpr uint32_t ODSR_TD2ODS = 0x80;        // Timer D Output 2 disable status
    static constexpr uint32_t ODSR_TD1ODS = 0x40;        // Timer D Output 1 disable status
    static constexpr uint32_t ODSR_TC2ODS = 0x20;        // Timer C Output 2 disable status
    static constexpr uint32_t ODSR_TC1ODS = 0x10;        // Timer C Output 1 disable status
    static constexpr uint32_t ODSR_TB2ODS = 0x8;         // Timer B Output 2 disable status
    static constexpr uint32_t ODSR_TB1ODS = 0x4;         // Timer B Output 1 disable status
    static constexpr uint32_t ODSR_TA2ODS = 0x2;         // Timer A Output 2 disable status
    static constexpr uint32_t ODSR_TA1ODS = 0x1;         // Timer A Output 1 disable status
    static const uint32_t ODSR_RESET_VALUE = 0x0;

    static constexpr uint32_t BMCR_BMSTAT = 0x80000000;  // Burst Mode Status
    static constexpr uint32_t BMCR_TEBM = 0x200000;      // Timer E Burst Mode
    static constexpr uint32_t BMCR_TDBM = 0x100000;      // Timer D Burst Mode
    static constexpr uint32_t BMCR_TCBM = 0x80000;       // Timer C Burst Mode
    static constexpr uint32_t BMCR_TBBM = 0x40000;       // Timer B Burst Mode
    static constexpr uint32_t BMCR_TABM = 0x20000;       // Timer A Burst Mode
    static constexpr uint32_t BMCR_MTBM = 0x10000;       // Master Timer Burst Mode
    static constexpr uint32_t BMCR_BMPREN = 0x400;       // Burst Mode Preload Enable
    template<uint32_t X>
    static constexpr uint32_t BMCR_BMPRSC =              // Burst Mode Prescaler (4 bits)
        bit_field_t<6, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BMCR_BMCLK =               // Burst Mode Clock source (4 bits)
        bit_field_t<2, 0xf>::value<X>();
    static constexpr uint32_t BMCR_BMOM = 0x2;           // Burst Mode operating mode
    static constexpr uint32_t BMCR_BME = 0x1;            // Burst Mode enable
    static const uint32_t BMCR_RESET_VALUE = 0x0;

    static constexpr uint32_t BMTRG_OCHPEV = 0x80000000;  // OCHPEV
    static constexpr uint32_t BMTRG_TECMP2 = 0x4000000;   // TECMP2
    static constexpr uint32_t BMTRG_TECMP1 = 0x2000000;   // TECMP1
    static constexpr uint32_t BMTRG_TEREP = 0x1000000;    // TEREP
    static constexpr uint32_t BMTRG_TERST = 0x800000;     // TERST
    static constexpr uint32_t BMTRG_TDCMP2 = 0x400000;    // TDCMP2
    static constexpr uint32_t BMTRG_TDCMP1 = 0x200000;    // TDCMP1
    static constexpr uint32_t BMTRG_TDREP = 0x100000;     // TDREP
    static constexpr uint32_t BMTRG_TDRST = 0x80000;      // TDRST
    static constexpr uint32_t BMTRG_TCCMP2 = 0x40000;     // TCCMP2
    static constexpr uint32_t BMTRG_TCCMP1 = 0x20000;     // TCCMP1
    static constexpr uint32_t BMTRG_TCREP = 0x10000;      // TCREP
    static constexpr uint32_t BMTRG_TCRST = 0x8000;       // TCRST
    static constexpr uint32_t BMTRG_TBCMP2 = 0x4000;      // TBCMP2
    static constexpr uint32_t BMTRG_TBCMP1 = 0x2000;      // TBCMP1
    static constexpr uint32_t BMTRG_TBREP = 0x1000;       // TBREP
    static constexpr uint32_t BMTRG_TBRST = 0x800;        // TBRST
    static constexpr uint32_t BMTRG_TACMP2 = 0x400;       // TACMP2
    static constexpr uint32_t BMTRG_TACMP1 = 0x200;       // TACMP1
    static constexpr uint32_t BMTRG_TAREP = 0x100;        // TAREP
    static constexpr uint32_t BMTRG_TARST = 0x80;         // TARST
    static constexpr uint32_t BMTRG_MSTCMP4 = 0x40;       // MSTCMP4
    static constexpr uint32_t BMTRG_MSTCMP3 = 0x20;       // MSTCMP3
    static constexpr uint32_t BMTRG_MSTCMP2 = 0x10;       // MSTCMP2
    static constexpr uint32_t BMTRG_MSTCMP1 = 0x8;        // MSTCMP1
    static constexpr uint32_t BMTRG_MSTREP = 0x4;         // MSTREP
    static constexpr uint32_t BMTRG_MSTRST = 0x2;         // MSTRST
    static constexpr uint32_t BMTRG_SW = 0x1;             // SW
    static const uint32_t BMTRG_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BMCMPR6_BMCMP =               // BMCMP (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t BMCMPR6_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BMPER_BMPER =               // Burst mode Period (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t BMPER_RESET_VALUE = 0x0;

    static constexpr uint32_t EECR1_EE5FAST = 0x20000000; // External Event 5 Fast mode
    template<uint32_t X>
    static constexpr uint32_t EECR1_EE5SNS =              // External Event 5 Sensitivity (2 bits)
        bit_field_t<27, 0x3>::value<X>();
    static constexpr uint32_t EECR1_EE5POL = 0x4000000;   // External Event 5 Polarity
    template<uint32_t X>
    static constexpr uint32_t EECR1_EE5SRC =              // External Event 5 Source (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    static constexpr uint32_t EECR1_EE4FAST = 0x800000;   // External Event 4 Fast mode
    template<uint32_t X>
    static constexpr uint32_t EECR1_EE4SNS =              // External Event 4 Sensitivity (2 bits)
        bit_field_t<21, 0x3>::value<X>();
    static constexpr uint32_t EECR1_EE4POL = 0x100000;    // External Event 4 Polarity
    template<uint32_t X>
    static constexpr uint32_t EECR1_EE4SRC =              // External Event 4 Source (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t EECR1_EE3FAST = 0x20000;    // External Event 3 Fast mode
    template<uint32_t X>
    static constexpr uint32_t EECR1_EE3SNS =              // External Event 3 Sensitivity (2 bits)
        bit_field_t<15, 0x3>::value<X>();
    static constexpr uint32_t EECR1_EE3POL = 0x4000;      // External Event 3 Polarity
    template<uint32_t X>
    static constexpr uint32_t EECR1_EE3SRC =              // External Event 3 Source (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    static constexpr uint32_t EECR1_EE2FAST = 0x800;      // External Event 2 Fast mode
    template<uint32_t X>
    static constexpr uint32_t EECR1_EE2SNS =              // External Event 2 Sensitivity (2 bits)
        bit_field_t<9, 0x3>::value<X>();
    static constexpr uint32_t EECR1_EE2POL = 0x100;       // External Event 2 Polarity
    template<uint32_t X>
    static constexpr uint32_t EECR1_EE2SRC =              // External Event 2 Source (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t EECR1_EE1FAST = 0x20;       // External Event 1 Fast mode
    template<uint32_t X>
    static constexpr uint32_t EECR1_EE1SNS =              // External Event 1 Sensitivity (2 bits)
        bit_field_t<3, 0x3>::value<X>();
    static constexpr uint32_t EECR1_EE1POL = 0x4;         // External Event 1 Polarity
    template<uint32_t X>
    static constexpr uint32_t EECR1_EE1SRC =              // External Event 1 Source (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t EECR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t EECR2_EE10SNS =             // External Event 10 Sensitivity (2 bits)
        bit_field_t<27, 0x3>::value<X>();
    static constexpr uint32_t EECR2_EE10POL = 0x4000000;  // External Event 10 Polarity
    template<uint32_t X>
    static constexpr uint32_t EECR2_EE10SRC =             // External Event 10 Source (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t EECR2_EE9SNS =              // External Event 9 Sensitivity (2 bits)
        bit_field_t<21, 0x3>::value<X>();
    static constexpr uint32_t EECR2_EE9POL = 0x100000;    // External Event 9 Polarity
    template<uint32_t X>
    static constexpr uint32_t EECR2_EE9SRC =              // External Event 9 Source (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t EECR2_EE8SNS =              // External Event 8 Sensitivity (2 bits)
        bit_field_t<15, 0x3>::value<X>();
    static constexpr uint32_t EECR2_EE8POL = 0x4000;      // External Event 8 Polarity
    template<uint32_t X>
    static constexpr uint32_t EECR2_EE8SRC =              // External Event 8 Source (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t EECR2_EE7SNS =              // External Event 7 Sensitivity (2 bits)
        bit_field_t<9, 0x3>::value<X>();
    static constexpr uint32_t EECR2_EE7POL = 0x100;       // External Event 7 Polarity
    template<uint32_t X>
    static constexpr uint32_t EECR2_EE7SRC =              // External Event 7 Source (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t EECR2_EE6SNS =              // External Event 6 Sensitivity (2 bits)
        bit_field_t<3, 0x3>::value<X>();
    static constexpr uint32_t EECR2_EE6POL = 0x4;         // External Event 6 Polarity
    template<uint32_t X>
    static constexpr uint32_t EECR2_EE6SRC =              // External Event 6 Source (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t EECR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t EECR3_EE10SNS =             // EE10SNS (2 bits)
        bit_field_t<27, 0x3>::value<X>();
    static constexpr uint32_t EECR3_EE10POL = 0x4000000;  // EE10POL
    template<uint32_t X>
    static constexpr uint32_t EECR3_EE10SRC =             // EE10SRC (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t EECR3_EE9SNS =              // EE9SNS (2 bits)
        bit_field_t<21, 0x3>::value<X>();
    static constexpr uint32_t EECR3_EE9POL = 0x100000;    // EE9POL
    template<uint32_t X>
    static constexpr uint32_t EECR3_EE9SRC =              // EE9SRC (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t EECR3_EE8SNS =              // EE8SNS (2 bits)
        bit_field_t<15, 0x3>::value<X>();
    static constexpr uint32_t EECR3_EE8POL = 0x4000;      // EE8POL
    template<uint32_t X>
    static constexpr uint32_t EECR3_EE8SRC =              // EE8SRC (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t EECR3_EE7SNS =              // EE7SNS (2 bits)
        bit_field_t<9, 0x3>::value<X>();
    static constexpr uint32_t EECR3_EE7POL = 0x100;       // EE7POL
    template<uint32_t X>
    static constexpr uint32_t EECR3_EE7SRC =              // EE7SRC (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t EECR3_EE6SNS =              // EE6SNS (2 bits)
        bit_field_t<3, 0x3>::value<X>();
    static constexpr uint32_t EECR3_EE6POL = 0x4;         // EE6POL
    template<uint32_t X>
    static constexpr uint32_t EECR3_EE6SRC =              // EE6SRC (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t EECR3_RESET_VALUE = 0x0;

    static constexpr uint32_t ADC1R_AD1TEPER = 0x80000000;// ADC trigger 1 on Timer E Period
    static constexpr uint32_t ADC1R_AD1TEC4 = 0x40000000; // ADC trigger 1 on Timer E compare 4
    static constexpr uint32_t ADC1R_AD1TEC3 = 0x20000000; // ADC trigger 1 on Timer E compare 3
    static constexpr uint32_t ADC1R_AD1TEC2 = 0x10000000; // ADC trigger 1 on Timer E compare 2
    static constexpr uint32_t ADC1R_AD1TDPER = 0x8000000; // ADC trigger 1 on Timer D Period
    static constexpr uint32_t ADC1R_AD1TDC4 = 0x4000000;  // ADC trigger 1 on Timer D compare 4
    static constexpr uint32_t ADC1R_AD1TDC3 = 0x2000000;  // ADC trigger 1 on Timer D compare 3
    static constexpr uint32_t ADC1R_AD1TDC2 = 0x1000000;  // ADC trigger 1 on Timer D compare 2
    static constexpr uint32_t ADC1R_AD1TCPER = 0x800000;  // ADC trigger 1 on Timer C Period
    static constexpr uint32_t ADC1R_AD1TCC4 = 0x400000;   // ADC trigger 1 on Timer C compare 4
    static constexpr uint32_t ADC1R_AD1TCC3 = 0x200000;   // ADC trigger 1 on Timer C compare 3
    static constexpr uint32_t ADC1R_AD1TCC2 = 0x100000;   // ADC trigger 1 on Timer C compare 2
    static constexpr uint32_t ADC1R_AD1TBRST = 0x80000;   // ADC trigger 1 on Timer B Reset
    static constexpr uint32_t ADC1R_AD1TBPER = 0x40000;   // ADC trigger 1 on Timer B Period
    static constexpr uint32_t ADC1R_AD1TBC4 = 0x20000;    // ADC trigger 1 on Timer B compare 4
    static constexpr uint32_t ADC1R_AD1TBC3 = 0x10000;    // ADC trigger 1 on Timer B compare 3
    static constexpr uint32_t ADC1R_AD1TBC2 = 0x8000;     // ADC trigger 1 on Timer B compare 2
    static constexpr uint32_t ADC1R_AD1TARST = 0x4000;    // ADC trigger 1 on Timer A Reset
    static constexpr uint32_t ADC1R_AD1TAPER = 0x2000;    // ADC trigger 1 on Timer A Period
    static constexpr uint32_t ADC1R_AD1TAC4 = 0x1000;     // ADC trigger 1 on Timer A compare 4
    static constexpr uint32_t ADC1R_AD1TAC3 = 0x800;      // ADC trigger 1 on Timer A compare 3
    static constexpr uint32_t ADC1R_AD1TAC2 = 0x400;      // ADC trigger 1 on Timer A compare 2
    static constexpr uint32_t ADC1R_AD1EEV5 = 0x200;      // ADC trigger 1 on External Event 5
    static constexpr uint32_t ADC1R_AD1EEV4 = 0x100;      // ADC trigger 1 on External Event 4
    static constexpr uint32_t ADC1R_AD1EEV3 = 0x80;       // ADC trigger 1 on External Event 3
    static constexpr uint32_t ADC1R_AD1EEV2 = 0x40;       // ADC trigger 1 on External Event 2
    static constexpr uint32_t ADC1R_AD1EEV1 = 0x20;       // ADC trigger 1 on External Event 1
    static constexpr uint32_t ADC1R_AD1MPER = 0x10;       // ADC trigger 1 on Master Period
    static constexpr uint32_t ADC1R_AD1MC4 = 0x8;         // ADC trigger 1 on Master Compare 4
    static constexpr uint32_t ADC1R_AD1MC3 = 0x4;         // ADC trigger 1 on Master Compare 3
    static constexpr uint32_t ADC1R_AD1MC2 = 0x2;         // ADC trigger 1 on Master Compare 2
    static constexpr uint32_t ADC1R_AD1MC1 = 0x1;         // ADC trigger 1 on Master Compare 1
    static const uint32_t ADC1R_RESET_VALUE = 0x0;

    static constexpr uint32_t ADC2R_AD2TERST = 0x80000000;// ADC trigger 2 on Timer E Reset
    static constexpr uint32_t ADC2R_AD2TEC4 = 0x40000000; // ADC trigger 2 on Timer E compare 4
    static constexpr uint32_t ADC2R_AD2TEC3 = 0x20000000; // ADC trigger 2 on Timer E compare 3
    static constexpr uint32_t ADC2R_AD2TEC2 = 0x10000000; // ADC trigger 2 on Timer E compare 2
    static constexpr uint32_t ADC2R_AD2TDRST = 0x8000000; // ADC trigger 2 on Timer D Reset
    static constexpr uint32_t ADC2R_AD2TDPER = 0x4000000; // ADC trigger 2 on Timer D Period
    static constexpr uint32_t ADC2R_AD2TDC4 = 0x2000000;  // ADC trigger 2 on Timer D compare 4
    static constexpr uint32_t ADC2R_AD2TDC3 = 0x1000000;  // ADC trigger 2 on Timer D compare 3
    static constexpr uint32_t ADC2R_AD2TDC2 = 0x800000;   // ADC trigger 2 on Timer D compare 2
    static constexpr uint32_t ADC2R_AD2TCRST = 0x400000;  // ADC trigger 2 on Timer C Reset
    static constexpr uint32_t ADC2R_AD2TCPER = 0x200000;  // ADC trigger 2 on Timer C Period
    static constexpr uint32_t ADC2R_AD2TCC4 = 0x100000;   // ADC trigger 2 on Timer C compare 4
    static constexpr uint32_t ADC2R_AD2TCC3 = 0x80000;    // ADC trigger 2 on Timer C compare 3
    static constexpr uint32_t ADC2R_AD2TCC2 = 0x40000;    // ADC trigger 2 on Timer C compare 2
    static constexpr uint32_t ADC2R_AD2TBPER = 0x20000;   // ADC trigger 2 on Timer B Period
    static constexpr uint32_t ADC2R_AD2TBC4 = 0x10000;    // ADC trigger 2 on Timer B compare 4
    static constexpr uint32_t ADC2R_AD2TBC3 = 0x8000;     // ADC trigger 2 on Timer B compare 3
    static constexpr uint32_t ADC2R_AD2TBC2 = 0x4000;     // ADC trigger 2 on Timer B compare 2
    static constexpr uint32_t ADC2R_AD2TAPER = 0x2000;    // ADC trigger 2 on Timer A Period
    static constexpr uint32_t ADC2R_AD2TAC4 = 0x1000;     // ADC trigger 2 on Timer A compare 4
    static constexpr uint32_t ADC2R_AD2TAC3 = 0x800;      // ADC trigger 2 on Timer A compare 3
    static constexpr uint32_t ADC2R_AD2TAC2 = 0x400;      // ADC trigger 2 on Timer A compare 2
    static constexpr uint32_t ADC2R_AD2EEV10 = 0x200;     // ADC trigger 2 on External Event 10
    static constexpr uint32_t ADC2R_AD2EEV9 = 0x100;      // ADC trigger 2 on External Event 9
    static constexpr uint32_t ADC2R_AD2EEV8 = 0x80;       // ADC trigger 2 on External Event 8
    static constexpr uint32_t ADC2R_AD2EEV7 = 0x40;       // ADC trigger 2 on External Event 7
    static constexpr uint32_t ADC2R_AD2EEV6 = 0x20;       // ADC trigger 2 on External Event 6
    static constexpr uint32_t ADC2R_AD2MPER = 0x10;       // ADC trigger 2 on Master Period
    static constexpr uint32_t ADC2R_AD2MC4 = 0x8;         // ADC trigger 2 on Master Compare 4
    static constexpr uint32_t ADC2R_AD2MC3 = 0x4;         // ADC trigger 2 on Master Compare 3
    static constexpr uint32_t ADC2R_AD2MC2 = 0x2;         // ADC trigger 2 on Master Compare 2
    static constexpr uint32_t ADC2R_AD2MC1 = 0x1;         // ADC trigger 2 on Master Compare 1
    static const uint32_t ADC2R_RESET_VALUE = 0x0;

    static constexpr uint32_t ADC3R_AD1TEPER = 0x80000000;// AD1TEPER
    static constexpr uint32_t ADC3R_AD1TEC4 = 0x40000000; // AD1TEC4
    static constexpr uint32_t ADC3R_AD1TEC3 = 0x20000000; // AD1TEC3
    static constexpr uint32_t ADC3R_AD1TEC2 = 0x10000000; // AD1TEC2
    static constexpr uint32_t ADC3R_AD1TDPER = 0x8000000; // AD1TDPER
    static constexpr uint32_t ADC3R_AD1TDC4 = 0x4000000;  // AD1TDC4
    static constexpr uint32_t ADC3R_AD1TDC3 = 0x2000000;  // AD1TDC3
    static constexpr uint32_t ADC3R_AD1TDC2 = 0x1000000;  // AD1TDC2
    static constexpr uint32_t ADC3R_AD1TCPER = 0x800000;  // AD1TCPER
    static constexpr uint32_t ADC3R_AD1TCC4 = 0x400000;   // AD1TCC4
    static constexpr uint32_t ADC3R_AD1TCC3 = 0x200000;   // AD1TCC3
    static constexpr uint32_t ADC3R_AD1TCC2 = 0x100000;   // AD1TCC2
    static constexpr uint32_t ADC3R_AD1TBRST = 0x80000;   // AD1TBRST
    static constexpr uint32_t ADC3R_AD1TBPER = 0x40000;   // AD1TBPER
    static constexpr uint32_t ADC3R_AD1TBC4 = 0x20000;    // AD1TBC4
    static constexpr uint32_t ADC3R_AD1TBC3 = 0x10000;    // AD1TBC3
    static constexpr uint32_t ADC3R_AD1TBC2 = 0x8000;     // AD1TBC2
    static constexpr uint32_t ADC3R_AD1TARST = 0x4000;    // AD1TARST
    static constexpr uint32_t ADC3R_AD1TAPER = 0x2000;    // AD1TAPER
    static constexpr uint32_t ADC3R_AD1TAC4 = 0x1000;     // AD1TAC4
    static constexpr uint32_t ADC3R_AD1TAC3 = 0x800;      // AD1TAC3
    static constexpr uint32_t ADC3R_AD1TAC2 = 0x400;      // AD1TAC2
    static constexpr uint32_t ADC3R_AD1EEV5 = 0x200;      // AD1EEV5
    static constexpr uint32_t ADC3R_AD1EEV4 = 0x100;      // AD1EEV4
    static constexpr uint32_t ADC3R_AD1EEV3 = 0x80;       // AD1EEV3
    static constexpr uint32_t ADC3R_AD1EEV2 = 0x40;       // AD1EEV2
    static constexpr uint32_t ADC3R_AD1EEV1 = 0x20;       // AD1EEV1
    static constexpr uint32_t ADC3R_AD1MPER = 0x10;       // AD1MPER
    static constexpr uint32_t ADC3R_AD1MC4 = 0x8;         // AD1MC4
    static constexpr uint32_t ADC3R_AD1MC3 = 0x4;         // AD1MC3
    static constexpr uint32_t ADC3R_AD1MC2 = 0x2;         // AD1MC2
    static constexpr uint32_t ADC3R_AD1MC1 = 0x1;         // AD1MC1
    static const uint32_t ADC3R_RESET_VALUE = 0x0;

    static constexpr uint32_t ADC4R_AD2TERST = 0x80000000;// AD2TERST
    static constexpr uint32_t ADC4R_AD2TEC4 = 0x40000000; // AD2TEC4
    static constexpr uint32_t ADC4R_AD2TEC3 = 0x20000000; // AD2TEC3
    static constexpr uint32_t ADC4R_AD2TEC2 = 0x10000000; // AD2TEC2
    static constexpr uint32_t ADC4R_AD2TDRST = 0x8000000; // AD2TDRST
    static constexpr uint32_t ADC4R_AD2TDPER = 0x4000000; // AD2TDPER
    static constexpr uint32_t ADC4R_AD2TDC4 = 0x2000000;  // AD2TDC4
    static constexpr uint32_t ADC4R_AD2TDC3 = 0x1000000;  // AD2TDC3
    static constexpr uint32_t ADC4R_AD2TDC2 = 0x800000;   // AD2TDC2
    static constexpr uint32_t ADC4R_AD2TCRST = 0x400000;  // AD2TCRST
    static constexpr uint32_t ADC4R_AD2TCPER = 0x200000;  // AD2TCPER
    static constexpr uint32_t ADC4R_AD2TCC4 = 0x100000;   // AD2TCC4
    static constexpr uint32_t ADC4R_AD2TCC3 = 0x80000;    // AD2TCC3
    static constexpr uint32_t ADC4R_AD2TCC2 = 0x40000;    // AD2TCC2
    static constexpr uint32_t ADC4R_AD2TBPER = 0x20000;   // AD2TBPER
    static constexpr uint32_t ADC4R_AD2TBC4 = 0x10000;    // AD2TBC4
    static constexpr uint32_t ADC4R_AD2TBC3 = 0x8000;     // AD2TBC3
    static constexpr uint32_t ADC4R_AD2TBC2 = 0x4000;     // AD2TBC2
    static constexpr uint32_t ADC4R_AD2TAPER = 0x2000;    // AD2TAPER
    static constexpr uint32_t ADC4R_AD2TAC4 = 0x1000;     // AD2TAC4
    static constexpr uint32_t ADC4R_AD2TAC3 = 0x800;      // AD2TAC3
    static constexpr uint32_t ADC4R_AD2TAC2 = 0x400;      // AD2TAC2
    static constexpr uint32_t ADC4R_AD2EEV10 = 0x200;     // AD2EEV10
    static constexpr uint32_t ADC4R_AD2EEV9 = 0x100;      // AD2EEV9
    static constexpr uint32_t ADC4R_AD2EEV8 = 0x80;       // AD2EEV8
    static constexpr uint32_t ADC4R_AD2EEV7 = 0x40;       // AD2EEV7
    static constexpr uint32_t ADC4R_AD2EEV6 = 0x20;       // AD2EEV6
    static constexpr uint32_t ADC4R_AD2MPER = 0x10;       // AD2MPER
    static constexpr uint32_t ADC4R_AD2MC4 = 0x8;         // AD2MC4
    static constexpr uint32_t ADC4R_AD2MC3 = 0x4;         // AD2MC3
    static constexpr uint32_t ADC4R_AD2MC2 = 0x2;         // AD2MC2
    static constexpr uint32_t ADC4R_AD2MC1 = 0x1;         // AD2MC1
    static const uint32_t ADC4R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DLLCR_CALRTE =              // DLL Calibration rate (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t DLLCR_CALEN = 0x2;          // DLL Calibration Enable
    static constexpr uint32_t DLLCR_CAL = 0x1;            // DLL Calibration Start
    static const uint32_t DLLCR_RESET_VALUE = 0x0;

    static constexpr uint32_t FLTINR1_FLT4LCK = 0x80000000; // FLT4LCK
    template<uint32_t X>
    static constexpr uint32_t FLTINR1_FLT4F =               // FLT4F (4 bits)
        bit_field_t<27, 0xf>::value<X>();
    static constexpr uint32_t FLTINR1_FLT4SRC = 0x4000000;  // FLT4SRC
    static constexpr uint32_t FLTINR1_FLT4P = 0x2000000;    // FLT4P
    static constexpr uint32_t FLTINR1_FLT4E = 0x1000000;    // FLT4E
    static constexpr uint32_t FLTINR1_FLT3LCK = 0x800000;   // FLT3LCK
    template<uint32_t X>
    static constexpr uint32_t FLTINR1_FLT3F =               // FLT3F (4 bits)
        bit_field_t<19, 0xf>::value<X>();
    static constexpr uint32_t FLTINR1_FLT3SRC = 0x40000;    // FLT3SRC
    static constexpr uint32_t FLTINR1_FLT3P = 0x20000;      // FLT3P
    static constexpr uint32_t FLTINR1_FLT3E = 0x10000;      // FLT3E
    static constexpr uint32_t FLTINR1_FLT2LCK = 0x8000;     // FLT2LCK
    template<uint32_t X>
    static constexpr uint32_t FLTINR1_FLT2F =               // FLT2F (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t FLTINR1_FLT2SRC = 0x400;      // FLT2SRC
    static constexpr uint32_t FLTINR1_FLT2P = 0x200;        // FLT2P
    static constexpr uint32_t FLTINR1_FLT2E = 0x100;        // FLT2E
    static constexpr uint32_t FLTINR1_FLT1LCK = 0x80;       // FLT1LCK
    template<uint32_t X>
    static constexpr uint32_t FLTINR1_FLT1F =               // FLT1F (4 bits)
        bit_field_t<3, 0xf>::value<X>();
    static constexpr uint32_t FLTINR1_FLT1SRC = 0x4;        // FLT1SRC
    static constexpr uint32_t FLTINR1_FLT1P = 0x2;          // FLT1P
    static constexpr uint32_t FLTINR1_FLT1E = 0x1;          // FLT1E
    static const uint32_t FLTINR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t FLTINR2_FLTSD =               // FLTSD (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    static constexpr uint32_t FLTINR2_FLT5LCK = 0x80;       // FLT5LCK
    template<uint32_t X>
    static constexpr uint32_t FLTINR2_FLT5F =               // FLT5F (4 bits)
        bit_field_t<3, 0xf>::value<X>();
    static constexpr uint32_t FLTINR2_FLT5SRC = 0x4;        // FLT5SRC
    static constexpr uint32_t FLTINR2_FLT5P = 0x2;          // FLT5P
    static constexpr uint32_t FLTINR2_FLT5E = 0x1;          // FLT5E
    static const uint32_t FLTINR2_RESET_VALUE = 0x0;

    static constexpr uint32_t BDMUPDR_MCMP4 = 0x200;        // MCMP4
    static constexpr uint32_t BDMUPDR_MCMP3 = 0x100;        // MCMP3
    static constexpr uint32_t BDMUPDR_MCMP2 = 0x80;         // MCMP2
    static constexpr uint32_t BDMUPDR_MCMP1 = 0x40;         // MCMP1
    static constexpr uint32_t BDMUPDR_MREP = 0x20;          // MREP
    static constexpr uint32_t BDMUPDR_MPER = 0x10;          // MPER
    static constexpr uint32_t BDMUPDR_MCNT = 0x8;           // MCNT
    static constexpr uint32_t BDMUPDR_MDIER = 0x4;          // MDIER
    static constexpr uint32_t BDMUPDR_MICR = 0x2;           // MICR
    static constexpr uint32_t BDMUPDR_MCR = 0x1;            // MCR
    static const uint32_t BDMUPDR_RESET_VALUE = 0x0;

    static constexpr uint32_t BDTxUPR_TIMxFLTR = 0x100000;  // HRTIM_FLTxR register update enable
    static constexpr uint32_t BDTxUPR_TIMxOUTR = 0x80000;   // HRTIM_OUTxR register update enable
    static constexpr uint32_t BDTxUPR_TIMxCHPR = 0x40000;   // HRTIM_CHPxR register update enable
    static constexpr uint32_t BDTxUPR_TIMxRSTR = 0x20000;   // HRTIM_RSTxR register update enable
    static constexpr uint32_t BDTxUPR_TIMxEEFR2 = 0x10000;  // HRTIM_EEFxR2 register update enable
    static constexpr uint32_t BDTxUPR_TIMxEEFR1 = 0x8000;   // HRTIM_EEFxR1 register update enable
    static constexpr uint32_t BDTxUPR_TIMxRST2R = 0x4000;   // HRTIM_RST2xR register update enable
    static constexpr uint32_t BDTxUPR_TIMxSET2R = 0x2000;   // HRTIM_SET2xR register update enable
    static constexpr uint32_t BDTxUPR_TIMxRST1R = 0x1000;   // HRTIM_RST1xR register update enable
    static constexpr uint32_t BDTxUPR_TIMxSET1R = 0x800;    // HRTIM_SET1xR register update enable
    static constexpr uint32_t BDTxUPR_TIMx_DTxR = 0x400;    // HRTIM_DTxR register update enable
    static constexpr uint32_t BDTxUPR_TIMxCMP4 = 0x200;     // HRTIM_CMP4xR register update enable
    static constexpr uint32_t BDTxUPR_TIMxCMP3 = 0x100;     // HRTIM_CMP3xR register update enable
    static constexpr uint32_t BDTxUPR_TIMxCMP2 = 0x80;      // HRTIM_CMP2xR register update enable
    static constexpr uint32_t BDTxUPR_TIMxCMP1 = 0x40;      // HRTIM_CMP1xR register update enable
    static constexpr uint32_t BDTxUPR_TIMxREP = 0x20;       // HRTIM_REPxR register update enable
    static constexpr uint32_t BDTxUPR_TIMxPER = 0x10;       // HRTIM_PERxR register update enable
    static constexpr uint32_t BDTxUPR_TIMxCNT = 0x8;        // HRTIM_CNTxR register update enable
    static constexpr uint32_t BDTxUPR_TIMxDIER = 0x4;       // HRTIM_TIMxDIER register update enable
    static constexpr uint32_t BDTxUPR_TIMxICR = 0x2;        // HRTIM_TIMxICR register update enable
    static constexpr uint32_t BDTxUPR_TIMxCR = 0x1;         // HRTIM_TIMxCR register update enable
    static const uint32_t BDTxUPR_RESET_VALUE = 0x0;


    static const uint32_t BDMADR_RESET_VALUE = 0x0;

    static constexpr uint8_t HRTIM_TIME = 108; // HRTIM1 timer E interrupt
};

static hrtim_common_t& HRTIM_COMMON = *reinterpret_cast<hrtim_common_t*>(0x40017780);

#define HAVE_PERIPHERAL_HRTIM_COMMON


////
//
//    Digital filter for sigma delta modulators
//
////

struct dfsdm_t
{
    volatile uint32_t    CHCFG0R1;             // [Read-write] DFSDM channel configuration 0 register 1
    volatile uint32_t    CHCFG1R1;             // [Read-write] DFSDM channel configuration 1 register 1
    volatile uint32_t    CHCFG2R1;             // [Read-write] DFSDM channel configuration 2 register 1
    volatile uint32_t    CHCFG3R1;             // [Read-write] DFSDM channel configuration 3 register 1
    volatile uint32_t    CHCFG4R1;             // [Read-write] DFSDM channel configuration 4 register 1
    volatile uint32_t    CHCFG5R1;             // [Read-write] DFSDM channel configuration 5 register 1
    volatile uint32_t    CHCFG6R1;             // [Read-write] DFSDM channel configuration 6 register 1
    volatile uint32_t    CHCFG7R1;             // [Read-write] DFSDM channel configuration 7 register 1
    volatile uint32_t    CHCFG0R2;             // [Read-write] DFSDM channel configuration 0 register 2
    volatile uint32_t    CHCFG1R2;             // [Read-write] DFSDM channel configuration 1 register 2
    volatile uint32_t    CHCFG2R2;             // [Read-write] DFSDM channel configuration 2 register 2
    volatile uint32_t    CHCFG3R2;             // [Read-write] DFSDM channel configuration 3 register 2
    volatile uint32_t    CHCFG4R2;             // [Read-write] DFSDM channel configuration 4 register 2
    volatile uint32_t    CHCFG5R2;             // [Read-write] DFSDM channel configuration 5 register 2
    volatile uint32_t    CHCFG6R2;             // [Read-write] DFSDM channel configuration 6 register 2
    volatile uint32_t    CHCFG7R2;             // [Read-write] DFSDM channel configuration 7 register 2
    volatile uint32_t    AWSCD0R;              // [Read-write] DFSDM analog watchdog and short-circuit detector register
    volatile uint32_t    AWSCD1R;              // [Read-write] DFSDM analog watchdog and short-circuit detector register
    volatile uint32_t    AWSCD2R;              // [Read-write] DFSDM analog watchdog and short-circuit detector register
    volatile uint32_t    AWSCD3R;              // [Read-write] DFSDM analog watchdog and short-circuit detector register
    volatile uint32_t    AWSCD4R;              // [Read-write] DFSDM analog watchdog and short-circuit detector register
    volatile uint32_t    AWSCD5R;              // [Read-write] DFSDM analog watchdog and short-circuit detector register
    volatile uint32_t    AWSCD6R;              // [Read-write] DFSDM analog watchdog and short-circuit detector register
    volatile uint32_t    AWSCD7R;              // [Read-write] DFSDM analog watchdog and short-circuit detector register
    volatile uint32_t    CHWDAT0R;             // [Read-only] DFSDM channel watchdog filter data register
    volatile uint32_t    CHWDAT1R;             // [Read-only] DFSDM channel watchdog filter data register
    volatile uint32_t    CHWDAT2R;             // [Read-only] DFSDM channel watchdog filter data register
    volatile uint32_t    CHWDAT3R;             // [Read-only] DFSDM channel watchdog filter data register
    volatile uint32_t    CHWDAT4R;             // [Read-only] DFSDM channel watchdog filter data register
    volatile uint32_t    CHWDAT5R;             // [Read-only] DFSDM channel watchdog filter data register
    volatile uint32_t    CHWDAT6R;             // [Read-only] DFSDM channel watchdog filter data register
    volatile uint32_t    CHWDAT7R;             // [Read-only] DFSDM channel watchdog filter data register
    volatile uint32_t    CHDATIN0R;            // [Read-write] DFSDM channel data input register
    volatile uint32_t    CHDATIN1R;            // [Read-write] DFSDM channel data input register
    volatile uint32_t    CHDATIN2R;            // [Read-write] DFSDM channel data input register
    volatile uint32_t    CHDATIN3R;            // [Read-write] DFSDM channel data input register
    volatile uint32_t    CHDATIN4R;            // [Read-write] DFSDM channel data input register
    volatile uint32_t    CHDATIN5R;            // [Read-write] DFSDM channel data input register
    volatile uint32_t    CHDATIN6R;            // [Read-write] DFSDM channel data input register
    volatile uint32_t    CHDATIN7R;            // [Read-write] DFSDM channel data input register
    volatile uint32_t    DFSDM0_CR1;           // [Read-write] DFSDM control register 1
    volatile uint32_t    DFSDM1_CR1;           // [Read-write] DFSDM control register 1
    volatile uint32_t    DFSDM2_CR1;           // [Read-write] DFSDM control register 1
    volatile uint32_t    DFSDM3_CR1;           // [Read-write] DFSDM control register 1
    volatile uint32_t    DFSDM0_CR2;           // [Read-write] DFSDM control register 2
    volatile uint32_t    DFSDM1_CR2;           // [Read-write] DFSDM control register 2
    volatile uint32_t    DFSDM2_CR2;           // [Read-write] DFSDM control register 2
    volatile uint32_t    DFSDM3_CR2;           // [Read-write] DFSDM control register 2
    volatile uint32_t    DFSDM0_ISR;           // [Read-only] DFSDM interrupt and status register
    volatile uint32_t    DFSDM1_ISR;           // [Read-only] DFSDM interrupt and status register
    volatile uint32_t    DFSDM2_ISR;           // [Read-only] DFSDM interrupt and status register
    volatile uint32_t    DFSDM3_ISR;           // [Read-only] DFSDM interrupt and status register
    volatile uint32_t    DFSDM0_ICR;           // [Read-write] DFSDM interrupt flag clear register
    volatile uint32_t    DFSDM1_ICR;           // [Read-write] DFSDM interrupt flag clear register
    volatile uint32_t    DFSDM2_ICR;           // [Read-write] DFSDM interrupt flag clear register
    volatile uint32_t    DFSDM3_ICR;           // [Read-write] DFSDM interrupt flag clear register
    volatile uint32_t    DFSDM0_JCHGR;         // [Read-write] DFSDM injected channel group selection register
    volatile uint32_t    DFSDM1_JCHGR;         // [Read-write] DFSDM injected channel group selection register
    volatile uint32_t    DFSDM2_JCHGR;         // [Read-write] DFSDM injected channel group selection register
    volatile uint32_t    DFSDM3_JCHGR;         // [Read-write] DFSDM injected channel group selection register
    volatile uint32_t    DFSDM0_FCR;           // [Read-write] DFSDM filter control register
    volatile uint32_t    DFSDM1_FCR;           // [Read-write] DFSDM filter control register
    volatile uint32_t    DFSDM2_FCR;           // [Read-write] DFSDM filter control register
    volatile uint32_t    DFSDM3_FCR;           // [Read-write] DFSDM filter control register
    volatile uint32_t    DFSDM0_JDATAR;        // [Read-only] DFSDM data register for injected group
    volatile uint32_t    DFSDM1_JDATAR;        // [Read-only] DFSDM data register for injected group
    volatile uint32_t    DFSDM2_JDATAR;        // [Read-only] DFSDM data register for injected group
    volatile uint32_t    DFSDM3_JDATAR;        // [Read-only] DFSDM data register for injected group
    volatile uint32_t    DFSDM0_RDATAR;        // [Read-only] DFSDM data register for the regular channel
    volatile uint32_t    DFSDM1_RDATAR;        // [Read-only] DFSDM data register for the regular channel
    volatile uint32_t    DFSDM2_RDATAR;        // [Read-only] DFSDM data register for the regular channel
    volatile uint32_t    DFSDM3_RDATAR;        // [Read-only] DFSDM data register for the regular channel
    volatile uint32_t    DFSDM0_AWHTR;         // [Read-write] DFSDM analog watchdog high threshold register
    volatile uint32_t    DFSDM1_AWHTR;         // [Read-write] DFSDM analog watchdog high threshold register
    volatile uint32_t    DFSDM2_AWHTR;         // [Read-write] DFSDM analog watchdog high threshold register
    volatile uint32_t    DFSDM3_AWHTR;         // [Read-write] DFSDM analog watchdog high threshold register
    volatile uint32_t    DFSDM0_AWLTR;         // [Read-write] DFSDM analog watchdog low threshold register
    volatile uint32_t    DFSDM1_AWLTR;         // [Read-write] DFSDM analog watchdog low threshold register
    volatile uint32_t    DFSDM2_AWLTR;         // [Read-write] DFSDM analog watchdog low threshold register
    volatile uint32_t    DFSDM3_AWLTR;         // [Read-write] DFSDM analog watchdog low threshold register
    volatile uint32_t    DFSDM0_AWSR;          // [Read-only] DFSDM analog watchdog status register
    volatile uint32_t    DFSDM1_AWSR;          // [Read-only] DFSDM analog watchdog status register
    volatile uint32_t    DFSDM2_AWSR;          // [Read-only] DFSDM analog watchdog status register
    volatile uint32_t    DFSDM3_AWSR;          // [Read-only] DFSDM analog watchdog status register
    volatile uint32_t    DFSDM0_AWCFR;         // [Read-write] DFSDM analog watchdog clear flag register
    volatile uint32_t    DFSDM1_AWCFR;         // [Read-write] DFSDM analog watchdog clear flag register
    volatile uint32_t    DFSDM2_AWCFR;         // [Read-write] DFSDM analog watchdog clear flag register
    volatile uint32_t    DFSDM3_AWCFR;         // [Read-write] DFSDM analog watchdog clear flag register
    volatile uint32_t    DFSDM0_EXMAX;         // [Read-only] DFSDM Extremes detector maximum register
    volatile uint32_t    DFSDM1_EXMAX;         // [Read-only] DFSDM Extremes detector maximum register
    volatile uint32_t    DFSDM2_EXMAX;         // [Read-only] DFSDM Extremes detector maximum register
    volatile uint32_t    DFSDM3_EXMAX;         // [Read-only] DFSDM Extremes detector maximum register
    volatile uint32_t    DFSDM0_EXMIN;         // [Read-only] DFSDM Extremes detector minimum register
    volatile uint32_t    DFSDM1_EXMIN;         // [Read-only] DFSDM Extremes detector minimum register
    volatile uint32_t    DFSDM2_EXMIN;         // [Read-only] DFSDM Extremes detector minimum register
    volatile uint32_t    DFSDM3_EXMIN;         // [Read-only] DFSDM Extremes detector minimum register
    volatile uint32_t    DFSDM0_CNVTIMR;       // [Read-only] DFSDM conversion timer register
    volatile uint32_t    DFSDM1_CNVTIMR;       // [Read-only] DFSDM conversion timer register
    volatile uint32_t    DFSDM2_CNVTIMR;       // [Read-only] DFSDM conversion timer register
    volatile uint32_t    DFSDM3_CNVTIMR;       // [Read-only] DFSDM conversion timer register

    template<uint32_t X>
    static constexpr uint32_t CHCFG0R1_SITP =                // Serial interface type for channel 0 (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG0R1_SPICKSEL =            // SPI clock select for channel 0 (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t CHCFG0R1_SCDEN = 0x20;         // Short-circuit detector enable on channel 0
    static constexpr uint32_t CHCFG0R1_CKABEN = 0x40;        // Clock absence detector enable on channel 0
    static constexpr uint32_t CHCFG0R1_CHEN = 0x80;          // Channel 0 enable
    static constexpr uint32_t CHCFG0R1_CHINSEL = 0x100;      // Channel inputs selection
    template<uint32_t X>
    static constexpr uint32_t CHCFG0R1_DATMPX =              // Input data multiplexer for channel 0 (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG0R1_DATPACK =             // Data packing mode in DFSDM_CHDATINyR register (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG0R1_CKOUTDIV =            // Output serial clock divider (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static constexpr uint32_t CHCFG0R1_CKOUTSRC = 0x40000000;// Output serial clock source selection
    static constexpr uint32_t CHCFG0R1_DFSDMEN = 0x80000000; // Global enable for DFSDM interface
    static const uint32_t CHCFG0R1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHCFG1R1_SITP =                // Serial interface type for channel 1 (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG1R1_SPICKSEL =            // SPI clock select for channel 1 (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t CHCFG1R1_SCDEN = 0x20;         // Short-circuit detector enable on channel 1
    static constexpr uint32_t CHCFG1R1_CKABEN = 0x40;        // Clock absence detector enable on channel 1
    static constexpr uint32_t CHCFG1R1_CHEN = 0x80;          // Channel 1 enable
    static constexpr uint32_t CHCFG1R1_CHINSEL = 0x100;      // Channel inputs selection
    template<uint32_t X>
    static constexpr uint32_t CHCFG1R1_DATMPX =              // Input data multiplexer for channel 1 (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG1R1_DATPACK =             // Data packing mode in DFSDM_CHDATINyR register (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG1R1_CKOUTDIV =            // Output serial clock divider (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static constexpr uint32_t CHCFG1R1_CKOUTSRC = 0x40000000;// Output serial clock source selection
    static constexpr uint32_t CHCFG1R1_DFSDMEN = 0x80000000; // Global enable for DFSDM interface
    static const uint32_t CHCFG1R1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHCFG2R1_SITP =                // Serial interface type for channel 2 (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG2R1_SPICKSEL =            // SPI clock select for channel 2 (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t CHCFG2R1_SCDEN = 0x20;         // Short-circuit detector enable on channel 2
    static constexpr uint32_t CHCFG2R1_CKABEN = 0x40;        // Clock absence detector enable on channel 2
    static constexpr uint32_t CHCFG2R1_CHEN = 0x80;          // Channel 2 enable
    static constexpr uint32_t CHCFG2R1_CHINSEL = 0x100;      // Channel inputs selection
    template<uint32_t X>
    static constexpr uint32_t CHCFG2R1_DATMPX =              // Input data multiplexer for channel 2 (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG2R1_DATPACK =             // Data packing mode in DFSDM_CHDATINyR register (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG2R1_CKOUTDIV =            // Output serial clock divider (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static constexpr uint32_t CHCFG2R1_CKOUTSRC = 0x40000000;// Output serial clock source selection
    static constexpr uint32_t CHCFG2R1_DFSDMEN = 0x80000000; // Global enable for DFSDM interface
    static const uint32_t CHCFG2R1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHCFG3R1_SITP =                // Serial interface type for channel 3 (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG3R1_SPICKSEL =            // SPI clock select for channel 3 (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t CHCFG3R1_SCDEN = 0x20;         // Short-circuit detector enable on channel 3
    static constexpr uint32_t CHCFG3R1_CKABEN = 0x40;        // Clock absence detector enable on channel 3
    static constexpr uint32_t CHCFG3R1_CHEN = 0x80;          // Channel 3 enable
    static constexpr uint32_t CHCFG3R1_CHINSEL = 0x100;      // Channel inputs selection
    template<uint32_t X>
    static constexpr uint32_t CHCFG3R1_DATMPX =              // Input data multiplexer for channel 3 (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG3R1_DATPACK =             // Data packing mode in DFSDM_CHDATINyR register (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG3R1_CKOUTDIV =            // Output serial clock divider (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static constexpr uint32_t CHCFG3R1_CKOUTSRC = 0x40000000;// Output serial clock source selection
    static constexpr uint32_t CHCFG3R1_DFSDMEN = 0x80000000; // Global enable for DFSDM interface
    static const uint32_t CHCFG3R1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHCFG4R1_SITP =                // Serial interface type for channel 4 (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG4R1_SPICKSEL =            // SPI clock select for channel 4 (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t CHCFG4R1_SCDEN = 0x20;         // Short-circuit detector enable on channel 4
    static constexpr uint32_t CHCFG4R1_CKABEN = 0x40;        // Clock absence detector enable on channel 4
    static constexpr uint32_t CHCFG4R1_CHEN = 0x80;          // Channel 4 enable
    static constexpr uint32_t CHCFG4R1_CHINSEL = 0x100;      // Channel inputs selection
    template<uint32_t X>
    static constexpr uint32_t CHCFG4R1_DATMPX =              // Input data multiplexer for channel 4 (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG4R1_DATPACK =             // Data packing mode in DFSDM_CHDATINyR register (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG4R1_CKOUTDIV =            // Output serial clock divider (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static constexpr uint32_t CHCFG4R1_CKOUTSRC = 0x40000000;// Output serial clock source selection
    static constexpr uint32_t CHCFG4R1_DFSDMEN = 0x80000000; // Global enable for DFSDM interface
    static const uint32_t CHCFG4R1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHCFG5R1_SITP =                // Serial interface type for channel 5 (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG5R1_SPICKSEL =            // SPI clock select for channel 5 (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t CHCFG5R1_SCDEN = 0x20;         // Short-circuit detector enable on channel 5
    static constexpr uint32_t CHCFG5R1_CKABEN = 0x40;        // Clock absence detector enable on channel 5
    static constexpr uint32_t CHCFG5R1_CHEN = 0x80;          // Channel 5 enable
    static constexpr uint32_t CHCFG5R1_CHINSEL = 0x100;      // Channel inputs selection
    template<uint32_t X>
    static constexpr uint32_t CHCFG5R1_DATMPX =              // Input data multiplexer for channel 5 (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG5R1_DATPACK =             // Data packing mode in DFSDM_CHDATINyR register (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG5R1_CKOUTDIV =            // Output serial clock divider (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static constexpr uint32_t CHCFG5R1_CKOUTSRC = 0x40000000;// Output serial clock source selection
    static constexpr uint32_t CHCFG5R1_DFSDMEN = 0x80000000; // Global enable for DFSDM interface
    static const uint32_t CHCFG5R1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHCFG6R1_SITP =                // Serial interface type for channel 6 (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG6R1_SPICKSEL =            // SPI clock select for channel 6 (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t CHCFG6R1_SCDEN = 0x20;         // Short-circuit detector enable on channel 6
    static constexpr uint32_t CHCFG6R1_CKABEN = 0x40;        // Clock absence detector enable on channel 6
    static constexpr uint32_t CHCFG6R1_CHEN = 0x80;          // Channel 6 enable
    static constexpr uint32_t CHCFG6R1_CHINSEL = 0x100;      // Channel inputs selection
    template<uint32_t X>
    static constexpr uint32_t CHCFG6R1_DATMPX =              // Input data multiplexer for channel 6 (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG6R1_DATPACK =             // Data packing mode in DFSDM_CHDATINyR register (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG6R1_CKOUTDIV =            // Output serial clock divider (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static constexpr uint32_t CHCFG6R1_CKOUTSRC = 0x40000000;// Output serial clock source selection
    static constexpr uint32_t CHCFG6R1_DFSDMEN = 0x80000000; // Global enable for DFSDM interface
    static const uint32_t CHCFG6R1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHCFG7R1_SITP =                // Serial interface type for channel 7 (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG7R1_SPICKSEL =            // SPI clock select for channel 7 (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t CHCFG7R1_SCDEN = 0x20;         // Short-circuit detector enable on channel 7
    static constexpr uint32_t CHCFG7R1_CKABEN = 0x40;        // Clock absence detector enable on channel 7
    static constexpr uint32_t CHCFG7R1_CHEN = 0x80;          // Channel 7 enable
    static constexpr uint32_t CHCFG7R1_CHINSEL = 0x100;      // Channel inputs selection
    template<uint32_t X>
    static constexpr uint32_t CHCFG7R1_DATMPX =              // Input data multiplexer for channel 7 (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG7R1_DATPACK =             // Data packing mode in DFSDM_CHDATINyR register (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG7R1_CKOUTDIV =            // Output serial clock divider (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static constexpr uint32_t CHCFG7R1_CKOUTSRC = 0x40000000;// Output serial clock source selection
    static constexpr uint32_t CHCFG7R1_DFSDMEN = 0x80000000; // Global enable for DFSDM interface
    static const uint32_t CHCFG7R1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHCFG0R2_DTRBS =               // Data right bit-shift for channel 0 (5 bits)
        bit_field_t<3, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG0R2_OFFSET =              // 24-bit calibration offset for channel 0 (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t CHCFG0R2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHCFG1R2_DTRBS =               // Data right bit-shift for channel 1 (5 bits)
        bit_field_t<3, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG1R2_OFFSET =              // 24-bit calibration offset for channel 1 (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t CHCFG1R2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHCFG2R2_DTRBS =               // Data right bit-shift for channel 2 (5 bits)
        bit_field_t<3, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG2R2_OFFSET =              // 24-bit calibration offset for channel 2 (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t CHCFG2R2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHCFG3R2_DTRBS =               // Data right bit-shift for channel 3 (5 bits)
        bit_field_t<3, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG3R2_OFFSET =              // 24-bit calibration offset for channel 3 (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t CHCFG3R2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHCFG4R2_DTRBS =               // Data right bit-shift for channel 4 (5 bits)
        bit_field_t<3, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG4R2_OFFSET =              // 24-bit calibration offset for channel 4 (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t CHCFG4R2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHCFG5R2_DTRBS =               // Data right bit-shift for channel 5 (5 bits)
        bit_field_t<3, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG5R2_OFFSET =              // 24-bit calibration offset for channel 5 (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t CHCFG5R2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHCFG6R2_DTRBS =               // Data right bit-shift for channel 6 (5 bits)
        bit_field_t<3, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG6R2_OFFSET =              // 24-bit calibration offset for channel 6 (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t CHCFG6R2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHCFG7R2_DTRBS =               // Data right bit-shift for channel 7 (5 bits)
        bit_field_t<3, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG7R2_OFFSET =              // 24-bit calibration offset for channel 7 (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t CHCFG7R2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AWSCD0R_SCDT =                // short-circuit detector threshold for channel 0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD0R_BKSCD =               // Break signal assignment for short-circuit detector on channel 0 (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD0R_AWFOSR =              // Analog watchdog filter oversampling ratio (decimation rate) on channel 0 (5 bits)
        bit_field_t<16, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD0R_AWFORD =              // Analog watchdog Sinc filter order on channel 0 (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    static const uint32_t AWSCD0R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AWSCD1R_SCDT =                // short-circuit detector threshold for channel 1 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD1R_BKSCD =               // Break signal assignment for short-circuit detector on channel 1 (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD1R_AWFOSR =              // Analog watchdog filter oversampling ratio (decimation rate) on channel 1 (5 bits)
        bit_field_t<16, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD1R_AWFORD =              // Analog watchdog Sinc filter order on channel 1 (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    static const uint32_t AWSCD1R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AWSCD2R_SCDT =                // short-circuit detector threshold for channel 2 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD2R_BKSCD =               // Break signal assignment for short-circuit detector on channel 2 (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD2R_AWFOSR =              // Analog watchdog filter oversampling ratio (decimation rate) on channel 2 (5 bits)
        bit_field_t<16, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD2R_AWFORD =              // Analog watchdog Sinc filter order on channel 2 (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    static const uint32_t AWSCD2R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AWSCD3R_SCDT =                // short-circuit detector threshold for channel 3 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD3R_BKSCD =               // Break signal assignment for short-circuit detector on channel 3 (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD3R_AWFOSR =              // Analog watchdog filter oversampling ratio (decimation rate) on channel 3 (5 bits)
        bit_field_t<16, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD3R_AWFORD =              // Analog watchdog Sinc filter order on channel 3 (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    static const uint32_t AWSCD3R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AWSCD4R_SCDT =                // short-circuit detector threshold for channel 4 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD4R_BKSCD =               // Break signal assignment for short-circuit detector on channel 4 (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD4R_AWFOSR =              // Analog watchdog filter oversampling ratio (decimation rate) on channel 4 (5 bits)
        bit_field_t<16, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD4R_AWFORD =              // Analog watchdog Sinc filter order on channel 4 (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    static const uint32_t AWSCD4R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AWSCD5R_SCDT =                // short-circuit detector threshold for channel 5 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD5R_BKSCD =               // Break signal assignment for short-circuit detector on channel 5 (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD5R_AWFOSR =              // Analog watchdog filter oversampling ratio (decimation rate) on channel 5 (5 bits)
        bit_field_t<16, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD5R_AWFORD =              // Analog watchdog Sinc filter order on channel 5 (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    static const uint32_t AWSCD5R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AWSCD6R_SCDT =                // short-circuit detector threshold for channel 6 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD6R_BKSCD =               // Break signal assignment for short-circuit detector on channel 6 (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD6R_AWFOSR =              // Analog watchdog filter oversampling ratio (decimation rate) on channel 6 (5 bits)
        bit_field_t<16, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD6R_AWFORD =              // Analog watchdog Sinc filter order on channel 6 (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    static const uint32_t AWSCD6R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AWSCD7R_SCDT =                // short-circuit detector threshold for channel 7 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD7R_BKSCD =               // Break signal assignment for short-circuit detector on channel 7 (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD7R_AWFOSR =              // Analog watchdog filter oversampling ratio (decimation rate) on channel 7 (5 bits)
        bit_field_t<16, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD7R_AWFORD =              // Analog watchdog Sinc filter order on channel 7 (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    static const uint32_t AWSCD7R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHWDAT0R_WDATA =               // Input channel y watchdog data (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CHWDAT0R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHWDAT1R_WDATA =               // Input channel y watchdog data (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CHWDAT1R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHWDAT2R_WDATA =               // Input channel y watchdog data (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CHWDAT2R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHWDAT3R_WDATA =               // Input channel y watchdog data (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CHWDAT3R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHWDAT4R_WDATA =               // Input channel y watchdog data (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CHWDAT4R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHWDAT5R_WDATA =               // Input channel y watchdog data (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CHWDAT5R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHWDAT6R_WDATA =               // Input channel y watchdog data (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CHWDAT6R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHWDAT7R_WDATA =               // Input channel y watchdog data (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CHWDAT7R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHDATIN0R_INDAT0 =              // Input data for channel 0 (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHDATIN0R_INDAT1 =              // Input data for channel 1 (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t CHDATIN0R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHDATIN1R_INDAT0 =              // Input data for channel 1 (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHDATIN1R_INDAT1 =              // Input data for channel 2 (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t CHDATIN1R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHDATIN2R_INDAT0 =              // Input data for channel 2 (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHDATIN2R_INDAT1 =              // Input data for channel 3 (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t CHDATIN2R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHDATIN3R_INDAT0 =              // Input data for channel 3 (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHDATIN3R_INDAT1 =              // Input data for channel 4 (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t CHDATIN3R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHDATIN4R_INDAT0 =              // Input data for channel 4 (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHDATIN4R_INDAT1 =              // Input data for channel 5 (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t CHDATIN4R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHDATIN5R_INDAT0 =              // Input data for channel 5 (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHDATIN5R_INDAT1 =              // Input data for channel 6 (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t CHDATIN5R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHDATIN6R_INDAT0 =              // Input data for channel 6 (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHDATIN6R_INDAT1 =              // Input data for channel 7 (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t CHDATIN6R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHDATIN7R_INDAT0 =              // Input data for channel 7 (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHDATIN7R_INDAT1 =              // Input data for channel 8 (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t CHDATIN7R_RESET_VALUE = 0x0;

    static constexpr uint32_t DFSDM0_CR1_DFEN = 0x1;           // DFSDM enable
    static constexpr uint32_t DFSDM0_CR1_JSWSTART = 0x2;       // Start a conversion of the injected group of channels
    static constexpr uint32_t DFSDM0_CR1_JSYNC = 0x8;          // Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
    static constexpr uint32_t DFSDM0_CR1_JSCAN = 0x10;         // Scanning conversion mode for injected conversions
    static constexpr uint32_t DFSDM0_CR1_JDMAEN = 0x20;        // DMA channel enabled to read data for the injected channel group
    template<uint32_t X>
    static constexpr uint32_t DFSDM0_CR1_JEXTSEL =             // Trigger signal selection for launching injected conversions (5 bits)
        bit_field_t<8, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM0_CR1_JEXTEN =              // Trigger enable and trigger edge selection for injected conversions (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    static constexpr uint32_t DFSDM0_CR1_RSWSTART = 0x20000;   // Software start of a conversion on the regular channel
    static constexpr uint32_t DFSDM0_CR1_RCONT = 0x40000;      // Continuous mode selection for regular conversions
    static constexpr uint32_t DFSDM0_CR1_RSYNC = 0x80000;      // Launch regular conversion synchronously with DFSDM0
    static constexpr uint32_t DFSDM0_CR1_RDMAEN = 0x200000;    // DMA channel enabled to read data for the regular conversion
    template<uint32_t X>
    static constexpr uint32_t DFSDM0_CR1_RCH =                 // Regular channel selection (3 bits)
        bit_field_t<24, 0x7>::value<X>();
    static constexpr uint32_t DFSDM0_CR1_FAST = 0x20000000;    // Fast conversion mode selection for regular conversions
    static constexpr uint32_t DFSDM0_CR1_AWFSEL = 0x40000000;  // Analog watchdog fast mode select
    static const uint32_t DFSDM0_CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t DFSDM1_CR1_DFEN = 0x1;           // DFSDM enable
    static constexpr uint32_t DFSDM1_CR1_JSWSTART = 0x2;       // Start a conversion of the injected group of channels
    static constexpr uint32_t DFSDM1_CR1_JSYNC = 0x8;          // Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
    static constexpr uint32_t DFSDM1_CR1_JSCAN = 0x10;         // Scanning conversion mode for injected conversions
    static constexpr uint32_t DFSDM1_CR1_JDMAEN = 0x20;        // DMA channel enabled to read data for the injected channel group
    template<uint32_t X>
    static constexpr uint32_t DFSDM1_CR1_JEXTSEL =             // Trigger signal selection for launching injected conversions (5 bits)
        bit_field_t<8, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM1_CR1_JEXTEN =              // Trigger enable and trigger edge selection for injected conversions (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    static constexpr uint32_t DFSDM1_CR1_RSWSTART = 0x20000;   // Software start of a conversion on the regular channel
    static constexpr uint32_t DFSDM1_CR1_RCONT = 0x40000;      // Continuous mode selection for regular conversions
    static constexpr uint32_t DFSDM1_CR1_RSYNC = 0x80000;      // Launch regular conversion synchronously with DFSDM0
    static constexpr uint32_t DFSDM1_CR1_RDMAEN = 0x200000;    // DMA channel enabled to read data for the regular conversion
    template<uint32_t X>
    static constexpr uint32_t DFSDM1_CR1_RCH =                 // Regular channel selection (3 bits)
        bit_field_t<24, 0x7>::value<X>();
    static constexpr uint32_t DFSDM1_CR1_FAST = 0x20000000;    // Fast conversion mode selection for regular conversions
    static constexpr uint32_t DFSDM1_CR1_AWFSEL = 0x40000000;  // Analog watchdog fast mode select
    static const uint32_t DFSDM1_CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t DFSDM2_CR1_DFEN = 0x1;           // DFSDM enable
    static constexpr uint32_t DFSDM2_CR1_JSWSTART = 0x2;       // Start a conversion of the injected group of channels
    static constexpr uint32_t DFSDM2_CR1_JSYNC = 0x8;          // Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
    static constexpr uint32_t DFSDM2_CR1_JSCAN = 0x10;         // Scanning conversion mode for injected conversions
    static constexpr uint32_t DFSDM2_CR1_JDMAEN = 0x20;        // DMA channel enabled to read data for the injected channel group
    template<uint32_t X>
    static constexpr uint32_t DFSDM2_CR1_JEXTSEL =             // Trigger signal selection for launching injected conversions (5 bits)
        bit_field_t<8, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM2_CR1_JEXTEN =              // Trigger enable and trigger edge selection for injected conversions (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    static constexpr uint32_t DFSDM2_CR1_RSWSTART = 0x20000;   // Software start of a conversion on the regular channel
    static constexpr uint32_t DFSDM2_CR1_RCONT = 0x40000;      // Continuous mode selection for regular conversions
    static constexpr uint32_t DFSDM2_CR1_RSYNC = 0x80000;      // Launch regular conversion synchronously with DFSDM0
    static constexpr uint32_t DFSDM2_CR1_RDMAEN = 0x200000;    // DMA channel enabled to read data for the regular conversion
    template<uint32_t X>
    static constexpr uint32_t DFSDM2_CR1_RCH =                 // Regular channel selection (3 bits)
        bit_field_t<24, 0x7>::value<X>();
    static constexpr uint32_t DFSDM2_CR1_FAST = 0x20000000;    // Fast conversion mode selection for regular conversions
    static constexpr uint32_t DFSDM2_CR1_AWFSEL = 0x40000000;  // Analog watchdog fast mode select
    static const uint32_t DFSDM2_CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t DFSDM3_CR1_DFEN = 0x1;           // DFSDM enable
    static constexpr uint32_t DFSDM3_CR1_JSWSTART = 0x2;       // Start a conversion of the injected group of channels
    static constexpr uint32_t DFSDM3_CR1_JSYNC = 0x8;          // Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
    static constexpr uint32_t DFSDM3_CR1_JSCAN = 0x10;         // Scanning conversion mode for injected conversions
    static constexpr uint32_t DFSDM3_CR1_JDMAEN = 0x20;        // DMA channel enabled to read data for the injected channel group
    template<uint32_t X>
    static constexpr uint32_t DFSDM3_CR1_JEXTSEL =             // Trigger signal selection for launching injected conversions (5 bits)
        bit_field_t<8, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM3_CR1_JEXTEN =              // Trigger enable and trigger edge selection for injected conversions (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    static constexpr uint32_t DFSDM3_CR1_RSWSTART = 0x20000;   // Software start of a conversion on the regular channel
    static constexpr uint32_t DFSDM3_CR1_RCONT = 0x40000;      // Continuous mode selection for regular conversions
    static constexpr uint32_t DFSDM3_CR1_RSYNC = 0x80000;      // Launch regular conversion synchronously with DFSDM0
    static constexpr uint32_t DFSDM3_CR1_RDMAEN = 0x200000;    // DMA channel enabled to read data for the regular conversion
    template<uint32_t X>
    static constexpr uint32_t DFSDM3_CR1_RCH =                 // Regular channel selection (3 bits)
        bit_field_t<24, 0x7>::value<X>();
    static constexpr uint32_t DFSDM3_CR1_FAST = 0x20000000;    // Fast conversion mode selection for regular conversions
    static constexpr uint32_t DFSDM3_CR1_AWFSEL = 0x40000000;  // Analog watchdog fast mode select
    static const uint32_t DFSDM3_CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t DFSDM0_CR2_JEOCIE = 0x1;         // Injected end of conversion interrupt enable
    static constexpr uint32_t DFSDM0_CR2_REOCIE = 0x2;         // Regular end of conversion interrupt enable
    static constexpr uint32_t DFSDM0_CR2_JOVRIE = 0x4;         // Injected data overrun interrupt enable
    static constexpr uint32_t DFSDM0_CR2_ROVRIE = 0x8;         // Regular data overrun interrupt enable
    static constexpr uint32_t DFSDM0_CR2_AWDIE = 0x10;         // Analog watchdog interrupt enable
    static constexpr uint32_t DFSDM0_CR2_SCDIE = 0x20;         // Short-circuit detector interrupt enable
    static constexpr uint32_t DFSDM0_CR2_CKABIE = 0x40;        // Clock absence interrupt enable
    template<uint32_t X>
    static constexpr uint32_t DFSDM0_CR2_EXCH =                // Extremes detector channel selection (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM0_CR2_AWDCH =               // Analog watchdog channel selection (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static const uint32_t DFSDM0_CR2_RESET_VALUE = 0x0;

    static constexpr uint32_t DFSDM1_CR2_JEOCIE = 0x1;         // Injected end of conversion interrupt enable
    static constexpr uint32_t DFSDM1_CR2_REOCIE = 0x2;         // Regular end of conversion interrupt enable
    static constexpr uint32_t DFSDM1_CR2_JOVRIE = 0x4;         // Injected data overrun interrupt enable
    static constexpr uint32_t DFSDM1_CR2_ROVRIE = 0x8;         // Regular data overrun interrupt enable
    static constexpr uint32_t DFSDM1_CR2_AWDIE = 0x10;         // Analog watchdog interrupt enable
    static constexpr uint32_t DFSDM1_CR2_SCDIE = 0x20;         // Short-circuit detector interrupt enable
    static constexpr uint32_t DFSDM1_CR2_CKABIE = 0x40;        // Clock absence interrupt enable
    template<uint32_t X>
    static constexpr uint32_t DFSDM1_CR2_EXCH =                // Extremes detector channel selection (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM1_CR2_AWDCH =               // Analog watchdog channel selection (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static const uint32_t DFSDM1_CR2_RESET_VALUE = 0x0;

    static constexpr uint32_t DFSDM2_CR2_JEOCIE = 0x1;         // Injected end of conversion interrupt enable
    static constexpr uint32_t DFSDM2_CR2_REOCIE = 0x2;         // Regular end of conversion interrupt enable
    static constexpr uint32_t DFSDM2_CR2_JOVRIE = 0x4;         // Injected data overrun interrupt enable
    static constexpr uint32_t DFSDM2_CR2_ROVRIE = 0x8;         // Regular data overrun interrupt enable
    static constexpr uint32_t DFSDM2_CR2_AWDIE = 0x10;         // Analog watchdog interrupt enable
    static constexpr uint32_t DFSDM2_CR2_SCDIE = 0x20;         // Short-circuit detector interrupt enable
    static constexpr uint32_t DFSDM2_CR2_CKABIE = 0x40;        // Clock absence interrupt enable
    template<uint32_t X>
    static constexpr uint32_t DFSDM2_CR2_EXCH =                // Extremes detector channel selection (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM2_CR2_AWDCH =               // Analog watchdog channel selection (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static const uint32_t DFSDM2_CR2_RESET_VALUE = 0x0;

    static constexpr uint32_t DFSDM3_CR2_JEOCIE = 0x1;         // Injected end of conversion interrupt enable
    static constexpr uint32_t DFSDM3_CR2_REOCIE = 0x2;         // Regular end of conversion interrupt enable
    static constexpr uint32_t DFSDM3_CR2_JOVRIE = 0x4;         // Injected data overrun interrupt enable
    static constexpr uint32_t DFSDM3_CR2_ROVRIE = 0x8;         // Regular data overrun interrupt enable
    static constexpr uint32_t DFSDM3_CR2_AWDIE = 0x10;         // Analog watchdog interrupt enable
    static constexpr uint32_t DFSDM3_CR2_SCDIE = 0x20;         // Short-circuit detector interrupt enable
    static constexpr uint32_t DFSDM3_CR2_CKABIE = 0x40;        // Clock absence interrupt enable
    template<uint32_t X>
    static constexpr uint32_t DFSDM3_CR2_EXCH =                // Extremes detector channel selection (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM3_CR2_AWDCH =               // Analog watchdog channel selection (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static const uint32_t DFSDM3_CR2_RESET_VALUE = 0x0;

    static constexpr uint32_t DFSDM0_ISR_JEOCF = 0x1;          // End of injected conversion flag
    static constexpr uint32_t DFSDM0_ISR_REOCF = 0x2;          // End of regular conversion flag
    static constexpr uint32_t DFSDM0_ISR_JOVRF = 0x4;          // Injected conversion overrun flag
    static constexpr uint32_t DFSDM0_ISR_ROVRF = 0x8;          // Regular conversion overrun flag
    static constexpr uint32_t DFSDM0_ISR_AWDF = 0x10;          // Analog watchdog
    static constexpr uint32_t DFSDM0_ISR_JCIP = 0x2000;        // Injected conversion in progress status
    static constexpr uint32_t DFSDM0_ISR_RCIP = 0x4000;        // Regular conversion in progress status
    template<uint32_t X>
    static constexpr uint32_t DFSDM0_ISR_CKABF =               // Clock absence flag (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM0_ISR_SCDF =                // short-circuit detector flag (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t DFSDM0_ISR_RESET_VALUE = 0x0;

    static constexpr uint32_t DFSDM1_ISR_JEOCF = 0x1;          // End of injected conversion flag
    static constexpr uint32_t DFSDM1_ISR_REOCF = 0x2;          // End of regular conversion flag
    static constexpr uint32_t DFSDM1_ISR_JOVRF = 0x4;          // Injected conversion overrun flag
    static constexpr uint32_t DFSDM1_ISR_ROVRF = 0x8;          // Regular conversion overrun flag
    static constexpr uint32_t DFSDM1_ISR_AWDF = 0x10;          // Analog watchdog
    static constexpr uint32_t DFSDM1_ISR_JCIP = 0x2000;        // Injected conversion in progress status
    static constexpr uint32_t DFSDM1_ISR_RCIP = 0x4000;        // Regular conversion in progress status
    template<uint32_t X>
    static constexpr uint32_t DFSDM1_ISR_CKABF =               // Clock absence flag (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM1_ISR_SCDF =                // short-circuit detector flag (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t DFSDM1_ISR_RESET_VALUE = 0x0;

    static constexpr uint32_t DFSDM2_ISR_JEOCF = 0x1;          // End of injected conversion flag
    static constexpr uint32_t DFSDM2_ISR_REOCF = 0x2;          // End of regular conversion flag
    static constexpr uint32_t DFSDM2_ISR_JOVRF = 0x4;          // Injected conversion overrun flag
    static constexpr uint32_t DFSDM2_ISR_ROVRF = 0x8;          // Regular conversion overrun flag
    static constexpr uint32_t DFSDM2_ISR_AWDF = 0x10;          // Analog watchdog
    static constexpr uint32_t DFSDM2_ISR_JCIP = 0x2000;        // Injected conversion in progress status
    static constexpr uint32_t DFSDM2_ISR_RCIP = 0x4000;        // Regular conversion in progress status
    template<uint32_t X>
    static constexpr uint32_t DFSDM2_ISR_CKABF =               // Clock absence flag (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM2_ISR_SCDF =                // short-circuit detector flag (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t DFSDM2_ISR_RESET_VALUE = 0x0;

    static constexpr uint32_t DFSDM3_ISR_JEOCF = 0x1;          // End of injected conversion flag
    static constexpr uint32_t DFSDM3_ISR_REOCF = 0x2;          // End of regular conversion flag
    static constexpr uint32_t DFSDM3_ISR_JOVRF = 0x4;          // Injected conversion overrun flag
    static constexpr uint32_t DFSDM3_ISR_ROVRF = 0x8;          // Regular conversion overrun flag
    static constexpr uint32_t DFSDM3_ISR_AWDF = 0x10;          // Analog watchdog
    static constexpr uint32_t DFSDM3_ISR_JCIP = 0x2000;        // Injected conversion in progress status
    static constexpr uint32_t DFSDM3_ISR_RCIP = 0x4000;        // Regular conversion in progress status
    template<uint32_t X>
    static constexpr uint32_t DFSDM3_ISR_CKABF =               // Clock absence flag (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM3_ISR_SCDF =                // short-circuit detector flag (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t DFSDM3_ISR_RESET_VALUE = 0x0;

    static constexpr uint32_t DFSDM0_ICR_CLRJOVRF = 0x4;       // Clear the injected conversion overrun flag
    static constexpr uint32_t DFSDM0_ICR_CLRROVRF = 0x8;       // Clear the regular conversion overrun flag
    template<uint32_t X>
    static constexpr uint32_t DFSDM0_ICR_CLRCKABF =            // Clear the clock absence flag (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM0_ICR_CLRSCDF =             // Clear the short-circuit detector flag (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t DFSDM0_ICR_RESET_VALUE = 0x0;

    static constexpr uint32_t DFSDM1_ICR_CLRJOVRF = 0x4;       // Clear the injected conversion overrun flag
    static constexpr uint32_t DFSDM1_ICR_CLRROVRF = 0x8;       // Clear the regular conversion overrun flag
    template<uint32_t X>
    static constexpr uint32_t DFSDM1_ICR_CLRCKABF =            // Clear the clock absence flag (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM1_ICR_CLRSCDF =             // Clear the short-circuit detector flag (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t DFSDM1_ICR_RESET_VALUE = 0x0;

    static constexpr uint32_t DFSDM2_ICR_CLRJOVRF = 0x4;       // Clear the injected conversion overrun flag
    static constexpr uint32_t DFSDM2_ICR_CLRROVRF = 0x8;       // Clear the regular conversion overrun flag
    template<uint32_t X>
    static constexpr uint32_t DFSDM2_ICR_CLRCKABF =            // Clear the clock absence flag (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM2_ICR_CLRSCDF =             // Clear the short-circuit detector flag (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t DFSDM2_ICR_RESET_VALUE = 0x0;

    static constexpr uint32_t DFSDM3_ICR_CLRJOVRF = 0x4;       // Clear the injected conversion overrun flag
    static constexpr uint32_t DFSDM3_ICR_CLRROVRF = 0x8;       // Clear the regular conversion overrun flag
    template<uint32_t X>
    static constexpr uint32_t DFSDM3_ICR_CLRCKABF =            // Clear the clock absence flag (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM3_ICR_CLRSCDF =             // Clear the short-circuit detector flag (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t DFSDM3_ICR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM0_JCHGR_JCHG =                // Injected channel group selection (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t DFSDM0_JCHGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM1_JCHGR_JCHG =                // Injected channel group selection (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t DFSDM1_JCHGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM2_JCHGR_JCHG =                // Injected channel group selection (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t DFSDM2_JCHGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM3_JCHGR_JCHG =                // Injected channel group selection (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t DFSDM3_JCHGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM0_FCR_IOSR =                // Integrator oversampling ratio (averaging length) (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM0_FCR_FOSR =                // Sinc filter oversampling ratio (decimation rate) (10 bits)
        bit_field_t<16, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM0_FCR_FORD =                // Sinc filter order (3 bits)
        bit_field_t<29, 0x7>::value<X>();
    static const uint32_t DFSDM0_FCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM1_FCR_IOSR =                // Integrator oversampling ratio (averaging length) (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM1_FCR_FOSR =                // Sinc filter oversampling ratio (decimation rate) (10 bits)
        bit_field_t<16, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM1_FCR_FORD =                // Sinc filter order (3 bits)
        bit_field_t<29, 0x7>::value<X>();
    static const uint32_t DFSDM1_FCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM2_FCR_IOSR =                // Integrator oversampling ratio (averaging length) (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM2_FCR_FOSR =                // Sinc filter oversampling ratio (decimation rate) (10 bits)
        bit_field_t<16, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM2_FCR_FORD =                // Sinc filter order (3 bits)
        bit_field_t<29, 0x7>::value<X>();
    static const uint32_t DFSDM2_FCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM3_FCR_IOSR =                // Integrator oversampling ratio (averaging length) (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM3_FCR_FOSR =                // Sinc filter oversampling ratio (decimation rate) (10 bits)
        bit_field_t<16, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM3_FCR_FORD =                // Sinc filter order (3 bits)
        bit_field_t<29, 0x7>::value<X>();
    static const uint32_t DFSDM3_FCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM0_JDATAR_JDATACH =             // Injected channel most recently converted (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM0_JDATAR_JDATA =               // Injected group conversion data (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t DFSDM0_JDATAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM1_JDATAR_JDATACH =             // Injected channel most recently converted (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM1_JDATAR_JDATA =               // Injected group conversion data (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t DFSDM1_JDATAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM2_JDATAR_JDATACH =             // Injected channel most recently converted (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM2_JDATAR_JDATA =               // Injected group conversion data (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t DFSDM2_JDATAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM3_JDATAR_JDATACH =             // Injected channel most recently converted (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM3_JDATAR_JDATA =               // Injected group conversion data (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t DFSDM3_JDATAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM0_RDATAR_RDATACH =             // Regular channel most recently converted (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static constexpr uint32_t DFSDM0_RDATAR_RPEND = 0x10;         // Regular channel pending data
    template<uint32_t X>
    static constexpr uint32_t DFSDM0_RDATAR_RDATA =               // Regular channel conversion data (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t DFSDM0_RDATAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM1_RDATAR_RDATACH =             // Regular channel most recently converted (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static constexpr uint32_t DFSDM1_RDATAR_RPEND = 0x10;         // Regular channel pending data
    template<uint32_t X>
    static constexpr uint32_t DFSDM1_RDATAR_RDATA =               // Regular channel conversion data (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t DFSDM1_RDATAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM2_RDATAR_RDATACH =             // Regular channel most recently converted (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static constexpr uint32_t DFSDM2_RDATAR_RPEND = 0x10;         // Regular channel pending data
    template<uint32_t X>
    static constexpr uint32_t DFSDM2_RDATAR_RDATA =               // Regular channel conversion data (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t DFSDM2_RDATAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM3_RDATAR_RDATACH =             // Regular channel most recently converted (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static constexpr uint32_t DFSDM3_RDATAR_RPEND = 0x10;         // Regular channel pending data
    template<uint32_t X>
    static constexpr uint32_t DFSDM3_RDATAR_RDATA =               // Regular channel conversion data (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t DFSDM3_RDATAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM0_AWHTR_BKAWH =               // Break signal assignment to analog watchdog high threshold event (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM0_AWHTR_AWHT =                // Analog watchdog high threshold (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t DFSDM0_AWHTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM1_AWHTR_BKAWH =               // Break signal assignment to analog watchdog high threshold event (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM1_AWHTR_AWHT =                // Analog watchdog high threshold (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t DFSDM1_AWHTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM2_AWHTR_BKAWH =               // Break signal assignment to analog watchdog high threshold event (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM2_AWHTR_AWHT =                // Analog watchdog high threshold (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t DFSDM2_AWHTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM3_AWHTR_BKAWH =               // Break signal assignment to analog watchdog high threshold event (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM3_AWHTR_AWHT =                // Analog watchdog high threshold (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t DFSDM3_AWHTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM0_AWLTR_BKAWL =               // Break signal assignment to analog watchdog low threshold event (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM0_AWLTR_AWLT =                // Analog watchdog low threshold (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t DFSDM0_AWLTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM1_AWLTR_BKAWL =               // Break signal assignment to analog watchdog low threshold event (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM1_AWLTR_AWLT =                // Analog watchdog low threshold (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t DFSDM1_AWLTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM2_AWLTR_BKAWL =               // Break signal assignment to analog watchdog low threshold event (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM2_AWLTR_AWLT =                // Analog watchdog low threshold (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t DFSDM2_AWLTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM3_AWLTR_BKAWL =               // Break signal assignment to analog watchdog low threshold event (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM3_AWLTR_AWLT =                // Analog watchdog low threshold (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t DFSDM3_AWLTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM0_AWSR_AWLTF =               // Analog watchdog low threshold flag (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM0_AWSR_AWHTF =               // Analog watchdog high threshold flag (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static const uint32_t DFSDM0_AWSR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM1_AWSR_AWLTF =               // Analog watchdog low threshold flag (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM1_AWSR_AWHTF =               // Analog watchdog high threshold flag (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static const uint32_t DFSDM1_AWSR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM2_AWSR_AWLTF =               // Analog watchdog low threshold flag (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM2_AWSR_AWHTF =               // Analog watchdog high threshold flag (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static const uint32_t DFSDM2_AWSR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM3_AWSR_AWLTF =               // Analog watchdog low threshold flag (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM3_AWSR_AWHTF =               // Analog watchdog high threshold flag (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static const uint32_t DFSDM3_AWSR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM0_AWCFR_CLRAWLTF =            // Clear the analog watchdog low threshold flag (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM0_AWCFR_CLRAWHTF =            // Clear the analog watchdog high threshold flag (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static const uint32_t DFSDM0_AWCFR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM1_AWCFR_CLRAWLTF =            // Clear the analog watchdog low threshold flag (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM1_AWCFR_CLRAWHTF =            // Clear the analog watchdog high threshold flag (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static const uint32_t DFSDM1_AWCFR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM2_AWCFR_CLRAWLTF =            // Clear the analog watchdog low threshold flag (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM2_AWCFR_CLRAWHTF =            // Clear the analog watchdog high threshold flag (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static const uint32_t DFSDM2_AWCFR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM3_AWCFR_CLRAWLTF =            // Clear the analog watchdog low threshold flag (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM3_AWCFR_CLRAWHTF =            // Clear the analog watchdog high threshold flag (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static const uint32_t DFSDM3_AWCFR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM0_EXMAX_EXMAXCH =             // Extremes detector maximum data channel (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM0_EXMAX_EXMAX =               // Extremes detector maximum value (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t DFSDM0_EXMAX_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM1_EXMAX_EXMAXCH =             // Extremes detector maximum data channel (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM1_EXMAX_EXMAX =               // Extremes detector maximum value (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t DFSDM1_EXMAX_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM2_EXMAX_EXMAXCH =             // Extremes detector maximum data channel (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM2_EXMAX_EXMAX =               // Extremes detector maximum value (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t DFSDM2_EXMAX_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM3_EXMAX_EXMAXCH =             // Extremes detector maximum data channel (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM3_EXMAX_EXMAX =               // Extremes detector maximum value (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t DFSDM3_EXMAX_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM0_EXMIN_EXMINCH =             // Extremes detector minimum data channel (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM0_EXMIN_EXMIN =               // Extremes detector minimum value (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t DFSDM0_EXMIN_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM1_EXMIN_EXMINCH =             // Extremes detector minimum data channel (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM1_EXMIN_EXMIN =               // Extremes detector minimum value (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t DFSDM1_EXMIN_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM2_EXMIN_EXMINCH =             // Extremes detector minimum data channel (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM2_EXMIN_EXMIN =               // Extremes detector minimum value (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t DFSDM2_EXMIN_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM3_EXMIN_EXMINCH =             // Extremes detector minimum data channel (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM3_EXMIN_EXMIN =               // Extremes detector minimum value (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t DFSDM3_EXMIN_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM0_CNVTIMR_CNVCNT =              // 28-bit timer counting conversion time (28 bits)
        bit_field_t<4, 0xfffffff>::value<X>();
    static const uint32_t DFSDM0_CNVTIMR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM1_CNVTIMR_CNVCNT =              // 28-bit timer counting conversion time (28 bits)
        bit_field_t<4, 0xfffffff>::value<X>();
    static const uint32_t DFSDM1_CNVTIMR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM2_CNVTIMR_CNVCNT =              // 28-bit timer counting conversion time (28 bits)
        bit_field_t<4, 0xfffffff>::value<X>();
    static const uint32_t DFSDM2_CNVTIMR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM3_CNVTIMR_CNVCNT =              // 28-bit timer counting conversion time (28 bits)
        bit_field_t<4, 0xfffffff>::value<X>();
    static const uint32_t DFSDM3_CNVTIMR_RESET_VALUE = 0x0;

    static constexpr uint8_t DFSDM1_FLT0 = 110; // DFSDM1 filter 0 interrupt
    static constexpr uint8_t DFSDM1_FLT1 = 111; // DFSDM1 filter 1 interrupt
    static constexpr uint8_t DFSDM1_FLT2 = 112; // DFSDM1 filter 2 interrupt
    static constexpr uint8_t DFSDM1_FLT3 = 113; // DFSDM1 filter 3 interrupt
};

static dfsdm_t& DFSDM = *reinterpret_cast<dfsdm_t*>(0x40017000);

#define HAVE_PERIPHERAL_DFSDM


////
//
//    General-purpose-timers
//
////

struct tim16_t
{
    volatile uint32_t    CR1;                  // [Read-write] control register 1
    volatile uint32_t    CR2;                  // [Read-write] control register 2
    reserved_t<1>        _0;
    volatile uint32_t    DIER;                 // [Read-write] DMA/Interrupt enable register
    volatile uint32_t    SR;                   // [Read-write] status register
    volatile uint32_t    EGR;                  // [Write-only] event generation register
    volatile uint32_t    CCMR1;                // [Read-write] capture/compare mode register (output mode)
    reserved_t<1>        _1;
    volatile uint32_t    CCER;                 // [Read-write] capture/compare enable register
    volatile uint32_t    CNT;                  // counter
    volatile uint32_t    PSC;                  // [Read-write] prescaler
    volatile uint32_t    ARR;                  // [Read-write] auto-reload register
    volatile uint32_t    RCR;                  // [Read-write] repetition counter register
    volatile uint32_t    CCR1;                 // [Read-write] capture/compare register 1
    reserved_t<3>        _2;
    volatile uint32_t    BDTR;                 // [Read-write] break and dead-time register
    volatile uint32_t    DCR;                  // [Read-write] DMA control register
    volatile uint32_t    DMAR;                 // [Read-write] DMA address for full transfer
    reserved_t<4>        _3;
    volatile uint32_t    TIM16_AF1;            // [Read-write] TIM16 alternate function register 1
    reserved_t<1>        _4;
    volatile uint32_t    TIM16_TISEL;          // [Read-write] TIM16 input selection register

    static constexpr uint32_t CR1_CEN = 0x1;            // Counter enable
    static constexpr uint32_t CR1_UDIS = 0x2;           // Update disable
    static constexpr uint32_t CR1_URS = 0x4;            // Update request source
    static constexpr uint32_t CR1_OPM = 0x8;            // One-pulse mode
    static constexpr uint32_t CR1_ARPE = 0x80;          // Auto-reload preload enable
    template<uint32_t X>
    static constexpr uint32_t CR1_CKD =                 // Clock division (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t CR1_UIFREMAP = 0x800;     // UIF status bit remapping
    static const uint32_t CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CR2_OIS1N = 0x200;        // Output Idle state 1
    static constexpr uint32_t CR2_OIS1 = 0x100;         // Output Idle state 1
    static constexpr uint32_t CR2_CCDS = 0x8;           // Capture/compare DMA selection
    static constexpr uint32_t CR2_CCUS = 0x4;           // Capture/compare control update selection
    static constexpr uint32_t CR2_CCPC = 0x1;           // Capture/compare preloaded control
    static const uint32_t CR2_RESET_VALUE = 0x0;

    static constexpr uint32_t DIER_UIE = 0x1;            // Update interrupt enable
    static constexpr uint32_t DIER_CC1IE = 0x2;          // Capture/Compare 1 interrupt enable
    static constexpr uint32_t DIER_COMIE = 0x20;         // COM interrupt enable
    static constexpr uint32_t DIER_BIE = 0x80;           // Break interrupt enable
    static constexpr uint32_t DIER_UDE = 0x100;          // Update DMA request enable
    static constexpr uint32_t DIER_CC1DE = 0x200;        // Capture/Compare 1 DMA request enable
    static constexpr uint32_t DIER_COMDE = 0x2000;       // COM DMA request enable
    static const uint32_t DIER_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_CC1OF = 0x200;        // Capture/Compare 1 overcapture flag
    static constexpr uint32_t SR_BIF = 0x80;           // Break interrupt flag
    static constexpr uint32_t SR_COMIF = 0x20;         // COM interrupt flag
    static constexpr uint32_t SR_CC1IF = 0x2;          // Capture/compare 1 interrupt flag
    static constexpr uint32_t SR_UIF = 0x1;            // Update interrupt flag
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint32_t EGR_BG = 0x80;            // Break generation
    static constexpr uint32_t EGR_COMG = 0x20;          // Capture/Compare control update generation
    static constexpr uint32_t EGR_CC1G = 0x2;           // Capture/compare 1 generation
    static constexpr uint32_t EGR_UG = 0x1;             // Update generation
    static const uint32_t EGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCMR1_CC1S =                // Capture/Compare 1 selection (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC1F =                // Input capture 1 filter (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC1PSC =              // Input capture 1 prescaler (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t CCMR1_OC1FE = 0x4;          // Output Compare 1 fast enable
    template<uint32_t X>
    static constexpr uint32_t CCMR1_OC1M =                // Output Compare 1 mode (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR1_OC1M_3 = 0x10000;     // Output Compare 1 mode
    static constexpr uint32_t CCMR1_OC1PE = 0x8;          // Output Compare 1 preload enable
    static const uint32_t CCMR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CCER_CC1NP = 0x8;          // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1NE = 0x4;          // Capture/Compare 1 complementary output enable
    static constexpr uint32_t CCER_CC1P = 0x2;           // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1E = 0x1;           // Capture/Compare 1 output enable
    static const uint32_t CCER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CNT_CNT =                 // counter value (16 bits), Read-write
        bit_field_t<0, 0xffff>::value<X>();
    static constexpr uint32_t CNT_UIFCPY = 0x80000000;  // UIF Copy, Read-only
    static const uint32_t CNT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PSC_PSC =                 // Prescaler value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t PSC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ARR_ARR =                 // Auto-reload value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t ARR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RCR_REP =                 // Repetition counter value (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t RCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR1_CCR1 =                // Capture/Compare 1 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BDTR_DTG =                 // Dead-time generator setup (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BDTR_LOCK =                // Lock configuration (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t BDTR_OSSI = 0x400;         // Off-state selection for Idle mode
    static constexpr uint32_t BDTR_OSSR = 0x800;         // Off-state selection for Run mode
    static constexpr uint32_t BDTR_BKE = 0x1000;         // Break enable
    static constexpr uint32_t BDTR_BKP = 0x2000;         // Break polarity
    static constexpr uint32_t BDTR_AOE = 0x4000;         // Automatic output enable
    static constexpr uint32_t BDTR_MOE = 0x8000;         // Main output enable
    template<uint32_t X>
    static constexpr uint32_t BDTR_BKF =                 // Break filter (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    static const uint32_t BDTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DCR_DBL =                 // DMA burst length (5 bits)
        bit_field_t<8, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DCR_DBA =                 // DMA base address (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t DCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DMAR_DMAB =                // DMA register for burst accesses (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DMAR_RESET_VALUE = 0x0;

    static constexpr uint32_t TIM16_AF1_BKINE = 0x1;          // BRK BKIN input enable
    static constexpr uint32_t TIM16_AF1_BKCMP1E = 0x2;        // BRK COMP1 enable
    static constexpr uint32_t TIM16_AF1_BKCMP2E = 0x4;        // BRK COMP2 enable
    static constexpr uint32_t TIM16_AF1_BKDFBK1E = 0x100;     // BRK dfsdm1_break[1] enable
    static constexpr uint32_t TIM16_AF1_BKINP = 0x200;        // BRK BKIN input polarity
    static constexpr uint32_t TIM16_AF1_BKCMP1P = 0x400;      // BRK COMP1 input polarity
    static constexpr uint32_t TIM16_AF1_BKCMP2P = 0x800;      // BRK COMP2 input polarity
    static const uint32_t TIM16_AF1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TIM16_TISEL_TI1SEL =              // selects TI1[0] to TI1[15] input (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t TIM16_TISEL_RESET_VALUE = 0x0;

    static constexpr uint8_t TIM16 = 117; // TIM16 global interrupt
};

static tim16_t& TIM16 = *reinterpret_cast<tim16_t*>(0x40014400);

#define HAVE_PERIPHERAL_TIM16


////
//
//    General-purpose-timers
//
////

struct tim17_t
{
    volatile uint32_t    CR1;                  // [Read-write] control register 1
    volatile uint32_t    CR2;                  // [Read-write] control register 2
    reserved_t<1>        _0;
    volatile uint32_t    DIER;                 // [Read-write] DMA/Interrupt enable register
    volatile uint32_t    SR;                   // [Read-write] status register
    volatile uint32_t    EGR;                  // [Write-only] event generation register
    volatile uint32_t    CCMR1;                // [Read-write] capture/compare mode register (output mode)
    reserved_t<1>        _1;
    volatile uint32_t    CCER;                 // [Read-write] capture/compare enable register
    volatile uint32_t    CNT;                  // counter
    volatile uint32_t    PSC;                  // [Read-write] prescaler
    volatile uint32_t    ARR;                  // [Read-write] auto-reload register
    volatile uint32_t    RCR;                  // [Read-write] repetition counter register
    volatile uint32_t    CCR1;                 // [Read-write] capture/compare register 1
    reserved_t<3>        _2;
    volatile uint32_t    BDTR;                 // [Read-write] break and dead-time register
    volatile uint32_t    DCR;                  // [Read-write] DMA control register
    volatile uint32_t    DMAR;                 // [Read-write] DMA address for full transfer
    reserved_t<4>        _3;
    volatile uint32_t    TIM17_AF1;            // [Read-write] TIM17 alternate function register 1
    reserved_t<1>        _4;
    volatile uint32_t    TIM17_TISEL;          // [Read-write] TIM17 input selection register

    static constexpr uint32_t CR1_CEN = 0x1;            // Counter enable
    static constexpr uint32_t CR1_UDIS = 0x2;           // Update disable
    static constexpr uint32_t CR1_URS = 0x4;            // Update request source
    static constexpr uint32_t CR1_OPM = 0x8;            // One-pulse mode
    static constexpr uint32_t CR1_ARPE = 0x80;          // Auto-reload preload enable
    template<uint32_t X>
    static constexpr uint32_t CR1_CKD =                 // Clock division (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t CR1_UIFREMAP = 0x800;     // UIF status bit remapping
    static const uint32_t CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CR2_OIS1N = 0x200;        // Output Idle state 1
    static constexpr uint32_t CR2_OIS1 = 0x100;         // Output Idle state 1
    static constexpr uint32_t CR2_CCDS = 0x8;           // Capture/compare DMA selection
    static constexpr uint32_t CR2_CCUS = 0x4;           // Capture/compare control update selection
    static constexpr uint32_t CR2_CCPC = 0x1;           // Capture/compare preloaded control
    static const uint32_t CR2_RESET_VALUE = 0x0;

    static constexpr uint32_t DIER_UIE = 0x1;            // Update interrupt enable
    static constexpr uint32_t DIER_CC1IE = 0x2;          // Capture/Compare 1 interrupt enable
    static constexpr uint32_t DIER_COMIE = 0x20;         // COM interrupt enable
    static constexpr uint32_t DIER_BIE = 0x80;           // Break interrupt enable
    static constexpr uint32_t DIER_UDE = 0x100;          // Update DMA request enable
    static constexpr uint32_t DIER_CC1DE = 0x200;        // Capture/Compare 1 DMA request enable
    static constexpr uint32_t DIER_COMDE = 0x2000;       // COM DMA request enable
    static const uint32_t DIER_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_CC1OF = 0x200;        // Capture/Compare 1 overcapture flag
    static constexpr uint32_t SR_BIF = 0x80;           // Break interrupt flag
    static constexpr uint32_t SR_COMIF = 0x20;         // COM interrupt flag
    static constexpr uint32_t SR_CC1IF = 0x2;          // Capture/compare 1 interrupt flag
    static constexpr uint32_t SR_UIF = 0x1;            // Update interrupt flag
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint32_t EGR_BG = 0x80;            // Break generation
    static constexpr uint32_t EGR_COMG = 0x20;          // Capture/Compare control update generation
    static constexpr uint32_t EGR_CC1G = 0x2;           // Capture/compare 1 generation
    static constexpr uint32_t EGR_UG = 0x1;             // Update generation
    static const uint32_t EGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCMR1_CC1S =                // Capture/Compare 1 selection (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC1F =                // Input capture 1 filter (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC1PSC =              // Input capture 1 prescaler (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t CCMR1_OC1FE = 0x4;          // Output Compare 1 fast enable
    template<uint32_t X>
    static constexpr uint32_t CCMR1_OC1M =                // Output Compare 1 mode (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR1_OC1M_3 = 0x10000;     // Output Compare 1 mode
    static constexpr uint32_t CCMR1_OC1PE = 0x8;          // Output Compare 1 preload enable
    static const uint32_t CCMR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CCER_CC1NP = 0x8;          // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1NE = 0x4;          // Capture/Compare 1 complementary output enable
    static constexpr uint32_t CCER_CC1P = 0x2;           // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1E = 0x1;           // Capture/Compare 1 output enable
    static const uint32_t CCER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CNT_CNT =                 // counter value (16 bits), Read-write
        bit_field_t<0, 0xffff>::value<X>();
    static constexpr uint32_t CNT_UIFCPY = 0x80000000;  // UIF Copy, Read-only
    static const uint32_t CNT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PSC_PSC =                 // Prescaler value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t PSC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ARR_ARR =                 // Auto-reload value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t ARR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RCR_REP =                 // Repetition counter value (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t RCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR1_CCR1 =                // Capture/Compare 1 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BDTR_DTG =                 // Dead-time generator setup (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BDTR_LOCK =                // Lock configuration (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t BDTR_OSSI = 0x400;         // Off-state selection for Idle mode
    static constexpr uint32_t BDTR_OSSR = 0x800;         // Off-state selection for Run mode
    static constexpr uint32_t BDTR_BKE = 0x1000;         // Break enable
    static constexpr uint32_t BDTR_BKP = 0x2000;         // Break polarity
    static constexpr uint32_t BDTR_AOE = 0x4000;         // Automatic output enable
    static constexpr uint32_t BDTR_MOE = 0x8000;         // Main output enable
    template<uint32_t X>
    static constexpr uint32_t BDTR_BKF =                 // Break filter (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    static const uint32_t BDTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DCR_DBL =                 // DMA burst length (5 bits)
        bit_field_t<8, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DCR_DBA =                 // DMA base address (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t DCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DMAR_DMAB =                // DMA register for burst accesses (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DMAR_RESET_VALUE = 0x0;

    static constexpr uint32_t TIM17_AF1_BKINE = 0x1;          // BRK BKIN input enable
    static constexpr uint32_t TIM17_AF1_BKCMP1E = 0x2;        // BRK COMP1 enable
    static constexpr uint32_t TIM17_AF1_BKCMP2E = 0x4;        // BRK COMP2 enable
    static constexpr uint32_t TIM17_AF1_BKDFBK1E = 0x100;     // BRK dfsdm1_break[1] enable
    static constexpr uint32_t TIM17_AF1_BKINP = 0x200;        // BRK BKIN input polarity
    static constexpr uint32_t TIM17_AF1_BKCMP1P = 0x400;      // BRK COMP1 input polarity
    static constexpr uint32_t TIM17_AF1_BKCMP2P = 0x800;      // BRK COMP2 input polarity
    static const uint32_t TIM17_AF1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TIM17_TISEL_TI1SEL =              // selects TI1[0] to TI1[15] input (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t TIM17_TISEL_RESET_VALUE = 0x0;

    static constexpr uint8_t TIM17 = 118; // TIM17 global interrupt
};

static tim17_t& TIM17 = *reinterpret_cast<tim17_t*>(0x40014800);

#define HAVE_PERIPHERAL_TIM17


////
//
//    General purpose timers
//
////

struct tim15_t
{
    volatile uint32_t    CR1;                  // [Read-write] control register 1
    volatile uint32_t    CR2;                  // [Read-write] control register 2
    volatile uint32_t    SMCR;                 // [Read-write] slave mode control register
    volatile uint32_t    DIER;                 // [Read-write] DMA/Interrupt enable register
    volatile uint32_t    SR;                   // [Read-write] status register
    volatile uint32_t    EGR;                  // [Write-only] event generation register
    volatile uint32_t    CCMR1;                // [Read-write] capture/compare mode register (output mode)
    reserved_t<1>        _0;
    volatile uint32_t    CCER;                 // [Read-write] capture/compare enable register
    volatile uint32_t    CNT;                  // counter
    volatile uint32_t    PSC;                  // [Read-write] prescaler
    volatile uint32_t    ARR;                  // [Read-write] auto-reload register
    volatile uint32_t    RCR;                  // [Read-write] repetition counter register
    volatile uint32_t    CCR1;                 // [Read-write] capture/compare register 1
    volatile uint32_t    CCR2;                 // [Read-write] capture/compare register 2
    reserved_t<2>        _1;
    volatile uint32_t    BDTR;                 // [Read-write] break and dead-time register
    volatile uint32_t    DCR;                  // [Read-write] DMA control register
    volatile uint32_t    DMAR;                 // [Read-write] DMA address for full transfer
    reserved_t<4>        _2;
    volatile uint32_t    AF1;                  // [Read-write] TIM15 alternate fdfsdm1_breakon register 1
    reserved_t<1>        _3;
    volatile uint32_t    TISEL;                // [Read-write] TIM15 input selection register

    static constexpr uint32_t CR1_CEN = 0x1;            // Counter enable
    static constexpr uint32_t CR1_UDIS = 0x2;           // Update disable
    static constexpr uint32_t CR1_URS = 0x4;            // Update request source
    static constexpr uint32_t CR1_OPM = 0x8;            // One-pulse mode
    static constexpr uint32_t CR1_ARPE = 0x80;          // Auto-reload preload enable
    template<uint32_t X>
    static constexpr uint32_t CR1_CKD =                 // Clock division (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t CR1_UIFREMAP = 0x800;     // UIF status bit remapping
    static const uint32_t CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CR2_CCPC = 0x1;           // Capture/compare preloaded control
    static constexpr uint32_t CR2_CCUS = 0x4;           // Capture/compare control update selection
    static constexpr uint32_t CR2_CCDS = 0x8;           // Capture/compare DMA selection
    template<uint32_t X>
    static constexpr uint32_t CR2_MMS =                 // Master mode selection (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CR2_TI1S = 0x80;          // TI1 selection
    static constexpr uint32_t CR2_OIS1 = 0x100;         // Output Idle state 1
    static constexpr uint32_t CR2_OIS1N = 0x200;        // Output Idle state 1
    static constexpr uint32_t CR2_OIS2 = 0x400;         // Output Idle state 2
    static const uint32_t CR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SMCR_SMS =                 // Slave mode selection (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMCR_TS_2_0 =              // Trigger selection (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t SMCR_MSM = 0x80;           // Master/Slave mode
    static constexpr uint32_t SMCR_SMS_3 = 0x10000;      // Slave mode selection bit 3
    template<uint32_t X>
    static constexpr uint32_t SMCR_TS_4_3 =              // Trigger selection - bit 4:3 (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    static const uint32_t SMCR_RESET_VALUE = 0x0;

    static constexpr uint32_t DIER_UIE = 0x1;            // Update interrupt enable
    static constexpr uint32_t DIER_CC1IE = 0x2;          // Capture/Compare 1 interrupt enable
    static constexpr uint32_t DIER_CC2IE = 0x4;          // Capture/Compare 2 interrupt enable
    static constexpr uint32_t DIER_COMIE = 0x20;         // COM interrupt enable
    static constexpr uint32_t DIER_TIE = 0x40;           // Trigger interrupt enable
    static constexpr uint32_t DIER_BIE = 0x80;           // Break interrupt enable
    static constexpr uint32_t DIER_UDE = 0x100;          // Update DMA request enable
    static constexpr uint32_t DIER_CC1DE = 0x200;        // Capture/Compare 1 DMA request enable
    static constexpr uint32_t DIER_CC2DE = 0x400;        // Capture/Compare 2 DMA request enable
    static constexpr uint32_t DIER_COMDE = 0x2000;       // COM DMA request enable
    static constexpr uint32_t DIER_TDE = 0x4000;         // Trigger DMA request enable
    static const uint32_t DIER_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_CC2OF = 0x400;        // Capture/compare 2 overcapture flag
    static constexpr uint32_t SR_CC1OF = 0x200;        // Capture/Compare 1 overcapture flag
    static constexpr uint32_t SR_BIF = 0x80;           // Break interrupt flag
    static constexpr uint32_t SR_TIF = 0x40;           // Trigger interrupt flag
    static constexpr uint32_t SR_COMIF = 0x20;         // COM interrupt flag
    static constexpr uint32_t SR_CC2IF = 0x4;          // Capture/Compare 2 interrupt flag
    static constexpr uint32_t SR_CC1IF = 0x2;          // Capture/compare 1 interrupt flag
    static constexpr uint32_t SR_UIF = 0x1;            // Update interrupt flag
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint32_t EGR_BG = 0x80;            // Break generation
    static constexpr uint32_t EGR_TG = 0x40;            // Trigger generation
    static constexpr uint32_t EGR_COMG = 0x20;          // Capture/Compare control update generation
    static constexpr uint32_t EGR_CC2G = 0x4;           // Capture/compare 2 generation
    static constexpr uint32_t EGR_CC1G = 0x2;           // Capture/compare 1 generation
    static constexpr uint32_t EGR_UG = 0x1;             // Update generation
    static const uint32_t EGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCMR1_CC1S =                // Capture/Compare 1 selection (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_CC2S =                // Capture/Compare 2 selection (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC1F =                // Input capture 1 filter (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC1PSC =              // Input capture 1 prescaler (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC2F =                // Input capture 2 filter (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC2PSC =              // Input capture 2 prescaler (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    static constexpr uint32_t CCMR1_OC1FE = 0x4;          // Output Compare 1 fast enable
    template<uint32_t X>
    static constexpr uint32_t CCMR1_OC1M =                // Output Compare 1 mode (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR1_OC1M_3 = 0x10000;     // Output Compare 1 mode bit 3
    static constexpr uint32_t CCMR1_OC1PE = 0x8;          // Output Compare 1 preload enable
    static constexpr uint32_t CCMR1_OC2FE = 0x400;        // Output Compare 2 fast enable
    template<uint32_t X>
    static constexpr uint32_t CCMR1_OC2M =                // Output Compare 2 mode (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    static constexpr uint32_t CCMR1_OC2M_3 = 0x1000000;   // Output Compare 2 mode bit 3
    static constexpr uint32_t CCMR1_OC2PE = 0x800;        // Output Compare 2 preload enable
    static const uint32_t CCMR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CCER_CC2NP = 0x80;         // Capture/Compare 2 output Polarity
    static constexpr uint32_t CCER_CC2P = 0x20;          // Capture/Compare 2 output Polarity
    static constexpr uint32_t CCER_CC2E = 0x10;          // Capture/Compare 2 output enable
    static constexpr uint32_t CCER_CC1NP = 0x8;          // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1NE = 0x4;          // Capture/Compare 1 complementary output enable
    static constexpr uint32_t CCER_CC1P = 0x2;           // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1E = 0x1;           // Capture/Compare 1 output enable
    static const uint32_t CCER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CNT_CNT =                 // counter value (16 bits), Read-write
        bit_field_t<0, 0xffff>::value<X>();
    static constexpr uint32_t CNT_UIFCPY = 0x80000000;  // UIF copy, Read-only
    static const uint32_t CNT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PSC_PSC =                 // Prescaler value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t PSC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ARR_ARR =                 // Auto-reload value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t ARR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RCR_REP =                 // Repetition counter value (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t RCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR1_CCR1 =                // Capture/Compare 1 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR2_CCR2 =                // Capture/Compare 2 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR2_RESET_VALUE = 0x0;

    static constexpr uint32_t BDTR_MOE = 0x8000;         // Main output enable
    static constexpr uint32_t BDTR_AOE = 0x4000;         // Automatic output enable
    static constexpr uint32_t BDTR_BKP = 0x2000;         // Break polarity
    static constexpr uint32_t BDTR_BKE = 0x1000;         // Break enable
    static constexpr uint32_t BDTR_OSSR = 0x800;         // Off-state selection for Run mode
    static constexpr uint32_t BDTR_OSSI = 0x400;         // Off-state selection for Idle mode
    template<uint32_t X>
    static constexpr uint32_t BDTR_LOCK =                // Lock configuration (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BDTR_DTG =                 // Dead-time generator setup (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BDTR_BKF =                 // Break filter (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    static const uint32_t BDTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DCR_DBL =                 // DMA burst length (5 bits)
        bit_field_t<8, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DCR_DBA =                 // DMA base address (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t DCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DMAR_DMAB =                // DMA register for burst accesses (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DMAR_RESET_VALUE = 0x0;

    static constexpr uint32_t AF1_BKINE = 0x1;          // BRK BKIN input enable
    static constexpr uint32_t AF1_BKCMP1E = 0x2;        // BRK COMP1 enable
    static constexpr uint32_t AF1_BKCMP2E = 0x4;        // BRK COMP2 enable
    static constexpr uint32_t AF1_BKDF1BK0E = 0x100;    // BRK dfsdm1_break[0] enable
    static constexpr uint32_t AF1_BKINP = 0x200;        // BRK BKIN input polarity
    static constexpr uint32_t AF1_BKCMP1P = 0x400;      // BRK COMP1 input polarity
    static constexpr uint32_t AF1_BKCMP2P = 0x800;      // BRK COMP2 input polarity
    static const uint32_t AF1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TISEL_TI1SEL =              // selects TI1[0] to TI1[15] input (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TISEL_TI2SEL =              // selects TI2[0] to TI2[15] input (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    static const uint32_t TISEL_RESET_VALUE = 0x0;

    static constexpr uint8_t TIM15 = 116; // TIM15 global interrupt
};

static tim15_t& TIM15 = *reinterpret_cast<tim15_t*>(0x40014000);

#define HAVE_PERIPHERAL_TIM15


////
//
//    Universal synchronous asynchronous receiver transmitter
//
////

struct usart1_t
{
    volatile uint32_t    CR1;                  // [Read-write] Control register 1
    volatile uint32_t    CR2;                  // [Read-write] Control register 2
    volatile uint32_t    CR3;                  // [Read-write] Control register 3
    volatile uint32_t    BRR;                  // [Read-write] Baud rate register
    volatile uint32_t    GTPR;                 // [Read-write] Guard time and prescaler register
    volatile uint32_t    RTOR;                 // [Read-write] Receiver timeout register
    volatile uint32_t    RQR;                  // [Write-only] Request register
    volatile uint32_t    ISR;                  // [Read-only] Interrupt &amp; status register
    volatile uint32_t    ICR;                  // [Write-only] Interrupt flag clear register
    volatile uint32_t    RDR;                  // [Read-only] Receive data register
    volatile uint32_t    TDR;                  // [Read-write] Transmit data register
    volatile uint32_t    PRESC;                // [Read-write] USART prescaler register

    static constexpr uint32_t CR1_RXFFIE = 0x80000000;  // RXFIFO Full interrupt enable
    static constexpr uint32_t CR1_TXFEIE = 0x40000000;  // TXFIFO empty interrupt enable
    static constexpr uint32_t CR1_FIFOEN = 0x20000000;  // FIFO mode enable
    static constexpr uint32_t CR1_M1 = 0x10000000;      // Word length
    static constexpr uint32_t CR1_EOBIE = 0x8000000;    // End of Block interrupt enable
    static constexpr uint32_t CR1_RTOIE = 0x4000000;    // Receiver timeout interrupt enable
    static constexpr uint32_t CR1_DEAT4 = 0x2000000;    // Driver Enable assertion time
    static constexpr uint32_t CR1_DEAT3 = 0x1000000;    // DEAT3
    static constexpr uint32_t CR1_DEAT2 = 0x800000;     // DEAT2
    static constexpr uint32_t CR1_DEAT1 = 0x400000;     // DEAT1
    static constexpr uint32_t CR1_DEAT0 = 0x200000;     // DEAT0
    static constexpr uint32_t CR1_DEDT4 = 0x100000;     // Driver Enable de-assertion time
    static constexpr uint32_t CR1_DEDT3 = 0x80000;      // DEDT3
    static constexpr uint32_t CR1_DEDT2 = 0x40000;      // DEDT2
    static constexpr uint32_t CR1_DEDT1 = 0x20000;      // DEDT1
    static constexpr uint32_t CR1_DEDT0 = 0x10000;      // DEDT0
    static constexpr uint32_t CR1_OVER8 = 0x8000;       // Oversampling mode
    static constexpr uint32_t CR1_CMIE = 0x4000;        // Character match interrupt enable
    static constexpr uint32_t CR1_MME = 0x2000;         // Mute mode enable
    static constexpr uint32_t CR1_M0 = 0x1000;          // Word length
    static constexpr uint32_t CR1_WAKE = 0x800;         // Receiver wakeup method
    static constexpr uint32_t CR1_PCE = 0x400;          // Parity control enable
    static constexpr uint32_t CR1_PS = 0x200;           // Parity selection
    static constexpr uint32_t CR1_PEIE = 0x100;         // PE interrupt enable
    static constexpr uint32_t CR1_TXEIE = 0x80;         // interrupt enable
    static constexpr uint32_t CR1_TCIE = 0x40;          // Transmission complete interrupt enable
    static constexpr uint32_t CR1_RXNEIE = 0x20;        // RXNE interrupt enable
    static constexpr uint32_t CR1_IDLEIE = 0x10;        // IDLE interrupt enable
    static constexpr uint32_t CR1_TE = 0x8;             // Transmitter enable
    static constexpr uint32_t CR1_RE = 0x4;             // Receiver enable
    static constexpr uint32_t CR1_UESM = 0x2;           // USART enable in Stop mode
    static constexpr uint32_t CR1_UE = 0x1;             // USART enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CR2_ADD4_7 =              // Address of the USART node (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR2_ADD0_3 =              // Address of the USART node (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    static constexpr uint32_t CR2_RTOEN = 0x800000;     // Receiver timeout enable
    static constexpr uint32_t CR2_ABRMOD1 = 0x400000;   // Auto baud rate mode
    static constexpr uint32_t CR2_ABRMOD0 = 0x200000;   // ABRMOD0
    static constexpr uint32_t CR2_ABREN = 0x100000;     // Auto baud rate enable
    static constexpr uint32_t CR2_MSBFIRST = 0x80000;   // Most significant bit first
    static constexpr uint32_t CR2_TAINV = 0x40000;      // Binary data inversion
    static constexpr uint32_t CR2_TXINV = 0x20000;      // TX pin active level inversion
    static constexpr uint32_t CR2_RXINV = 0x10000;      // RX pin active level inversion
    static constexpr uint32_t CR2_SWAP = 0x8000;        // Swap TX/RX pins
    static constexpr uint32_t CR2_LINEN = 0x4000;       // LIN mode enable
    template<uint32_t X>
    static constexpr uint32_t CR2_STOP =                // STOP bits (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    static constexpr uint32_t CR2_CLKEN = 0x800;        // Clock enable
    static constexpr uint32_t CR2_CPOL = 0x400;         // Clock polarity
    static constexpr uint32_t CR2_CPHA = 0x200;         // Clock phase
    static constexpr uint32_t CR2_LBCL = 0x100;         // Last bit clock pulse
    static constexpr uint32_t CR2_LBDIE = 0x40;         // LIN break detection interrupt enable
    static constexpr uint32_t CR2_LBDL = 0x20;          // LIN break detection length
    static constexpr uint32_t CR2_ADDM7 = 0x10;         // 7-bit Address Detection/4-bit Address Detection
    static constexpr uint32_t CR2_DIS_NSS = 0x8;        // When the DSI_NSS bit is set, the NSS pin input is ignored
    static constexpr uint32_t CR2_SLVEN = 0x1;          // Synchronous Slave mode enable
    static const uint32_t CR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CR3_TXFTCFG =             // TXFIFO threshold configuration (3 bits)
        bit_field_t<29, 0x7>::value<X>();
    static constexpr uint32_t CR3_RXFTIE = 0x10000000;  // RXFIFO threshold interrupt enable
    template<uint32_t X>
    static constexpr uint32_t CR3_RXFTCFG =             // Receive FIFO threshold configuration (3 bits)
        bit_field_t<25, 0x7>::value<X>();
    static constexpr uint32_t CR3_TCBGTIE = 0x1000000;  // Transmission Complete before guard time, interrupt enable
    static constexpr uint32_t CR3_TXFTIE = 0x800000;    // TXFIFO threshold interrupt enable
    static constexpr uint32_t CR3_WUFIE = 0x400000;     // Wakeup from Stop mode interrupt enable
    template<uint32_t X>
    static constexpr uint32_t CR3_WUS =                 // Wakeup from Stop mode interrupt flag selection (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR3_SCARCNT =             // Smartcard auto-retry count (3 bits)
        bit_field_t<17, 0x7>::value<X>();
    static constexpr uint32_t CR3_DEP = 0x8000;         // Driver enable polarity selection
    static constexpr uint32_t CR3_DEM = 0x4000;         // Driver enable mode
    static constexpr uint32_t CR3_DDRE = 0x2000;        // DMA Disable on Reception Error
    static constexpr uint32_t CR3_OVRDIS = 0x1000;      // Overrun Disable
    static constexpr uint32_t CR3_ONEBIT = 0x800;       // One sample bit method enable
    static constexpr uint32_t CR3_CTSIE = 0x400;        // CTS interrupt enable
    static constexpr uint32_t CR3_CTSE = 0x200;         // CTS enable
    static constexpr uint32_t CR3_RTSE = 0x100;         // RTS enable
    static constexpr uint32_t CR3_DMAT = 0x80;          // DMA enable transmitter
    static constexpr uint32_t CR3_DMAR = 0x40;          // DMA enable receiver
    static constexpr uint32_t CR3_SCEN = 0x20;          // Smartcard mode enable
    static constexpr uint32_t CR3_NACK = 0x10;          // Smartcard NACK enable
    static constexpr uint32_t CR3_HDSEL = 0x8;          // Half-duplex selection
    static constexpr uint32_t CR3_IRLP = 0x4;           // Ir low-power
    static constexpr uint32_t CR3_IREN = 0x2;           // Ir mode enable
    static constexpr uint32_t CR3_EIE = 0x1;            // Error interrupt enable
    static const uint32_t CR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BRR_BRR_4_15 =            // DIV_Mantissa (12 bits)
        bit_field_t<4, 0xfff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BRR_BRR_0_3 =             // DIV_Fraction (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t BRR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t GTPR_GT =                  // Guard time value (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GTPR_PSC =                 // Prescaler value (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t GTPR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RTOR_BLEN =                // Block Length (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RTOR_RTO =                 // Receiver timeout value (24 bits)
        bit_field_t<0, 0xffffff>::value<X>();
    static const uint32_t RTOR_RESET_VALUE = 0x0;

    static constexpr uint32_t RQR_TXFRQ = 0x10;         // Transmit data flush request
    static constexpr uint32_t RQR_RXFRQ = 0x8;          // Receive data flush request
    static constexpr uint32_t RQR_MMRQ = 0x4;           // Mute mode request
    static constexpr uint32_t RQR_SBKRQ = 0x2;          // Send break request
    static constexpr uint32_t RQR_ABRRQ = 0x1;          // Auto baud rate request
    static const uint32_t RQR_RESET_VALUE = 0x0;

    static constexpr uint32_t ISR_TXFT = 0x8000000;     // TXFIFO threshold flag
    static constexpr uint32_t ISR_RXFT = 0x4000000;     // RXFIFO threshold flag
    static constexpr uint32_t ISR_TCBGT = 0x2000000;    // Transmission complete before guard time flag
    static constexpr uint32_t ISR_RXFF = 0x1000000;     // RXFIFO Full
    static constexpr uint32_t ISR_TXFE = 0x800000;      // TXFIFO Empty
    static constexpr uint32_t ISR_REACK = 0x400000;     // REACK
    static constexpr uint32_t ISR_TEACK = 0x200000;     // TEACK
    static constexpr uint32_t ISR_WUF = 0x100000;       // WUF
    static constexpr uint32_t ISR_RWU = 0x80000;        // RWU
    static constexpr uint32_t ISR_SBKF = 0x40000;       // SBKF
    static constexpr uint32_t ISR_CMF = 0x20000;        // CMF
    static constexpr uint32_t ISR_BUSY = 0x10000;       // BUSY
    static constexpr uint32_t ISR_ABRF = 0x8000;        // ABRF
    static constexpr uint32_t ISR_ABRE = 0x4000;        // ABRE
    static constexpr uint32_t ISR_UDR = 0x2000;         // SPI slave underrun error flag
    static constexpr uint32_t ISR_EOBF = 0x1000;        // EOBF
    static constexpr uint32_t ISR_RTOF = 0x800;         // RTOF
    static constexpr uint32_t ISR_CTS = 0x400;          // CTS
    static constexpr uint32_t ISR_CTSIF = 0x200;        // CTSIF
    static constexpr uint32_t ISR_LBDF = 0x100;         // LBDF
    static constexpr uint32_t ISR_TXE = 0x80;           // TXE
    static constexpr uint32_t ISR_TC = 0x40;            // TC
    static constexpr uint32_t ISR_RXNE = 0x20;          // RXNE
    static constexpr uint32_t ISR_IDLE = 0x10;          // IDLE
    static constexpr uint32_t ISR_ORE = 0x8;            // ORE
    static constexpr uint32_t ISR_NF = 0x4;             // NF
    static constexpr uint32_t ISR_FE = 0x2;             // FE
    static constexpr uint32_t ISR_PE = 0x1;             // PE
    static const uint32_t ISR_RESET_VALUE = 0xc0;

    static constexpr uint32_t ICR_WUCF = 0x100000;      // Wakeup from Stop mode clear flag
    static constexpr uint32_t ICR_CMCF = 0x20000;       // Character match clear flag
    static constexpr uint32_t ICR_UDRCF = 0x2000;       // SPI slave underrun clear flag
    static constexpr uint32_t ICR_EOBCF = 0x1000;       // End of block clear flag
    static constexpr uint32_t ICR_RTOCF = 0x800;        // Receiver timeout clear flag
    static constexpr uint32_t ICR_CTSCF = 0x200;        // CTS clear flag
    static constexpr uint32_t ICR_LBDCF = 0x100;        // LIN break detection clear flag
    static constexpr uint32_t ICR_TCBGTC = 0x80;        // Transmission complete before Guard time clear flag
    static constexpr uint32_t ICR_TCCF = 0x40;          // Transmission complete clear flag
    static constexpr uint32_t ICR_TXFECF = 0x20;        // TXFIFO empty clear flag
    static constexpr uint32_t ICR_IDLECF = 0x10;        // Idle line detected clear flag
    static constexpr uint32_t ICR_ORECF = 0x8;          // Overrun error clear flag
    static constexpr uint32_t ICR_NCF = 0x4;            // Noise detected clear flag
    static constexpr uint32_t ICR_FECF = 0x2;           // Framing error clear flag
    static constexpr uint32_t ICR_PECF = 0x1;           // Parity error clear flag
    static const uint32_t ICR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RDR_RDR =                 // Receive data value (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static const uint32_t RDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDR_TDR =                 // Transmit data value (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static const uint32_t TDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PRESC_PRESCALER =           // Clock prescaler (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t PRESC_RESET_VALUE = 0x0;
};

static usart1_t& USART1 = *reinterpret_cast<usart1_t*>(0x40011000);

#define HAVE_PERIPHERAL_USART1


////
//
//    Universal synchronous asynchronous receiver transmitter
//
////

struct usart2_t
{
    volatile uint32_t    CR1;                  // [Read-write] Control register 1
    volatile uint32_t    CR2;                  // [Read-write] Control register 2
    volatile uint32_t    CR3;                  // [Read-write] Control register 3
    volatile uint32_t    BRR;                  // [Read-write] Baud rate register
    volatile uint32_t    GTPR;                 // [Read-write] Guard time and prescaler register
    volatile uint32_t    RTOR;                 // [Read-write] Receiver timeout register
    volatile uint32_t    RQR;                  // [Write-only] Request register
    volatile uint32_t    ISR;                  // [Read-only] Interrupt &amp; status register
    volatile uint32_t    ICR;                  // [Write-only] Interrupt flag clear register
    volatile uint32_t    RDR;                  // [Read-only] Receive data register
    volatile uint32_t    TDR;                  // [Read-write] Transmit data register
    volatile uint32_t    PRESC;                // [Read-write] USART prescaler register

    static constexpr uint32_t CR1_RXFFIE = 0x80000000;  // RXFIFO Full interrupt enable
    static constexpr uint32_t CR1_TXFEIE = 0x40000000;  // TXFIFO empty interrupt enable
    static constexpr uint32_t CR1_FIFOEN = 0x20000000;  // FIFO mode enable
    static constexpr uint32_t CR1_M1 = 0x10000000;      // Word length
    static constexpr uint32_t CR1_EOBIE = 0x8000000;    // End of Block interrupt enable
    static constexpr uint32_t CR1_RTOIE = 0x4000000;    // Receiver timeout interrupt enable
    static constexpr uint32_t CR1_DEAT4 = 0x2000000;    // Driver Enable assertion time
    static constexpr uint32_t CR1_DEAT3 = 0x1000000;    // DEAT3
    static constexpr uint32_t CR1_DEAT2 = 0x800000;     // DEAT2
    static constexpr uint32_t CR1_DEAT1 = 0x400000;     // DEAT1
    static constexpr uint32_t CR1_DEAT0 = 0x200000;     // DEAT0
    static constexpr uint32_t CR1_DEDT4 = 0x100000;     // Driver Enable de-assertion time
    static constexpr uint32_t CR1_DEDT3 = 0x80000;      // DEDT3
    static constexpr uint32_t CR1_DEDT2 = 0x40000;      // DEDT2
    static constexpr uint32_t CR1_DEDT1 = 0x20000;      // DEDT1
    static constexpr uint32_t CR1_DEDT0 = 0x10000;      // DEDT0
    static constexpr uint32_t CR1_OVER8 = 0x8000;       // Oversampling mode
    static constexpr uint32_t CR1_CMIE = 0x4000;        // Character match interrupt enable
    static constexpr uint32_t CR1_MME = 0x2000;         // Mute mode enable
    static constexpr uint32_t CR1_M0 = 0x1000;          // Word length
    static constexpr uint32_t CR1_WAKE = 0x800;         // Receiver wakeup method
    static constexpr uint32_t CR1_PCE = 0x400;          // Parity control enable
    static constexpr uint32_t CR1_PS = 0x200;           // Parity selection
    static constexpr uint32_t CR1_PEIE = 0x100;         // PE interrupt enable
    static constexpr uint32_t CR1_TXEIE = 0x80;         // interrupt enable
    static constexpr uint32_t CR1_TCIE = 0x40;          // Transmission complete interrupt enable
    static constexpr uint32_t CR1_RXNEIE = 0x20;        // RXNE interrupt enable
    static constexpr uint32_t CR1_IDLEIE = 0x10;        // IDLE interrupt enable
    static constexpr uint32_t CR1_TE = 0x8;             // Transmitter enable
    static constexpr uint32_t CR1_RE = 0x4;             // Receiver enable
    static constexpr uint32_t CR1_UESM = 0x2;           // USART enable in Stop mode
    static constexpr uint32_t CR1_UE = 0x1;             // USART enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CR2_ADD4_7 =              // Address of the USART node (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR2_ADD0_3 =              // Address of the USART node (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    static constexpr uint32_t CR2_RTOEN = 0x800000;     // Receiver timeout enable
    static constexpr uint32_t CR2_ABRMOD1 = 0x400000;   // Auto baud rate mode
    static constexpr uint32_t CR2_ABRMOD0 = 0x200000;   // ABRMOD0
    static constexpr uint32_t CR2_ABREN = 0x100000;     // Auto baud rate enable
    static constexpr uint32_t CR2_MSBFIRST = 0x80000;   // Most significant bit first
    static constexpr uint32_t CR2_TAINV = 0x40000;      // Binary data inversion
    static constexpr uint32_t CR2_TXINV = 0x20000;      // TX pin active level inversion
    static constexpr uint32_t CR2_RXINV = 0x10000;      // RX pin active level inversion
    static constexpr uint32_t CR2_SWAP = 0x8000;        // Swap TX/RX pins
    static constexpr uint32_t CR2_LINEN = 0x4000;       // LIN mode enable
    template<uint32_t X>
    static constexpr uint32_t CR2_STOP =                // STOP bits (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    static constexpr uint32_t CR2_CLKEN = 0x800;        // Clock enable
    static constexpr uint32_t CR2_CPOL = 0x400;         // Clock polarity
    static constexpr uint32_t CR2_CPHA = 0x200;         // Clock phase
    static constexpr uint32_t CR2_LBCL = 0x100;         // Last bit clock pulse
    static constexpr uint32_t CR2_LBDIE = 0x40;         // LIN break detection interrupt enable
    static constexpr uint32_t CR2_LBDL = 0x20;          // LIN break detection length
    static constexpr uint32_t CR2_ADDM7 = 0x10;         // 7-bit Address Detection/4-bit Address Detection
    static constexpr uint32_t CR2_DIS_NSS = 0x8;        // When the DSI_NSS bit is set, the NSS pin input is ignored
    static constexpr uint32_t CR2_SLVEN = 0x1;          // Synchronous Slave mode enable
    static const uint32_t CR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CR3_TXFTCFG =             // TXFIFO threshold configuration (3 bits)
        bit_field_t<29, 0x7>::value<X>();
    static constexpr uint32_t CR3_RXFTIE = 0x10000000;  // RXFIFO threshold interrupt enable
    template<uint32_t X>
    static constexpr uint32_t CR3_RXFTCFG =             // Receive FIFO threshold configuration (3 bits)
        bit_field_t<25, 0x7>::value<X>();
    static constexpr uint32_t CR3_TCBGTIE = 0x1000000;  // Transmission Complete before guard time, interrupt enable
    static constexpr uint32_t CR3_TXFTIE = 0x800000;    // TXFIFO threshold interrupt enable
    static constexpr uint32_t CR3_WUFIE = 0x400000;     // Wakeup from Stop mode interrupt enable
    template<uint32_t X>
    static constexpr uint32_t CR3_WUS =                 // Wakeup from Stop mode interrupt flag selection (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR3_SCARCNT =             // Smartcard auto-retry count (3 bits)
        bit_field_t<17, 0x7>::value<X>();
    static constexpr uint32_t CR3_DEP = 0x8000;         // Driver enable polarity selection
    static constexpr uint32_t CR3_DEM = 0x4000;         // Driver enable mode
    static constexpr uint32_t CR3_DDRE = 0x2000;        // DMA Disable on Reception Error
    static constexpr uint32_t CR3_OVRDIS = 0x1000;      // Overrun Disable
    static constexpr uint32_t CR3_ONEBIT = 0x800;       // One sample bit method enable
    static constexpr uint32_t CR3_CTSIE = 0x400;        // CTS interrupt enable
    static constexpr uint32_t CR3_CTSE = 0x200;         // CTS enable
    static constexpr uint32_t CR3_RTSE = 0x100;         // RTS enable
    static constexpr uint32_t CR3_DMAT = 0x80;          // DMA enable transmitter
    static constexpr uint32_t CR3_DMAR = 0x40;          // DMA enable receiver
    static constexpr uint32_t CR3_SCEN = 0x20;          // Smartcard mode enable
    static constexpr uint32_t CR3_NACK = 0x10;          // Smartcard NACK enable
    static constexpr uint32_t CR3_HDSEL = 0x8;          // Half-duplex selection
    static constexpr uint32_t CR3_IRLP = 0x4;           // Ir low-power
    static constexpr uint32_t CR3_IREN = 0x2;           // Ir mode enable
    static constexpr uint32_t CR3_EIE = 0x1;            // Error interrupt enable
    static const uint32_t CR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BRR_BRR_4_15 =            // DIV_Mantissa (12 bits)
        bit_field_t<4, 0xfff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BRR_BRR_0_3 =             // DIV_Fraction (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t BRR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t GTPR_GT =                  // Guard time value (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GTPR_PSC =                 // Prescaler value (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t GTPR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RTOR_BLEN =                // Block Length (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RTOR_RTO =                 // Receiver timeout value (24 bits)
        bit_field_t<0, 0xffffff>::value<X>();
    static const uint32_t RTOR_RESET_VALUE = 0x0;

    static constexpr uint32_t RQR_TXFRQ = 0x10;         // Transmit data flush request
    static constexpr uint32_t RQR_RXFRQ = 0x8;          // Receive data flush request
    static constexpr uint32_t RQR_MMRQ = 0x4;           // Mute mode request
    static constexpr uint32_t RQR_SBKRQ = 0x2;          // Send break request
    static constexpr uint32_t RQR_ABRRQ = 0x1;          // Auto baud rate request
    static const uint32_t RQR_RESET_VALUE = 0x0;

    static constexpr uint32_t ISR_TXFT = 0x8000000;     // TXFIFO threshold flag
    static constexpr uint32_t ISR_RXFT = 0x4000000;     // RXFIFO threshold flag
    static constexpr uint32_t ISR_TCBGT = 0x2000000;    // Transmission complete before guard time flag
    static constexpr uint32_t ISR_RXFF = 0x1000000;     // RXFIFO Full
    static constexpr uint32_t ISR_TXFE = 0x800000;      // TXFIFO Empty
    static constexpr uint32_t ISR_REACK = 0x400000;     // REACK
    static constexpr uint32_t ISR_TEACK = 0x200000;     // TEACK
    static constexpr uint32_t ISR_WUF = 0x100000;       // WUF
    static constexpr uint32_t ISR_RWU = 0x80000;        // RWU
    static constexpr uint32_t ISR_SBKF = 0x40000;       // SBKF
    static constexpr uint32_t ISR_CMF = 0x20000;        // CMF
    static constexpr uint32_t ISR_BUSY = 0x10000;       // BUSY
    static constexpr uint32_t ISR_ABRF = 0x8000;        // ABRF
    static constexpr uint32_t ISR_ABRE = 0x4000;        // ABRE
    static constexpr uint32_t ISR_UDR = 0x2000;         // SPI slave underrun error flag
    static constexpr uint32_t ISR_EOBF = 0x1000;        // EOBF
    static constexpr uint32_t ISR_RTOF = 0x800;         // RTOF
    static constexpr uint32_t ISR_CTS = 0x400;          // CTS
    static constexpr uint32_t ISR_CTSIF = 0x200;        // CTSIF
    static constexpr uint32_t ISR_LBDF = 0x100;         // LBDF
    static constexpr uint32_t ISR_TXE = 0x80;           // TXE
    static constexpr uint32_t ISR_TC = 0x40;            // TC
    static constexpr uint32_t ISR_RXNE = 0x20;          // RXNE
    static constexpr uint32_t ISR_IDLE = 0x10;          // IDLE
    static constexpr uint32_t ISR_ORE = 0x8;            // ORE
    static constexpr uint32_t ISR_NF = 0x4;             // NF
    static constexpr uint32_t ISR_FE = 0x2;             // FE
    static constexpr uint32_t ISR_PE = 0x1;             // PE
    static const uint32_t ISR_RESET_VALUE = 0xc0;

    static constexpr uint32_t ICR_WUCF = 0x100000;      // Wakeup from Stop mode clear flag
    static constexpr uint32_t ICR_CMCF = 0x20000;       // Character match clear flag
    static constexpr uint32_t ICR_UDRCF = 0x2000;       // SPI slave underrun clear flag
    static constexpr uint32_t ICR_EOBCF = 0x1000;       // End of block clear flag
    static constexpr uint32_t ICR_RTOCF = 0x800;        // Receiver timeout clear flag
    static constexpr uint32_t ICR_CTSCF = 0x200;        // CTS clear flag
    static constexpr uint32_t ICR_LBDCF = 0x100;        // LIN break detection clear flag
    static constexpr uint32_t ICR_TCBGTC = 0x80;        // Transmission complete before Guard time clear flag
    static constexpr uint32_t ICR_TCCF = 0x40;          // Transmission complete clear flag
    static constexpr uint32_t ICR_TXFECF = 0x20;        // TXFIFO empty clear flag
    static constexpr uint32_t ICR_IDLECF = 0x10;        // Idle line detected clear flag
    static constexpr uint32_t ICR_ORECF = 0x8;          // Overrun error clear flag
    static constexpr uint32_t ICR_NCF = 0x4;            // Noise detected clear flag
    static constexpr uint32_t ICR_FECF = 0x2;           // Framing error clear flag
    static constexpr uint32_t ICR_PECF = 0x1;           // Parity error clear flag
    static const uint32_t ICR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RDR_RDR =                 // Receive data value (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static const uint32_t RDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDR_TDR =                 // Transmit data value (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static const uint32_t TDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PRESC_PRESCALER =           // Clock prescaler (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t PRESC_RESET_VALUE = 0x0;

    static constexpr uint8_t USART1 = 37; // USART1 global interrupt
};

static usart2_t& USART2 = *reinterpret_cast<usart2_t*>(0x40004400);

#define HAVE_PERIPHERAL_USART2


////
//
//    Universal synchronous asynchronous receiver transmitter
//
////

struct usart3_t
{
    volatile uint32_t    CR1;                  // [Read-write] Control register 1
    volatile uint32_t    CR2;                  // [Read-write] Control register 2
    volatile uint32_t    CR3;                  // [Read-write] Control register 3
    volatile uint32_t    BRR;                  // [Read-write] Baud rate register
    volatile uint32_t    GTPR;                 // [Read-write] Guard time and prescaler register
    volatile uint32_t    RTOR;                 // [Read-write] Receiver timeout register
    volatile uint32_t    RQR;                  // [Write-only] Request register
    volatile uint32_t    ISR;                  // [Read-only] Interrupt &amp; status register
    volatile uint32_t    ICR;                  // [Write-only] Interrupt flag clear register
    volatile uint32_t    RDR;                  // [Read-only] Receive data register
    volatile uint32_t    TDR;                  // [Read-write] Transmit data register
    volatile uint32_t    PRESC;                // [Read-write] USART prescaler register

    static constexpr uint32_t CR1_RXFFIE = 0x80000000;  // RXFIFO Full interrupt enable
    static constexpr uint32_t CR1_TXFEIE = 0x40000000;  // TXFIFO empty interrupt enable
    static constexpr uint32_t CR1_FIFOEN = 0x20000000;  // FIFO mode enable
    static constexpr uint32_t CR1_M1 = 0x10000000;      // Word length
    static constexpr uint32_t CR1_EOBIE = 0x8000000;    // End of Block interrupt enable
    static constexpr uint32_t CR1_RTOIE = 0x4000000;    // Receiver timeout interrupt enable
    static constexpr uint32_t CR1_DEAT4 = 0x2000000;    // Driver Enable assertion time
    static constexpr uint32_t CR1_DEAT3 = 0x1000000;    // DEAT3
    static constexpr uint32_t CR1_DEAT2 = 0x800000;     // DEAT2
    static constexpr uint32_t CR1_DEAT1 = 0x400000;     // DEAT1
    static constexpr uint32_t CR1_DEAT0 = 0x200000;     // DEAT0
    static constexpr uint32_t CR1_DEDT4 = 0x100000;     // Driver Enable de-assertion time
    static constexpr uint32_t CR1_DEDT3 = 0x80000;      // DEDT3
    static constexpr uint32_t CR1_DEDT2 = 0x40000;      // DEDT2
    static constexpr uint32_t CR1_DEDT1 = 0x20000;      // DEDT1
    static constexpr uint32_t CR1_DEDT0 = 0x10000;      // DEDT0
    static constexpr uint32_t CR1_OVER8 = 0x8000;       // Oversampling mode
    static constexpr uint32_t CR1_CMIE = 0x4000;        // Character match interrupt enable
    static constexpr uint32_t CR1_MME = 0x2000;         // Mute mode enable
    static constexpr uint32_t CR1_M0 = 0x1000;          // Word length
    static constexpr uint32_t CR1_WAKE = 0x800;         // Receiver wakeup method
    static constexpr uint32_t CR1_PCE = 0x400;          // Parity control enable
    static constexpr uint32_t CR1_PS = 0x200;           // Parity selection
    static constexpr uint32_t CR1_PEIE = 0x100;         // PE interrupt enable
    static constexpr uint32_t CR1_TXEIE = 0x80;         // interrupt enable
    static constexpr uint32_t CR1_TCIE = 0x40;          // Transmission complete interrupt enable
    static constexpr uint32_t CR1_RXNEIE = 0x20;        // RXNE interrupt enable
    static constexpr uint32_t CR1_IDLEIE = 0x10;        // IDLE interrupt enable
    static constexpr uint32_t CR1_TE = 0x8;             // Transmitter enable
    static constexpr uint32_t CR1_RE = 0x4;             // Receiver enable
    static constexpr uint32_t CR1_UESM = 0x2;           // USART enable in Stop mode
    static constexpr uint32_t CR1_UE = 0x1;             // USART enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CR2_ADD4_7 =              // Address of the USART node (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR2_ADD0_3 =              // Address of the USART node (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    static constexpr uint32_t CR2_RTOEN = 0x800000;     // Receiver timeout enable
    static constexpr uint32_t CR2_ABRMOD1 = 0x400000;   // Auto baud rate mode
    static constexpr uint32_t CR2_ABRMOD0 = 0x200000;   // ABRMOD0
    static constexpr uint32_t CR2_ABREN = 0x100000;     // Auto baud rate enable
    static constexpr uint32_t CR2_MSBFIRST = 0x80000;   // Most significant bit first
    static constexpr uint32_t CR2_TAINV = 0x40000;      // Binary data inversion
    static constexpr uint32_t CR2_TXINV = 0x20000;      // TX pin active level inversion
    static constexpr uint32_t CR2_RXINV = 0x10000;      // RX pin active level inversion
    static constexpr uint32_t CR2_SWAP = 0x8000;        // Swap TX/RX pins
    static constexpr uint32_t CR2_LINEN = 0x4000;       // LIN mode enable
    template<uint32_t X>
    static constexpr uint32_t CR2_STOP =                // STOP bits (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    static constexpr uint32_t CR2_CLKEN = 0x800;        // Clock enable
    static constexpr uint32_t CR2_CPOL = 0x400;         // Clock polarity
    static constexpr uint32_t CR2_CPHA = 0x200;         // Clock phase
    static constexpr uint32_t CR2_LBCL = 0x100;         // Last bit clock pulse
    static constexpr uint32_t CR2_LBDIE = 0x40;         // LIN break detection interrupt enable
    static constexpr uint32_t CR2_LBDL = 0x20;          // LIN break detection length
    static constexpr uint32_t CR2_ADDM7 = 0x10;         // 7-bit Address Detection/4-bit Address Detection
    static constexpr uint32_t CR2_DIS_NSS = 0x8;        // When the DSI_NSS bit is set, the NSS pin input is ignored
    static constexpr uint32_t CR2_SLVEN = 0x1;          // Synchronous Slave mode enable
    static const uint32_t CR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CR3_TXFTCFG =             // TXFIFO threshold configuration (3 bits)
        bit_field_t<29, 0x7>::value<X>();
    static constexpr uint32_t CR3_RXFTIE = 0x10000000;  // RXFIFO threshold interrupt enable
    template<uint32_t X>
    static constexpr uint32_t CR3_RXFTCFG =             // Receive FIFO threshold configuration (3 bits)
        bit_field_t<25, 0x7>::value<X>();
    static constexpr uint32_t CR3_TCBGTIE = 0x1000000;  // Transmission Complete before guard time, interrupt enable
    static constexpr uint32_t CR3_TXFTIE = 0x800000;    // TXFIFO threshold interrupt enable
    static constexpr uint32_t CR3_WUFIE = 0x400000;     // Wakeup from Stop mode interrupt enable
    template<uint32_t X>
    static constexpr uint32_t CR3_WUS =                 // Wakeup from Stop mode interrupt flag selection (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR3_SCARCNT =             // Smartcard auto-retry count (3 bits)
        bit_field_t<17, 0x7>::value<X>();
    static constexpr uint32_t CR3_DEP = 0x8000;         // Driver enable polarity selection
    static constexpr uint32_t CR3_DEM = 0x4000;         // Driver enable mode
    static constexpr uint32_t CR3_DDRE = 0x2000;        // DMA Disable on Reception Error
    static constexpr uint32_t CR3_OVRDIS = 0x1000;      // Overrun Disable
    static constexpr uint32_t CR3_ONEBIT = 0x800;       // One sample bit method enable
    static constexpr uint32_t CR3_CTSIE = 0x400;        // CTS interrupt enable
    static constexpr uint32_t CR3_CTSE = 0x200;         // CTS enable
    static constexpr uint32_t CR3_RTSE = 0x100;         // RTS enable
    static constexpr uint32_t CR3_DMAT = 0x80;          // DMA enable transmitter
    static constexpr uint32_t CR3_DMAR = 0x40;          // DMA enable receiver
    static constexpr uint32_t CR3_SCEN = 0x20;          // Smartcard mode enable
    static constexpr uint32_t CR3_NACK = 0x10;          // Smartcard NACK enable
    static constexpr uint32_t CR3_HDSEL = 0x8;          // Half-duplex selection
    static constexpr uint32_t CR3_IRLP = 0x4;           // Ir low-power
    static constexpr uint32_t CR3_IREN = 0x2;           // Ir mode enable
    static constexpr uint32_t CR3_EIE = 0x1;            // Error interrupt enable
    static const uint32_t CR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BRR_BRR_4_15 =            // DIV_Mantissa (12 bits)
        bit_field_t<4, 0xfff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BRR_BRR_0_3 =             // DIV_Fraction (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t BRR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t GTPR_GT =                  // Guard time value (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GTPR_PSC =                 // Prescaler value (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t GTPR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RTOR_BLEN =                // Block Length (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RTOR_RTO =                 // Receiver timeout value (24 bits)
        bit_field_t<0, 0xffffff>::value<X>();
    static const uint32_t RTOR_RESET_VALUE = 0x0;

    static constexpr uint32_t RQR_TXFRQ = 0x10;         // Transmit data flush request
    static constexpr uint32_t RQR_RXFRQ = 0x8;          // Receive data flush request
    static constexpr uint32_t RQR_MMRQ = 0x4;           // Mute mode request
    static constexpr uint32_t RQR_SBKRQ = 0x2;          // Send break request
    static constexpr uint32_t RQR_ABRRQ = 0x1;          // Auto baud rate request
    static const uint32_t RQR_RESET_VALUE = 0x0;

    static constexpr uint32_t ISR_TXFT = 0x8000000;     // TXFIFO threshold flag
    static constexpr uint32_t ISR_RXFT = 0x4000000;     // RXFIFO threshold flag
    static constexpr uint32_t ISR_TCBGT = 0x2000000;    // Transmission complete before guard time flag
    static constexpr uint32_t ISR_RXFF = 0x1000000;     // RXFIFO Full
    static constexpr uint32_t ISR_TXFE = 0x800000;      // TXFIFO Empty
    static constexpr uint32_t ISR_REACK = 0x400000;     // REACK
    static constexpr uint32_t ISR_TEACK = 0x200000;     // TEACK
    static constexpr uint32_t ISR_WUF = 0x100000;       // WUF
    static constexpr uint32_t ISR_RWU = 0x80000;        // RWU
    static constexpr uint32_t ISR_SBKF = 0x40000;       // SBKF
    static constexpr uint32_t ISR_CMF = 0x20000;        // CMF
    static constexpr uint32_t ISR_BUSY = 0x10000;       // BUSY
    static constexpr uint32_t ISR_ABRF = 0x8000;        // ABRF
    static constexpr uint32_t ISR_ABRE = 0x4000;        // ABRE
    static constexpr uint32_t ISR_UDR = 0x2000;         // SPI slave underrun error flag
    static constexpr uint32_t ISR_EOBF = 0x1000;        // EOBF
    static constexpr uint32_t ISR_RTOF = 0x800;         // RTOF
    static constexpr uint32_t ISR_CTS = 0x400;          // CTS
    static constexpr uint32_t ISR_CTSIF = 0x200;        // CTSIF
    static constexpr uint32_t ISR_LBDF = 0x100;         // LBDF
    static constexpr uint32_t ISR_TXE = 0x80;           // TXE
    static constexpr uint32_t ISR_TC = 0x40;            // TC
    static constexpr uint32_t ISR_RXNE = 0x20;          // RXNE
    static constexpr uint32_t ISR_IDLE = 0x10;          // IDLE
    static constexpr uint32_t ISR_ORE = 0x8;            // ORE
    static constexpr uint32_t ISR_NF = 0x4;             // NF
    static constexpr uint32_t ISR_FE = 0x2;             // FE
    static constexpr uint32_t ISR_PE = 0x1;             // PE
    static const uint32_t ISR_RESET_VALUE = 0xc0;

    static constexpr uint32_t ICR_WUCF = 0x100000;      // Wakeup from Stop mode clear flag
    static constexpr uint32_t ICR_CMCF = 0x20000;       // Character match clear flag
    static constexpr uint32_t ICR_UDRCF = 0x2000;       // SPI slave underrun clear flag
    static constexpr uint32_t ICR_EOBCF = 0x1000;       // End of block clear flag
    static constexpr uint32_t ICR_RTOCF = 0x800;        // Receiver timeout clear flag
    static constexpr uint32_t ICR_CTSCF = 0x200;        // CTS clear flag
    static constexpr uint32_t ICR_LBDCF = 0x100;        // LIN break detection clear flag
    static constexpr uint32_t ICR_TCBGTC = 0x80;        // Transmission complete before Guard time clear flag
    static constexpr uint32_t ICR_TCCF = 0x40;          // Transmission complete clear flag
    static constexpr uint32_t ICR_TXFECF = 0x20;        // TXFIFO empty clear flag
    static constexpr uint32_t ICR_IDLECF = 0x10;        // Idle line detected clear flag
    static constexpr uint32_t ICR_ORECF = 0x8;          // Overrun error clear flag
    static constexpr uint32_t ICR_NCF = 0x4;            // Noise detected clear flag
    static constexpr uint32_t ICR_FECF = 0x2;           // Framing error clear flag
    static constexpr uint32_t ICR_PECF = 0x1;           // Parity error clear flag
    static const uint32_t ICR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RDR_RDR =                 // Receive data value (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static const uint32_t RDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDR_TDR =                 // Transmit data value (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static const uint32_t TDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PRESC_PRESCALER =           // Clock prescaler (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t PRESC_RESET_VALUE = 0x0;

    static constexpr uint8_t USART2 = 38; // USART2 global interrupt
};

static usart3_t& USART3 = *reinterpret_cast<usart3_t*>(0x40004800);

#define HAVE_PERIPHERAL_USART3


////
//
//    Universal synchronous asynchronous receiver transmitter
//
////

struct uart4_t
{
    volatile uint32_t    CR1;                  // [Read-write] Control register 1
    volatile uint32_t    CR2;                  // [Read-write] Control register 2
    volatile uint32_t    CR3;                  // [Read-write] Control register 3
    volatile uint32_t    BRR;                  // [Read-write] Baud rate register
    volatile uint32_t    GTPR;                 // [Read-write] Guard time and prescaler register
    volatile uint32_t    RTOR;                 // [Read-write] Receiver timeout register
    volatile uint32_t    RQR;                  // [Write-only] Request register
    volatile uint32_t    ISR;                  // [Read-only] Interrupt &amp; status register
    volatile uint32_t    ICR;                  // [Write-only] Interrupt flag clear register
    volatile uint32_t    RDR;                  // [Read-only] Receive data register
    volatile uint32_t    TDR;                  // [Read-write] Transmit data register
    volatile uint32_t    PRESC;                // [Read-write] USART prescaler register

    static constexpr uint32_t CR1_RXFFIE = 0x80000000;  // RXFIFO Full interrupt enable
    static constexpr uint32_t CR1_TXFEIE = 0x40000000;  // TXFIFO empty interrupt enable
    static constexpr uint32_t CR1_FIFOEN = 0x20000000;  // FIFO mode enable
    static constexpr uint32_t CR1_M1 = 0x10000000;      // Word length
    static constexpr uint32_t CR1_EOBIE = 0x8000000;    // End of Block interrupt enable
    static constexpr uint32_t CR1_RTOIE = 0x4000000;    // Receiver timeout interrupt enable
    static constexpr uint32_t CR1_DEAT4 = 0x2000000;    // Driver Enable assertion time
    static constexpr uint32_t CR1_DEAT3 = 0x1000000;    // DEAT3
    static constexpr uint32_t CR1_DEAT2 = 0x800000;     // DEAT2
    static constexpr uint32_t CR1_DEAT1 = 0x400000;     // DEAT1
    static constexpr uint32_t CR1_DEAT0 = 0x200000;     // DEAT0
    static constexpr uint32_t CR1_DEDT4 = 0x100000;     // Driver Enable de-assertion time
    static constexpr uint32_t CR1_DEDT3 = 0x80000;      // DEDT3
    static constexpr uint32_t CR1_DEDT2 = 0x40000;      // DEDT2
    static constexpr uint32_t CR1_DEDT1 = 0x20000;      // DEDT1
    static constexpr uint32_t CR1_DEDT0 = 0x10000;      // DEDT0
    static constexpr uint32_t CR1_OVER8 = 0x8000;       // Oversampling mode
    static constexpr uint32_t CR1_CMIE = 0x4000;        // Character match interrupt enable
    static constexpr uint32_t CR1_MME = 0x2000;         // Mute mode enable
    static constexpr uint32_t CR1_M0 = 0x1000;          // Word length
    static constexpr uint32_t CR1_WAKE = 0x800;         // Receiver wakeup method
    static constexpr uint32_t CR1_PCE = 0x400;          // Parity control enable
    static constexpr uint32_t CR1_PS = 0x200;           // Parity selection
    static constexpr uint32_t CR1_PEIE = 0x100;         // PE interrupt enable
    static constexpr uint32_t CR1_TXEIE = 0x80;         // interrupt enable
    static constexpr uint32_t CR1_TCIE = 0x40;          // Transmission complete interrupt enable
    static constexpr uint32_t CR1_RXNEIE = 0x20;        // RXNE interrupt enable
    static constexpr uint32_t CR1_IDLEIE = 0x10;        // IDLE interrupt enable
    static constexpr uint32_t CR1_TE = 0x8;             // Transmitter enable
    static constexpr uint32_t CR1_RE = 0x4;             // Receiver enable
    static constexpr uint32_t CR1_UESM = 0x2;           // USART enable in Stop mode
    static constexpr uint32_t CR1_UE = 0x1;             // USART enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CR2_ADD4_7 =              // Address of the USART node (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR2_ADD0_3 =              // Address of the USART node (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    static constexpr uint32_t CR2_RTOEN = 0x800000;     // Receiver timeout enable
    static constexpr uint32_t CR2_ABRMOD1 = 0x400000;   // Auto baud rate mode
    static constexpr uint32_t CR2_ABRMOD0 = 0x200000;   // ABRMOD0
    static constexpr uint32_t CR2_ABREN = 0x100000;     // Auto baud rate enable
    static constexpr uint32_t CR2_MSBFIRST = 0x80000;   // Most significant bit first
    static constexpr uint32_t CR2_TAINV = 0x40000;      // Binary data inversion
    static constexpr uint32_t CR2_TXINV = 0x20000;      // TX pin active level inversion
    static constexpr uint32_t CR2_RXINV = 0x10000;      // RX pin active level inversion
    static constexpr uint32_t CR2_SWAP = 0x8000;        // Swap TX/RX pins
    static constexpr uint32_t CR2_LINEN = 0x4000;       // LIN mode enable
    template<uint32_t X>
    static constexpr uint32_t CR2_STOP =                // STOP bits (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    static constexpr uint32_t CR2_CLKEN = 0x800;        // Clock enable
    static constexpr uint32_t CR2_CPOL = 0x400;         // Clock polarity
    static constexpr uint32_t CR2_CPHA = 0x200;         // Clock phase
    static constexpr uint32_t CR2_LBCL = 0x100;         // Last bit clock pulse
    static constexpr uint32_t CR2_LBDIE = 0x40;         // LIN break detection interrupt enable
    static constexpr uint32_t CR2_LBDL = 0x20;          // LIN break detection length
    static constexpr uint32_t CR2_ADDM7 = 0x10;         // 7-bit Address Detection/4-bit Address Detection
    static constexpr uint32_t CR2_DIS_NSS = 0x8;        // When the DSI_NSS bit is set, the NSS pin input is ignored
    static constexpr uint32_t CR2_SLVEN = 0x1;          // Synchronous Slave mode enable
    static const uint32_t CR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CR3_TXFTCFG =             // TXFIFO threshold configuration (3 bits)
        bit_field_t<29, 0x7>::value<X>();
    static constexpr uint32_t CR3_RXFTIE = 0x10000000;  // RXFIFO threshold interrupt enable
    template<uint32_t X>
    static constexpr uint32_t CR3_RXFTCFG =             // Receive FIFO threshold configuration (3 bits)
        bit_field_t<25, 0x7>::value<X>();
    static constexpr uint32_t CR3_TCBGTIE = 0x1000000;  // Transmission Complete before guard time, interrupt enable
    static constexpr uint32_t CR3_TXFTIE = 0x800000;    // TXFIFO threshold interrupt enable
    static constexpr uint32_t CR3_WUFIE = 0x400000;     // Wakeup from Stop mode interrupt enable
    template<uint32_t X>
    static constexpr uint32_t CR3_WUS =                 // Wakeup from Stop mode interrupt flag selection (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR3_SCARCNT =             // Smartcard auto-retry count (3 bits)
        bit_field_t<17, 0x7>::value<X>();
    static constexpr uint32_t CR3_DEP = 0x8000;         // Driver enable polarity selection
    static constexpr uint32_t CR3_DEM = 0x4000;         // Driver enable mode
    static constexpr uint32_t CR3_DDRE = 0x2000;        // DMA Disable on Reception Error
    static constexpr uint32_t CR3_OVRDIS = 0x1000;      // Overrun Disable
    static constexpr uint32_t CR3_ONEBIT = 0x800;       // One sample bit method enable
    static constexpr uint32_t CR3_CTSIE = 0x400;        // CTS interrupt enable
    static constexpr uint32_t CR3_CTSE = 0x200;         // CTS enable
    static constexpr uint32_t CR3_RTSE = 0x100;         // RTS enable
    static constexpr uint32_t CR3_DMAT = 0x80;          // DMA enable transmitter
    static constexpr uint32_t CR3_DMAR = 0x40;          // DMA enable receiver
    static constexpr uint32_t CR3_SCEN = 0x20;          // Smartcard mode enable
    static constexpr uint32_t CR3_NACK = 0x10;          // Smartcard NACK enable
    static constexpr uint32_t CR3_HDSEL = 0x8;          // Half-duplex selection
    static constexpr uint32_t CR3_IRLP = 0x4;           // Ir low-power
    static constexpr uint32_t CR3_IREN = 0x2;           // Ir mode enable
    static constexpr uint32_t CR3_EIE = 0x1;            // Error interrupt enable
    static const uint32_t CR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BRR_BRR_4_15 =            // DIV_Mantissa (12 bits)
        bit_field_t<4, 0xfff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BRR_BRR_0_3 =             // DIV_Fraction (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t BRR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t GTPR_GT =                  // Guard time value (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GTPR_PSC =                 // Prescaler value (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t GTPR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RTOR_BLEN =                // Block Length (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RTOR_RTO =                 // Receiver timeout value (24 bits)
        bit_field_t<0, 0xffffff>::value<X>();
    static const uint32_t RTOR_RESET_VALUE = 0x0;

    static constexpr uint32_t RQR_TXFRQ = 0x10;         // Transmit data flush request
    static constexpr uint32_t RQR_RXFRQ = 0x8;          // Receive data flush request
    static constexpr uint32_t RQR_MMRQ = 0x4;           // Mute mode request
    static constexpr uint32_t RQR_SBKRQ = 0x2;          // Send break request
    static constexpr uint32_t RQR_ABRRQ = 0x1;          // Auto baud rate request
    static const uint32_t RQR_RESET_VALUE = 0x0;

    static constexpr uint32_t ISR_TXFT = 0x8000000;     // TXFIFO threshold flag
    static constexpr uint32_t ISR_RXFT = 0x4000000;     // RXFIFO threshold flag
    static constexpr uint32_t ISR_TCBGT = 0x2000000;    // Transmission complete before guard time flag
    static constexpr uint32_t ISR_RXFF = 0x1000000;     // RXFIFO Full
    static constexpr uint32_t ISR_TXFE = 0x800000;      // TXFIFO Empty
    static constexpr uint32_t ISR_REACK = 0x400000;     // REACK
    static constexpr uint32_t ISR_TEACK = 0x200000;     // TEACK
    static constexpr uint32_t ISR_WUF = 0x100000;       // WUF
    static constexpr uint32_t ISR_RWU = 0x80000;        // RWU
    static constexpr uint32_t ISR_SBKF = 0x40000;       // SBKF
    static constexpr uint32_t ISR_CMF = 0x20000;        // CMF
    static constexpr uint32_t ISR_BUSY = 0x10000;       // BUSY
    static constexpr uint32_t ISR_ABRF = 0x8000;        // ABRF
    static constexpr uint32_t ISR_ABRE = 0x4000;        // ABRE
    static constexpr uint32_t ISR_UDR = 0x2000;         // SPI slave underrun error flag
    static constexpr uint32_t ISR_EOBF = 0x1000;        // EOBF
    static constexpr uint32_t ISR_RTOF = 0x800;         // RTOF
    static constexpr uint32_t ISR_CTS = 0x400;          // CTS
    static constexpr uint32_t ISR_CTSIF = 0x200;        // CTSIF
    static constexpr uint32_t ISR_LBDF = 0x100;         // LBDF
    static constexpr uint32_t ISR_TXE = 0x80;           // TXE
    static constexpr uint32_t ISR_TC = 0x40;            // TC
    static constexpr uint32_t ISR_RXNE = 0x20;          // RXNE
    static constexpr uint32_t ISR_IDLE = 0x10;          // IDLE
    static constexpr uint32_t ISR_ORE = 0x8;            // ORE
    static constexpr uint32_t ISR_NF = 0x4;             // NF
    static constexpr uint32_t ISR_FE = 0x2;             // FE
    static constexpr uint32_t ISR_PE = 0x1;             // PE
    static const uint32_t ISR_RESET_VALUE = 0xc0;

    static constexpr uint32_t ICR_WUCF = 0x100000;      // Wakeup from Stop mode clear flag
    static constexpr uint32_t ICR_CMCF = 0x20000;       // Character match clear flag
    static constexpr uint32_t ICR_UDRCF = 0x2000;       // SPI slave underrun clear flag
    static constexpr uint32_t ICR_EOBCF = 0x1000;       // End of block clear flag
    static constexpr uint32_t ICR_RTOCF = 0x800;        // Receiver timeout clear flag
    static constexpr uint32_t ICR_CTSCF = 0x200;        // CTS clear flag
    static constexpr uint32_t ICR_LBDCF = 0x100;        // LIN break detection clear flag
    static constexpr uint32_t ICR_TCBGTC = 0x80;        // Transmission complete before Guard time clear flag
    static constexpr uint32_t ICR_TCCF = 0x40;          // Transmission complete clear flag
    static constexpr uint32_t ICR_TXFECF = 0x20;        // TXFIFO empty clear flag
    static constexpr uint32_t ICR_IDLECF = 0x10;        // Idle line detected clear flag
    static constexpr uint32_t ICR_ORECF = 0x8;          // Overrun error clear flag
    static constexpr uint32_t ICR_NCF = 0x4;            // Noise detected clear flag
    static constexpr uint32_t ICR_FECF = 0x2;           // Framing error clear flag
    static constexpr uint32_t ICR_PECF = 0x1;           // Parity error clear flag
    static const uint32_t ICR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RDR_RDR =                 // Receive data value (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static const uint32_t RDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDR_TDR =                 // Transmit data value (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static const uint32_t TDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PRESC_PRESCALER =           // Clock prescaler (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t PRESC_RESET_VALUE = 0x0;

    static constexpr uint8_t UART4 = 52; // UART4 global interrupt
    static constexpr uint8_t USART3 = 39; // USART3 global interrupt
};

static uart4_t& UART4 = *reinterpret_cast<uart4_t*>(0x40004c00);

#define HAVE_PERIPHERAL_UART4


////
//
//    Universal synchronous asynchronous receiver transmitter
//
////

struct uart5_t
{
    volatile uint32_t    CR1;                  // [Read-write] Control register 1
    volatile uint32_t    CR2;                  // [Read-write] Control register 2
    volatile uint32_t    CR3;                  // [Read-write] Control register 3
    volatile uint32_t    BRR;                  // [Read-write] Baud rate register
    volatile uint32_t    GTPR;                 // [Read-write] Guard time and prescaler register
    volatile uint32_t    RTOR;                 // [Read-write] Receiver timeout register
    volatile uint32_t    RQR;                  // [Write-only] Request register
    volatile uint32_t    ISR;                  // [Read-only] Interrupt &amp; status register
    volatile uint32_t    ICR;                  // [Write-only] Interrupt flag clear register
    volatile uint32_t    RDR;                  // [Read-only] Receive data register
    volatile uint32_t    TDR;                  // [Read-write] Transmit data register
    volatile uint32_t    PRESC;                // [Read-write] USART prescaler register

    static constexpr uint32_t CR1_RXFFIE = 0x80000000;  // RXFIFO Full interrupt enable
    static constexpr uint32_t CR1_TXFEIE = 0x40000000;  // TXFIFO empty interrupt enable
    static constexpr uint32_t CR1_FIFOEN = 0x20000000;  // FIFO mode enable
    static constexpr uint32_t CR1_M1 = 0x10000000;      // Word length
    static constexpr uint32_t CR1_EOBIE = 0x8000000;    // End of Block interrupt enable
    static constexpr uint32_t CR1_RTOIE = 0x4000000;    // Receiver timeout interrupt enable
    static constexpr uint32_t CR1_DEAT4 = 0x2000000;    // Driver Enable assertion time
    static constexpr uint32_t CR1_DEAT3 = 0x1000000;    // DEAT3
    static constexpr uint32_t CR1_DEAT2 = 0x800000;     // DEAT2
    static constexpr uint32_t CR1_DEAT1 = 0x400000;     // DEAT1
    static constexpr uint32_t CR1_DEAT0 = 0x200000;     // DEAT0
    static constexpr uint32_t CR1_DEDT4 = 0x100000;     // Driver Enable de-assertion time
    static constexpr uint32_t CR1_DEDT3 = 0x80000;      // DEDT3
    static constexpr uint32_t CR1_DEDT2 = 0x40000;      // DEDT2
    static constexpr uint32_t CR1_DEDT1 = 0x20000;      // DEDT1
    static constexpr uint32_t CR1_DEDT0 = 0x10000;      // DEDT0
    static constexpr uint32_t CR1_OVER8 = 0x8000;       // Oversampling mode
    static constexpr uint32_t CR1_CMIE = 0x4000;        // Character match interrupt enable
    static constexpr uint32_t CR1_MME = 0x2000;         // Mute mode enable
    static constexpr uint32_t CR1_M0 = 0x1000;          // Word length
    static constexpr uint32_t CR1_WAKE = 0x800;         // Receiver wakeup method
    static constexpr uint32_t CR1_PCE = 0x400;          // Parity control enable
    static constexpr uint32_t CR1_PS = 0x200;           // Parity selection
    static constexpr uint32_t CR1_PEIE = 0x100;         // PE interrupt enable
    static constexpr uint32_t CR1_TXEIE = 0x80;         // interrupt enable
    static constexpr uint32_t CR1_TCIE = 0x40;          // Transmission complete interrupt enable
    static constexpr uint32_t CR1_RXNEIE = 0x20;        // RXNE interrupt enable
    static constexpr uint32_t CR1_IDLEIE = 0x10;        // IDLE interrupt enable
    static constexpr uint32_t CR1_TE = 0x8;             // Transmitter enable
    static constexpr uint32_t CR1_RE = 0x4;             // Receiver enable
    static constexpr uint32_t CR1_UESM = 0x2;           // USART enable in Stop mode
    static constexpr uint32_t CR1_UE = 0x1;             // USART enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CR2_ADD4_7 =              // Address of the USART node (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR2_ADD0_3 =              // Address of the USART node (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    static constexpr uint32_t CR2_RTOEN = 0x800000;     // Receiver timeout enable
    static constexpr uint32_t CR2_ABRMOD1 = 0x400000;   // Auto baud rate mode
    static constexpr uint32_t CR2_ABRMOD0 = 0x200000;   // ABRMOD0
    static constexpr uint32_t CR2_ABREN = 0x100000;     // Auto baud rate enable
    static constexpr uint32_t CR2_MSBFIRST = 0x80000;   // Most significant bit first
    static constexpr uint32_t CR2_TAINV = 0x40000;      // Binary data inversion
    static constexpr uint32_t CR2_TXINV = 0x20000;      // TX pin active level inversion
    static constexpr uint32_t CR2_RXINV = 0x10000;      // RX pin active level inversion
    static constexpr uint32_t CR2_SWAP = 0x8000;        // Swap TX/RX pins
    static constexpr uint32_t CR2_LINEN = 0x4000;       // LIN mode enable
    template<uint32_t X>
    static constexpr uint32_t CR2_STOP =                // STOP bits (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    static constexpr uint32_t CR2_CLKEN = 0x800;        // Clock enable
    static constexpr uint32_t CR2_CPOL = 0x400;         // Clock polarity
    static constexpr uint32_t CR2_CPHA = 0x200;         // Clock phase
    static constexpr uint32_t CR2_LBCL = 0x100;         // Last bit clock pulse
    static constexpr uint32_t CR2_LBDIE = 0x40;         // LIN break detection interrupt enable
    static constexpr uint32_t CR2_LBDL = 0x20;          // LIN break detection length
    static constexpr uint32_t CR2_ADDM7 = 0x10;         // 7-bit Address Detection/4-bit Address Detection
    static constexpr uint32_t CR2_DIS_NSS = 0x8;        // When the DSI_NSS bit is set, the NSS pin input is ignored
    static constexpr uint32_t CR2_SLVEN = 0x1;          // Synchronous Slave mode enable
    static const uint32_t CR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CR3_TXFTCFG =             // TXFIFO threshold configuration (3 bits)
        bit_field_t<29, 0x7>::value<X>();
    static constexpr uint32_t CR3_RXFTIE = 0x10000000;  // RXFIFO threshold interrupt enable
    template<uint32_t X>
    static constexpr uint32_t CR3_RXFTCFG =             // Receive FIFO threshold configuration (3 bits)
        bit_field_t<25, 0x7>::value<X>();
    static constexpr uint32_t CR3_TCBGTIE = 0x1000000;  // Transmission Complete before guard time, interrupt enable
    static constexpr uint32_t CR3_TXFTIE = 0x800000;    // TXFIFO threshold interrupt enable
    static constexpr uint32_t CR3_WUFIE = 0x400000;     // Wakeup from Stop mode interrupt enable
    template<uint32_t X>
    static constexpr uint32_t CR3_WUS =                 // Wakeup from Stop mode interrupt flag selection (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR3_SCARCNT =             // Smartcard auto-retry count (3 bits)
        bit_field_t<17, 0x7>::value<X>();
    static constexpr uint32_t CR3_DEP = 0x8000;         // Driver enable polarity selection
    static constexpr uint32_t CR3_DEM = 0x4000;         // Driver enable mode
    static constexpr uint32_t CR3_DDRE = 0x2000;        // DMA Disable on Reception Error
    static constexpr uint32_t CR3_OVRDIS = 0x1000;      // Overrun Disable
    static constexpr uint32_t CR3_ONEBIT = 0x800;       // One sample bit method enable
    static constexpr uint32_t CR3_CTSIE = 0x400;        // CTS interrupt enable
    static constexpr uint32_t CR3_CTSE = 0x200;         // CTS enable
    static constexpr uint32_t CR3_RTSE = 0x100;         // RTS enable
    static constexpr uint32_t CR3_DMAT = 0x80;          // DMA enable transmitter
    static constexpr uint32_t CR3_DMAR = 0x40;          // DMA enable receiver
    static constexpr uint32_t CR3_SCEN = 0x20;          // Smartcard mode enable
    static constexpr uint32_t CR3_NACK = 0x10;          // Smartcard NACK enable
    static constexpr uint32_t CR3_HDSEL = 0x8;          // Half-duplex selection
    static constexpr uint32_t CR3_IRLP = 0x4;           // Ir low-power
    static constexpr uint32_t CR3_IREN = 0x2;           // Ir mode enable
    static constexpr uint32_t CR3_EIE = 0x1;            // Error interrupt enable
    static const uint32_t CR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BRR_BRR_4_15 =            // DIV_Mantissa (12 bits)
        bit_field_t<4, 0xfff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BRR_BRR_0_3 =             // DIV_Fraction (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t BRR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t GTPR_GT =                  // Guard time value (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GTPR_PSC =                 // Prescaler value (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t GTPR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RTOR_BLEN =                // Block Length (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RTOR_RTO =                 // Receiver timeout value (24 bits)
        bit_field_t<0, 0xffffff>::value<X>();
    static const uint32_t RTOR_RESET_VALUE = 0x0;

    static constexpr uint32_t RQR_TXFRQ = 0x10;         // Transmit data flush request
    static constexpr uint32_t RQR_RXFRQ = 0x8;          // Receive data flush request
    static constexpr uint32_t RQR_MMRQ = 0x4;           // Mute mode request
    static constexpr uint32_t RQR_SBKRQ = 0x2;          // Send break request
    static constexpr uint32_t RQR_ABRRQ = 0x1;          // Auto baud rate request
    static const uint32_t RQR_RESET_VALUE = 0x0;

    static constexpr uint32_t ISR_TXFT = 0x8000000;     // TXFIFO threshold flag
    static constexpr uint32_t ISR_RXFT = 0x4000000;     // RXFIFO threshold flag
    static constexpr uint32_t ISR_TCBGT = 0x2000000;    // Transmission complete before guard time flag
    static constexpr uint32_t ISR_RXFF = 0x1000000;     // RXFIFO Full
    static constexpr uint32_t ISR_TXFE = 0x800000;      // TXFIFO Empty
    static constexpr uint32_t ISR_REACK = 0x400000;     // REACK
    static constexpr uint32_t ISR_TEACK = 0x200000;     // TEACK
    static constexpr uint32_t ISR_WUF = 0x100000;       // WUF
    static constexpr uint32_t ISR_RWU = 0x80000;        // RWU
    static constexpr uint32_t ISR_SBKF = 0x40000;       // SBKF
    static constexpr uint32_t ISR_CMF = 0x20000;        // CMF
    static constexpr uint32_t ISR_BUSY = 0x10000;       // BUSY
    static constexpr uint32_t ISR_ABRF = 0x8000;        // ABRF
    static constexpr uint32_t ISR_ABRE = 0x4000;        // ABRE
    static constexpr uint32_t ISR_UDR = 0x2000;         // SPI slave underrun error flag
    static constexpr uint32_t ISR_EOBF = 0x1000;        // EOBF
    static constexpr uint32_t ISR_RTOF = 0x800;         // RTOF
    static constexpr uint32_t ISR_CTS = 0x400;          // CTS
    static constexpr uint32_t ISR_CTSIF = 0x200;        // CTSIF
    static constexpr uint32_t ISR_LBDF = 0x100;         // LBDF
    static constexpr uint32_t ISR_TXE = 0x80;           // TXE
    static constexpr uint32_t ISR_TC = 0x40;            // TC
    static constexpr uint32_t ISR_RXNE = 0x20;          // RXNE
    static constexpr uint32_t ISR_IDLE = 0x10;          // IDLE
    static constexpr uint32_t ISR_ORE = 0x8;            // ORE
    static constexpr uint32_t ISR_NF = 0x4;             // NF
    static constexpr uint32_t ISR_FE = 0x2;             // FE
    static constexpr uint32_t ISR_PE = 0x1;             // PE
    static const uint32_t ISR_RESET_VALUE = 0xc0;

    static constexpr uint32_t ICR_WUCF = 0x100000;      // Wakeup from Stop mode clear flag
    static constexpr uint32_t ICR_CMCF = 0x20000;       // Character match clear flag
    static constexpr uint32_t ICR_UDRCF = 0x2000;       // SPI slave underrun clear flag
    static constexpr uint32_t ICR_EOBCF = 0x1000;       // End of block clear flag
    static constexpr uint32_t ICR_RTOCF = 0x800;        // Receiver timeout clear flag
    static constexpr uint32_t ICR_CTSCF = 0x200;        // CTS clear flag
    static constexpr uint32_t ICR_LBDCF = 0x100;        // LIN break detection clear flag
    static constexpr uint32_t ICR_TCBGTC = 0x80;        // Transmission complete before Guard time clear flag
    static constexpr uint32_t ICR_TCCF = 0x40;          // Transmission complete clear flag
    static constexpr uint32_t ICR_TXFECF = 0x20;        // TXFIFO empty clear flag
    static constexpr uint32_t ICR_IDLECF = 0x10;        // Idle line detected clear flag
    static constexpr uint32_t ICR_ORECF = 0x8;          // Overrun error clear flag
    static constexpr uint32_t ICR_NCF = 0x4;            // Noise detected clear flag
    static constexpr uint32_t ICR_FECF = 0x2;           // Framing error clear flag
    static constexpr uint32_t ICR_PECF = 0x1;           // Parity error clear flag
    static const uint32_t ICR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RDR_RDR =                 // Receive data value (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static const uint32_t RDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDR_TDR =                 // Transmit data value (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static const uint32_t TDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PRESC_PRESCALER =           // Clock prescaler (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t PRESC_RESET_VALUE = 0x0;

    static constexpr uint8_t UART5 = 53; // UART5 global interrupt
};

static uart5_t& UART5 = *reinterpret_cast<uart5_t*>(0x40005000);

#define HAVE_PERIPHERAL_UART5


////
//
//    Universal synchronous asynchronous receiver transmitter
//
////

struct usart6_t
{
    volatile uint32_t    CR1;                  // [Read-write] Control register 1
    volatile uint32_t    CR2;                  // [Read-write] Control register 2
    volatile uint32_t    CR3;                  // [Read-write] Control register 3
    volatile uint32_t    BRR;                  // [Read-write] Baud rate register
    volatile uint32_t    GTPR;                 // [Read-write] Guard time and prescaler register
    volatile uint32_t    RTOR;                 // [Read-write] Receiver timeout register
    volatile uint32_t    RQR;                  // [Write-only] Request register
    volatile uint32_t    ISR;                  // [Read-only] Interrupt &amp; status register
    volatile uint32_t    ICR;                  // [Write-only] Interrupt flag clear register
    volatile uint32_t    RDR;                  // [Read-only] Receive data register
    volatile uint32_t    TDR;                  // [Read-write] Transmit data register
    volatile uint32_t    PRESC;                // [Read-write] USART prescaler register

    static constexpr uint32_t CR1_RXFFIE = 0x80000000;  // RXFIFO Full interrupt enable
    static constexpr uint32_t CR1_TXFEIE = 0x40000000;  // TXFIFO empty interrupt enable
    static constexpr uint32_t CR1_FIFOEN = 0x20000000;  // FIFO mode enable
    static constexpr uint32_t CR1_M1 = 0x10000000;      // Word length
    static constexpr uint32_t CR1_EOBIE = 0x8000000;    // End of Block interrupt enable
    static constexpr uint32_t CR1_RTOIE = 0x4000000;    // Receiver timeout interrupt enable
    static constexpr uint32_t CR1_DEAT4 = 0x2000000;    // Driver Enable assertion time
    static constexpr uint32_t CR1_DEAT3 = 0x1000000;    // DEAT3
    static constexpr uint32_t CR1_DEAT2 = 0x800000;     // DEAT2
    static constexpr uint32_t CR1_DEAT1 = 0x400000;     // DEAT1
    static constexpr uint32_t CR1_DEAT0 = 0x200000;     // DEAT0
    static constexpr uint32_t CR1_DEDT4 = 0x100000;     // Driver Enable de-assertion time
    static constexpr uint32_t CR1_DEDT3 = 0x80000;      // DEDT3
    static constexpr uint32_t CR1_DEDT2 = 0x40000;      // DEDT2
    static constexpr uint32_t CR1_DEDT1 = 0x20000;      // DEDT1
    static constexpr uint32_t CR1_DEDT0 = 0x10000;      // DEDT0
    static constexpr uint32_t CR1_OVER8 = 0x8000;       // Oversampling mode
    static constexpr uint32_t CR1_CMIE = 0x4000;        // Character match interrupt enable
    static constexpr uint32_t CR1_MME = 0x2000;         // Mute mode enable
    static constexpr uint32_t CR1_M0 = 0x1000;          // Word length
    static constexpr uint32_t CR1_WAKE = 0x800;         // Receiver wakeup method
    static constexpr uint32_t CR1_PCE = 0x400;          // Parity control enable
    static constexpr uint32_t CR1_PS = 0x200;           // Parity selection
    static constexpr uint32_t CR1_PEIE = 0x100;         // PE interrupt enable
    static constexpr uint32_t CR1_TXEIE = 0x80;         // interrupt enable
    static constexpr uint32_t CR1_TCIE = 0x40;          // Transmission complete interrupt enable
    static constexpr uint32_t CR1_RXNEIE = 0x20;        // RXNE interrupt enable
    static constexpr uint32_t CR1_IDLEIE = 0x10;        // IDLE interrupt enable
    static constexpr uint32_t CR1_TE = 0x8;             // Transmitter enable
    static constexpr uint32_t CR1_RE = 0x4;             // Receiver enable
    static constexpr uint32_t CR1_UESM = 0x2;           // USART enable in Stop mode
    static constexpr uint32_t CR1_UE = 0x1;             // USART enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CR2_ADD4_7 =              // Address of the USART node (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR2_ADD0_3 =              // Address of the USART node (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    static constexpr uint32_t CR2_RTOEN = 0x800000;     // Receiver timeout enable
    static constexpr uint32_t CR2_ABRMOD1 = 0x400000;   // Auto baud rate mode
    static constexpr uint32_t CR2_ABRMOD0 = 0x200000;   // ABRMOD0
    static constexpr uint32_t CR2_ABREN = 0x100000;     // Auto baud rate enable
    static constexpr uint32_t CR2_MSBFIRST = 0x80000;   // Most significant bit first
    static constexpr uint32_t CR2_TAINV = 0x40000;      // Binary data inversion
    static constexpr uint32_t CR2_TXINV = 0x20000;      // TX pin active level inversion
    static constexpr uint32_t CR2_RXINV = 0x10000;      // RX pin active level inversion
    static constexpr uint32_t CR2_SWAP = 0x8000;        // Swap TX/RX pins
    static constexpr uint32_t CR2_LINEN = 0x4000;       // LIN mode enable
    template<uint32_t X>
    static constexpr uint32_t CR2_STOP =                // STOP bits (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    static constexpr uint32_t CR2_CLKEN = 0x800;        // Clock enable
    static constexpr uint32_t CR2_CPOL = 0x400;         // Clock polarity
    static constexpr uint32_t CR2_CPHA = 0x200;         // Clock phase
    static constexpr uint32_t CR2_LBCL = 0x100;         // Last bit clock pulse
    static constexpr uint32_t CR2_LBDIE = 0x40;         // LIN break detection interrupt enable
    static constexpr uint32_t CR2_LBDL = 0x20;          // LIN break detection length
    static constexpr uint32_t CR2_ADDM7 = 0x10;         // 7-bit Address Detection/4-bit Address Detection
    static constexpr uint32_t CR2_DIS_NSS = 0x8;        // When the DSI_NSS bit is set, the NSS pin input is ignored
    static constexpr uint32_t CR2_SLVEN = 0x1;          // Synchronous Slave mode enable
    static const uint32_t CR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CR3_TXFTCFG =             // TXFIFO threshold configuration (3 bits)
        bit_field_t<29, 0x7>::value<X>();
    static constexpr uint32_t CR3_RXFTIE = 0x10000000;  // RXFIFO threshold interrupt enable
    template<uint32_t X>
    static constexpr uint32_t CR3_RXFTCFG =             // Receive FIFO threshold configuration (3 bits)
        bit_field_t<25, 0x7>::value<X>();
    static constexpr uint32_t CR3_TCBGTIE = 0x1000000;  // Transmission Complete before guard time, interrupt enable
    static constexpr uint32_t CR3_TXFTIE = 0x800000;    // TXFIFO threshold interrupt enable
    static constexpr uint32_t CR3_WUFIE = 0x400000;     // Wakeup from Stop mode interrupt enable
    template<uint32_t X>
    static constexpr uint32_t CR3_WUS =                 // Wakeup from Stop mode interrupt flag selection (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR3_SCARCNT =             // Smartcard auto-retry count (3 bits)
        bit_field_t<17, 0x7>::value<X>();
    static constexpr uint32_t CR3_DEP = 0x8000;         // Driver enable polarity selection
    static constexpr uint32_t CR3_DEM = 0x4000;         // Driver enable mode
    static constexpr uint32_t CR3_DDRE = 0x2000;        // DMA Disable on Reception Error
    static constexpr uint32_t CR3_OVRDIS = 0x1000;      // Overrun Disable
    static constexpr uint32_t CR3_ONEBIT = 0x800;       // One sample bit method enable
    static constexpr uint32_t CR3_CTSIE = 0x400;        // CTS interrupt enable
    static constexpr uint32_t CR3_CTSE = 0x200;         // CTS enable
    static constexpr uint32_t CR3_RTSE = 0x100;         // RTS enable
    static constexpr uint32_t CR3_DMAT = 0x80;          // DMA enable transmitter
    static constexpr uint32_t CR3_DMAR = 0x40;          // DMA enable receiver
    static constexpr uint32_t CR3_SCEN = 0x20;          // Smartcard mode enable
    static constexpr uint32_t CR3_NACK = 0x10;          // Smartcard NACK enable
    static constexpr uint32_t CR3_HDSEL = 0x8;          // Half-duplex selection
    static constexpr uint32_t CR3_IRLP = 0x4;           // Ir low-power
    static constexpr uint32_t CR3_IREN = 0x2;           // Ir mode enable
    static constexpr uint32_t CR3_EIE = 0x1;            // Error interrupt enable
    static const uint32_t CR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BRR_BRR_4_15 =            // DIV_Mantissa (12 bits)
        bit_field_t<4, 0xfff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BRR_BRR_0_3 =             // DIV_Fraction (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t BRR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t GTPR_GT =                  // Guard time value (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GTPR_PSC =                 // Prescaler value (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t GTPR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RTOR_BLEN =                // Block Length (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RTOR_RTO =                 // Receiver timeout value (24 bits)
        bit_field_t<0, 0xffffff>::value<X>();
    static const uint32_t RTOR_RESET_VALUE = 0x0;

    static constexpr uint32_t RQR_TXFRQ = 0x10;         // Transmit data flush request
    static constexpr uint32_t RQR_RXFRQ = 0x8;          // Receive data flush request
    static constexpr uint32_t RQR_MMRQ = 0x4;           // Mute mode request
    static constexpr uint32_t RQR_SBKRQ = 0x2;          // Send break request
    static constexpr uint32_t RQR_ABRRQ = 0x1;          // Auto baud rate request
    static const uint32_t RQR_RESET_VALUE = 0x0;

    static constexpr uint32_t ISR_TXFT = 0x8000000;     // TXFIFO threshold flag
    static constexpr uint32_t ISR_RXFT = 0x4000000;     // RXFIFO threshold flag
    static constexpr uint32_t ISR_TCBGT = 0x2000000;    // Transmission complete before guard time flag
    static constexpr uint32_t ISR_RXFF = 0x1000000;     // RXFIFO Full
    static constexpr uint32_t ISR_TXFE = 0x800000;      // TXFIFO Empty
    static constexpr uint32_t ISR_REACK = 0x400000;     // REACK
    static constexpr uint32_t ISR_TEACK = 0x200000;     // TEACK
    static constexpr uint32_t ISR_WUF = 0x100000;       // WUF
    static constexpr uint32_t ISR_RWU = 0x80000;        // RWU
    static constexpr uint32_t ISR_SBKF = 0x40000;       // SBKF
    static constexpr uint32_t ISR_CMF = 0x20000;        // CMF
    static constexpr uint32_t ISR_BUSY = 0x10000;       // BUSY
    static constexpr uint32_t ISR_ABRF = 0x8000;        // ABRF
    static constexpr uint32_t ISR_ABRE = 0x4000;        // ABRE
    static constexpr uint32_t ISR_UDR = 0x2000;         // SPI slave underrun error flag
    static constexpr uint32_t ISR_EOBF = 0x1000;        // EOBF
    static constexpr uint32_t ISR_RTOF = 0x800;         // RTOF
    static constexpr uint32_t ISR_CTS = 0x400;          // CTS
    static constexpr uint32_t ISR_CTSIF = 0x200;        // CTSIF
    static constexpr uint32_t ISR_LBDF = 0x100;         // LBDF
    static constexpr uint32_t ISR_TXE = 0x80;           // TXE
    static constexpr uint32_t ISR_TC = 0x40;            // TC
    static constexpr uint32_t ISR_RXNE = 0x20;          // RXNE
    static constexpr uint32_t ISR_IDLE = 0x10;          // IDLE
    static constexpr uint32_t ISR_ORE = 0x8;            // ORE
    static constexpr uint32_t ISR_NF = 0x4;             // NF
    static constexpr uint32_t ISR_FE = 0x2;             // FE
    static constexpr uint32_t ISR_PE = 0x1;             // PE
    static const uint32_t ISR_RESET_VALUE = 0xc0;

    static constexpr uint32_t ICR_WUCF = 0x100000;      // Wakeup from Stop mode clear flag
    static constexpr uint32_t ICR_CMCF = 0x20000;       // Character match clear flag
    static constexpr uint32_t ICR_UDRCF = 0x2000;       // SPI slave underrun clear flag
    static constexpr uint32_t ICR_EOBCF = 0x1000;       // End of block clear flag
    static constexpr uint32_t ICR_RTOCF = 0x800;        // Receiver timeout clear flag
    static constexpr uint32_t ICR_CTSCF = 0x200;        // CTS clear flag
    static constexpr uint32_t ICR_LBDCF = 0x100;        // LIN break detection clear flag
    static constexpr uint32_t ICR_TCBGTC = 0x80;        // Transmission complete before Guard time clear flag
    static constexpr uint32_t ICR_TCCF = 0x40;          // Transmission complete clear flag
    static constexpr uint32_t ICR_TXFECF = 0x20;        // TXFIFO empty clear flag
    static constexpr uint32_t ICR_IDLECF = 0x10;        // Idle line detected clear flag
    static constexpr uint32_t ICR_ORECF = 0x8;          // Overrun error clear flag
    static constexpr uint32_t ICR_NCF = 0x4;            // Noise detected clear flag
    static constexpr uint32_t ICR_FECF = 0x2;           // Framing error clear flag
    static constexpr uint32_t ICR_PECF = 0x1;           // Parity error clear flag
    static const uint32_t ICR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RDR_RDR =                 // Receive data value (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static const uint32_t RDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDR_TDR =                 // Transmit data value (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static const uint32_t TDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PRESC_PRESCALER =           // Clock prescaler (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t PRESC_RESET_VALUE = 0x0;

    static constexpr uint8_t USART6 = 71; // USART6 global interrupt
};

static usart6_t& USART6 = *reinterpret_cast<usart6_t*>(0x40011400);

#define HAVE_PERIPHERAL_USART6


////
//
//    Universal synchronous asynchronous receiver transmitter
//
////

struct uart7_t
{
    volatile uint32_t    CR1;                  // [Read-write] Control register 1
    volatile uint32_t    CR2;                  // [Read-write] Control register 2
    volatile uint32_t    CR3;                  // [Read-write] Control register 3
    volatile uint32_t    BRR;                  // [Read-write] Baud rate register
    volatile uint32_t    GTPR;                 // [Read-write] Guard time and prescaler register
    volatile uint32_t    RTOR;                 // [Read-write] Receiver timeout register
    volatile uint32_t    RQR;                  // [Write-only] Request register
    volatile uint32_t    ISR;                  // [Read-only] Interrupt &amp; status register
    volatile uint32_t    ICR;                  // [Write-only] Interrupt flag clear register
    volatile uint32_t    RDR;                  // [Read-only] Receive data register
    volatile uint32_t    TDR;                  // [Read-write] Transmit data register
    volatile uint32_t    PRESC;                // [Read-write] USART prescaler register

    static constexpr uint32_t CR1_RXFFIE = 0x80000000;  // RXFIFO Full interrupt enable
    static constexpr uint32_t CR1_TXFEIE = 0x40000000;  // TXFIFO empty interrupt enable
    static constexpr uint32_t CR1_FIFOEN = 0x20000000;  // FIFO mode enable
    static constexpr uint32_t CR1_M1 = 0x10000000;      // Word length
    static constexpr uint32_t CR1_EOBIE = 0x8000000;    // End of Block interrupt enable
    static constexpr uint32_t CR1_RTOIE = 0x4000000;    // Receiver timeout interrupt enable
    static constexpr uint32_t CR1_DEAT4 = 0x2000000;    // Driver Enable assertion time
    static constexpr uint32_t CR1_DEAT3 = 0x1000000;    // DEAT3
    static constexpr uint32_t CR1_DEAT2 = 0x800000;     // DEAT2
    static constexpr uint32_t CR1_DEAT1 = 0x400000;     // DEAT1
    static constexpr uint32_t CR1_DEAT0 = 0x200000;     // DEAT0
    static constexpr uint32_t CR1_DEDT4 = 0x100000;     // Driver Enable de-assertion time
    static constexpr uint32_t CR1_DEDT3 = 0x80000;      // DEDT3
    static constexpr uint32_t CR1_DEDT2 = 0x40000;      // DEDT2
    static constexpr uint32_t CR1_DEDT1 = 0x20000;      // DEDT1
    static constexpr uint32_t CR1_DEDT0 = 0x10000;      // DEDT0
    static constexpr uint32_t CR1_OVER8 = 0x8000;       // Oversampling mode
    static constexpr uint32_t CR1_CMIE = 0x4000;        // Character match interrupt enable
    static constexpr uint32_t CR1_MME = 0x2000;         // Mute mode enable
    static constexpr uint32_t CR1_M0 = 0x1000;          // Word length
    static constexpr uint32_t CR1_WAKE = 0x800;         // Receiver wakeup method
    static constexpr uint32_t CR1_PCE = 0x400;          // Parity control enable
    static constexpr uint32_t CR1_PS = 0x200;           // Parity selection
    static constexpr uint32_t CR1_PEIE = 0x100;         // PE interrupt enable
    static constexpr uint32_t CR1_TXEIE = 0x80;         // interrupt enable
    static constexpr uint32_t CR1_TCIE = 0x40;          // Transmission complete interrupt enable
    static constexpr uint32_t CR1_RXNEIE = 0x20;        // RXNE interrupt enable
    static constexpr uint32_t CR1_IDLEIE = 0x10;        // IDLE interrupt enable
    static constexpr uint32_t CR1_TE = 0x8;             // Transmitter enable
    static constexpr uint32_t CR1_RE = 0x4;             // Receiver enable
    static constexpr uint32_t CR1_UESM = 0x2;           // USART enable in Stop mode
    static constexpr uint32_t CR1_UE = 0x1;             // USART enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CR2_ADD4_7 =              // Address of the USART node (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR2_ADD0_3 =              // Address of the USART node (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    static constexpr uint32_t CR2_RTOEN = 0x800000;     // Receiver timeout enable
    static constexpr uint32_t CR2_ABRMOD1 = 0x400000;   // Auto baud rate mode
    static constexpr uint32_t CR2_ABRMOD0 = 0x200000;   // ABRMOD0
    static constexpr uint32_t CR2_ABREN = 0x100000;     // Auto baud rate enable
    static constexpr uint32_t CR2_MSBFIRST = 0x80000;   // Most significant bit first
    static constexpr uint32_t CR2_TAINV = 0x40000;      // Binary data inversion
    static constexpr uint32_t CR2_TXINV = 0x20000;      // TX pin active level inversion
    static constexpr uint32_t CR2_RXINV = 0x10000;      // RX pin active level inversion
    static constexpr uint32_t CR2_SWAP = 0x8000;        // Swap TX/RX pins
    static constexpr uint32_t CR2_LINEN = 0x4000;       // LIN mode enable
    template<uint32_t X>
    static constexpr uint32_t CR2_STOP =                // STOP bits (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    static constexpr uint32_t CR2_CLKEN = 0x800;        // Clock enable
    static constexpr uint32_t CR2_CPOL = 0x400;         // Clock polarity
    static constexpr uint32_t CR2_CPHA = 0x200;         // Clock phase
    static constexpr uint32_t CR2_LBCL = 0x100;         // Last bit clock pulse
    static constexpr uint32_t CR2_LBDIE = 0x40;         // LIN break detection interrupt enable
    static constexpr uint32_t CR2_LBDL = 0x20;          // LIN break detection length
    static constexpr uint32_t CR2_ADDM7 = 0x10;         // 7-bit Address Detection/4-bit Address Detection
    static constexpr uint32_t CR2_DIS_NSS = 0x8;        // When the DSI_NSS bit is set, the NSS pin input is ignored
    static constexpr uint32_t CR2_SLVEN = 0x1;          // Synchronous Slave mode enable
    static const uint32_t CR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CR3_TXFTCFG =             // TXFIFO threshold configuration (3 bits)
        bit_field_t<29, 0x7>::value<X>();
    static constexpr uint32_t CR3_RXFTIE = 0x10000000;  // RXFIFO threshold interrupt enable
    template<uint32_t X>
    static constexpr uint32_t CR3_RXFTCFG =             // Receive FIFO threshold configuration (3 bits)
        bit_field_t<25, 0x7>::value<X>();
    static constexpr uint32_t CR3_TCBGTIE = 0x1000000;  // Transmission Complete before guard time, interrupt enable
    static constexpr uint32_t CR3_TXFTIE = 0x800000;    // TXFIFO threshold interrupt enable
    static constexpr uint32_t CR3_WUFIE = 0x400000;     // Wakeup from Stop mode interrupt enable
    template<uint32_t X>
    static constexpr uint32_t CR3_WUS =                 // Wakeup from Stop mode interrupt flag selection (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR3_SCARCNT =             // Smartcard auto-retry count (3 bits)
        bit_field_t<17, 0x7>::value<X>();
    static constexpr uint32_t CR3_DEP = 0x8000;         // Driver enable polarity selection
    static constexpr uint32_t CR3_DEM = 0x4000;         // Driver enable mode
    static constexpr uint32_t CR3_DDRE = 0x2000;        // DMA Disable on Reception Error
    static constexpr uint32_t CR3_OVRDIS = 0x1000;      // Overrun Disable
    static constexpr uint32_t CR3_ONEBIT = 0x800;       // One sample bit method enable
    static constexpr uint32_t CR3_CTSIE = 0x400;        // CTS interrupt enable
    static constexpr uint32_t CR3_CTSE = 0x200;         // CTS enable
    static constexpr uint32_t CR3_RTSE = 0x100;         // RTS enable
    static constexpr uint32_t CR3_DMAT = 0x80;          // DMA enable transmitter
    static constexpr uint32_t CR3_DMAR = 0x40;          // DMA enable receiver
    static constexpr uint32_t CR3_SCEN = 0x20;          // Smartcard mode enable
    static constexpr uint32_t CR3_NACK = 0x10;          // Smartcard NACK enable
    static constexpr uint32_t CR3_HDSEL = 0x8;          // Half-duplex selection
    static constexpr uint32_t CR3_IRLP = 0x4;           // Ir low-power
    static constexpr uint32_t CR3_IREN = 0x2;           // Ir mode enable
    static constexpr uint32_t CR3_EIE = 0x1;            // Error interrupt enable
    static const uint32_t CR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BRR_BRR_4_15 =            // DIV_Mantissa (12 bits)
        bit_field_t<4, 0xfff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BRR_BRR_0_3 =             // DIV_Fraction (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t BRR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t GTPR_GT =                  // Guard time value (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GTPR_PSC =                 // Prescaler value (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t GTPR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RTOR_BLEN =                // Block Length (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RTOR_RTO =                 // Receiver timeout value (24 bits)
        bit_field_t<0, 0xffffff>::value<X>();
    static const uint32_t RTOR_RESET_VALUE = 0x0;

    static constexpr uint32_t RQR_TXFRQ = 0x10;         // Transmit data flush request
    static constexpr uint32_t RQR_RXFRQ = 0x8;          // Receive data flush request
    static constexpr uint32_t RQR_MMRQ = 0x4;           // Mute mode request
    static constexpr uint32_t RQR_SBKRQ = 0x2;          // Send break request
    static constexpr uint32_t RQR_ABRRQ = 0x1;          // Auto baud rate request
    static const uint32_t RQR_RESET_VALUE = 0x0;

    static constexpr uint32_t ISR_TXFT = 0x8000000;     // TXFIFO threshold flag
    static constexpr uint32_t ISR_RXFT = 0x4000000;     // RXFIFO threshold flag
    static constexpr uint32_t ISR_TCBGT = 0x2000000;    // Transmission complete before guard time flag
    static constexpr uint32_t ISR_RXFF = 0x1000000;     // RXFIFO Full
    static constexpr uint32_t ISR_TXFE = 0x800000;      // TXFIFO Empty
    static constexpr uint32_t ISR_REACK = 0x400000;     // REACK
    static constexpr uint32_t ISR_TEACK = 0x200000;     // TEACK
    static constexpr uint32_t ISR_WUF = 0x100000;       // WUF
    static constexpr uint32_t ISR_RWU = 0x80000;        // RWU
    static constexpr uint32_t ISR_SBKF = 0x40000;       // SBKF
    static constexpr uint32_t ISR_CMF = 0x20000;        // CMF
    static constexpr uint32_t ISR_BUSY = 0x10000;       // BUSY
    static constexpr uint32_t ISR_ABRF = 0x8000;        // ABRF
    static constexpr uint32_t ISR_ABRE = 0x4000;        // ABRE
    static constexpr uint32_t ISR_UDR = 0x2000;         // SPI slave underrun error flag
    static constexpr uint32_t ISR_EOBF = 0x1000;        // EOBF
    static constexpr uint32_t ISR_RTOF = 0x800;         // RTOF
    static constexpr uint32_t ISR_CTS = 0x400;          // CTS
    static constexpr uint32_t ISR_CTSIF = 0x200;        // CTSIF
    static constexpr uint32_t ISR_LBDF = 0x100;         // LBDF
    static constexpr uint32_t ISR_TXE = 0x80;           // TXE
    static constexpr uint32_t ISR_TC = 0x40;            // TC
    static constexpr uint32_t ISR_RXNE = 0x20;          // RXNE
    static constexpr uint32_t ISR_IDLE = 0x10;          // IDLE
    static constexpr uint32_t ISR_ORE = 0x8;            // ORE
    static constexpr uint32_t ISR_NF = 0x4;             // NF
    static constexpr uint32_t ISR_FE = 0x2;             // FE
    static constexpr uint32_t ISR_PE = 0x1;             // PE
    static const uint32_t ISR_RESET_VALUE = 0xc0;

    static constexpr uint32_t ICR_WUCF = 0x100000;      // Wakeup from Stop mode clear flag
    static constexpr uint32_t ICR_CMCF = 0x20000;       // Character match clear flag
    static constexpr uint32_t ICR_UDRCF = 0x2000;       // SPI slave underrun clear flag
    static constexpr uint32_t ICR_EOBCF = 0x1000;       // End of block clear flag
    static constexpr uint32_t ICR_RTOCF = 0x800;        // Receiver timeout clear flag
    static constexpr uint32_t ICR_CTSCF = 0x200;        // CTS clear flag
    static constexpr uint32_t ICR_LBDCF = 0x100;        // LIN break detection clear flag
    static constexpr uint32_t ICR_TCBGTC = 0x80;        // Transmission complete before Guard time clear flag
    static constexpr uint32_t ICR_TCCF = 0x40;          // Transmission complete clear flag
    static constexpr uint32_t ICR_TXFECF = 0x20;        // TXFIFO empty clear flag
    static constexpr uint32_t ICR_IDLECF = 0x10;        // Idle line detected clear flag
    static constexpr uint32_t ICR_ORECF = 0x8;          // Overrun error clear flag
    static constexpr uint32_t ICR_NCF = 0x4;            // Noise detected clear flag
    static constexpr uint32_t ICR_FECF = 0x2;           // Framing error clear flag
    static constexpr uint32_t ICR_PECF = 0x1;           // Parity error clear flag
    static const uint32_t ICR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RDR_RDR =                 // Receive data value (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static const uint32_t RDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDR_TDR =                 // Transmit data value (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static const uint32_t TDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PRESC_PRESCALER =           // Clock prescaler (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t PRESC_RESET_VALUE = 0x0;

    static constexpr uint8_t UART7 = 82; // UART7 global interrupt
};

static uart7_t& UART7 = *reinterpret_cast<uart7_t*>(0x40007800);

#define HAVE_PERIPHERAL_UART7


////
//
//    Universal synchronous asynchronous receiver transmitter
//
////

struct uart8_t
{
    volatile uint32_t    CR1;                  // [Read-write] Control register 1
    volatile uint32_t    CR2;                  // [Read-write] Control register 2
    volatile uint32_t    CR3;                  // [Read-write] Control register 3
    volatile uint32_t    BRR;                  // [Read-write] Baud rate register
    volatile uint32_t    GTPR;                 // [Read-write] Guard time and prescaler register
    volatile uint32_t    RTOR;                 // [Read-write] Receiver timeout register
    volatile uint32_t    RQR;                  // [Write-only] Request register
    volatile uint32_t    ISR;                  // [Read-only] Interrupt &amp; status register
    volatile uint32_t    ICR;                  // [Write-only] Interrupt flag clear register
    volatile uint32_t    RDR;                  // [Read-only] Receive data register
    volatile uint32_t    TDR;                  // [Read-write] Transmit data register
    volatile uint32_t    PRESC;                // [Read-write] USART prescaler register

    static constexpr uint32_t CR1_RXFFIE = 0x80000000;  // RXFIFO Full interrupt enable
    static constexpr uint32_t CR1_TXFEIE = 0x40000000;  // TXFIFO empty interrupt enable
    static constexpr uint32_t CR1_FIFOEN = 0x20000000;  // FIFO mode enable
    static constexpr uint32_t CR1_M1 = 0x10000000;      // Word length
    static constexpr uint32_t CR1_EOBIE = 0x8000000;    // End of Block interrupt enable
    static constexpr uint32_t CR1_RTOIE = 0x4000000;    // Receiver timeout interrupt enable
    static constexpr uint32_t CR1_DEAT4 = 0x2000000;    // Driver Enable assertion time
    static constexpr uint32_t CR1_DEAT3 = 0x1000000;    // DEAT3
    static constexpr uint32_t CR1_DEAT2 = 0x800000;     // DEAT2
    static constexpr uint32_t CR1_DEAT1 = 0x400000;     // DEAT1
    static constexpr uint32_t CR1_DEAT0 = 0x200000;     // DEAT0
    static constexpr uint32_t CR1_DEDT4 = 0x100000;     // Driver Enable de-assertion time
    static constexpr uint32_t CR1_DEDT3 = 0x80000;      // DEDT3
    static constexpr uint32_t CR1_DEDT2 = 0x40000;      // DEDT2
    static constexpr uint32_t CR1_DEDT1 = 0x20000;      // DEDT1
    static constexpr uint32_t CR1_DEDT0 = 0x10000;      // DEDT0
    static constexpr uint32_t CR1_OVER8 = 0x8000;       // Oversampling mode
    static constexpr uint32_t CR1_CMIE = 0x4000;        // Character match interrupt enable
    static constexpr uint32_t CR1_MME = 0x2000;         // Mute mode enable
    static constexpr uint32_t CR1_M0 = 0x1000;          // Word length
    static constexpr uint32_t CR1_WAKE = 0x800;         // Receiver wakeup method
    static constexpr uint32_t CR1_PCE = 0x400;          // Parity control enable
    static constexpr uint32_t CR1_PS = 0x200;           // Parity selection
    static constexpr uint32_t CR1_PEIE = 0x100;         // PE interrupt enable
    static constexpr uint32_t CR1_TXEIE = 0x80;         // interrupt enable
    static constexpr uint32_t CR1_TCIE = 0x40;          // Transmission complete interrupt enable
    static constexpr uint32_t CR1_RXNEIE = 0x20;        // RXNE interrupt enable
    static constexpr uint32_t CR1_IDLEIE = 0x10;        // IDLE interrupt enable
    static constexpr uint32_t CR1_TE = 0x8;             // Transmitter enable
    static constexpr uint32_t CR1_RE = 0x4;             // Receiver enable
    static constexpr uint32_t CR1_UESM = 0x2;           // USART enable in Stop mode
    static constexpr uint32_t CR1_UE = 0x1;             // USART enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CR2_ADD4_7 =              // Address of the USART node (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR2_ADD0_3 =              // Address of the USART node (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    static constexpr uint32_t CR2_RTOEN = 0x800000;     // Receiver timeout enable
    static constexpr uint32_t CR2_ABRMOD1 = 0x400000;   // Auto baud rate mode
    static constexpr uint32_t CR2_ABRMOD0 = 0x200000;   // ABRMOD0
    static constexpr uint32_t CR2_ABREN = 0x100000;     // Auto baud rate enable
    static constexpr uint32_t CR2_MSBFIRST = 0x80000;   // Most significant bit first
    static constexpr uint32_t CR2_TAINV = 0x40000;      // Binary data inversion
    static constexpr uint32_t CR2_TXINV = 0x20000;      // TX pin active level inversion
    static constexpr uint32_t CR2_RXINV = 0x10000;      // RX pin active level inversion
    static constexpr uint32_t CR2_SWAP = 0x8000;        // Swap TX/RX pins
    static constexpr uint32_t CR2_LINEN = 0x4000;       // LIN mode enable
    template<uint32_t X>
    static constexpr uint32_t CR2_STOP =                // STOP bits (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    static constexpr uint32_t CR2_CLKEN = 0x800;        // Clock enable
    static constexpr uint32_t CR2_CPOL = 0x400;         // Clock polarity
    static constexpr uint32_t CR2_CPHA = 0x200;         // Clock phase
    static constexpr uint32_t CR2_LBCL = 0x100;         // Last bit clock pulse
    static constexpr uint32_t CR2_LBDIE = 0x40;         // LIN break detection interrupt enable
    static constexpr uint32_t CR2_LBDL = 0x20;          // LIN break detection length
    static constexpr uint32_t CR2_ADDM7 = 0x10;         // 7-bit Address Detection/4-bit Address Detection
    static constexpr uint32_t CR2_DIS_NSS = 0x8;        // When the DSI_NSS bit is set, the NSS pin input is ignored
    static constexpr uint32_t CR2_SLVEN = 0x1;          // Synchronous Slave mode enable
    static const uint32_t CR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CR3_TXFTCFG =             // TXFIFO threshold configuration (3 bits)
        bit_field_t<29, 0x7>::value<X>();
    static constexpr uint32_t CR3_RXFTIE = 0x10000000;  // RXFIFO threshold interrupt enable
    template<uint32_t X>
    static constexpr uint32_t CR3_RXFTCFG =             // Receive FIFO threshold configuration (3 bits)
        bit_field_t<25, 0x7>::value<X>();
    static constexpr uint32_t CR3_TCBGTIE = 0x1000000;  // Transmission Complete before guard time, interrupt enable
    static constexpr uint32_t CR3_TXFTIE = 0x800000;    // TXFIFO threshold interrupt enable
    static constexpr uint32_t CR3_WUFIE = 0x400000;     // Wakeup from Stop mode interrupt enable
    template<uint32_t X>
    static constexpr uint32_t CR3_WUS =                 // Wakeup from Stop mode interrupt flag selection (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR3_SCARCNT =             // Smartcard auto-retry count (3 bits)
        bit_field_t<17, 0x7>::value<X>();
    static constexpr uint32_t CR3_DEP = 0x8000;         // Driver enable polarity selection
    static constexpr uint32_t CR3_DEM = 0x4000;         // Driver enable mode
    static constexpr uint32_t CR3_DDRE = 0x2000;        // DMA Disable on Reception Error
    static constexpr uint32_t CR3_OVRDIS = 0x1000;      // Overrun Disable
    static constexpr uint32_t CR3_ONEBIT = 0x800;       // One sample bit method enable
    static constexpr uint32_t CR3_CTSIE = 0x400;        // CTS interrupt enable
    static constexpr uint32_t CR3_CTSE = 0x200;         // CTS enable
    static constexpr uint32_t CR3_RTSE = 0x100;         // RTS enable
    static constexpr uint32_t CR3_DMAT = 0x80;          // DMA enable transmitter
    static constexpr uint32_t CR3_DMAR = 0x40;          // DMA enable receiver
    static constexpr uint32_t CR3_SCEN = 0x20;          // Smartcard mode enable
    static constexpr uint32_t CR3_NACK = 0x10;          // Smartcard NACK enable
    static constexpr uint32_t CR3_HDSEL = 0x8;          // Half-duplex selection
    static constexpr uint32_t CR3_IRLP = 0x4;           // Ir low-power
    static constexpr uint32_t CR3_IREN = 0x2;           // Ir mode enable
    static constexpr uint32_t CR3_EIE = 0x1;            // Error interrupt enable
    static const uint32_t CR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BRR_BRR_4_15 =            // DIV_Mantissa (12 bits)
        bit_field_t<4, 0xfff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BRR_BRR_0_3 =             // DIV_Fraction (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t BRR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t GTPR_GT =                  // Guard time value (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GTPR_PSC =                 // Prescaler value (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t GTPR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RTOR_BLEN =                // Block Length (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RTOR_RTO =                 // Receiver timeout value (24 bits)
        bit_field_t<0, 0xffffff>::value<X>();
    static const uint32_t RTOR_RESET_VALUE = 0x0;

    static constexpr uint32_t RQR_TXFRQ = 0x10;         // Transmit data flush request
    static constexpr uint32_t RQR_RXFRQ = 0x8;          // Receive data flush request
    static constexpr uint32_t RQR_MMRQ = 0x4;           // Mute mode request
    static constexpr uint32_t RQR_SBKRQ = 0x2;          // Send break request
    static constexpr uint32_t RQR_ABRRQ = 0x1;          // Auto baud rate request
    static const uint32_t RQR_RESET_VALUE = 0x0;

    static constexpr uint32_t ISR_TXFT = 0x8000000;     // TXFIFO threshold flag
    static constexpr uint32_t ISR_RXFT = 0x4000000;     // RXFIFO threshold flag
    static constexpr uint32_t ISR_TCBGT = 0x2000000;    // Transmission complete before guard time flag
    static constexpr uint32_t ISR_RXFF = 0x1000000;     // RXFIFO Full
    static constexpr uint32_t ISR_TXFE = 0x800000;      // TXFIFO Empty
    static constexpr uint32_t ISR_REACK = 0x400000;     // REACK
    static constexpr uint32_t ISR_TEACK = 0x200000;     // TEACK
    static constexpr uint32_t ISR_WUF = 0x100000;       // WUF
    static constexpr uint32_t ISR_RWU = 0x80000;        // RWU
    static constexpr uint32_t ISR_SBKF = 0x40000;       // SBKF
    static constexpr uint32_t ISR_CMF = 0x20000;        // CMF
    static constexpr uint32_t ISR_BUSY = 0x10000;       // BUSY
    static constexpr uint32_t ISR_ABRF = 0x8000;        // ABRF
    static constexpr uint32_t ISR_ABRE = 0x4000;        // ABRE
    static constexpr uint32_t ISR_UDR = 0x2000;         // SPI slave underrun error flag
    static constexpr uint32_t ISR_EOBF = 0x1000;        // EOBF
    static constexpr uint32_t ISR_RTOF = 0x800;         // RTOF
    static constexpr uint32_t ISR_CTS = 0x400;          // CTS
    static constexpr uint32_t ISR_CTSIF = 0x200;        // CTSIF
    static constexpr uint32_t ISR_LBDF = 0x100;         // LBDF
    static constexpr uint32_t ISR_TXE = 0x80;           // TXE
    static constexpr uint32_t ISR_TC = 0x40;            // TC
    static constexpr uint32_t ISR_RXNE = 0x20;          // RXNE
    static constexpr uint32_t ISR_IDLE = 0x10;          // IDLE
    static constexpr uint32_t ISR_ORE = 0x8;            // ORE
    static constexpr uint32_t ISR_NF = 0x4;             // NF
    static constexpr uint32_t ISR_FE = 0x2;             // FE
    static constexpr uint32_t ISR_PE = 0x1;             // PE
    static const uint32_t ISR_RESET_VALUE = 0xc0;

    static constexpr uint32_t ICR_WUCF = 0x100000;      // Wakeup from Stop mode clear flag
    static constexpr uint32_t ICR_CMCF = 0x20000;       // Character match clear flag
    static constexpr uint32_t ICR_UDRCF = 0x2000;       // SPI slave underrun clear flag
    static constexpr uint32_t ICR_EOBCF = 0x1000;       // End of block clear flag
    static constexpr uint32_t ICR_RTOCF = 0x800;        // Receiver timeout clear flag
    static constexpr uint32_t ICR_CTSCF = 0x200;        // CTS clear flag
    static constexpr uint32_t ICR_LBDCF = 0x100;        // LIN break detection clear flag
    static constexpr uint32_t ICR_TCBGTC = 0x80;        // Transmission complete before Guard time clear flag
    static constexpr uint32_t ICR_TCCF = 0x40;          // Transmission complete clear flag
    static constexpr uint32_t ICR_TXFECF = 0x20;        // TXFIFO empty clear flag
    static constexpr uint32_t ICR_IDLECF = 0x10;        // Idle line detected clear flag
    static constexpr uint32_t ICR_ORECF = 0x8;          // Overrun error clear flag
    static constexpr uint32_t ICR_NCF = 0x4;            // Noise detected clear flag
    static constexpr uint32_t ICR_FECF = 0x2;           // Framing error clear flag
    static constexpr uint32_t ICR_PECF = 0x1;           // Parity error clear flag
    static const uint32_t ICR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RDR_RDR =                 // Receive data value (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static const uint32_t RDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDR_TDR =                 // Transmit data value (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static const uint32_t TDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PRESC_PRESCALER =           // Clock prescaler (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t PRESC_RESET_VALUE = 0x0;

    static constexpr uint8_t UART8 = 83; // UART8 global interrupt
};

static uart8_t& UART8 = *reinterpret_cast<uart8_t*>(0x40007c00);

#define HAVE_PERIPHERAL_UART8


////
//
//    Advanced-timers
//
////

struct tim1_t
{
    volatile uint32_t    CR1;                  // [Read-write] control register 1
    volatile uint32_t    CR2;                  // [Read-write] control register 2
    volatile uint32_t    SMCR;                 // [Read-write] slave mode control register
    volatile uint32_t    DIER;                 // [Read-write] DMA/Interrupt enable register
    volatile uint32_t    SR;                   // [Read-write] status register
    volatile uint32_t    EGR;                  // [Write-only] event generation register
    volatile uint32_t    CCMR1;                // [Read-write] capture/compare mode register 1 (output mode)
    volatile uint32_t    CCMR2;                // [Read-write] capture/compare mode register 2 (output mode)
    volatile uint32_t    CCER;                 // [Read-write] capture/compare enable register
    volatile uint32_t    CNT;                  // counter
    volatile uint32_t    PSC;                  // [Read-write] prescaler
    volatile uint32_t    ARR;                  // [Read-write] auto-reload register
    volatile uint32_t    RCR;                  // [Read-write] repetition counter register
    volatile uint32_t    CCR1;                 // [Read-write] capture/compare register 1
    volatile uint32_t    CCR2;                 // [Read-write] capture/compare register 2
    volatile uint32_t    CCR3;                 // [Read-write] capture/compare register 3
    volatile uint32_t    CCR4;                 // [Read-write] capture/compare register 4
    volatile uint32_t    BDTR;                 // [Read-write] break and dead-time register
    volatile uint32_t    DCR;                  // [Read-write] DMA control register
    volatile uint32_t    DMAR;                 // [Read-write] DMA address for full transfer
    reserved_t<1>        _0;
    volatile uint32_t    CCMR3_Output;         // [Read-write] capture/compare mode register 3 (output mode)
    volatile uint32_t    CCR5;                 // [Read-write] capture/compare register 5
    volatile uint32_t    CRR6;                 // [Read-write] capture/compare register 6
    volatile uint32_t    AF1;                  // [Read-write] TIM1 alternate function option register 1
    volatile uint32_t    AF2;                  // [Read-write] TIM1 Alternate function odfsdm1_breakster 2
    volatile uint32_t    TISEL;                // [Read-write] TIM1 timer input selection register

    static constexpr uint32_t CR1_CEN = 0x1;            // Counter enable
    static constexpr uint32_t CR1_UDIS = 0x2;           // Update disable
    static constexpr uint32_t CR1_URS = 0x4;            // Update request source
    static constexpr uint32_t CR1_OPM = 0x8;            // One-pulse mode
    static constexpr uint32_t CR1_DIR = 0x10;           // Direction
    template<uint32_t X>
    static constexpr uint32_t CR1_CMS =                 // Center-aligned mode selection (2 bits)
        bit_field_t<5, 0x3>::value<X>();
    static constexpr uint32_t CR1_ARPE = 0x80;          // Auto-reload preload enable
    template<uint32_t X>
    static constexpr uint32_t CR1_CKD =                 // Clock division (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t CR1_UIFREMAP = 0x800;     // UIF status bit remapping
    static const uint32_t CR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CR2_MMS2 =                // Master mode selection 2 (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    static constexpr uint32_t CR2_OIS6 = 0x40000;       // Output Idle state 6
    static constexpr uint32_t CR2_OIS5 = 0x10000;       // Output Idle state 5
    static constexpr uint32_t CR2_OIS4 = 0x4000;        // Output Idle state 4
    static constexpr uint32_t CR2_OIS3N = 0x2000;       // Output Idle state 3
    static constexpr uint32_t CR2_OIS3 = 0x1000;        // Output Idle state 3
    static constexpr uint32_t CR2_OIS2N = 0x800;        // Output Idle state 2
    static constexpr uint32_t CR2_OIS2 = 0x400;         // Output Idle state 2
    static constexpr uint32_t CR2_OIS1N = 0x200;        // Output Idle state 1
    static constexpr uint32_t CR2_OIS1 = 0x100;         // Output Idle state 1
    static constexpr uint32_t CR2_TI1S = 0x80;          // TI1 selection
    template<uint32_t X>
    static constexpr uint32_t CR2_MMS =                 // Master mode selection (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CR2_CCDS = 0x8;           // Capture/compare DMA selection
    static constexpr uint32_t CR2_CCUS = 0x4;           // Capture/compare control update selection
    static constexpr uint32_t CR2_CCPC = 0x1;           // Capture/compare preloaded control
    static const uint32_t CR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SMCR_SMS =                 // Slave mode selection (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMCR_TS =                  // Trigger selection (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t SMCR_MSM = 0x80;           // Master/Slave mode
    template<uint32_t X>
    static constexpr uint32_t SMCR_ETF =                 // External trigger filter (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMCR_ETPS =                // External trigger prescaler (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    static constexpr uint32_t SMCR_ECE = 0x4000;         // External clock enable
    static constexpr uint32_t SMCR_ETP = 0x8000;         // External trigger polarity
    static constexpr uint32_t SMCR_SMS_3 = 0x10000;      // Slave mode selection - bit 3
    template<uint32_t X>
    static constexpr uint32_t SMCR_TS_4_3 =              // Trigger selection - bit 4:3 (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    static const uint32_t SMCR_RESET_VALUE = 0x0;

    static constexpr uint32_t DIER_TDE = 0x4000;         // Trigger DMA request enable
    static constexpr uint32_t DIER_COMDE = 0x2000;       // COM DMA request enable
    static constexpr uint32_t DIER_CC4DE = 0x1000;       // Capture/Compare 4 DMA request enable
    static constexpr uint32_t DIER_CC3DE = 0x800;        // Capture/Compare 3 DMA request enable
    static constexpr uint32_t DIER_CC2DE = 0x400;        // Capture/Compare 2 DMA request enable
    static constexpr uint32_t DIER_CC1DE = 0x200;        // Capture/Compare 1 DMA request enable
    static constexpr uint32_t DIER_UDE = 0x100;          // Update DMA request enable
    static constexpr uint32_t DIER_TIE = 0x40;           // Trigger interrupt enable
    static constexpr uint32_t DIER_CC4IE = 0x10;         // Capture/Compare 4 interrupt enable
    static constexpr uint32_t DIER_CC3IE = 0x8;          // Capture/Compare 3 interrupt enable
    static constexpr uint32_t DIER_CC2IE = 0x4;          // Capture/Compare 2 interrupt enable
    static constexpr uint32_t DIER_CC1IE = 0x2;          // Capture/Compare 1 interrupt enable
    static constexpr uint32_t DIER_UIE = 0x1;            // Update interrupt enable
    static constexpr uint32_t DIER_BIE = 0x80;           // Break interrupt enable
    static constexpr uint32_t DIER_COMIE = 0x20;         // COM interrupt enable
    static const uint32_t DIER_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_CC6IF = 0x20000;      // Compare 6 interrupt flag
    static constexpr uint32_t SR_CC5IF = 0x10000;      // Compare 5 interrupt flag
    static constexpr uint32_t SR_SBIF = 0x2000;        // System Break interrupt flag
    static constexpr uint32_t SR_CC4OF = 0x1000;       // Capture/Compare 4 overcapture flag
    static constexpr uint32_t SR_CC3OF = 0x800;        // Capture/Compare 3 overcapture flag
    static constexpr uint32_t SR_CC2OF = 0x400;        // Capture/compare 2 overcapture flag
    static constexpr uint32_t SR_CC1OF = 0x200;        // Capture/Compare 1 overcapture flag
    static constexpr uint32_t SR_B2IF = 0x100;         // Break 2 interrupt flag
    static constexpr uint32_t SR_BIF = 0x80;           // Break interrupt flag
    static constexpr uint32_t SR_TIF = 0x40;           // Trigger interrupt flag
    static constexpr uint32_t SR_COMIF = 0x20;         // COM interrupt flag
    static constexpr uint32_t SR_CC4IF = 0x10;         // Capture/Compare 4 interrupt flag
    static constexpr uint32_t SR_CC3IF = 0x8;          // Capture/Compare 3 interrupt flag
    static constexpr uint32_t SR_CC2IF = 0x4;          // Capture/Compare 2 interrupt flag
    static constexpr uint32_t SR_CC1IF = 0x2;          // Capture/compare 1 interrupt flag
    static constexpr uint32_t SR_UIF = 0x1;            // Update interrupt flag
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint32_t EGR_UG = 0x1;             // Update generation
    static constexpr uint32_t EGR_CC1G = 0x2;           // Capture/compare 1 generation
    static constexpr uint32_t EGR_CC2G = 0x4;           // Capture/compare 2 generation
    static constexpr uint32_t EGR_CC3G = 0x8;           // Capture/compare 3 generation
    static constexpr uint32_t EGR_CC4G = 0x10;          // Capture/compare 4 generation
    static constexpr uint32_t EGR_COMG = 0x20;          // Capture/Compare control update generation
    static constexpr uint32_t EGR_TG = 0x40;            // Trigger generation
    static constexpr uint32_t EGR_BG = 0x80;            // Break generation
    static constexpr uint32_t EGR_B2G = 0x100;          // Break 2 generation
    static const uint32_t EGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCMR1_CC1S =                // Capture/Compare 1 selection (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_CC2S =                // Capture/Compare 2 selection (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC1F =                // Input capture 1 filter (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC2F =                // Input capture 2 filter (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC2PCS =              // Input capture 2 prescaler (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_ICPCS =               // Input capture 1 prescaler (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t CCMR1_OC1CE = 0x80;         // Output Compare 1 clear enable
    static constexpr uint32_t CCMR1_OC1FE = 0x4;          // Output Compare 1 fast enable
    template<uint32_t X>
    static constexpr uint32_t CCMR1_OC1M =                // Output Compare 1 mode (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR1_OC1M_3 = 0x10000;     // Output Compare 1 mode - bit 3
    static constexpr uint32_t CCMR1_OC1PE = 0x8;          // Output Compare 1 preload enable
    static constexpr uint32_t CCMR1_OC2CE = 0x8000;       // Output Compare 2 clear enable
    static constexpr uint32_t CCMR1_OC2FE = 0x400;        // Output Compare 2 fast enable
    template<uint32_t X>
    static constexpr uint32_t CCMR1_OC2M =                // Output Compare 2 mode (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    static constexpr uint32_t CCMR1_OC2M_3 = 0x1000000;   // Output Compare 2 mode - bit 3
    static constexpr uint32_t CCMR1_OC2PE = 0x800;        // Output Compare 2 preload enable
    static const uint32_t CCMR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCMR2_CC3S =                // Capture/Compare 3 selection (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_CC4S =                // Capture/Compare 4 selection (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC3F =                // Input capture 3 filter (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC3PSC =              // Input capture 3 prescaler (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC4F =                // Input capture 4 filter (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC4PSC =              // Input capture 4 prescaler (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    static constexpr uint32_t CCMR2_OC3CE = 0x80;         // Output compare 3 clear enable
    static constexpr uint32_t CCMR2_OC3FE = 0x4;          // Output compare 3 fast enable
    template<uint32_t X>
    static constexpr uint32_t CCMR2_OC3M =                // Output compare 3 mode (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR2_OC3M_3 = 0x10000;     // Output Compare 3 mode - bit 3
    static constexpr uint32_t CCMR2_OC3PE = 0x8;          // Output compare 3 preload enable
    static constexpr uint32_t CCMR2_OC4CE = 0x8000;       // Output compare 4 clear enable
    static constexpr uint32_t CCMR2_OC4FE = 0x400;        // Output compare 4 fast enable
    template<uint32_t X>
    static constexpr uint32_t CCMR2_OC4M =                // Output compare 4 mode (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    static constexpr uint32_t CCMR2_OC4M_4 = 0x1000000;   // Output Compare 4 mode - bit 3
    static constexpr uint32_t CCMR2_OC4PE = 0x800;        // Output compare 4 preload enable
    static const uint32_t CCMR2_RESET_VALUE = 0x0;

    static constexpr uint32_t CCER_CC1E = 0x1;           // Capture/Compare 1 output enable
    static constexpr uint32_t CCER_CC1P = 0x2;           // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1NE = 0x4;          // Capture/Compare 1 complementary output enable
    static constexpr uint32_t CCER_CC1NP = 0x8;          // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC2E = 0x10;          // Capture/Compare 2 output enable
    static constexpr uint32_t CCER_CC2P = 0x20;          // Capture/Compare 2 output Polarity
    static constexpr uint32_t CCER_CC2NE = 0x40;         // Capture/Compare 2 complementary output enable
    static constexpr uint32_t CCER_CC2NP = 0x80;         // Capture/Compare 2 output Polarity
    static constexpr uint32_t CCER_CC3E = 0x100;         // Capture/Compare 3 output enable
    static constexpr uint32_t CCER_CC3P = 0x200;         // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC3NE = 0x400;        // Capture/Compare 3 complementary output enable
    static constexpr uint32_t CCER_CC3NP = 0x800;        // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC4E = 0x1000;        // Capture/Compare 4 output enable
    static constexpr uint32_t CCER_CC4P = 0x2000;        // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC4NP = 0x8000;       // Capture/Compare 4 complementary output polarity
    static constexpr uint32_t CCER_CC5E = 0x10000;       // Capture/Compare 5 output enable
    static constexpr uint32_t CCER_CC5P = 0x20000;       // Capture/Compare 5 output polarity
    static constexpr uint32_t CCER_CC6E = 0x100000;      // Capture/Compare 6 output enable
    static constexpr uint32_t CCER_CC6P = 0x200000;      // Capture/Compare 6 output polarity
    static const uint32_t CCER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CNT_CNT =                 // counter value (16 bits), Read-write
        bit_field_t<0, 0xffff>::value<X>();
    static constexpr uint32_t CNT_UIFCPY = 0x80000000;  // UIF copy, Read-only
    static const uint32_t CNT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PSC_PSC =                 // Prescaler value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t PSC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ARR_ARR =                 // Auto-reload value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t ARR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RCR_REP =                 // Repetition counter value (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t RCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR1_CCR1 =                // Capture/Compare 1 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR2_CCR2 =                // Capture/Compare 2 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR3_CCR3 =                // Capture/Compare value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR4_CCR4 =                // Capture/Compare value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BDTR_DTG =                 // Dead-time generator setup (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BDTR_LOCK =                // Lock configuration (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t BDTR_OSSI = 0x400;         // Off-state selection for Idle mode
    static constexpr uint32_t BDTR_OSSR = 0x800;         // Off-state selection for Run mode
    static constexpr uint32_t BDTR_BKE = 0x1000;         // Break enable
    static constexpr uint32_t BDTR_BKP = 0x2000;         // Break polarity
    static constexpr uint32_t BDTR_AOE = 0x4000;         // Automatic output enable
    static constexpr uint32_t BDTR_MOE = 0x8000;         // Main output enable
    template<uint32_t X>
    static constexpr uint32_t BDTR_BKF =                 // Break filter (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BDTR_BK2F =                // Break 2 filter (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    static constexpr uint32_t BDTR_BK2E = 0x1000000;     // Break 2 enable
    static constexpr uint32_t BDTR_BK2P = 0x2000000;     // Break 2 polarity
    static const uint32_t BDTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DCR_DBL =                 // DMA burst length (5 bits)
        bit_field_t<8, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DCR_DBA =                 // DMA base address (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t DCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DMAR_DMAB =                // DMA register for burst accesses (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DMAR_RESET_VALUE = 0x0;

    static constexpr uint32_t CCMR3_Output_OC5FE = 0x4;          // Output compare 5 fast enable
    static constexpr uint32_t CCMR3_Output_OC5PE = 0x8;          // Output compare 5 preload enable
    template<uint32_t X>
    static constexpr uint32_t CCMR3_Output_OC5M =                // Output compare 5 mode (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR3_Output_OC5CE = 0x80;         // Output compare 5 clear enable
    static constexpr uint32_t CCMR3_Output_OC6FE = 0x400;        // Output compare 6 fast enable
    static constexpr uint32_t CCMR3_Output_OC6PE = 0x800;        // Output compare 6 preload enable
    template<uint32_t X>
    static constexpr uint32_t CCMR3_Output_OC6M =                // Output compare 6 mode (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    static constexpr uint32_t CCMR3_Output_OC6CE = 0x8000;       // Output compare 6 clear enable
    static constexpr uint32_t CCMR3_Output_OC5M3 = 0x10000;      // Output Compare 5 mode
    static constexpr uint32_t CCMR3_Output_OC6M3 = 0x1000000;    // Output Compare 6 mode
    static const uint32_t CCMR3_Output_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR5_CCR5 =                // Capture/Compare 5 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static constexpr uint32_t CCR5_GC5C1 = 0x20000000;   // Group Channel 5 and Channel 1
    static constexpr uint32_t CCR5_GC5C2 = 0x40000000;   // Group Channel 5 and Channel 2
    static constexpr uint32_t CCR5_GC5C3 = 0x80000000;   // Group Channel 5 and Channel 3
    static const uint32_t CCR5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CRR6_CCR6 =                // Capture/Compare 6 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CRR6_RESET_VALUE = 0x0;

    static constexpr uint32_t AF1_BKINE = 0x1;          // BRK BKIN input enable
    static constexpr uint32_t AF1_BKCMP1E = 0x2;        // BRK COMP1 enable
    static constexpr uint32_t AF1_BKCMP2E = 0x4;        // BRK COMP2 enable
    static constexpr uint32_t AF1_BKDF1BK0E = 0x100;    // BRK dfsdm1_break[0] enable
    static constexpr uint32_t AF1_BKINP = 0x200;        // BRK BKIN input polarity
    static constexpr uint32_t AF1_BKCMP1P = 0x400;      // BRK COMP1 input polarity
    static constexpr uint32_t AF1_BKCMP2P = 0x800;      // BRK COMP2 input polarity
    template<uint32_t X>
    static constexpr uint32_t AF1_ETRSEL =              // ETR source selection (4 bits)
        bit_field_t<14, 0xf>::value<X>();
    static const uint32_t AF1_RESET_VALUE = 0x0;

    static constexpr uint32_t AF2_BK2INE = 0x1;         // BRK2 BKIN input enable
    static constexpr uint32_t AF2_BK2CMP1E = 0x2;       // BRK2 COMP1 enable
    static constexpr uint32_t AF2_BK2CMP2E = 0x4;       // BRK2 COMP2 enable
    static constexpr uint32_t AF2_BK2DF1BK1E = 0x100;   // BRK2 dfsdm1_break[1] enable
    static constexpr uint32_t AF2_BK2INP = 0x200;       // BRK2 BKIN2 input polarity
    static constexpr uint32_t AF2_BK2CMP1P = 0x400;     // BRK2 COMP1 input polarit
    static constexpr uint32_t AF2_BK2CMP2P = 0x800;     // BRK2 COMP2 input polarity
    static const uint32_t AF2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TISEL_TI1SEL =              // selects TI1[0] to TI1[15] input (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TISEL_TI2SEL =              // selects TI2[0] to TI2[15] input (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TISEL_TI3SEL =              // selects TI3[0] to TI3[15] input (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TISEL_TI4SEL =              // selects TI4[0] to TI4[15] input (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    static const uint32_t TISEL_RESET_VALUE = 0x0;

    static constexpr uint8_t TIM1_BRK = 24; // TIM1 break interrupt
    static constexpr uint8_t TIM1_TRG_COM = 26; // TIM1 trigger and commutation
    static constexpr uint8_t TIM1_UP = 25; // TIM1 update interrupt
    static constexpr uint8_t TIM_CC = 27; // TIM1 capture / compare
};

static tim1_t& TIM1 = *reinterpret_cast<tim1_t*>(0x40010000);

#define HAVE_PERIPHERAL_TIM1


////
//
//    Advanced-timers
//
////

struct tim8_t
{
    volatile uint32_t    CR1;                  // [Read-write] control register 1
    volatile uint32_t    CR2;                  // [Read-write] control register 2
    volatile uint32_t    SMCR;                 // [Read-write] slave mode control register
    volatile uint32_t    DIER;                 // [Read-write] DMA/Interrupt enable register
    volatile uint32_t    SR;                   // [Read-write] status register
    volatile uint32_t    EGR;                  // [Write-only] event generation register
    volatile uint32_t    CCMR1;                // [Read-write] capture/compare mode register 1 (output mode)
    volatile uint32_t    CCMR2;                // [Read-write] capture/compare mode register 2 (output mode)
    volatile uint32_t    CCER;                 // [Read-write] capture/compare enable register
    volatile uint32_t    CNT;                  // counter
    volatile uint32_t    PSC;                  // [Read-write] prescaler
    volatile uint32_t    ARR;                  // [Read-write] auto-reload register
    volatile uint32_t    RCR;                  // [Read-write] repetition counter register
    volatile uint32_t    CCR1;                 // [Read-write] capture/compare register 1
    volatile uint32_t    CCR2;                 // [Read-write] capture/compare register 2
    volatile uint32_t    CCR3;                 // [Read-write] capture/compare register 3
    volatile uint32_t    CCR4;                 // [Read-write] capture/compare register 4
    volatile uint32_t    BDTR;                 // [Read-write] break and dead-time register
    volatile uint32_t    DCR;                  // [Read-write] DMA control register
    volatile uint32_t    DMAR;                 // [Read-write] DMA address for full transfer
    reserved_t<1>        _0;
    volatile uint32_t    CCMR3_Output;         // [Read-write] capture/compare mode register 3 (output mode)
    volatile uint32_t    CCR5;                 // [Read-write] capture/compare register 5
    volatile uint32_t    CRR6;                 // [Read-write] capture/compare register 6
    volatile uint32_t    AF1;                  // [Read-write] TIM1 alternate function option register 1
    volatile uint32_t    AF2;                  // [Read-write] TIM1 Alternate function odfsdm1_breakster 2
    volatile uint32_t    TISEL;                // [Read-write] TIM1 timer input selection register

    static constexpr uint32_t CR1_CEN = 0x1;            // Counter enable
    static constexpr uint32_t CR1_UDIS = 0x2;           // Update disable
    static constexpr uint32_t CR1_URS = 0x4;            // Update request source
    static constexpr uint32_t CR1_OPM = 0x8;            // One-pulse mode
    static constexpr uint32_t CR1_DIR = 0x10;           // Direction
    template<uint32_t X>
    static constexpr uint32_t CR1_CMS =                 // Center-aligned mode selection (2 bits)
        bit_field_t<5, 0x3>::value<X>();
    static constexpr uint32_t CR1_ARPE = 0x80;          // Auto-reload preload enable
    template<uint32_t X>
    static constexpr uint32_t CR1_CKD =                 // Clock division (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t CR1_UIFREMAP = 0x800;     // UIF status bit remapping
    static const uint32_t CR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CR2_MMS2 =                // Master mode selection 2 (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    static constexpr uint32_t CR2_OIS6 = 0x40000;       // Output Idle state 6
    static constexpr uint32_t CR2_OIS5 = 0x10000;       // Output Idle state 5
    static constexpr uint32_t CR2_OIS4 = 0x4000;        // Output Idle state 4
    static constexpr uint32_t CR2_OIS3N = 0x2000;       // Output Idle state 3
    static constexpr uint32_t CR2_OIS3 = 0x1000;        // Output Idle state 3
    static constexpr uint32_t CR2_OIS2N = 0x800;        // Output Idle state 2
    static constexpr uint32_t CR2_OIS2 = 0x400;         // Output Idle state 2
    static constexpr uint32_t CR2_OIS1N = 0x200;        // Output Idle state 1
    static constexpr uint32_t CR2_OIS1 = 0x100;         // Output Idle state 1
    static constexpr uint32_t CR2_TI1S = 0x80;          // TI1 selection
    template<uint32_t X>
    static constexpr uint32_t CR2_MMS =                 // Master mode selection (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CR2_CCDS = 0x8;           // Capture/compare DMA selection
    static constexpr uint32_t CR2_CCUS = 0x4;           // Capture/compare control update selection
    static constexpr uint32_t CR2_CCPC = 0x1;           // Capture/compare preloaded control
    static const uint32_t CR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SMCR_SMS =                 // Slave mode selection (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMCR_TS =                  // Trigger selection (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t SMCR_MSM = 0x80;           // Master/Slave mode
    template<uint32_t X>
    static constexpr uint32_t SMCR_ETF =                 // External trigger filter (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMCR_ETPS =                // External trigger prescaler (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    static constexpr uint32_t SMCR_ECE = 0x4000;         // External clock enable
    static constexpr uint32_t SMCR_ETP = 0x8000;         // External trigger polarity
    static constexpr uint32_t SMCR_SMS_3 = 0x10000;      // Slave mode selection - bit 3
    template<uint32_t X>
    static constexpr uint32_t SMCR_TS_4_3 =              // Trigger selection - bit 4:3 (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    static const uint32_t SMCR_RESET_VALUE = 0x0;

    static constexpr uint32_t DIER_TDE = 0x4000;         // Trigger DMA request enable
    static constexpr uint32_t DIER_COMDE = 0x2000;       // COM DMA request enable
    static constexpr uint32_t DIER_CC4DE = 0x1000;       // Capture/Compare 4 DMA request enable
    static constexpr uint32_t DIER_CC3DE = 0x800;        // Capture/Compare 3 DMA request enable
    static constexpr uint32_t DIER_CC2DE = 0x400;        // Capture/Compare 2 DMA request enable
    static constexpr uint32_t DIER_CC1DE = 0x200;        // Capture/Compare 1 DMA request enable
    static constexpr uint32_t DIER_UDE = 0x100;          // Update DMA request enable
    static constexpr uint32_t DIER_TIE = 0x40;           // Trigger interrupt enable
    static constexpr uint32_t DIER_CC4IE = 0x10;         // Capture/Compare 4 interrupt enable
    static constexpr uint32_t DIER_CC3IE = 0x8;          // Capture/Compare 3 interrupt enable
    static constexpr uint32_t DIER_CC2IE = 0x4;          // Capture/Compare 2 interrupt enable
    static constexpr uint32_t DIER_CC1IE = 0x2;          // Capture/Compare 1 interrupt enable
    static constexpr uint32_t DIER_UIE = 0x1;            // Update interrupt enable
    static constexpr uint32_t DIER_BIE = 0x80;           // Break interrupt enable
    static constexpr uint32_t DIER_COMIE = 0x20;         // COM interrupt enable
    static const uint32_t DIER_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_CC6IF = 0x20000;      // Compare 6 interrupt flag
    static constexpr uint32_t SR_CC5IF = 0x10000;      // Compare 5 interrupt flag
    static constexpr uint32_t SR_SBIF = 0x2000;        // System Break interrupt flag
    static constexpr uint32_t SR_CC4OF = 0x1000;       // Capture/Compare 4 overcapture flag
    static constexpr uint32_t SR_CC3OF = 0x800;        // Capture/Compare 3 overcapture flag
    static constexpr uint32_t SR_CC2OF = 0x400;        // Capture/compare 2 overcapture flag
    static constexpr uint32_t SR_CC1OF = 0x200;        // Capture/Compare 1 overcapture flag
    static constexpr uint32_t SR_B2IF = 0x100;         // Break 2 interrupt flag
    static constexpr uint32_t SR_BIF = 0x80;           // Break interrupt flag
    static constexpr uint32_t SR_TIF = 0x40;           // Trigger interrupt flag
    static constexpr uint32_t SR_COMIF = 0x20;         // COM interrupt flag
    static constexpr uint32_t SR_CC4IF = 0x10;         // Capture/Compare 4 interrupt flag
    static constexpr uint32_t SR_CC3IF = 0x8;          // Capture/Compare 3 interrupt flag
    static constexpr uint32_t SR_CC2IF = 0x4;          // Capture/Compare 2 interrupt flag
    static constexpr uint32_t SR_CC1IF = 0x2;          // Capture/compare 1 interrupt flag
    static constexpr uint32_t SR_UIF = 0x1;            // Update interrupt flag
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint32_t EGR_UG = 0x1;             // Update generation
    static constexpr uint32_t EGR_CC1G = 0x2;           // Capture/compare 1 generation
    static constexpr uint32_t EGR_CC2G = 0x4;           // Capture/compare 2 generation
    static constexpr uint32_t EGR_CC3G = 0x8;           // Capture/compare 3 generation
    static constexpr uint32_t EGR_CC4G = 0x10;          // Capture/compare 4 generation
    static constexpr uint32_t EGR_COMG = 0x20;          // Capture/Compare control update generation
    static constexpr uint32_t EGR_TG = 0x40;            // Trigger generation
    static constexpr uint32_t EGR_BG = 0x80;            // Break generation
    static constexpr uint32_t EGR_B2G = 0x100;          // Break 2 generation
    static const uint32_t EGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCMR1_CC1S =                // Capture/Compare 1 selection (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_CC2S =                // Capture/Compare 2 selection (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC1F =                // Input capture 1 filter (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC2F =                // Input capture 2 filter (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC2PCS =              // Input capture 2 prescaler (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_ICPCS =               // Input capture 1 prescaler (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t CCMR1_OC1CE = 0x80;         // Output Compare 1 clear enable
    static constexpr uint32_t CCMR1_OC1FE = 0x4;          // Output Compare 1 fast enable
    template<uint32_t X>
    static constexpr uint32_t CCMR1_OC1M =                // Output Compare 1 mode (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR1_OC1M_3 = 0x10000;     // Output Compare 1 mode - bit 3
    static constexpr uint32_t CCMR1_OC1PE = 0x8;          // Output Compare 1 preload enable
    static constexpr uint32_t CCMR1_OC2CE = 0x8000;       // Output Compare 2 clear enable
    static constexpr uint32_t CCMR1_OC2FE = 0x400;        // Output Compare 2 fast enable
    template<uint32_t X>
    static constexpr uint32_t CCMR1_OC2M =                // Output Compare 2 mode (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    static constexpr uint32_t CCMR1_OC2M_3 = 0x1000000;   // Output Compare 2 mode - bit 3
    static constexpr uint32_t CCMR1_OC2PE = 0x800;        // Output Compare 2 preload enable
    static const uint32_t CCMR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCMR2_CC3S =                // Capture/Compare 3 selection (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_CC4S =                // Capture/Compare 4 selection (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC3F =                // Input capture 3 filter (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC3PSC =              // Input capture 3 prescaler (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC4F =                // Input capture 4 filter (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC4PSC =              // Input capture 4 prescaler (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    static constexpr uint32_t CCMR2_OC3CE = 0x80;         // Output compare 3 clear enable
    static constexpr uint32_t CCMR2_OC3FE = 0x4;          // Output compare 3 fast enable
    template<uint32_t X>
    static constexpr uint32_t CCMR2_OC3M =                // Output compare 3 mode (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR2_OC3M_3 = 0x10000;     // Output Compare 3 mode - bit 3
    static constexpr uint32_t CCMR2_OC3PE = 0x8;          // Output compare 3 preload enable
    static constexpr uint32_t CCMR2_OC4CE = 0x8000;       // Output compare 4 clear enable
    static constexpr uint32_t CCMR2_OC4FE = 0x400;        // Output compare 4 fast enable
    template<uint32_t X>
    static constexpr uint32_t CCMR2_OC4M =                // Output compare 4 mode (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    static constexpr uint32_t CCMR2_OC4M_4 = 0x1000000;   // Output Compare 4 mode - bit 3
    static constexpr uint32_t CCMR2_OC4PE = 0x800;        // Output compare 4 preload enable
    static const uint32_t CCMR2_RESET_VALUE = 0x0;

    static constexpr uint32_t CCER_CC1E = 0x1;           // Capture/Compare 1 output enable
    static constexpr uint32_t CCER_CC1P = 0x2;           // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1NE = 0x4;          // Capture/Compare 1 complementary output enable
    static constexpr uint32_t CCER_CC1NP = 0x8;          // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC2E = 0x10;          // Capture/Compare 2 output enable
    static constexpr uint32_t CCER_CC2P = 0x20;          // Capture/Compare 2 output Polarity
    static constexpr uint32_t CCER_CC2NE = 0x40;         // Capture/Compare 2 complementary output enable
    static constexpr uint32_t CCER_CC2NP = 0x80;         // Capture/Compare 2 output Polarity
    static constexpr uint32_t CCER_CC3E = 0x100;         // Capture/Compare 3 output enable
    static constexpr uint32_t CCER_CC3P = 0x200;         // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC3NE = 0x400;        // Capture/Compare 3 complementary output enable
    static constexpr uint32_t CCER_CC3NP = 0x800;        // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC4E = 0x1000;        // Capture/Compare 4 output enable
    static constexpr uint32_t CCER_CC4P = 0x2000;        // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC4NP = 0x8000;       // Capture/Compare 4 complementary output polarity
    static constexpr uint32_t CCER_CC5E = 0x10000;       // Capture/Compare 5 output enable
    static constexpr uint32_t CCER_CC5P = 0x20000;       // Capture/Compare 5 output polarity
    static constexpr uint32_t CCER_CC6E = 0x100000;      // Capture/Compare 6 output enable
    static constexpr uint32_t CCER_CC6P = 0x200000;      // Capture/Compare 6 output polarity
    static const uint32_t CCER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CNT_CNT =                 // counter value (16 bits), Read-write
        bit_field_t<0, 0xffff>::value<X>();
    static constexpr uint32_t CNT_UIFCPY = 0x80000000;  // UIF copy, Read-only
    static const uint32_t CNT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PSC_PSC =                 // Prescaler value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t PSC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ARR_ARR =                 // Auto-reload value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t ARR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RCR_REP =                 // Repetition counter value (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t RCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR1_CCR1 =                // Capture/Compare 1 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR2_CCR2 =                // Capture/Compare 2 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR3_CCR3 =                // Capture/Compare value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR4_CCR4 =                // Capture/Compare value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BDTR_DTG =                 // Dead-time generator setup (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BDTR_LOCK =                // Lock configuration (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t BDTR_OSSI = 0x400;         // Off-state selection for Idle mode
    static constexpr uint32_t BDTR_OSSR = 0x800;         // Off-state selection for Run mode
    static constexpr uint32_t BDTR_BKE = 0x1000;         // Break enable
    static constexpr uint32_t BDTR_BKP = 0x2000;         // Break polarity
    static constexpr uint32_t BDTR_AOE = 0x4000;         // Automatic output enable
    static constexpr uint32_t BDTR_MOE = 0x8000;         // Main output enable
    template<uint32_t X>
    static constexpr uint32_t BDTR_BKF =                 // Break filter (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BDTR_BK2F =                // Break 2 filter (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    static constexpr uint32_t BDTR_BK2E = 0x1000000;     // Break 2 enable
    static constexpr uint32_t BDTR_BK2P = 0x2000000;     // Break 2 polarity
    static const uint32_t BDTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DCR_DBL =                 // DMA burst length (5 bits)
        bit_field_t<8, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DCR_DBA =                 // DMA base address (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t DCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DMAR_DMAB =                // DMA register for burst accesses (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DMAR_RESET_VALUE = 0x0;

    static constexpr uint32_t CCMR3_Output_OC5FE = 0x4;          // Output compare 5 fast enable
    static constexpr uint32_t CCMR3_Output_OC5PE = 0x8;          // Output compare 5 preload enable
    template<uint32_t X>
    static constexpr uint32_t CCMR3_Output_OC5M =                // Output compare 5 mode (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR3_Output_OC5CE = 0x80;         // Output compare 5 clear enable
    static constexpr uint32_t CCMR3_Output_OC6FE = 0x400;        // Output compare 6 fast enable
    static constexpr uint32_t CCMR3_Output_OC6PE = 0x800;        // Output compare 6 preload enable
    template<uint32_t X>
    static constexpr uint32_t CCMR3_Output_OC6M =                // Output compare 6 mode (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    static constexpr uint32_t CCMR3_Output_OC6CE = 0x8000;       // Output compare 6 clear enable
    static constexpr uint32_t CCMR3_Output_OC5M3 = 0x10000;      // Output Compare 5 mode
    static constexpr uint32_t CCMR3_Output_OC6M3 = 0x1000000;    // Output Compare 6 mode
    static const uint32_t CCMR3_Output_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR5_CCR5 =                // Capture/Compare 5 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static constexpr uint32_t CCR5_GC5C1 = 0x20000000;   // Group Channel 5 and Channel 1
    static constexpr uint32_t CCR5_GC5C2 = 0x40000000;   // Group Channel 5 and Channel 2
    static constexpr uint32_t CCR5_GC5C3 = 0x80000000;   // Group Channel 5 and Channel 3
    static const uint32_t CCR5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CRR6_CCR6 =                // Capture/Compare 6 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CRR6_RESET_VALUE = 0x0;

    static constexpr uint32_t AF1_BKINE = 0x1;          // BRK BKIN input enable
    static constexpr uint32_t AF1_BKCMP1E = 0x2;        // BRK COMP1 enable
    static constexpr uint32_t AF1_BKCMP2E = 0x4;        // BRK COMP2 enable
    static constexpr uint32_t AF1_BKDF1BK0E = 0x100;    // BRK dfsdm1_break[0] enable
    static constexpr uint32_t AF1_BKINP = 0x200;        // BRK BKIN input polarity
    static constexpr uint32_t AF1_BKCMP1P = 0x400;      // BRK COMP1 input polarity
    static constexpr uint32_t AF1_BKCMP2P = 0x800;      // BRK COMP2 input polarity
    template<uint32_t X>
    static constexpr uint32_t AF1_ETRSEL =              // ETR source selection (4 bits)
        bit_field_t<14, 0xf>::value<X>();
    static const uint32_t AF1_RESET_VALUE = 0x0;

    static constexpr uint32_t AF2_BK2INE = 0x1;         // BRK2 BKIN input enable
    static constexpr uint32_t AF2_BK2CMP1E = 0x2;       // BRK2 COMP1 enable
    static constexpr uint32_t AF2_BK2CMP2E = 0x4;       // BRK2 COMP2 enable
    static constexpr uint32_t AF2_BK2DF1BK1E = 0x100;   // BRK2 dfsdm1_break[1] enable
    static constexpr uint32_t AF2_BK2INP = 0x200;       // BRK2 BKIN2 input polarity
    static constexpr uint32_t AF2_BK2CMP1P = 0x400;     // BRK2 COMP1 input polarit
    static constexpr uint32_t AF2_BK2CMP2P = 0x800;     // BRK2 COMP2 input polarity
    static const uint32_t AF2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TISEL_TI1SEL =              // selects TI1[0] to TI1[15] input (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TISEL_TI2SEL =              // selects TI2[0] to TI2[15] input (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TISEL_TI3SEL =              // selects TI3[0] to TI3[15] input (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TISEL_TI4SEL =              // selects TI4[0] to TI4[15] input (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    static const uint32_t TISEL_RESET_VALUE = 0x0;

    static constexpr uint8_t TIM8_CC = 46; // TIM8 capture / compare
};

static tim8_t& TIM8 = *reinterpret_cast<tim8_t*>(0x40010400);

#define HAVE_PERIPHERAL_TIM8


////
//
//    FDCAN1
//
////

struct fdcan1_t
{
    volatile uint32_t    CREL;                 // [Read-only] FDCAN Core Release Register
    volatile uint32_t    ENDN;                 // [Read-only] FDCAN Core Release Register
    reserved_t<1>        _0;
    volatile uint32_t    DBTP;                 // [Read-only] FDCAN Data Bit Timing and Prescaler Register
    volatile uint32_t    TEST;                 // [Read-only] FDCAN Test Register
    volatile uint32_t    RWD;                  // [Read-only] FDCAN RAM Watchdog Register
    volatile uint32_t    CCCR;                 // [Read-write] FDCAN CC Control Register
    volatile uint32_t    NBTP;                 // [Read-write] FDCAN Nominal Bit Timing and Prescaler Register
    volatile uint32_t    TSCC;                 // [Read-write] FDCAN Timestamp Counter Configuration Register
    volatile uint32_t    TSCV;                 // [Read-write] FDCAN Timestamp Counter Value Register
    volatile uint32_t    TOCC;                 // [Read-write] FDCAN Timeout Counter Configuration Register
    volatile uint32_t    TOCV;                 // [Read-write] FDCAN Timeout Counter Value Register
    reserved_t<4>        _1;
    volatile uint32_t    ECR;                  // [Read-write] FDCAN Error Counter Register
    volatile uint32_t    PSR;                  // [Read-write] FDCAN Protocol Status Register
    volatile uint32_t    TDCR;                 // [Read-only] FDCAN Transmitter Delay Compensation Register
    reserved_t<1>        _2;
    volatile uint32_t    IR;                   // [Read-only] FDCAN Interrupt Register
    volatile uint32_t    IE;                   // [Read-only] FDCAN Interrupt Enable Register
    volatile uint32_t    ILS;                  // [Read-only] FDCAN Interrupt Line Select Register
    volatile uint32_t    ILE;                  // [Read-write] FDCAN Interrupt Line Enable Register
    reserved_t<8>        _3;
    volatile uint32_t    GFC;                  // [Read-write] FDCAN Global Filter Configuration Register
    volatile uint32_t    SIDFC;                // [Read-write] FDCAN Standard ID Filter Configuration Register
    volatile uint32_t    XIDFC;                // [Read-write] FDCAN Extended ID Filter Configuration Register
    reserved_t<1>        _4;
    volatile uint32_t    XIDAM;                // [Read-write] FDCAN Extended ID and Mask Register
    volatile uint32_t    HPMS;                 // [Read-only] FDCAN High Priority Message Status Register
    volatile uint32_t    NDAT1;                // [Read-only] FDCAN New Data 1 Register
    volatile uint32_t    NDAT2;                // [Read-only] FDCAN New Data 2 Register
    volatile uint32_t    RXF0C;                // [Read-write] FDCAN Rx FIFO 0 Configuration Register
    volatile uint32_t    RXF0S;                // [Read-write] FDCAN Rx FIFO 0 Status Register
    volatile uint32_t    RXF0A;                // [Read-write] CAN Rx FIFO 0 Acknowledge Register
    volatile uint32_t    RXBC;                 // [Read-write] FDCAN Rx Buffer Configuration Register
    volatile uint32_t    RXF1C;                // [Read-write] FDCAN Rx FIFO 1 Configuration Register
    volatile uint32_t    RXF1S;                // [Read-write] FDCAN Rx FIFO 1 Status Register
    volatile uint32_t    RXF1A;                // [Read-write] FDCAN Rx FIFO 1 Acknowledge Register
    volatile uint32_t    RXESC;                // [Read-write] FDCAN Rx Buffer Element Size Configuration Register
    volatile uint32_t    TXBC;                 // [Read-write] FDCAN Tx Buffer Configuration Register
    volatile uint32_t    TXFQS;                // [Read-only] FDCAN Tx FIFO/Queue Status Register
    volatile uint32_t    TXESC;                // [Read-write] FDCAN Tx Buffer Element Size Configuration Register
    volatile uint32_t    TXBRP;                // [Read-only] FDCAN Tx Buffer Request Pending Register
    volatile uint32_t    TXBAR;                // [Read-write] FDCAN Tx Buffer Add Request Register
    volatile uint32_t    TXBCR;                // [Read-write] FDCAN Tx Buffer Cancellation Request Register
    volatile uint32_t    TXBTO;                // [Read-write] FDCAN Tx Buffer Transmission Occurred Register
    volatile uint32_t    TXBCF;                // [Read-only] FDCAN Tx Buffer Cancellation Finished Register
    volatile uint32_t    TXBTIE;               // [Read-write] FDCAN Tx Buffer Transmission Interrupt Enable Register
    volatile uint32_t    TXBCIE;               // [Read-write] FDCAN Tx Buffer Cancellation Finished Interrupt Enable Register
    reserved_t<2>        _5;
    volatile uint32_t    TXEFC;                // [Read-write] FDCAN Tx Event FIFO Configuration Register
    volatile uint32_t    TXEFS;                // [Read-write] FDCAN Tx Event FIFO Status Register
    volatile uint32_t    TXEFA;                // [Read-write] FDCAN Tx Event FIFO Acknowledge Register
    reserved_t<1>        _6;
    volatile uint32_t    TTTMC;                // [Read-write] FDCAN TT Trigger Memory Configuration Register
    volatile uint32_t    TTRMC;                // [Read-write] FDCAN TT Reference Message Configuration Register
    volatile uint32_t    TTOCF;                // [Read-write] FDCAN TT Operation Configuration Register
    volatile uint32_t    TTMLM;                // [Read-write] FDCAN TT Matrix Limits Register
    volatile uint32_t    TURCF;                // [Read-write] FDCAN TUR Configuration Register
    volatile uint32_t    TTOCN;                // [Read-write] FDCAN TT Operation Control Register
    volatile uint32_t    CAN_TTGTP;            // [Read-write] FDCAN TT Global Time Preset Register
    volatile uint32_t    TTTMK;                // [Read-write] FDCAN TT Time Mark Register
    volatile uint32_t    TTIR;                 // [Read-write] FDCAN TT Interrupt Register
    volatile uint32_t    TTIE;                 // [Read-write] FDCAN TT Interrupt Enable Register
    volatile uint32_t    TTILS;                // [Read-write] FDCAN TT Interrupt Line Select Register
    volatile uint32_t    TTOST;                // [Read-write] FDCAN TT Operation Status Register
    volatile uint32_t    TURNA;                // [Read-only] FDCAN TUR Numerator Actual Register
    volatile uint32_t    TTLGT;                // [Read-only] FDCAN TT Local and Global Time Register
    volatile uint32_t    TTCTC;                // [Read-only] FDCAN TT Cycle Time and Count Register
    volatile uint32_t    TTCPT;                // [Read-only] FDCAN TT Capture Time Register
    volatile uint32_t    TTCSM;                // [Read-only] FDCAN TT Cycle Sync Mark Register
    reserved_t<111>      _7;
    volatile uint32_t    TTTS;                 // [Read-write] FDCAN TT Trigger Select Register

    template<uint32_t X>
    static constexpr uint32_t CREL_REL =                 // Core release (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CREL_STEP =                // Step of Core release (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CREL_SUBSTEP =             // Sub-step of Core release (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CREL_YEAR =                // Timestamp Year (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CREL_MON =                 // Timestamp Month (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CREL_DAY =                 // Timestamp Day (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t CREL_RESET_VALUE = 0x0;


    static const uint32_t ENDN_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DBTP_DSJW =                // Synchronization Jump Width (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DBTP_DTSEG2 =              // Data time segment after sample point (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DBTP_DTSEG1 =              // Data time segment after sample point (5 bits)
        bit_field_t<8, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DBTP_DBRP =                // Data BIt Rate Prescaler (5 bits)
        bit_field_t<16, 0x1f>::value<X>();
    static constexpr uint32_t DBTP_TDC = 0x800000;       // Transceiver Delay Compensation
    static const uint32_t DBTP_RESET_VALUE = 0x0;

    static constexpr uint32_t TEST_LBCK = 0x10;          // Loop Back mode
    template<uint32_t X>
    static constexpr uint32_t TEST_TX =                  // Loop Back mode (2 bits)
        bit_field_t<5, 0x3>::value<X>();
    static constexpr uint32_t TEST_RX = 0x80;            // Control of Transmit Pin
    static const uint32_t TEST_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RWD_WDV =                 // Watchdog value (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RWD_WDC =                 // Watchdog configuration (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t RWD_RESET_VALUE = 0x0;

    static constexpr uint32_t CCCR_INIT = 0x1;           // Initialization
    static constexpr uint32_t CCCR_CCE = 0x2;            // Configuration Change Enable
    static constexpr uint32_t CCCR_ASM = 0x4;            // ASM Restricted Operation Mode
    static constexpr uint32_t CCCR_CSA = 0x8;            // Clock Stop Acknowledge
    static constexpr uint32_t CCCR_CSR = 0x10;           // Clock Stop Request
    static constexpr uint32_t CCCR_MON = 0x20;           // Bus Monitoring Mode
    static constexpr uint32_t CCCR_DAR = 0x40;           // Disable Automatic Retransmission
    static constexpr uint32_t CCCR_TEST = 0x80;          // Test Mode Enable
    static constexpr uint32_t CCCR_FDOE = 0x100;         // FD Operation Enable
    static constexpr uint32_t CCCR_BSE = 0x200;          // FDCAN Bit Rate Switching
    static constexpr uint32_t CCCR_PXHD = 0x1000;        // Protocol Exception Handling Disable
    static constexpr uint32_t CCCR_EFBI = 0x2000;        // Edge Filtering during Bus Integration
    static constexpr uint32_t CCCR_TXP = 0x4000;         // TXP
    static constexpr uint32_t CCCR_NISO = 0x8000;        // Non ISO Operation
    static const uint32_t CCCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t NBTP_NSJW =                // NSJW: Nominal (Re)Synchronization Jump Width (7 bits)
        bit_field_t<25, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t NBTP_NBRP =                // Bit Rate Prescaler (9 bits)
        bit_field_t<16, 0x1ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t NBTP_NTSEG1 =              // Nominal Time segment before sample point (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t NBTP_TSEG2 =               // Nominal Time segment after sample point (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    static const uint32_t NBTP_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TSCC_TCP =                 // Timestamp Counter Prescaler (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TSCC_TSS =                 // Timestamp Select (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t TSCC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TSCV_TSC =                 // Timestamp Counter (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t TSCV_RESET_VALUE = 0x0;

    static constexpr uint32_t TOCC_ETOC = 0x1;           // Enable Timeout Counter
    template<uint32_t X>
    static constexpr uint32_t TOCC_TOS =                 // Timeout Select (2 bits)
        bit_field_t<1, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TOCC_TOP =                 // Timeout Period (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t TOCC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TOCV_TOC =                 // Timeout Counter (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t TOCV_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ECR_CEL =                 // AN Error Logging (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static constexpr uint32_t ECR_RP = 0x8000;          // Receive Error Passive
    template<uint32_t X>
    static constexpr uint32_t ECR_TREC =                // Receive Error Counter (7 bits)
        bit_field_t<8, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ECR_TEC =                 // Transmit Error Counter (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t ECR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PSR_LEC =                 // Last Error Code (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PSR_ACT =                 // Activity (2 bits)
        bit_field_t<3, 0x3>::value<X>();
    static constexpr uint32_t PSR_EP = 0x20;            // Error Passive
    static constexpr uint32_t PSR_EW = 0x40;            // Warning Status
    static constexpr uint32_t PSR_BO = 0x80;            // Bus_Off Status
    template<uint32_t X>
    static constexpr uint32_t PSR_DLEC =                // Data Last Error Code (3 bits)
        bit_field_t<8, 0x7>::value<X>();
    static constexpr uint32_t PSR_RESI = 0x800;         // ESI flag of last received FDCAN Message
    static constexpr uint32_t PSR_RBRS = 0x1000;        // BRS flag of last received FDCAN Message
    static constexpr uint32_t PSR_REDL = 0x2000;        // Received FDCAN Message
    static constexpr uint32_t PSR_PXE = 0x4000;         // Protocol Exception Event
    template<uint32_t X>
    static constexpr uint32_t PSR_TDCV =                // Transmitter Delay Compensation Value (7 bits)
        bit_field_t<16, 0x7f>::value<X>();
    static const uint32_t PSR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDCR_TDCF =                // Transmitter Delay Compensation Filter Window Length (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDCR_TDCO =                // Transmitter Delay Compensation Offset (7 bits)
        bit_field_t<8, 0x7f>::value<X>();
    static const uint32_t TDCR_RESET_VALUE = 0x0;

    static constexpr uint32_t IR_RF0N = 0x1;           // Rx FIFO 0 New Message
    static constexpr uint32_t IR_RF0W = 0x2;           // Rx FIFO 0 Full
    static constexpr uint32_t IR_RF0F = 0x4;           // Rx FIFO 0 Full
    static constexpr uint32_t IR_RF0L = 0x8;           // Rx FIFO 0 Message Lost
    static constexpr uint32_t IR_RF1N = 0x10;          // Rx FIFO 1 New Message
    static constexpr uint32_t IR_RF1W = 0x20;          // Rx FIFO 1 Watermark Reached
    static constexpr uint32_t IR_RF1F = 0x40;          // Rx FIFO 1 Watermark Reached
    static constexpr uint32_t IR_RF1L = 0x80;          // Rx FIFO 1 Message Lost
    static constexpr uint32_t IR_HPM = 0x100;          // High Priority Message
    static constexpr uint32_t IR_TC = 0x200;           // Transmission Completed
    static constexpr uint32_t IR_TCF = 0x400;          // Transmission Cancellation Finished
    static constexpr uint32_t IR_TEF = 0x800;          // Tx FIFO Empty
    static constexpr uint32_t IR_TEFN = 0x1000;        // Tx Event FIFO New Entry
    static constexpr uint32_t IR_TEFW = 0x2000;        // Tx Event FIFO Watermark Reached
    static constexpr uint32_t IR_TEFF = 0x4000;        // Tx Event FIFO Full
    static constexpr uint32_t IR_TEFL = 0x8000;        // Tx Event FIFO Element Lost
    static constexpr uint32_t IR_TSW = 0x10000;        // Timestamp Wraparound
    static constexpr uint32_t IR_MRAF = 0x20000;       // Message RAM Access Failure
    static constexpr uint32_t IR_TOO = 0x40000;        // Timeout Occurred
    static constexpr uint32_t IR_DRX = 0x80000;        // Message stored to Dedicated Rx Buffer
    static constexpr uint32_t IR_ELO = 0x400000;       // Error Logging Overflow
    static constexpr uint32_t IR_EP = 0x800000;        // Error Passive
    static constexpr uint32_t IR_EW = 0x1000000;       // Warning Status
    static constexpr uint32_t IR_BO = 0x2000000;       // Bus_Off Status
    static constexpr uint32_t IR_WDI = 0x4000000;      // Watchdog Interrupt
    static constexpr uint32_t IR_PEA = 0x8000000;      // Protocol Error in Arbitration Phase (Nominal Bit Time is used)
    static constexpr uint32_t IR_PED = 0x10000000;     // Protocol Error in Data Phase (Data Bit Time is used)
    static constexpr uint32_t IR_ARA = 0x20000000;     // Access to Reserved Address
    static const uint32_t IR_RESET_VALUE = 0x0;

    static constexpr uint32_t IE_RF0NE = 0x1;          // Rx FIFO 0 New Message Enable
    static constexpr uint32_t IE_RF0WE = 0x2;          // Rx FIFO 0 Full Enable
    static constexpr uint32_t IE_RF0FE = 0x4;          // Rx FIFO 0 Full Enable
    static constexpr uint32_t IE_RF0LE = 0x8;          // Rx FIFO 0 Message Lost Enable
    static constexpr uint32_t IE_RF1NE = 0x10;         // Rx FIFO 1 New Message Enable
    static constexpr uint32_t IE_RF1WE = 0x20;         // Rx FIFO 1 Watermark Reached Enable
    static constexpr uint32_t IE_RF1FE = 0x40;         // Rx FIFO 1 Watermark Reached Enable
    static constexpr uint32_t IE_RF1LE = 0x80;         // Rx FIFO 1 Message Lost Enable
    static constexpr uint32_t IE_HPME = 0x100;         // High Priority Message Enable
    static constexpr uint32_t IE_TCE = 0x200;          // Transmission Completed Enable
    static constexpr uint32_t IE_TCFE = 0x400;         // Transmission Cancellation Finished Enable
    static constexpr uint32_t IE_TEFE = 0x800;         // Tx FIFO Empty Enable
    static constexpr uint32_t IE_TEFNE = 0x1000;       // Tx Event FIFO New Entry Enable
    static constexpr uint32_t IE_TEFWE = 0x2000;       // Tx Event FIFO Watermark Reached Enable
    static constexpr uint32_t IE_TEFFE = 0x4000;       // Tx Event FIFO Full Enable
    static constexpr uint32_t IE_TEFLE = 0x8000;       // Tx Event FIFO Element Lost Enable
    static constexpr uint32_t IE_TSWE = 0x10000;       // Timestamp Wraparound Enable
    static constexpr uint32_t IE_MRAFE = 0x20000;      // Message RAM Access Failure Enable
    static constexpr uint32_t IE_TOOE = 0x40000;       // Timeout Occurred Enable
    static constexpr uint32_t IE_DRXE = 0x80000;       // Message stored to Dedicated Rx Buffer Enable
    static constexpr uint32_t IE_BECE = 0x100000;      // Bit Error Corrected Interrupt Enable
    static constexpr uint32_t IE_BEUE = 0x200000;      // Bit Error Uncorrected Interrupt Enable
    static constexpr uint32_t IE_ELOE = 0x400000;      // Error Logging Overflow Enable
    static constexpr uint32_t IE_EPE = 0x800000;       // Error Passive Enable
    static constexpr uint32_t IE_EWE = 0x1000000;      // Warning Status Enable
    static constexpr uint32_t IE_BOE = 0x2000000;      // Bus_Off Status Enable
    static constexpr uint32_t IE_WDIE = 0x4000000;     // Watchdog Interrupt Enable
    static constexpr uint32_t IE_PEAE = 0x8000000;     // Protocol Error in Arbitration Phase Enable
    static constexpr uint32_t IE_PEDE = 0x10000000;    // Protocol Error in Data Phase Enable
    static constexpr uint32_t IE_ARAE = 0x20000000;    // Access to Reserved Address Enable
    static const uint32_t IE_RESET_VALUE = 0x0;

    static constexpr uint32_t ILS_RF0NL = 0x1;          // Rx FIFO 0 New Message Interrupt Line
    static constexpr uint32_t ILS_RF0WL = 0x2;          // Rx FIFO 0 Watermark Reached Interrupt Line
    static constexpr uint32_t ILS_RF0FL = 0x4;          // Rx FIFO 0 Full Interrupt Line
    static constexpr uint32_t ILS_RF0LL = 0x8;          // Rx FIFO 0 Message Lost Interrupt Line
    static constexpr uint32_t ILS_RF1NL = 0x10;         // Rx FIFO 1 New Message Interrupt Line
    static constexpr uint32_t ILS_RF1WL = 0x20;         // Rx FIFO 1 Watermark Reached Interrupt Line
    static constexpr uint32_t ILS_RF1FL = 0x40;         // Rx FIFO 1 Full Interrupt Line
    static constexpr uint32_t ILS_RF1LL = 0x80;         // Rx FIFO 1 Message Lost Interrupt Line
    static constexpr uint32_t ILS_HPML = 0x100;         // High Priority Message Interrupt Line
    static constexpr uint32_t ILS_TCL = 0x200;          // Transmission Completed Interrupt Line
    static constexpr uint32_t ILS_TCFL = 0x400;         // Transmission Cancellation Finished Interrupt Line
    static constexpr uint32_t ILS_TEFL = 0x800;         // Tx FIFO Empty Interrupt Line
    static constexpr uint32_t ILS_TEFNL = 0x1000;       // Tx Event FIFO New Entry Interrupt Line
    static constexpr uint32_t ILS_TEFWL = 0x2000;       // Tx Event FIFO Watermark Reached Interrupt Line
    static constexpr uint32_t ILS_TEFFL = 0x4000;       // Tx Event FIFO Full Interrupt Line
    static constexpr uint32_t ILS_TEFLL = 0x8000;       // Tx Event FIFO Element Lost Interrupt Line
    static constexpr uint32_t ILS_TSWL = 0x10000;       // Timestamp Wraparound Interrupt Line
    static constexpr uint32_t ILS_MRAFL = 0x20000;      // Message RAM Access Failure Interrupt Line
    static constexpr uint32_t ILS_TOOL = 0x40000;       // Timeout Occurred Interrupt Line
    static constexpr uint32_t ILS_DRXL = 0x80000;       // Message stored to Dedicated Rx Buffer Interrupt Line
    static constexpr uint32_t ILS_BECL = 0x100000;      // Bit Error Corrected Interrupt Line
    static constexpr uint32_t ILS_BEUL = 0x200000;      // Bit Error Uncorrected Interrupt Line
    static constexpr uint32_t ILS_ELOL = 0x400000;      // Error Logging Overflow Interrupt Line
    static constexpr uint32_t ILS_EPL = 0x800000;       // Error Passive Interrupt Line
    static constexpr uint32_t ILS_EWL = 0x1000000;      // Warning Status Interrupt Line
    static constexpr uint32_t ILS_BOL = 0x2000000;      // Bus_Off Status
    static constexpr uint32_t ILS_WDIL = 0x4000000;     // Watchdog Interrupt Line
    static constexpr uint32_t ILS_PEAL = 0x8000000;     // Protocol Error in Arbitration Phase Line
    static constexpr uint32_t ILS_PEDL = 0x10000000;    // Protocol Error in Data Phase Line
    static constexpr uint32_t ILS_ARAL = 0x20000000;    // Access to Reserved Address Line
    static const uint32_t ILS_RESET_VALUE = 0x0;

    static constexpr uint32_t ILE_EINT0 = 0x1;          // Enable Interrupt Line 0
    static constexpr uint32_t ILE_EINT1 = 0x2;          // Enable Interrupt Line 1
    static const uint32_t ILE_RESET_VALUE = 0x0;

    static constexpr uint32_t GFC_RRFE = 0x1;           // Reject Remote Frames Extended
    static constexpr uint32_t GFC_RRFS = 0x2;           // Reject Remote Frames Standard
    template<uint32_t X>
    static constexpr uint32_t GFC_ANFE =                // Accept Non-matching Frames Extended (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GFC_ANFS =                // Accept Non-matching Frames Standard (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static const uint32_t GFC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SIDFC_FLSSA =               // Filter List Standard Start Address (14 bits)
        bit_field_t<2, 0x3fff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SIDFC_LSS =                 // List Size Standard (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static const uint32_t SIDFC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t XIDFC_FLESA =               // Filter List Standard Start Address (14 bits)
        bit_field_t<2, 0x3fff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t XIDFC_LSE =                 // List Size Extended (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static const uint32_t XIDFC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t XIDAM_EIDM =                // Extended ID Mask (29 bits)
        bit_field_t<0, 0x1fffffff>::value<X>();
    static const uint32_t XIDAM_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HPMS_BIDX =                // Buffer Index (6 bits)
        bit_field_t<0, 0x3f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t HPMS_MSI =                 // Message Storage Indicator (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t HPMS_FIDX =                // Filter Index (7 bits)
        bit_field_t<8, 0x7f>::value<X>();
    static constexpr uint32_t HPMS_FLST = 0x8000;        // Filter List
    static const uint32_t HPMS_RESET_VALUE = 0x0;

    static constexpr uint32_t NDAT1_ND0 = 0x1;            // New data
    static constexpr uint32_t NDAT1_ND1 = 0x2;            // New data
    static constexpr uint32_t NDAT1_ND2 = 0x4;            // New data
    static constexpr uint32_t NDAT1_ND3 = 0x8;            // New data
    static constexpr uint32_t NDAT1_ND4 = 0x10;           // New data
    static constexpr uint32_t NDAT1_ND5 = 0x20;           // New data
    static constexpr uint32_t NDAT1_ND6 = 0x40;           // New data
    static constexpr uint32_t NDAT1_ND7 = 0x80;           // New data
    static constexpr uint32_t NDAT1_ND8 = 0x100;          // New data
    static constexpr uint32_t NDAT1_ND9 = 0x200;          // New data
    static constexpr uint32_t NDAT1_ND10 = 0x400;         // New data
    static constexpr uint32_t NDAT1_ND11 = 0x800;         // New data
    static constexpr uint32_t NDAT1_ND12 = 0x1000;        // New data
    static constexpr uint32_t NDAT1_ND13 = 0x2000;        // New data
    static constexpr uint32_t NDAT1_ND14 = 0x4000;        // New data
    static constexpr uint32_t NDAT1_ND15 = 0x8000;        // New data
    static constexpr uint32_t NDAT1_ND16 = 0x10000;       // New data
    static constexpr uint32_t NDAT1_ND17 = 0x20000;       // New data
    static constexpr uint32_t NDAT1_ND18 = 0x40000;       // New data
    static constexpr uint32_t NDAT1_ND19 = 0x80000;       // New data
    static constexpr uint32_t NDAT1_ND20 = 0x100000;      // New data
    static constexpr uint32_t NDAT1_ND21 = 0x200000;      // New data
    static constexpr uint32_t NDAT1_ND22 = 0x400000;      // New data
    static constexpr uint32_t NDAT1_ND23 = 0x800000;      // New data
    static constexpr uint32_t NDAT1_ND24 = 0x1000000;     // New data
    static constexpr uint32_t NDAT1_ND25 = 0x2000000;     // New data
    static constexpr uint32_t NDAT1_ND26 = 0x4000000;     // New data
    static constexpr uint32_t NDAT1_ND27 = 0x8000000;     // New data
    static constexpr uint32_t NDAT1_ND28 = 0x10000000;    // New data
    static constexpr uint32_t NDAT1_ND29 = 0x20000000;    // New data
    static constexpr uint32_t NDAT1_ND30 = 0x40000000;    // New data
    static constexpr uint32_t NDAT1_ND31 = 0x80000000;    // New data
    static const uint32_t NDAT1_RESET_VALUE = 0x0;

    static constexpr uint32_t NDAT2_ND32 = 0x1;           // New data
    static constexpr uint32_t NDAT2_ND33 = 0x2;           // New data
    static constexpr uint32_t NDAT2_ND34 = 0x4;           // New data
    static constexpr uint32_t NDAT2_ND35 = 0x8;           // New data
    static constexpr uint32_t NDAT2_ND36 = 0x10;          // New data
    static constexpr uint32_t NDAT2_ND37 = 0x20;          // New data
    static constexpr uint32_t NDAT2_ND38 = 0x40;          // New data
    static constexpr uint32_t NDAT2_ND39 = 0x80;          // New data
    static constexpr uint32_t NDAT2_ND40 = 0x100;         // New data
    static constexpr uint32_t NDAT2_ND41 = 0x200;         // New data
    static constexpr uint32_t NDAT2_ND42 = 0x400;         // New data
    static constexpr uint32_t NDAT2_ND43 = 0x800;         // New data
    static constexpr uint32_t NDAT2_ND44 = 0x1000;        // New data
    static constexpr uint32_t NDAT2_ND45 = 0x2000;        // New data
    static constexpr uint32_t NDAT2_ND46 = 0x4000;        // New data
    static constexpr uint32_t NDAT2_ND47 = 0x8000;        // New data
    static constexpr uint32_t NDAT2_ND48 = 0x10000;       // New data
    static constexpr uint32_t NDAT2_ND49 = 0x20000;       // New data
    static constexpr uint32_t NDAT2_ND50 = 0x40000;       // New data
    static constexpr uint32_t NDAT2_ND51 = 0x80000;       // New data
    static constexpr uint32_t NDAT2_ND52 = 0x100000;      // New data
    static constexpr uint32_t NDAT2_ND53 = 0x200000;      // New data
    static constexpr uint32_t NDAT2_ND54 = 0x400000;      // New data
    static constexpr uint32_t NDAT2_ND55 = 0x800000;      // New data
    static constexpr uint32_t NDAT2_ND56 = 0x1000000;     // New data
    static constexpr uint32_t NDAT2_ND57 = 0x2000000;     // New data
    static constexpr uint32_t NDAT2_ND58 = 0x4000000;     // New data
    static constexpr uint32_t NDAT2_ND59 = 0x8000000;     // New data
    static constexpr uint32_t NDAT2_ND60 = 0x10000000;    // New data
    static constexpr uint32_t NDAT2_ND61 = 0x20000000;    // New data
    static constexpr uint32_t NDAT2_ND62 = 0x40000000;    // New data
    static constexpr uint32_t NDAT2_ND63 = 0x80000000;    // New data
    static const uint32_t NDAT2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RXF0C_F0SA =                // Rx FIFO 0 Start Address (14 bits)
        bit_field_t<2, 0x3fff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RXF0C_F0S =                 // Rx FIFO 0 Size (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RXF0C_F0WM =                // FIFO 0 Watermark (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t RXF0C_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RXF0S_F0FL =                // Rx FIFO 0 Fill Level (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RXF0S_F0G =                 // Rx FIFO 0 Get Index (6 bits)
        bit_field_t<8, 0x3f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RXF0S_F0P =                 // Rx FIFO 0 Put Index (6 bits)
        bit_field_t<16, 0x3f>::value<X>();
    static constexpr uint32_t RXF0S_F0F = 0x1000000;      // Rx FIFO 0 Full
    static constexpr uint32_t RXF0S_RF0L = 0x2000000;     // Rx FIFO 0 Message Lost
    static const uint32_t RXF0S_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RXF0A_FA01 =                // Rx FIFO 0 Acknowledge Index (6 bits)
        bit_field_t<0, 0x3f>::value<X>();
    static const uint32_t RXF0A_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RXBC_RBSA =                // Rx Buffer Start Address (14 bits)
        bit_field_t<2, 0x3fff>::value<X>();
    static const uint32_t RXBC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RXF1C_F1SA =                // Rx FIFO 1 Start Address (14 bits)
        bit_field_t<2, 0x3fff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RXF1C_F1S =                 // Rx FIFO 1 Size (7 bits)
        bit_field_t<16, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RXF1C_F1WM =                // Rx FIFO 1 Watermark (7 bits)
        bit_field_t<24, 0x7f>::value<X>();
    static const uint32_t RXF1C_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RXF1S_F1FL =                // Rx FIFO 1 Fill Level (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RXF1S_F1GI =                // Rx FIFO 1 Get Index (7 bits)
        bit_field_t<8, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RXF1S_F1PI =                // Rx FIFO 1 Put Index (7 bits)
        bit_field_t<16, 0x7f>::value<X>();
    static constexpr uint32_t RXF1S_F1F = 0x1000000;      // Rx FIFO 1 Full
    static constexpr uint32_t RXF1S_RF1L = 0x2000000;     // Rx FIFO 1 Message Lost
    template<uint32_t X>
    static constexpr uint32_t RXF1S_DMS =                 // Debug Message Status (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    static const uint32_t RXF1S_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RXF1A_F1AI =                // Rx FIFO 1 Acknowledge Index (6 bits)
        bit_field_t<0, 0x3f>::value<X>();
    static const uint32_t RXF1A_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RXESC_F0DS =                // Rx FIFO 1 Data Field Size: (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RXESC_F1DS =                // Rx FIFO 0 Data Field Size: (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RXESC_RBDS =                // Rx Buffer Data Field Size: (3 bits)
        bit_field_t<8, 0x7>::value<X>();
    static const uint32_t RXESC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TXBC_TBSA =                // Tx Buffers Start Address (14 bits)
        bit_field_t<2, 0x3fff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TXBC_NDTB =                // Number of Dedicated Transmit Buffers (6 bits)
        bit_field_t<16, 0x3f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TXBC_TFQS =                // Transmit FIFO/Queue Size (6 bits)
        bit_field_t<24, 0x3f>::value<X>();
    static constexpr uint32_t TXBC_TFQM = 0x40000000;    // Tx FIFO/Queue Mode
    static const uint32_t TXBC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TXFQS_TFFL =                // Tx FIFO Free Level (6 bits)
        bit_field_t<0, 0x3f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TXFQS_TFGI =                // TFGI (5 bits)
        bit_field_t<8, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TXFQS_TFQPI =               // Tx FIFO/Queue Put Index (5 bits)
        bit_field_t<16, 0x1f>::value<X>();
    static constexpr uint32_t TXFQS_TFQF = 0x200000;      // Tx FIFO/Queue Full
    static const uint32_t TXFQS_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TXESC_TBDS =                // Tx Buffer Data Field Size: (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t TXESC_RESET_VALUE = 0x0;


    static const uint32_t TXBRP_RESET_VALUE = 0x0;


    static const uint32_t TXBAR_RESET_VALUE = 0x0;


    static const uint32_t TXBCR_RESET_VALUE = 0x0;


    static const uint32_t TXBTO_RESET_VALUE = 0x0;


    static const uint32_t TXBCF_RESET_VALUE = 0x0;


    static const uint32_t TXBTIE_RESET_VALUE = 0x0;


    static const uint32_t TXBCIE_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TXEFC_EFSA =                // Event FIFO Start Address (14 bits)
        bit_field_t<2, 0x3fff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TXEFC_EFS =                 // Event FIFO Size (6 bits)
        bit_field_t<16, 0x3f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TXEFC_EFWM =                // Event FIFO Watermark (6 bits)
        bit_field_t<24, 0x3f>::value<X>();
    static const uint32_t TXEFC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TXEFS_EFFL =                // Event FIFO Fill Level (6 bits)
        bit_field_t<0, 0x3f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TXEFS_EFGI =                // Event FIFO Get Index. (5 bits)
        bit_field_t<8, 0x1f>::value<X>();
    static constexpr uint32_t TXEFS_EFF = 0x1000000;      // Event FIFO Full.
    static constexpr uint32_t TXEFS_TEFL = 0x2000000;     // Tx Event FIFO Element Lost.
    static const uint32_t TXEFS_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TXEFA_EFAI =                // Event FIFO Acknowledge Index (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t TXEFA_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TTTMC_TMSA =                // Trigger Memory Start Address (14 bits)
        bit_field_t<2, 0x3fff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TTTMC_TME =                 // Trigger Memory Elements (7 bits)
        bit_field_t<16, 0x7f>::value<X>();
    static const uint32_t TTTMC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TTRMC_RID =                 // Reference Identifier. (29 bits)
        bit_field_t<0, 0x1fffffff>::value<X>();
    static constexpr uint32_t TTRMC_XTD = 0x40000000;     // Extended Identifier
    static constexpr uint32_t TTRMC_RMPS = 0x80000000;    // Reference Message Payload Select
    static const uint32_t TTRMC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TTOCF_OM =                  // Operation Mode (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static constexpr uint32_t TTOCF_GEN = 0x8;            // Gap Enable
    static constexpr uint32_t TTOCF_TM = 0x10;            // Time Master
    template<uint32_t X>
    static constexpr uint32_t TTOCF_LDSDL =               // LD of Synchronization Deviation Limit (3 bits)
        bit_field_t<5, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TTOCF_IRTO =                // Initial Reference Trigger Offset (7 bits)
        bit_field_t<8, 0x7f>::value<X>();
    static constexpr uint32_t TTOCF_EECS = 0x8000;        // Enable External Clock Synchronization
    template<uint32_t X>
    static constexpr uint32_t TTOCF_AWL =                 // Application Watchdog Limit (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static constexpr uint32_t TTOCF_EGTF = 0x1000000;     // Enable Global Time Filtering
    static constexpr uint32_t TTOCF_ECC = 0x2000000;      // Enable Clock Calibration
    static constexpr uint32_t TTOCF_EVTP = 0x4000000;     // Event Trigger Polarity
    static const uint32_t TTOCF_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TTMLM_CCM =                 // Cycle Count Max (6 bits)
        bit_field_t<0, 0x3f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TTMLM_CSS =                 // Cycle Start Synchronization (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TTMLM_TXEW =                // Tx Enable Window (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TTMLM_ENTT =                // Expected Number of Tx Triggers (12 bits)
        bit_field_t<16, 0xfff>::value<X>();
    static const uint32_t TTMLM_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TURCF_NCL =                 // Numerator Configuration Low. (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TURCF_DC =                  // Denominator Configuration. (14 bits)
        bit_field_t<16, 0x3fff>::value<X>();
    static constexpr uint32_t TURCF_ELT = 0x80000000;     // Enable Local Time
    static const uint32_t TURCF_RESET_VALUE = 0x0;

    static constexpr uint32_t TTOCN_SGT = 0x1;            // Set Global time
    static constexpr uint32_t TTOCN_ECS = 0x2;            // External Clock Synchronization
    static constexpr uint32_t TTOCN_SWP = 0x4;            // Stop Watch Polarity
    template<uint32_t X>
    static constexpr uint32_t TTOCN_SWS =                 // Stop Watch Source. (2 bits)
        bit_field_t<3, 0x3>::value<X>();
    static constexpr uint32_t TTOCN_RTIE = 0x20;          // Register Time Mark Interrupt Pulse Enable
    template<uint32_t X>
    static constexpr uint32_t TTOCN_TMC =                 // Register Time Mark Compare (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t TTOCN_TTIE = 0x100;         // Trigger Time Mark Interrupt Pulse Enable
    static constexpr uint32_t TTOCN_GCS = 0x200;          // Gap Control Select
    static constexpr uint32_t TTOCN_FGP = 0x400;          // Finish Gap.
    static constexpr uint32_t TTOCN_TMG = 0x800;          // Time Mark Gap
    static constexpr uint32_t TTOCN_NIG = 0x1000;         // Next is Gap
    static constexpr uint32_t TTOCN_ESCN = 0x2000;        // External Synchronization Control
    static constexpr uint32_t TTOCN_LCKC = 0x8000;        // TT Operation Control Register Locked
    static const uint32_t TTOCN_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CAN_TTGTP_NCL =                 // Time Preset (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CAN_TTGTP_CTP =                 // Cycle Time Target Phase (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t CAN_TTGTP_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TTTMK_TM =                  // Time Mark (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TTTMK_TICC =                // Time Mark Cycle Code (7 bits)
        bit_field_t<16, 0x7f>::value<X>();
    static constexpr uint32_t TTTMK_LCKM = 0x80000000;    // TT Time Mark Register Locked
    static const uint32_t TTTMK_RESET_VALUE = 0x0;

    static constexpr uint32_t TTIR_SBC = 0x1;            // Start of Basic Cycle
    static constexpr uint32_t TTIR_SMC = 0x2;            // Start of Matrix Cycle
    static constexpr uint32_t TTIR_CSM = 0x4;            // Change of Synchronization Mode
    static constexpr uint32_t TTIR_SOG = 0x8;            // Start of Gap
    static constexpr uint32_t TTIR_RTMI = 0x10;          // Register Time Mark Interrupt.
    static constexpr uint32_t TTIR_TTMI = 0x20;          // Trigger Time Mark Event Internal
    static constexpr uint32_t TTIR_SWE = 0x40;           // Stop Watch Event
    static constexpr uint32_t TTIR_GTW = 0x80;           // Global Time Wrap
    static constexpr uint32_t TTIR_GTD = 0x100;          // Global Time Discontinuity
    static constexpr uint32_t TTIR_GTE = 0x200;          // Global Time Error
    static constexpr uint32_t TTIR_TXU = 0x400;          // Tx Count Underflow
    static constexpr uint32_t TTIR_TXO = 0x800;          // Tx Count Overflow
    static constexpr uint32_t TTIR_SE1 = 0x1000;         // Scheduling Error 1
    static constexpr uint32_t TTIR_SE2 = 0x2000;         // Scheduling Error 2
    static constexpr uint32_t TTIR_ELC = 0x4000;         // Error Level Changed.
    static constexpr uint32_t TTIR_IWTG = 0x8000;        // Initialization Watch Trigger
    static constexpr uint32_t TTIR_WT = 0x10000;         // Watch Trigger
    static constexpr uint32_t TTIR_AW = 0x20000;         // Application Watchdog
    static constexpr uint32_t TTIR_CER = 0x40000;        // Configuration Error
    static const uint32_t TTIR_RESET_VALUE = 0x0;

    static constexpr uint32_t TTIE_SBCE = 0x1;           // Start of Basic Cycle Interrupt Enable
    static constexpr uint32_t TTIE_SMCE = 0x2;           // Start of Matrix Cycle Interrupt Enable
    static constexpr uint32_t TTIE_CSME = 0x4;           // Change of Synchronization Mode Interrupt Enable
    static constexpr uint32_t TTIE_SOGE = 0x8;           // Start of Gap Interrupt Enable
    static constexpr uint32_t TTIE_RTMIE = 0x10;         // Register Time Mark Interrupt Enable
    static constexpr uint32_t TTIE_TTMIE = 0x20;         // Trigger Time Mark Event Internal Interrupt Enable
    static constexpr uint32_t TTIE_SWEE = 0x40;          // Stop Watch Event Interrupt Enable
    static constexpr uint32_t TTIE_GTWE = 0x80;          // Global Time Wrap Interrupt Enable
    static constexpr uint32_t TTIE_GTDE = 0x100;         // Global Time Discontinuity Interrupt Enable
    static constexpr uint32_t TTIE_GTEE = 0x200;         // Global Time Error Interrupt Enable
    static constexpr uint32_t TTIE_TXUE = 0x400;         // Tx Count Underflow Interrupt Enable
    static constexpr uint32_t TTIE_TXOE = 0x800;         // Tx Count Overflow Interrupt Enable
    static constexpr uint32_t TTIE_SE1E = 0x1000;        // Scheduling Error 1 Interrupt Enable
    static constexpr uint32_t TTIE_SE2E = 0x2000;        // Scheduling Error 2 Interrupt Enable
    static constexpr uint32_t TTIE_ELCE = 0x4000;        // Change Error Level Interrupt Enable
    static constexpr uint32_t TTIE_IWTGE = 0x8000;       // Initialization Watch Trigger Interrupt Enable
    static constexpr uint32_t TTIE_WTE = 0x10000;        // Watch Trigger Interrupt Enable
    static constexpr uint32_t TTIE_AWE = 0x20000;        // Application Watchdog Interrupt Enable
    static constexpr uint32_t TTIE_CERE = 0x40000;       // Configuration Error Interrupt Enable
    static const uint32_t TTIE_RESET_VALUE = 0x0;

    static constexpr uint32_t TTILS_SBCL = 0x1;           // Start of Basic Cycle Interrupt Line
    static constexpr uint32_t TTILS_SMCL = 0x2;           // Start of Matrix Cycle Interrupt Line
    static constexpr uint32_t TTILS_CSML = 0x4;           // Change of Synchronization Mode Interrupt Line
    static constexpr uint32_t TTILS_SOGL = 0x8;           // Start of Gap Interrupt Line
    static constexpr uint32_t TTILS_RTMIL = 0x10;         // Register Time Mark Interrupt Line
    static constexpr uint32_t TTILS_TTMIL = 0x20;         // Trigger Time Mark Event Internal Interrupt Line
    static constexpr uint32_t TTILS_SWEL = 0x40;          // Stop Watch Event Interrupt Line
    static constexpr uint32_t TTILS_GTWL = 0x80;          // Global Time Wrap Interrupt Line
    static constexpr uint32_t TTILS_GTDL = 0x100;         // Global Time Discontinuity Interrupt Line
    static constexpr uint32_t TTILS_GTEL = 0x200;         // Global Time Error Interrupt Line
    static constexpr uint32_t TTILS_TXUL = 0x400;         // Tx Count Underflow Interrupt Line
    static constexpr uint32_t TTILS_TXOL = 0x800;         // Tx Count Overflow Interrupt Line
    static constexpr uint32_t TTILS_SE1L = 0x1000;        // Scheduling Error 1 Interrupt Line
    static constexpr uint32_t TTILS_SE2L = 0x2000;        // Scheduling Error 2 Interrupt Line
    static constexpr uint32_t TTILS_ELCL = 0x4000;        // Change Error Level Interrupt Line
    static constexpr uint32_t TTILS_IWTGL = 0x8000;       // Initialization Watch Trigger Interrupt Line
    static constexpr uint32_t TTILS_WTL = 0x10000;        // Watch Trigger Interrupt Line
    static constexpr uint32_t TTILS_AWL = 0x20000;        // Application Watchdog Interrupt Line
    static constexpr uint32_t TTILS_CERL = 0x40000;       // Configuration Error Interrupt Line
    static const uint32_t TTILS_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TTOST_EL =                  // Error Level (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TTOST_MS =                  // Master State. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TTOST_SYS =                 // Synchronization State (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static constexpr uint32_t TTOST_GTP = 0x40;           // Quality of Global Time Phase
    static constexpr uint32_t TTOST_QCS = 0x80;           // Quality of Clock Speed
    template<uint32_t X>
    static constexpr uint32_t TTOST_RTO =                 // Reference Trigger Offset (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t TTOST_WGTD = 0x400000;      // Wait for Global Time Discontinuity
    static constexpr uint32_t TTOST_GFI = 0x800000;       // Gap Finished Indicator.
    template<uint32_t X>
    static constexpr uint32_t TTOST_TMP =                 // Time Master Priority (3 bits)
        bit_field_t<24, 0x7>::value<X>();
    static constexpr uint32_t TTOST_GSI = 0x8000000;      // Gap Started Indicator.
    static constexpr uint32_t TTOST_WFE = 0x10000000;     // Wait for Event
    static constexpr uint32_t TTOST_AWE = 0x20000000;     // Application Watchdog Event
    static constexpr uint32_t TTOST_WECS = 0x40000000;    // Wait for External Clock Synchronization
    static constexpr uint32_t TTOST_SPL = 0x80000000;     // Schedule Phase Lock
    static const uint32_t TTOST_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TURNA_NAV =                 // Numerator Actual Value (18 bits)
        bit_field_t<0, 0x3ffff>::value<X>();
    static const uint32_t TURNA_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TTLGT_LT =                  // Local Time (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TTLGT_GT =                  // Global Time (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t TTLGT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TTCTC_CT =                  // Cycle Time (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TTCTC_CC =                  // Cycle Count (6 bits)
        bit_field_t<16, 0x3f>::value<X>();
    static const uint32_t TTCTC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TTCPT_CT =                  // Cycle Count Value (6 bits)
        bit_field_t<0, 0x3f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TTCPT_SWV =                 // Stop Watch Value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t TTCPT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TTCSM_CSM =                 // Cycle Sync Mark (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t TTCSM_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TTTS_SWTDEL =              // Stop watch trigger input selection (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TTTS_EVTSEL =              // Event trigger input selection (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static const uint32_t TTTS_RESET_VALUE = 0x0;

    static constexpr uint8_t FDCAN1_IT0 = 19; // FDCAN1 Interrupt 0
    static constexpr uint8_t FDCAN1_IT1 = 21; // FDCAN1 Interrupt 1
    static constexpr uint8_t FDCAN_CAL = 63; // CAN2TX interrupts
};

static fdcan1_t& FDCAN1 = *reinterpret_cast<fdcan1_t*>(0x4000a000);

#define HAVE_PERIPHERAL_FDCAN1


////
//
//    FDCAN1
//
////

struct fdcan2_t
{
    volatile uint32_t    CREL;                 // [Read-only] FDCAN Core Release Register
    volatile uint32_t    ENDN;                 // [Read-only] FDCAN Core Release Register
    reserved_t<1>        _0;
    volatile uint32_t    DBTP;                 // [Read-only] FDCAN Data Bit Timing and Prescaler Register
    volatile uint32_t    TEST;                 // [Read-only] FDCAN Test Register
    volatile uint32_t    RWD;                  // [Read-only] FDCAN RAM Watchdog Register
    volatile uint32_t    CCCR;                 // [Read-write] FDCAN CC Control Register
    volatile uint32_t    NBTP;                 // [Read-write] FDCAN Nominal Bit Timing and Prescaler Register
    volatile uint32_t    TSCC;                 // [Read-write] FDCAN Timestamp Counter Configuration Register
    volatile uint32_t    TSCV;                 // [Read-write] FDCAN Timestamp Counter Value Register
    volatile uint32_t    TOCC;                 // [Read-write] FDCAN Timeout Counter Configuration Register
    volatile uint32_t    TOCV;                 // [Read-write] FDCAN Timeout Counter Value Register
    reserved_t<4>        _1;
    volatile uint32_t    ECR;                  // [Read-write] FDCAN Error Counter Register
    volatile uint32_t    PSR;                  // [Read-write] FDCAN Protocol Status Register
    volatile uint32_t    TDCR;                 // [Read-only] FDCAN Transmitter Delay Compensation Register
    reserved_t<1>        _2;
    volatile uint32_t    IR;                   // [Read-only] FDCAN Interrupt Register
    volatile uint32_t    IE;                   // [Read-only] FDCAN Interrupt Enable Register
    volatile uint32_t    ILS;                  // [Read-only] FDCAN Interrupt Line Select Register
    volatile uint32_t    ILE;                  // [Read-write] FDCAN Interrupt Line Enable Register
    reserved_t<8>        _3;
    volatile uint32_t    GFC;                  // [Read-write] FDCAN Global Filter Configuration Register
    volatile uint32_t    SIDFC;                // [Read-write] FDCAN Standard ID Filter Configuration Register
    volatile uint32_t    XIDFC;                // [Read-write] FDCAN Extended ID Filter Configuration Register
    reserved_t<1>        _4;
    volatile uint32_t    XIDAM;                // [Read-write] FDCAN Extended ID and Mask Register
    volatile uint32_t    HPMS;                 // [Read-only] FDCAN High Priority Message Status Register
    volatile uint32_t    NDAT1;                // [Read-only] FDCAN New Data 1 Register
    volatile uint32_t    NDAT2;                // [Read-only] FDCAN New Data 2 Register
    volatile uint32_t    RXF0C;                // [Read-write] FDCAN Rx FIFO 0 Configuration Register
    volatile uint32_t    RXF0S;                // [Read-write] FDCAN Rx FIFO 0 Status Register
    volatile uint32_t    RXF0A;                // [Read-write] CAN Rx FIFO 0 Acknowledge Register
    volatile uint32_t    RXBC;                 // [Read-write] FDCAN Rx Buffer Configuration Register
    volatile uint32_t    RXF1C;                // [Read-write] FDCAN Rx FIFO 1 Configuration Register
    volatile uint32_t    RXF1S;                // [Read-write] FDCAN Rx FIFO 1 Status Register
    volatile uint32_t    RXF1A;                // [Read-write] FDCAN Rx FIFO 1 Acknowledge Register
    volatile uint32_t    RXESC;                // [Read-write] FDCAN Rx Buffer Element Size Configuration Register
    volatile uint32_t    TXBC;                 // [Read-write] FDCAN Tx Buffer Configuration Register
    volatile uint32_t    TXFQS;                // [Read-only] FDCAN Tx FIFO/Queue Status Register
    volatile uint32_t    TXESC;                // [Read-write] FDCAN Tx Buffer Element Size Configuration Register
    volatile uint32_t    TXBRP;                // [Read-only] FDCAN Tx Buffer Request Pending Register
    volatile uint32_t    TXBAR;                // [Read-write] FDCAN Tx Buffer Add Request Register
    volatile uint32_t    TXBCR;                // [Read-write] FDCAN Tx Buffer Cancellation Request Register
    volatile uint32_t    TXBTO;                // [Read-write] FDCAN Tx Buffer Transmission Occurred Register
    volatile uint32_t    TXBCF;                // [Read-only] FDCAN Tx Buffer Cancellation Finished Register
    volatile uint32_t    TXBTIE;               // [Read-write] FDCAN Tx Buffer Transmission Interrupt Enable Register
    volatile uint32_t    TXBCIE;               // [Read-write] FDCAN Tx Buffer Cancellation Finished Interrupt Enable Register
    reserved_t<2>        _5;
    volatile uint32_t    TXEFC;                // [Read-write] FDCAN Tx Event FIFO Configuration Register
    volatile uint32_t    TXEFS;                // [Read-write] FDCAN Tx Event FIFO Status Register
    volatile uint32_t    TXEFA;                // [Read-write] FDCAN Tx Event FIFO Acknowledge Register
    reserved_t<1>        _6;
    volatile uint32_t    TTTMC;                // [Read-write] FDCAN TT Trigger Memory Configuration Register
    volatile uint32_t    TTRMC;                // [Read-write] FDCAN TT Reference Message Configuration Register
    volatile uint32_t    TTOCF;                // [Read-write] FDCAN TT Operation Configuration Register
    volatile uint32_t    TTMLM;                // [Read-write] FDCAN TT Matrix Limits Register
    volatile uint32_t    TURCF;                // [Read-write] FDCAN TUR Configuration Register
    volatile uint32_t    TTOCN;                // [Read-write] FDCAN TT Operation Control Register
    volatile uint32_t    CAN_TTGTP;            // [Read-write] FDCAN TT Global Time Preset Register
    volatile uint32_t    TTTMK;                // [Read-write] FDCAN TT Time Mark Register
    volatile uint32_t    TTIR;                 // [Read-write] FDCAN TT Interrupt Register
    volatile uint32_t    TTIE;                 // [Read-write] FDCAN TT Interrupt Enable Register
    volatile uint32_t    TTILS;                // [Read-write] FDCAN TT Interrupt Line Select Register
    volatile uint32_t    TTOST;                // [Read-write] FDCAN TT Operation Status Register
    volatile uint32_t    TURNA;                // [Read-only] FDCAN TUR Numerator Actual Register
    volatile uint32_t    TTLGT;                // [Read-only] FDCAN TT Local and Global Time Register
    volatile uint32_t    TTCTC;                // [Read-only] FDCAN TT Cycle Time and Count Register
    volatile uint32_t    TTCPT;                // [Read-only] FDCAN TT Capture Time Register
    volatile uint32_t    TTCSM;                // [Read-only] FDCAN TT Cycle Sync Mark Register
    reserved_t<111>      _7;
    volatile uint32_t    TTTS;                 // [Read-write] FDCAN TT Trigger Select Register

    template<uint32_t X>
    static constexpr uint32_t CREL_REL =                 // Core release (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CREL_STEP =                // Step of Core release (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CREL_SUBSTEP =             // Sub-step of Core release (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CREL_YEAR =                // Timestamp Year (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CREL_MON =                 // Timestamp Month (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CREL_DAY =                 // Timestamp Day (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t CREL_RESET_VALUE = 0x0;


    static const uint32_t ENDN_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DBTP_DSJW =                // Synchronization Jump Width (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DBTP_DTSEG2 =              // Data time segment after sample point (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DBTP_DTSEG1 =              // Data time segment after sample point (5 bits)
        bit_field_t<8, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DBTP_DBRP =                // Data BIt Rate Prescaler (5 bits)
        bit_field_t<16, 0x1f>::value<X>();
    static constexpr uint32_t DBTP_TDC = 0x800000;       // Transceiver Delay Compensation
    static const uint32_t DBTP_RESET_VALUE = 0x0;

    static constexpr uint32_t TEST_LBCK = 0x10;          // Loop Back mode
    template<uint32_t X>
    static constexpr uint32_t TEST_TX =                  // Loop Back mode (2 bits)
        bit_field_t<5, 0x3>::value<X>();
    static constexpr uint32_t TEST_RX = 0x80;            // Control of Transmit Pin
    static const uint32_t TEST_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RWD_WDV =                 // Watchdog value (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RWD_WDC =                 // Watchdog configuration (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t RWD_RESET_VALUE = 0x0;

    static constexpr uint32_t CCCR_INIT = 0x1;           // Initialization
    static constexpr uint32_t CCCR_CCE = 0x2;            // Configuration Change Enable
    static constexpr uint32_t CCCR_ASM = 0x4;            // ASM Restricted Operation Mode
    static constexpr uint32_t CCCR_CSA = 0x8;            // Clock Stop Acknowledge
    static constexpr uint32_t CCCR_CSR = 0x10;           // Clock Stop Request
    static constexpr uint32_t CCCR_MON = 0x20;           // Bus Monitoring Mode
    static constexpr uint32_t CCCR_DAR = 0x40;           // Disable Automatic Retransmission
    static constexpr uint32_t CCCR_TEST = 0x80;          // Test Mode Enable
    static constexpr uint32_t CCCR_FDOE = 0x100;         // FD Operation Enable
    static constexpr uint32_t CCCR_BSE = 0x200;          // FDCAN Bit Rate Switching
    static constexpr uint32_t CCCR_PXHD = 0x1000;        // Protocol Exception Handling Disable
    static constexpr uint32_t CCCR_EFBI = 0x2000;        // Edge Filtering during Bus Integration
    static constexpr uint32_t CCCR_TXP = 0x4000;         // TXP
    static constexpr uint32_t CCCR_NISO = 0x8000;        // Non ISO Operation
    static const uint32_t CCCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t NBTP_NSJW =                // NSJW: Nominal (Re)Synchronization Jump Width (7 bits)
        bit_field_t<25, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t NBTP_NBRP =                // Bit Rate Prescaler (9 bits)
        bit_field_t<16, 0x1ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t NBTP_NTSEG1 =              // Nominal Time segment before sample point (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t NBTP_TSEG2 =               // Nominal Time segment after sample point (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    static const uint32_t NBTP_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TSCC_TCP =                 // Timestamp Counter Prescaler (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TSCC_TSS =                 // Timestamp Select (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t TSCC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TSCV_TSC =                 // Timestamp Counter (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t TSCV_RESET_VALUE = 0x0;

    static constexpr uint32_t TOCC_ETOC = 0x1;           // Enable Timeout Counter
    template<uint32_t X>
    static constexpr uint32_t TOCC_TOS =                 // Timeout Select (2 bits)
        bit_field_t<1, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TOCC_TOP =                 // Timeout Period (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t TOCC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TOCV_TOC =                 // Timeout Counter (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t TOCV_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ECR_CEL =                 // AN Error Logging (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static constexpr uint32_t ECR_RP = 0x8000;          // Receive Error Passive
    template<uint32_t X>
    static constexpr uint32_t ECR_TREC =                // Receive Error Counter (7 bits)
        bit_field_t<8, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ECR_TEC =                 // Transmit Error Counter (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t ECR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PSR_LEC =                 // Last Error Code (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PSR_ACT =                 // Activity (2 bits)
        bit_field_t<3, 0x3>::value<X>();
    static constexpr uint32_t PSR_EP = 0x20;            // Error Passive
    static constexpr uint32_t PSR_EW = 0x40;            // Warning Status
    static constexpr uint32_t PSR_BO = 0x80;            // Bus_Off Status
    template<uint32_t X>
    static constexpr uint32_t PSR_DLEC =                // Data Last Error Code (3 bits)
        bit_field_t<8, 0x7>::value<X>();
    static constexpr uint32_t PSR_RESI = 0x800;         // ESI flag of last received FDCAN Message
    static constexpr uint32_t PSR_RBRS = 0x1000;        // BRS flag of last received FDCAN Message
    static constexpr uint32_t PSR_REDL = 0x2000;        // Received FDCAN Message
    static constexpr uint32_t PSR_PXE = 0x4000;         // Protocol Exception Event
    template<uint32_t X>
    static constexpr uint32_t PSR_TDCV =                // Transmitter Delay Compensation Value (7 bits)
        bit_field_t<16, 0x7f>::value<X>();
    static const uint32_t PSR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDCR_TDCF =                // Transmitter Delay Compensation Filter Window Length (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDCR_TDCO =                // Transmitter Delay Compensation Offset (7 bits)
        bit_field_t<8, 0x7f>::value<X>();
    static const uint32_t TDCR_RESET_VALUE = 0x0;

    static constexpr uint32_t IR_RF0N = 0x1;           // Rx FIFO 0 New Message
    static constexpr uint32_t IR_RF0W = 0x2;           // Rx FIFO 0 Full
    static constexpr uint32_t IR_RF0F = 0x4;           // Rx FIFO 0 Full
    static constexpr uint32_t IR_RF0L = 0x8;           // Rx FIFO 0 Message Lost
    static constexpr uint32_t IR_RF1N = 0x10;          // Rx FIFO 1 New Message
    static constexpr uint32_t IR_RF1W = 0x20;          // Rx FIFO 1 Watermark Reached
    static constexpr uint32_t IR_RF1F = 0x40;          // Rx FIFO 1 Watermark Reached
    static constexpr uint32_t IR_RF1L = 0x80;          // Rx FIFO 1 Message Lost
    static constexpr uint32_t IR_HPM = 0x100;          // High Priority Message
    static constexpr uint32_t IR_TC = 0x200;           // Transmission Completed
    static constexpr uint32_t IR_TCF = 0x400;          // Transmission Cancellation Finished
    static constexpr uint32_t IR_TEF = 0x800;          // Tx FIFO Empty
    static constexpr uint32_t IR_TEFN = 0x1000;        // Tx Event FIFO New Entry
    static constexpr uint32_t IR_TEFW = 0x2000;        // Tx Event FIFO Watermark Reached
    static constexpr uint32_t IR_TEFF = 0x4000;        // Tx Event FIFO Full
    static constexpr uint32_t IR_TEFL = 0x8000;        // Tx Event FIFO Element Lost
    static constexpr uint32_t IR_TSW = 0x10000;        // Timestamp Wraparound
    static constexpr uint32_t IR_MRAF = 0x20000;       // Message RAM Access Failure
    static constexpr uint32_t IR_TOO = 0x40000;        // Timeout Occurred
    static constexpr uint32_t IR_DRX = 0x80000;        // Message stored to Dedicated Rx Buffer
    static constexpr uint32_t IR_ELO = 0x400000;       // Error Logging Overflow
    static constexpr uint32_t IR_EP = 0x800000;        // Error Passive
    static constexpr uint32_t IR_EW = 0x1000000;       // Warning Status
    static constexpr uint32_t IR_BO = 0x2000000;       // Bus_Off Status
    static constexpr uint32_t IR_WDI = 0x4000000;      // Watchdog Interrupt
    static constexpr uint32_t IR_PEA = 0x8000000;      // Protocol Error in Arbitration Phase (Nominal Bit Time is used)
    static constexpr uint32_t IR_PED = 0x10000000;     // Protocol Error in Data Phase (Data Bit Time is used)
    static constexpr uint32_t IR_ARA = 0x20000000;     // Access to Reserved Address
    static const uint32_t IR_RESET_VALUE = 0x0;

    static constexpr uint32_t IE_RF0NE = 0x1;          // Rx FIFO 0 New Message Enable
    static constexpr uint32_t IE_RF0WE = 0x2;          // Rx FIFO 0 Full Enable
    static constexpr uint32_t IE_RF0FE = 0x4;          // Rx FIFO 0 Full Enable
    static constexpr uint32_t IE_RF0LE = 0x8;          // Rx FIFO 0 Message Lost Enable
    static constexpr uint32_t IE_RF1NE = 0x10;         // Rx FIFO 1 New Message Enable
    static constexpr uint32_t IE_RF1WE = 0x20;         // Rx FIFO 1 Watermark Reached Enable
    static constexpr uint32_t IE_RF1FE = 0x40;         // Rx FIFO 1 Watermark Reached Enable
    static constexpr uint32_t IE_RF1LE = 0x80;         // Rx FIFO 1 Message Lost Enable
    static constexpr uint32_t IE_HPME = 0x100;         // High Priority Message Enable
    static constexpr uint32_t IE_TCE = 0x200;          // Transmission Completed Enable
    static constexpr uint32_t IE_TCFE = 0x400;         // Transmission Cancellation Finished Enable
    static constexpr uint32_t IE_TEFE = 0x800;         // Tx FIFO Empty Enable
    static constexpr uint32_t IE_TEFNE = 0x1000;       // Tx Event FIFO New Entry Enable
    static constexpr uint32_t IE_TEFWE = 0x2000;       // Tx Event FIFO Watermark Reached Enable
    static constexpr uint32_t IE_TEFFE = 0x4000;       // Tx Event FIFO Full Enable
    static constexpr uint32_t IE_TEFLE = 0x8000;       // Tx Event FIFO Element Lost Enable
    static constexpr uint32_t IE_TSWE = 0x10000;       // Timestamp Wraparound Enable
    static constexpr uint32_t IE_MRAFE = 0x20000;      // Message RAM Access Failure Enable
    static constexpr uint32_t IE_TOOE = 0x40000;       // Timeout Occurred Enable
    static constexpr uint32_t IE_DRXE = 0x80000;       // Message stored to Dedicated Rx Buffer Enable
    static constexpr uint32_t IE_BECE = 0x100000;      // Bit Error Corrected Interrupt Enable
    static constexpr uint32_t IE_BEUE = 0x200000;      // Bit Error Uncorrected Interrupt Enable
    static constexpr uint32_t IE_ELOE = 0x400000;      // Error Logging Overflow Enable
    static constexpr uint32_t IE_EPE = 0x800000;       // Error Passive Enable
    static constexpr uint32_t IE_EWE = 0x1000000;      // Warning Status Enable
    static constexpr uint32_t IE_BOE = 0x2000000;      // Bus_Off Status Enable
    static constexpr uint32_t IE_WDIE = 0x4000000;     // Watchdog Interrupt Enable
    static constexpr uint32_t IE_PEAE = 0x8000000;     // Protocol Error in Arbitration Phase Enable
    static constexpr uint32_t IE_PEDE = 0x10000000;    // Protocol Error in Data Phase Enable
    static constexpr uint32_t IE_ARAE = 0x20000000;    // Access to Reserved Address Enable
    static const uint32_t IE_RESET_VALUE = 0x0;

    static constexpr uint32_t ILS_RF0NL = 0x1;          // Rx FIFO 0 New Message Interrupt Line
    static constexpr uint32_t ILS_RF0WL = 0x2;          // Rx FIFO 0 Watermark Reached Interrupt Line
    static constexpr uint32_t ILS_RF0FL = 0x4;          // Rx FIFO 0 Full Interrupt Line
    static constexpr uint32_t ILS_RF0LL = 0x8;          // Rx FIFO 0 Message Lost Interrupt Line
    static constexpr uint32_t ILS_RF1NL = 0x10;         // Rx FIFO 1 New Message Interrupt Line
    static constexpr uint32_t ILS_RF1WL = 0x20;         // Rx FIFO 1 Watermark Reached Interrupt Line
    static constexpr uint32_t ILS_RF1FL = 0x40;         // Rx FIFO 1 Full Interrupt Line
    static constexpr uint32_t ILS_RF1LL = 0x80;         // Rx FIFO 1 Message Lost Interrupt Line
    static constexpr uint32_t ILS_HPML = 0x100;         // High Priority Message Interrupt Line
    static constexpr uint32_t ILS_TCL = 0x200;          // Transmission Completed Interrupt Line
    static constexpr uint32_t ILS_TCFL = 0x400;         // Transmission Cancellation Finished Interrupt Line
    static constexpr uint32_t ILS_TEFL = 0x800;         // Tx FIFO Empty Interrupt Line
    static constexpr uint32_t ILS_TEFNL = 0x1000;       // Tx Event FIFO New Entry Interrupt Line
    static constexpr uint32_t ILS_TEFWL = 0x2000;       // Tx Event FIFO Watermark Reached Interrupt Line
    static constexpr uint32_t ILS_TEFFL = 0x4000;       // Tx Event FIFO Full Interrupt Line
    static constexpr uint32_t ILS_TEFLL = 0x8000;       // Tx Event FIFO Element Lost Interrupt Line
    static constexpr uint32_t ILS_TSWL = 0x10000;       // Timestamp Wraparound Interrupt Line
    static constexpr uint32_t ILS_MRAFL = 0x20000;      // Message RAM Access Failure Interrupt Line
    static constexpr uint32_t ILS_TOOL = 0x40000;       // Timeout Occurred Interrupt Line
    static constexpr uint32_t ILS_DRXL = 0x80000;       // Message stored to Dedicated Rx Buffer Interrupt Line
    static constexpr uint32_t ILS_BECL = 0x100000;      // Bit Error Corrected Interrupt Line
    static constexpr uint32_t ILS_BEUL = 0x200000;      // Bit Error Uncorrected Interrupt Line
    static constexpr uint32_t ILS_ELOL = 0x400000;      // Error Logging Overflow Interrupt Line
    static constexpr uint32_t ILS_EPL = 0x800000;       // Error Passive Interrupt Line
    static constexpr uint32_t ILS_EWL = 0x1000000;      // Warning Status Interrupt Line
    static constexpr uint32_t ILS_BOL = 0x2000000;      // Bus_Off Status
    static constexpr uint32_t ILS_WDIL = 0x4000000;     // Watchdog Interrupt Line
    static constexpr uint32_t ILS_PEAL = 0x8000000;     // Protocol Error in Arbitration Phase Line
    static constexpr uint32_t ILS_PEDL = 0x10000000;    // Protocol Error in Data Phase Line
    static constexpr uint32_t ILS_ARAL = 0x20000000;    // Access to Reserved Address Line
    static const uint32_t ILS_RESET_VALUE = 0x0;

    static constexpr uint32_t ILE_EINT0 = 0x1;          // Enable Interrupt Line 0
    static constexpr uint32_t ILE_EINT1 = 0x2;          // Enable Interrupt Line 1
    static const uint32_t ILE_RESET_VALUE = 0x0;

    static constexpr uint32_t GFC_RRFE = 0x1;           // Reject Remote Frames Extended
    static constexpr uint32_t GFC_RRFS = 0x2;           // Reject Remote Frames Standard
    template<uint32_t X>
    static constexpr uint32_t GFC_ANFE =                // Accept Non-matching Frames Extended (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GFC_ANFS =                // Accept Non-matching Frames Standard (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static const uint32_t GFC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SIDFC_FLSSA =               // Filter List Standard Start Address (14 bits)
        bit_field_t<2, 0x3fff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SIDFC_LSS =                 // List Size Standard (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static const uint32_t SIDFC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t XIDFC_FLESA =               // Filter List Standard Start Address (14 bits)
        bit_field_t<2, 0x3fff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t XIDFC_LSE =                 // List Size Extended (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static const uint32_t XIDFC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t XIDAM_EIDM =                // Extended ID Mask (29 bits)
        bit_field_t<0, 0x1fffffff>::value<X>();
    static const uint32_t XIDAM_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HPMS_BIDX =                // Buffer Index (6 bits)
        bit_field_t<0, 0x3f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t HPMS_MSI =                 // Message Storage Indicator (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t HPMS_FIDX =                // Filter Index (7 bits)
        bit_field_t<8, 0x7f>::value<X>();
    static constexpr uint32_t HPMS_FLST = 0x8000;        // Filter List
    static const uint32_t HPMS_RESET_VALUE = 0x0;

    static constexpr uint32_t NDAT1_ND0 = 0x1;            // New data
    static constexpr uint32_t NDAT1_ND1 = 0x2;            // New data
    static constexpr uint32_t NDAT1_ND2 = 0x4;            // New data
    static constexpr uint32_t NDAT1_ND3 = 0x8;            // New data
    static constexpr uint32_t NDAT1_ND4 = 0x10;           // New data
    static constexpr uint32_t NDAT1_ND5 = 0x20;           // New data
    static constexpr uint32_t NDAT1_ND6 = 0x40;           // New data
    static constexpr uint32_t NDAT1_ND7 = 0x80;           // New data
    static constexpr uint32_t NDAT1_ND8 = 0x100;          // New data
    static constexpr uint32_t NDAT1_ND9 = 0x200;          // New data
    static constexpr uint32_t NDAT1_ND10 = 0x400;         // New data
    static constexpr uint32_t NDAT1_ND11 = 0x800;         // New data
    static constexpr uint32_t NDAT1_ND12 = 0x1000;        // New data
    static constexpr uint32_t NDAT1_ND13 = 0x2000;        // New data
    static constexpr uint32_t NDAT1_ND14 = 0x4000;        // New data
    static constexpr uint32_t NDAT1_ND15 = 0x8000;        // New data
    static constexpr uint32_t NDAT1_ND16 = 0x10000;       // New data
    static constexpr uint32_t NDAT1_ND17 = 0x20000;       // New data
    static constexpr uint32_t NDAT1_ND18 = 0x40000;       // New data
    static constexpr uint32_t NDAT1_ND19 = 0x80000;       // New data
    static constexpr uint32_t NDAT1_ND20 = 0x100000;      // New data
    static constexpr uint32_t NDAT1_ND21 = 0x200000;      // New data
    static constexpr uint32_t NDAT1_ND22 = 0x400000;      // New data
    static constexpr uint32_t NDAT1_ND23 = 0x800000;      // New data
    static constexpr uint32_t NDAT1_ND24 = 0x1000000;     // New data
    static constexpr uint32_t NDAT1_ND25 = 0x2000000;     // New data
    static constexpr uint32_t NDAT1_ND26 = 0x4000000;     // New data
    static constexpr uint32_t NDAT1_ND27 = 0x8000000;     // New data
    static constexpr uint32_t NDAT1_ND28 = 0x10000000;    // New data
    static constexpr uint32_t NDAT1_ND29 = 0x20000000;    // New data
    static constexpr uint32_t NDAT1_ND30 = 0x40000000;    // New data
    static constexpr uint32_t NDAT1_ND31 = 0x80000000;    // New data
    static const uint32_t NDAT1_RESET_VALUE = 0x0;

    static constexpr uint32_t NDAT2_ND32 = 0x1;           // New data
    static constexpr uint32_t NDAT2_ND33 = 0x2;           // New data
    static constexpr uint32_t NDAT2_ND34 = 0x4;           // New data
    static constexpr uint32_t NDAT2_ND35 = 0x8;           // New data
    static constexpr uint32_t NDAT2_ND36 = 0x10;          // New data
    static constexpr uint32_t NDAT2_ND37 = 0x20;          // New data
    static constexpr uint32_t NDAT2_ND38 = 0x40;          // New data
    static constexpr uint32_t NDAT2_ND39 = 0x80;          // New data
    static constexpr uint32_t NDAT2_ND40 = 0x100;         // New data
    static constexpr uint32_t NDAT2_ND41 = 0x200;         // New data
    static constexpr uint32_t NDAT2_ND42 = 0x400;         // New data
    static constexpr uint32_t NDAT2_ND43 = 0x800;         // New data
    static constexpr uint32_t NDAT2_ND44 = 0x1000;        // New data
    static constexpr uint32_t NDAT2_ND45 = 0x2000;        // New data
    static constexpr uint32_t NDAT2_ND46 = 0x4000;        // New data
    static constexpr uint32_t NDAT2_ND47 = 0x8000;        // New data
    static constexpr uint32_t NDAT2_ND48 = 0x10000;       // New data
    static constexpr uint32_t NDAT2_ND49 = 0x20000;       // New data
    static constexpr uint32_t NDAT2_ND50 = 0x40000;       // New data
    static constexpr uint32_t NDAT2_ND51 = 0x80000;       // New data
    static constexpr uint32_t NDAT2_ND52 = 0x100000;      // New data
    static constexpr uint32_t NDAT2_ND53 = 0x200000;      // New data
    static constexpr uint32_t NDAT2_ND54 = 0x400000;      // New data
    static constexpr uint32_t NDAT2_ND55 = 0x800000;      // New data
    static constexpr uint32_t NDAT2_ND56 = 0x1000000;     // New data
    static constexpr uint32_t NDAT2_ND57 = 0x2000000;     // New data
    static constexpr uint32_t NDAT2_ND58 = 0x4000000;     // New data
    static constexpr uint32_t NDAT2_ND59 = 0x8000000;     // New data
    static constexpr uint32_t NDAT2_ND60 = 0x10000000;    // New data
    static constexpr uint32_t NDAT2_ND61 = 0x20000000;    // New data
    static constexpr uint32_t NDAT2_ND62 = 0x40000000;    // New data
    static constexpr uint32_t NDAT2_ND63 = 0x80000000;    // New data
    static const uint32_t NDAT2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RXF0C_F0SA =                // Rx FIFO 0 Start Address (14 bits)
        bit_field_t<2, 0x3fff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RXF0C_F0S =                 // Rx FIFO 0 Size (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RXF0C_F0WM =                // FIFO 0 Watermark (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t RXF0C_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RXF0S_F0FL =                // Rx FIFO 0 Fill Level (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RXF0S_F0G =                 // Rx FIFO 0 Get Index (6 bits)
        bit_field_t<8, 0x3f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RXF0S_F0P =                 // Rx FIFO 0 Put Index (6 bits)
        bit_field_t<16, 0x3f>::value<X>();
    static constexpr uint32_t RXF0S_F0F = 0x1000000;      // Rx FIFO 0 Full
    static constexpr uint32_t RXF0S_RF0L = 0x2000000;     // Rx FIFO 0 Message Lost
    static const uint32_t RXF0S_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RXF0A_FA01 =                // Rx FIFO 0 Acknowledge Index (6 bits)
        bit_field_t<0, 0x3f>::value<X>();
    static const uint32_t RXF0A_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RXBC_RBSA =                // Rx Buffer Start Address (14 bits)
        bit_field_t<2, 0x3fff>::value<X>();
    static const uint32_t RXBC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RXF1C_F1SA =                // Rx FIFO 1 Start Address (14 bits)
        bit_field_t<2, 0x3fff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RXF1C_F1S =                 // Rx FIFO 1 Size (7 bits)
        bit_field_t<16, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RXF1C_F1WM =                // Rx FIFO 1 Watermark (7 bits)
        bit_field_t<24, 0x7f>::value<X>();
    static const uint32_t RXF1C_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RXF1S_F1FL =                // Rx FIFO 1 Fill Level (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RXF1S_F1GI =                // Rx FIFO 1 Get Index (7 bits)
        bit_field_t<8, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RXF1S_F1PI =                // Rx FIFO 1 Put Index (7 bits)
        bit_field_t<16, 0x7f>::value<X>();
    static constexpr uint32_t RXF1S_F1F = 0x1000000;      // Rx FIFO 1 Full
    static constexpr uint32_t RXF1S_RF1L = 0x2000000;     // Rx FIFO 1 Message Lost
    template<uint32_t X>
    static constexpr uint32_t RXF1S_DMS =                 // Debug Message Status (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    static const uint32_t RXF1S_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RXF1A_F1AI =                // Rx FIFO 1 Acknowledge Index (6 bits)
        bit_field_t<0, 0x3f>::value<X>();
    static const uint32_t RXF1A_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RXESC_F0DS =                // Rx FIFO 1 Data Field Size: (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RXESC_F1DS =                // Rx FIFO 0 Data Field Size: (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RXESC_RBDS =                // Rx Buffer Data Field Size: (3 bits)
        bit_field_t<8, 0x7>::value<X>();
    static const uint32_t RXESC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TXBC_TBSA =                // Tx Buffers Start Address (14 bits)
        bit_field_t<2, 0x3fff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TXBC_NDTB =                // Number of Dedicated Transmit Buffers (6 bits)
        bit_field_t<16, 0x3f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TXBC_TFQS =                // Transmit FIFO/Queue Size (6 bits)
        bit_field_t<24, 0x3f>::value<X>();
    static constexpr uint32_t TXBC_TFQM = 0x40000000;    // Tx FIFO/Queue Mode
    static const uint32_t TXBC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TXFQS_TFFL =                // Tx FIFO Free Level (6 bits)
        bit_field_t<0, 0x3f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TXFQS_TFGI =                // TFGI (5 bits)
        bit_field_t<8, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TXFQS_TFQPI =               // Tx FIFO/Queue Put Index (5 bits)
        bit_field_t<16, 0x1f>::value<X>();
    static constexpr uint32_t TXFQS_TFQF = 0x200000;      // Tx FIFO/Queue Full
    static const uint32_t TXFQS_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TXESC_TBDS =                // Tx Buffer Data Field Size: (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t TXESC_RESET_VALUE = 0x0;


    static const uint32_t TXBRP_RESET_VALUE = 0x0;


    static const uint32_t TXBAR_RESET_VALUE = 0x0;


    static const uint32_t TXBCR_RESET_VALUE = 0x0;


    static const uint32_t TXBTO_RESET_VALUE = 0x0;


    static const uint32_t TXBCF_RESET_VALUE = 0x0;


    static const uint32_t TXBTIE_RESET_VALUE = 0x0;


    static const uint32_t TXBCIE_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TXEFC_EFSA =                // Event FIFO Start Address (14 bits)
        bit_field_t<2, 0x3fff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TXEFC_EFS =                 // Event FIFO Size (6 bits)
        bit_field_t<16, 0x3f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TXEFC_EFWM =                // Event FIFO Watermark (6 bits)
        bit_field_t<24, 0x3f>::value<X>();
    static const uint32_t TXEFC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TXEFS_EFFL =                // Event FIFO Fill Level (6 bits)
        bit_field_t<0, 0x3f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TXEFS_EFGI =                // Event FIFO Get Index. (5 bits)
        bit_field_t<8, 0x1f>::value<X>();
    static constexpr uint32_t TXEFS_EFF = 0x1000000;      // Event FIFO Full.
    static constexpr uint32_t TXEFS_TEFL = 0x2000000;     // Tx Event FIFO Element Lost.
    static const uint32_t TXEFS_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TXEFA_EFAI =                // Event FIFO Acknowledge Index (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t TXEFA_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TTTMC_TMSA =                // Trigger Memory Start Address (14 bits)
        bit_field_t<2, 0x3fff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TTTMC_TME =                 // Trigger Memory Elements (7 bits)
        bit_field_t<16, 0x7f>::value<X>();
    static const uint32_t TTTMC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TTRMC_RID =                 // Reference Identifier. (29 bits)
        bit_field_t<0, 0x1fffffff>::value<X>();
    static constexpr uint32_t TTRMC_XTD = 0x40000000;     // Extended Identifier
    static constexpr uint32_t TTRMC_RMPS = 0x80000000;    // Reference Message Payload Select
    static const uint32_t TTRMC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TTOCF_OM =                  // Operation Mode (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static constexpr uint32_t TTOCF_GEN = 0x8;            // Gap Enable
    static constexpr uint32_t TTOCF_TM = 0x10;            // Time Master
    template<uint32_t X>
    static constexpr uint32_t TTOCF_LDSDL =               // LD of Synchronization Deviation Limit (3 bits)
        bit_field_t<5, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TTOCF_IRTO =                // Initial Reference Trigger Offset (7 bits)
        bit_field_t<8, 0x7f>::value<X>();
    static constexpr uint32_t TTOCF_EECS = 0x8000;        // Enable External Clock Synchronization
    template<uint32_t X>
    static constexpr uint32_t TTOCF_AWL =                 // Application Watchdog Limit (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static constexpr uint32_t TTOCF_EGTF = 0x1000000;     // Enable Global Time Filtering
    static constexpr uint32_t TTOCF_ECC = 0x2000000;      // Enable Clock Calibration
    static constexpr uint32_t TTOCF_EVTP = 0x4000000;     // Event Trigger Polarity
    static const uint32_t TTOCF_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TTMLM_CCM =                 // Cycle Count Max (6 bits)
        bit_field_t<0, 0x3f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TTMLM_CSS =                 // Cycle Start Synchronization (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TTMLM_TXEW =                // Tx Enable Window (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TTMLM_ENTT =                // Expected Number of Tx Triggers (12 bits)
        bit_field_t<16, 0xfff>::value<X>();
    static const uint32_t TTMLM_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TURCF_NCL =                 // Numerator Configuration Low. (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TURCF_DC =                  // Denominator Configuration. (14 bits)
        bit_field_t<16, 0x3fff>::value<X>();
    static constexpr uint32_t TURCF_ELT = 0x80000000;     // Enable Local Time
    static const uint32_t TURCF_RESET_VALUE = 0x0;

    static constexpr uint32_t TTOCN_SGT = 0x1;            // Set Global time
    static constexpr uint32_t TTOCN_ECS = 0x2;            // External Clock Synchronization
    static constexpr uint32_t TTOCN_SWP = 0x4;            // Stop Watch Polarity
    template<uint32_t X>
    static constexpr uint32_t TTOCN_SWS =                 // Stop Watch Source. (2 bits)
        bit_field_t<3, 0x3>::value<X>();
    static constexpr uint32_t TTOCN_RTIE = 0x20;          // Register Time Mark Interrupt Pulse Enable
    template<uint32_t X>
    static constexpr uint32_t TTOCN_TMC =                 // Register Time Mark Compare (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t TTOCN_TTIE = 0x100;         // Trigger Time Mark Interrupt Pulse Enable
    static constexpr uint32_t TTOCN_GCS = 0x200;          // Gap Control Select
    static constexpr uint32_t TTOCN_FGP = 0x400;          // Finish Gap.
    static constexpr uint32_t TTOCN_TMG = 0x800;          // Time Mark Gap
    static constexpr uint32_t TTOCN_NIG = 0x1000;         // Next is Gap
    static constexpr uint32_t TTOCN_ESCN = 0x2000;        // External Synchronization Control
    static constexpr uint32_t TTOCN_LCKC = 0x8000;        // TT Operation Control Register Locked
    static const uint32_t TTOCN_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CAN_TTGTP_NCL =                 // Time Preset (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CAN_TTGTP_CTP =                 // Cycle Time Target Phase (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t CAN_TTGTP_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TTTMK_TM =                  // Time Mark (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TTTMK_TICC =                // Time Mark Cycle Code (7 bits)
        bit_field_t<16, 0x7f>::value<X>();
    static constexpr uint32_t TTTMK_LCKM = 0x80000000;    // TT Time Mark Register Locked
    static const uint32_t TTTMK_RESET_VALUE = 0x0;

    static constexpr uint32_t TTIR_SBC = 0x1;            // Start of Basic Cycle
    static constexpr uint32_t TTIR_SMC = 0x2;            // Start of Matrix Cycle
    static constexpr uint32_t TTIR_CSM = 0x4;            // Change of Synchronization Mode
    static constexpr uint32_t TTIR_SOG = 0x8;            // Start of Gap
    static constexpr uint32_t TTIR_RTMI = 0x10;          // Register Time Mark Interrupt.
    static constexpr uint32_t TTIR_TTMI = 0x20;          // Trigger Time Mark Event Internal
    static constexpr uint32_t TTIR_SWE = 0x40;           // Stop Watch Event
    static constexpr uint32_t TTIR_GTW = 0x80;           // Global Time Wrap
    static constexpr uint32_t TTIR_GTD = 0x100;          // Global Time Discontinuity
    static constexpr uint32_t TTIR_GTE = 0x200;          // Global Time Error
    static constexpr uint32_t TTIR_TXU = 0x400;          // Tx Count Underflow
    static constexpr uint32_t TTIR_TXO = 0x800;          // Tx Count Overflow
    static constexpr uint32_t TTIR_SE1 = 0x1000;         // Scheduling Error 1
    static constexpr uint32_t TTIR_SE2 = 0x2000;         // Scheduling Error 2
    static constexpr uint32_t TTIR_ELC = 0x4000;         // Error Level Changed.
    static constexpr uint32_t TTIR_IWTG = 0x8000;        // Initialization Watch Trigger
    static constexpr uint32_t TTIR_WT = 0x10000;         // Watch Trigger
    static constexpr uint32_t TTIR_AW = 0x20000;         // Application Watchdog
    static constexpr uint32_t TTIR_CER = 0x40000;        // Configuration Error
    static const uint32_t TTIR_RESET_VALUE = 0x0;

    static constexpr uint32_t TTIE_SBCE = 0x1;           // Start of Basic Cycle Interrupt Enable
    static constexpr uint32_t TTIE_SMCE = 0x2;           // Start of Matrix Cycle Interrupt Enable
    static constexpr uint32_t TTIE_CSME = 0x4;           // Change of Synchronization Mode Interrupt Enable
    static constexpr uint32_t TTIE_SOGE = 0x8;           // Start of Gap Interrupt Enable
    static constexpr uint32_t TTIE_RTMIE = 0x10;         // Register Time Mark Interrupt Enable
    static constexpr uint32_t TTIE_TTMIE = 0x20;         // Trigger Time Mark Event Internal Interrupt Enable
    static constexpr uint32_t TTIE_SWEE = 0x40;          // Stop Watch Event Interrupt Enable
    static constexpr uint32_t TTIE_GTWE = 0x80;          // Global Time Wrap Interrupt Enable
    static constexpr uint32_t TTIE_GTDE = 0x100;         // Global Time Discontinuity Interrupt Enable
    static constexpr uint32_t TTIE_GTEE = 0x200;         // Global Time Error Interrupt Enable
    static constexpr uint32_t TTIE_TXUE = 0x400;         // Tx Count Underflow Interrupt Enable
    static constexpr uint32_t TTIE_TXOE = 0x800;         // Tx Count Overflow Interrupt Enable
    static constexpr uint32_t TTIE_SE1E = 0x1000;        // Scheduling Error 1 Interrupt Enable
    static constexpr uint32_t TTIE_SE2E = 0x2000;        // Scheduling Error 2 Interrupt Enable
    static constexpr uint32_t TTIE_ELCE = 0x4000;        // Change Error Level Interrupt Enable
    static constexpr uint32_t TTIE_IWTGE = 0x8000;       // Initialization Watch Trigger Interrupt Enable
    static constexpr uint32_t TTIE_WTE = 0x10000;        // Watch Trigger Interrupt Enable
    static constexpr uint32_t TTIE_AWE = 0x20000;        // Application Watchdog Interrupt Enable
    static constexpr uint32_t TTIE_CERE = 0x40000;       // Configuration Error Interrupt Enable
    static const uint32_t TTIE_RESET_VALUE = 0x0;

    static constexpr uint32_t TTILS_SBCL = 0x1;           // Start of Basic Cycle Interrupt Line
    static constexpr uint32_t TTILS_SMCL = 0x2;           // Start of Matrix Cycle Interrupt Line
    static constexpr uint32_t TTILS_CSML = 0x4;           // Change of Synchronization Mode Interrupt Line
    static constexpr uint32_t TTILS_SOGL = 0x8;           // Start of Gap Interrupt Line
    static constexpr uint32_t TTILS_RTMIL = 0x10;         // Register Time Mark Interrupt Line
    static constexpr uint32_t TTILS_TTMIL = 0x20;         // Trigger Time Mark Event Internal Interrupt Line
    static constexpr uint32_t TTILS_SWEL = 0x40;          // Stop Watch Event Interrupt Line
    static constexpr uint32_t TTILS_GTWL = 0x80;          // Global Time Wrap Interrupt Line
    static constexpr uint32_t TTILS_GTDL = 0x100;         // Global Time Discontinuity Interrupt Line
    static constexpr uint32_t TTILS_GTEL = 0x200;         // Global Time Error Interrupt Line
    static constexpr uint32_t TTILS_TXUL = 0x400;         // Tx Count Underflow Interrupt Line
    static constexpr uint32_t TTILS_TXOL = 0x800;         // Tx Count Overflow Interrupt Line
    static constexpr uint32_t TTILS_SE1L = 0x1000;        // Scheduling Error 1 Interrupt Line
    static constexpr uint32_t TTILS_SE2L = 0x2000;        // Scheduling Error 2 Interrupt Line
    static constexpr uint32_t TTILS_ELCL = 0x4000;        // Change Error Level Interrupt Line
    static constexpr uint32_t TTILS_IWTGL = 0x8000;       // Initialization Watch Trigger Interrupt Line
    static constexpr uint32_t TTILS_WTL = 0x10000;        // Watch Trigger Interrupt Line
    static constexpr uint32_t TTILS_AWL = 0x20000;        // Application Watchdog Interrupt Line
    static constexpr uint32_t TTILS_CERL = 0x40000;       // Configuration Error Interrupt Line
    static const uint32_t TTILS_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TTOST_EL =                  // Error Level (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TTOST_MS =                  // Master State. (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TTOST_SYS =                 // Synchronization State (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static constexpr uint32_t TTOST_GTP = 0x40;           // Quality of Global Time Phase
    static constexpr uint32_t TTOST_QCS = 0x80;           // Quality of Clock Speed
    template<uint32_t X>
    static constexpr uint32_t TTOST_RTO =                 // Reference Trigger Offset (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t TTOST_WGTD = 0x400000;      // Wait for Global Time Discontinuity
    static constexpr uint32_t TTOST_GFI = 0x800000;       // Gap Finished Indicator.
    template<uint32_t X>
    static constexpr uint32_t TTOST_TMP =                 // Time Master Priority (3 bits)
        bit_field_t<24, 0x7>::value<X>();
    static constexpr uint32_t TTOST_GSI = 0x8000000;      // Gap Started Indicator.
    static constexpr uint32_t TTOST_WFE = 0x10000000;     // Wait for Event
    static constexpr uint32_t TTOST_AWE = 0x20000000;     // Application Watchdog Event
    static constexpr uint32_t TTOST_WECS = 0x40000000;    // Wait for External Clock Synchronization
    static constexpr uint32_t TTOST_SPL = 0x80000000;     // Schedule Phase Lock
    static const uint32_t TTOST_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TURNA_NAV =                 // Numerator Actual Value (18 bits)
        bit_field_t<0, 0x3ffff>::value<X>();
    static const uint32_t TURNA_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TTLGT_LT =                  // Local Time (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TTLGT_GT =                  // Global Time (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t TTLGT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TTCTC_CT =                  // Cycle Time (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TTCTC_CC =                  // Cycle Count (6 bits)
        bit_field_t<16, 0x3f>::value<X>();
    static const uint32_t TTCTC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TTCPT_CT =                  // Cycle Count Value (6 bits)
        bit_field_t<0, 0x3f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TTCPT_SWV =                 // Stop Watch Value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t TTCPT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TTCSM_CSM =                 // Cycle Sync Mark (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t TTCSM_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TTTS_SWTDEL =              // Stop watch trigger input selection (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TTTS_EVTSEL =              // Event trigger input selection (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static const uint32_t TTTS_RESET_VALUE = 0x0;

    static constexpr uint8_t FDCAN2_IT0 = 20; // FDCAN2 Interrupt 0
    static constexpr uint8_t FDCAN2_IT1 = 22; // FDCAN2 Interrupt 1
};

static fdcan2_t& FDCAN2 = *reinterpret_cast<fdcan2_t*>(0x4000a400);

#define HAVE_PERIPHERAL_FDCAN2


////
//
//    CCU registers
//
////

struct can_ccu_t
{
    volatile uint32_t    CREL;                 // [Read-write] Clock Calibration Unit Core Release Register
    volatile uint32_t    CCFG;                 // [Read-write] Calibration Configuration Register
    volatile uint32_t    CSTAT;                // [Read-write] Calibration Status Register
    volatile uint32_t    CWD;                  // [Read-write] Calibration Watchdog Register
    volatile uint32_t    IR;                   // [Read-write] Clock Calibration Unit Interrupt Register
    volatile uint32_t    IE;                   // [Read-write] Clock Calibration Unit Interrupt Enable Register

    template<uint32_t X>
    static constexpr uint32_t CREL_DAY =                 // Time Stamp Day (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CREL_MON =                 // Time Stamp Month (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CREL_YEAR =                // Time Stamp Year (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CREL_SUBSTEP =             // Sub-step of Core Release (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CREL_STEP =                // Step of Core Release (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CREL_REL =                 // Core Release (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    static const uint32_t CREL_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCFG_TQBT =                // Time Quanta per Bit Time (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static constexpr uint32_t CCFG_BCC = 0x40;           // Bypass Clock Calibration
    static constexpr uint32_t CCFG_CFL = 0x80;           // Calibration Field Length
    template<uint32_t X>
    static constexpr uint32_t CCFG_OCPM =                // Oscillator Clock Periods Minimum (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCFG_CDIV =                // Clock Divider (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    static constexpr uint32_t CCFG_SWR = 0x80000000;     // Software Reset
    static const uint32_t CCFG_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CSTAT_OCPC =                // Oscillator Clock Period Counter (18 bits)
        bit_field_t<0, 0x3ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CSTAT_TQC =                 // Time Quanta Counter (11 bits)
        bit_field_t<18, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CSTAT_CALS =                // Calibration State (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    static const uint32_t CSTAT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CWD_WDC =                 // WDC (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CWD_WDV =                 // WDV (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t CWD_RESET_VALUE = 0x0;

    static constexpr uint32_t IR_CWE = 0x1;            // Calibration Watchdog Event
    static constexpr uint32_t IR_CSC = 0x2;            // Calibration State Changed
    static const uint32_t IR_RESET_VALUE = 0x0;

    static constexpr uint32_t IE_CWEE = 0x1;           // Calibration Watchdog Event Enable
    static constexpr uint32_t IE_CSCE = 0x2;           // Calibration State Changed Enable
    static const uint32_t IE_RESET_VALUE = 0x0;
};

static can_ccu_t& CAN_CCU = *reinterpret_cast<can_ccu_t*>(0x4000a800);

#define HAVE_PERIPHERAL_CAN_CCU


////
//
//    Management data input/output slave
//
////

struct mdios_t
{
    volatile uint32_t    CR;                   // [Read-write] MDIOS configuration register
    volatile uint32_t    WRFR;                 // [Read-only] MDIOS write flag register
    volatile uint32_t    CWRFR;                // [Read-write] MDIOS clear write flag register
    volatile uint32_t    RDFR;                 // [Read-only] MDIOS read flag register
    volatile uint32_t    CRDFR;                // [Read-write] MDIOS clear read flag register
    volatile uint32_t    SR;                   // [Read-only] MDIOS status register
    volatile uint32_t    CLRFR;                // [Read-write] MDIOS clear flag register
    volatile uint32_t    DINR0;                // [Read-only] MDIOS input data register 0
    volatile uint32_t    DINR1;                // [Read-only] MDIOS input data register 1
    volatile uint32_t    DINR2;                // [Read-only] MDIOS input data register 2
    volatile uint32_t    DINR3;                // [Read-only] MDIOS input data register 3
    volatile uint32_t    DINR4;                // [Read-only] MDIOS input data register 4
    volatile uint32_t    DINR5;                // [Read-only] MDIOS input data register 5
    volatile uint32_t    DINR6;                // [Read-only] MDIOS input data register 6
    volatile uint32_t    DINR7;                // [Read-only] MDIOS input data register 7
    volatile uint32_t    DINR8;                // [Read-only] MDIOS input data register 8
    volatile uint32_t    DINR9;                // [Read-only] MDIOS input data register 9
    volatile uint32_t    DINR10;               // [Read-only] MDIOS input data register 10
    volatile uint32_t    DINR11;               // [Read-only] MDIOS input data register 11
    volatile uint32_t    DINR12;               // [Read-only] MDIOS input data register 12
    volatile uint32_t    DINR13;               // [Read-only] MDIOS input data register 13
    volatile uint32_t    DINR14;               // [Read-only] MDIOS input data register 14
    volatile uint32_t    DINR15;               // [Read-only] MDIOS input data register 15
    volatile uint32_t    DINR16;               // [Read-only] MDIOS input data register 16
    volatile uint32_t    DINR17;               // [Read-only] MDIOS input data register 17
    volatile uint32_t    DINR18;               // [Read-only] MDIOS input data register 18
    volatile uint32_t    DINR19;               // [Read-only] MDIOS input data register 19
    volatile uint32_t    DINR20;               // [Read-only] MDIOS input data register 20
    volatile uint32_t    DINR21;               // [Read-only] MDIOS input data register 21
    volatile uint32_t    DINR22;               // [Read-only] MDIOS input data register 22
    volatile uint32_t    DINR23;               // [Read-only] MDIOS input data register 23
    volatile uint32_t    DINR24;               // [Read-only] MDIOS input data register 24
    volatile uint32_t    DINR25;               // [Read-only] MDIOS input data register 25
    volatile uint32_t    DINR26;               // [Read-only] MDIOS input data register 26
    volatile uint32_t    DINR27;               // [Read-only] MDIOS input data register 27
    volatile uint32_t    DINR28;               // [Read-only] MDIOS input data register 28
    volatile uint32_t    DINR29;               // [Read-only] MDIOS input data register 29
    volatile uint32_t    DINR30;               // [Read-only] MDIOS input data register 30
    volatile uint32_t    DINR31;               // [Read-only] MDIOS input data register 31
    volatile uint32_t    DOUTR0;               // [Read-write] MDIOS output data register 0
    volatile uint32_t    DOUTR1;               // [Read-write] MDIOS output data register 1
    volatile uint32_t    DOUTR2;               // [Read-write] MDIOS output data register 2
    volatile uint32_t    DOUTR3;               // [Read-write] MDIOS output data register 3
    volatile uint32_t    DOUTR4;               // [Read-write] MDIOS output data register 4
    volatile uint32_t    DOUTR5;               // [Read-write] MDIOS output data register 5
    volatile uint32_t    DOUTR6;               // [Read-write] MDIOS output data register 6
    volatile uint32_t    DOUTR7;               // [Read-write] MDIOS output data register 7
    volatile uint32_t    DOUTR8;               // [Read-write] MDIOS output data register 8
    volatile uint32_t    DOUTR9;               // [Read-write] MDIOS output data register 9
    volatile uint32_t    DOUTR10;              // [Read-write] MDIOS output data register 10
    volatile uint32_t    DOUTR11;              // [Read-write] MDIOS output data register 11
    volatile uint32_t    DOUTR12;              // [Read-write] MDIOS output data register 12
    volatile uint32_t    DOUTR13;              // [Read-write] MDIOS output data register 13
    volatile uint32_t    DOUTR14;              // [Read-write] MDIOS output data register 14
    volatile uint32_t    DOUTR15;              // [Read-write] MDIOS output data register 15
    volatile uint32_t    DOUTR16;              // [Read-write] MDIOS output data register 16
    volatile uint32_t    DOUTR17;              // [Read-write] MDIOS output data register 17
    volatile uint32_t    DOUTR18;              // [Read-write] MDIOS output data register 18
    volatile uint32_t    DOUTR19;              // [Read-write] MDIOS output data register 19
    volatile uint32_t    DOUTR20;              // [Read-write] MDIOS output data register 20
    volatile uint32_t    DOUTR21;              // [Read-write] MDIOS output data register 21
    volatile uint32_t    DOUTR22;              // [Read-write] MDIOS output data register 22
    volatile uint32_t    DOUTR23;              // [Read-write] MDIOS output data register 23
    volatile uint32_t    DOUTR24;              // [Read-write] MDIOS output data register 24
    volatile uint32_t    DOUTR25;              // [Read-write] MDIOS output data register 25
    volatile uint32_t    DOUTR26;              // [Read-write] MDIOS output data register 26
    volatile uint32_t    DOUTR27;              // [Read-write] MDIOS output data register 27
    volatile uint32_t    DOUTR28;              // [Read-write] MDIOS output data register 28
    volatile uint32_t    DOUTR29;              // [Read-write] MDIOS output data register 29
    volatile uint32_t    DOUTR30;              // [Read-write] MDIOS output data register 30
    volatile uint32_t    DOUTR31;              // [Read-write] MDIOS output data register 31

    static constexpr uint32_t CR_EN = 0x1;             // Peripheral enable
    static constexpr uint32_t CR_WRIE = 0x2;           // Register write interrupt enable
    static constexpr uint32_t CR_RDIE = 0x4;           // Register Read Interrupt Enable
    static constexpr uint32_t CR_EIE = 0x8;            // Error interrupt enable
    static constexpr uint32_t CR_DPC = 0x80;           // Disable Preamble Check
    template<uint32_t X>
    static constexpr uint32_t CR_PORT_ADDRESS =        // Slaves's address (5 bits)
        bit_field_t<8, 0x1f>::value<X>();
    static const uint32_t CR_RESET_VALUE = 0x0;


    static const uint32_t WRFR_RESET_VALUE = 0x0;


    static const uint32_t CWRFR_RESET_VALUE = 0x0;


    static const uint32_t RDFR_RESET_VALUE = 0x0;


    static const uint32_t CRDFR_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_PERF = 0x1;           // Preamble error flag
    static constexpr uint32_t SR_SERF = 0x2;           // Start error flag
    static constexpr uint32_t SR_TERF = 0x4;           // Turnaround error flag
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint32_t CLRFR_CPERF = 0x1;          // Clear the preamble error flag
    static constexpr uint32_t CLRFR_CSERF = 0x2;          // Clear the start error flag
    static constexpr uint32_t CLRFR_CTERF = 0x4;          // Clear the turnaround error flag
    static const uint32_t CLRFR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR0_DIN0 =                // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR0_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR1_DIN1 =                // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR2_DIN2 =                // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR3_DIN3 =                // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR4_DIN4 =                // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR5_DIN5 =                // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR6_DIN6 =                // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR6_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR7_DIN7 =                // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR7_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR8_DIN8 =                // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR8_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR9_DIN9 =                // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR9_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR10_DIN10 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR10_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR11_DIN11 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR11_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR12_DIN12 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR12_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR13_DIN13 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR13_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR14_DIN14 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR14_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR15_DIN15 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR15_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR16_DIN16 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR16_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR17_DIN17 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR17_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR18_DIN18 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR18_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR19_DIN19 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR19_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR20_DIN20 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR20_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR21_DIN21 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR21_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR22_DIN22 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR22_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR23_DIN23 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR23_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR24_DIN24 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR24_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR25_DIN25 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR25_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR26_DIN26 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR26_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR27_DIN27 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR27_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR28_DIN28 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR28_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR29_DIN29 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR29_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR30_DIN30 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR30_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR31_DIN31 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR31_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR0_DOUT0 =               // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR0_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR1_DOUT1 =               // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR2_DOUT2 =               // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR3_DOUT3 =               // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR4_DOUT4 =               // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR5_DOUT5 =               // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR6_DOUT6 =               // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR6_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR7_DOUT7 =               // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR7_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR8_DOUT8 =               // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR8_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR9_DOUT9 =               // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR9_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR10_DOUT10 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR10_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR11_DOUT11 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR11_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR12_DOUT12 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR12_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR13_DOUT13 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR13_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR14_DOUT14 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR14_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR15_DOUT15 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR15_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR16_DOUT16 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR16_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR17_DOUT17 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR17_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR18_DOUT18 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR18_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR19_DOUT19 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR19_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR20_DOUT20 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR20_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR21_DOUT21 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR21_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR22_DOUT22 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR22_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR23_DOUT23 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR23_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR24_DOUT24 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR24_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR25_DOUT25 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR25_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR26_DOUT26 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR26_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR27_DOUT27 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR27_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR28_DOUT28 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR28_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR29_DOUT29 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR29_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR30_DOUT30 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR30_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR31_DOUT31 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR31_RESET_VALUE = 0x0;

    static constexpr uint8_t MDIOS = 120; // MDIOS global interrupt
    static constexpr uint8_t MDIOS_WKUP = 119; // MDIOS wakeup
};

static mdios_t& MDIOS = *reinterpret_cast<mdios_t*>(0x40009400);

#define HAVE_PERIPHERAL_MDIOS


////
//
//    Operational amplifiers
//
////

struct opamp_t
{
    volatile uint32_t    OPAMP1_CSR;           // [Read-write] OPAMP1 control/status register
    volatile uint32_t    OPAMP1_OTR;           // [Read-write] OPAMP1 offset trimming register in normal mode
    volatile uint32_t    OPAMP1_HSOTR;         // [Read-write] OPAMP1 offset trimming register in low-power mode
    reserved_t<1>        _0;
    volatile uint32_t    OPAMP2_CSR;           // [Read-write] OPAMP2 control/status register
    volatile uint32_t    OPAMP2_OTR;           // [Read-write] OPAMP2 offset trimming register in normal mode
    volatile uint32_t    OPAMP2_HSOTR;         // [Read-write] OPAMP2 offset trimming register in low-power mode

    static constexpr uint32_t OPAMP1_CSR_OPAEN = 0x1;          // Operational amplifier Enable
    static constexpr uint32_t OPAMP1_CSR_FORCE_VP = 0x2;       // Force internal reference on VP (reserved for test
    template<uint32_t X>
    static constexpr uint32_t OPAMP1_CSR_VP_SEL =              // Operational amplifier PGA mode (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OPAMP1_CSR_VM_SEL =              // Inverting input selection (2 bits)
        bit_field_t<5, 0x3>::value<X>();
    static constexpr uint32_t OPAMP1_CSR_OPAHSM = 0x100;       // Operational amplifier high-speed mode
    static constexpr uint32_t OPAMP1_CSR_CALON = 0x800;        // Calibration mode enabled
    template<uint32_t X>
    static constexpr uint32_t OPAMP1_CSR_CALSEL =              // Calibration selection (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OPAMP1_CSR_PGA_GAIN =            // allows to switch from AOP offset trimmed values to AOP offset (4 bits)
        bit_field_t<14, 0xf>::value<X>();
    static constexpr uint32_t OPAMP1_CSR_USERTRIM = 0x40000;   // User trimming enable
    static constexpr uint32_t OPAMP1_CSR_TSTREF = 0x20000000;  // OPAMP calibration reference voltage output control (reserved for test)
    static constexpr uint32_t OPAMP1_CSR_CALOUT = 0x40000000;  // Operational amplifier calibration output
    static const uint32_t OPAMP1_CSR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OPAMP1_OTR_TRIMOFFSETN =         // Trim for NMOS differential pairs (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OPAMP1_OTR_TRIMOFFSETP =         // Trim for PMOS differential pairs (5 bits)
        bit_field_t<8, 0x1f>::value<X>();
    static const uint32_t OPAMP1_OTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OPAMP1_HSOTR_TRIMLPOFFSETN =       // Trim for NMOS differential pairs (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OPAMP1_HSOTR_TRIMLPOFFSETP =       // Trim for PMOS differential pairs (5 bits)
        bit_field_t<8, 0x1f>::value<X>();
    static const uint32_t OPAMP1_HSOTR_RESET_VALUE = 0x0;

    static constexpr uint32_t OPAMP2_CSR_OPAEN = 0x1;          // Operational amplifier Enable
    static constexpr uint32_t OPAMP2_CSR_FORCE_VP = 0x2;       // Force internal reference on VP (reserved for test)
    template<uint32_t X>
    static constexpr uint32_t OPAMP2_CSR_VM_SEL =              // Inverting input selection (2 bits)
        bit_field_t<5, 0x3>::value<X>();
    static constexpr uint32_t OPAMP2_CSR_OPAHSM = 0x100;       // Operational amplifier high-speed mode
    static constexpr uint32_t OPAMP2_CSR_CALON = 0x800;        // Calibration mode enabled
    template<uint32_t X>
    static constexpr uint32_t OPAMP2_CSR_CALSEL =              // Calibration selection (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OPAMP2_CSR_PGA_GAIN =            // Operational amplifier Programmable amplifier gain value (4 bits)
        bit_field_t<14, 0xf>::value<X>();
    static constexpr uint32_t OPAMP2_CSR_USERTRIM = 0x40000;   // User trimming enable
    static constexpr uint32_t OPAMP2_CSR_TSTREF = 0x20000000;  // OPAMP calibration reference voltage output control (reserved for test)
    static constexpr uint32_t OPAMP2_CSR_CALOUT = 0x40000000;  // Operational amplifier calibration output
    static const uint32_t OPAMP2_CSR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OPAMP2_OTR_TRIMOFFSETN =         // Trim for NMOS differential pairs (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OPAMP2_OTR_TRIMOFFSETP =         // Trim for PMOS differential pairs (5 bits)
        bit_field_t<8, 0x1f>::value<X>();
    static const uint32_t OPAMP2_OTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OPAMP2_HSOTR_TRIMLPOFFSETN =       // Trim for NMOS differential pairs (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OPAMP2_HSOTR_TRIMLPOFFSETP =       // Trim for PMOS differential pairs (5 bits)
        bit_field_t<8, 0x1f>::value<X>();
    static const uint32_t OPAMP2_HSOTR_RESET_VALUE = 0x0;
};

static opamp_t& OPAMP = *reinterpret_cast<opamp_t*>(0x40009000);

#define HAVE_PERIPHERAL_OPAMP


////
//
//    Single Wire Protocol Master Interface
//
////

struct swpmi_t
{
    volatile uint32_t    CR;                   // [Read-write] SWPMI Configuration/Control register
    volatile uint32_t    BRR;                  // [Read-write] SWPMI Bitrate register
    reserved_t<1>        _0;
    volatile uint32_t    ISR;                  // [Read-only] SWPMI Interrupt and Status register
    volatile uint32_t    ICR;                  // [Write-only] SWPMI Interrupt Flag Clear register
    volatile uint32_t    IER;                  // [Read-write] SWPMI Interrupt Enable register
    volatile uint32_t    RFL;                  // [Read-only] SWPMI Receive Frame Length register
    volatile uint32_t    TDR;                  // [Write-only] SWPMI Transmit data register
    volatile uint32_t    RDR;                  // [Read-only] SWPMI Receive data register
    volatile uint32_t    OR;                   // [Read-write] SWPMI Option register

    static constexpr uint32_t CR_RXDMA = 0x1;          // Reception DMA enable
    static constexpr uint32_t CR_TXDMA = 0x2;          // Transmission DMA enable
    static constexpr uint32_t CR_RXMODE = 0x4;         // Reception buffering mode
    static constexpr uint32_t CR_TXMODE = 0x8;         // Transmission buffering mode
    static constexpr uint32_t CR_LPBK = 0x10;          // Loopback mode enable
    static constexpr uint32_t CR_SWPACT = 0x20;        // Single wire protocol master interface activate
    static constexpr uint32_t CR_DEACT = 0x400;        // Single wire protocol master interface deactivate
    static constexpr uint32_t CR_SWPTEN = 0x800;       // Single wire protocol master transceiver enable
    static const uint32_t CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BRR_BR =                  // Bitrate prescaler (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t BRR_RESET_VALUE = 0x1;

    static constexpr uint32_t ISR_RXBFF = 0x1;          // Receive buffer full flag
    static constexpr uint32_t ISR_TXBEF = 0x2;          // Transmit buffer empty flag
    static constexpr uint32_t ISR_RXBERF = 0x4;         // Receive CRC error flag
    static constexpr uint32_t ISR_RXOVRF = 0x8;         // Receive overrun error flag
    static constexpr uint32_t ISR_TXUNRF = 0x10;        // Transmit underrun error flag
    static constexpr uint32_t ISR_RXNE = 0x20;          // Receive data register not empty
    static constexpr uint32_t ISR_TXE = 0x40;           // Transmit data register empty
    static constexpr uint32_t ISR_TCF = 0x80;           // Transfer complete flag
    static constexpr uint32_t ISR_SRF = 0x100;          // Slave resume flag
    static constexpr uint32_t ISR_SUSP = 0x200;         // SUSPEND flag
    static constexpr uint32_t ISR_DEACTF = 0x400;       // DEACTIVATED flag
    static constexpr uint32_t ISR_RDYF = 0x800;         // transceiver ready flag
    static const uint32_t ISR_RESET_VALUE = 0x2c2;

    static constexpr uint32_t ICR_CRXBFF = 0x1;         // Clear receive buffer full flag
    static constexpr uint32_t ICR_CTXBEF = 0x2;         // Clear transmit buffer empty flag
    static constexpr uint32_t ICR_CRXBERF = 0x4;        // Clear receive CRC error flag
    static constexpr uint32_t ICR_CRXOVRF = 0x8;        // Clear receive overrun error flag
    static constexpr uint32_t ICR_CTXUNRF = 0x10;       // Clear transmit underrun error flag
    static constexpr uint32_t ICR_CTCF = 0x80;          // Clear transfer complete flag
    static constexpr uint32_t ICR_CSRF = 0x100;         // Clear slave resume flag
    static constexpr uint32_t ICR_CRDYF = 0x800;        // Clear transceiver ready flag
    static const uint32_t ICR_RESET_VALUE = 0x0;

    static constexpr uint32_t IER_RXBFIE = 0x1;         // Receive buffer full interrupt enable
    static constexpr uint32_t IER_TXBEIE = 0x2;         // Transmit buffer empty interrupt enable
    static constexpr uint32_t IER_RXBERIE = 0x4;        // Receive CRC error interrupt enable
    static constexpr uint32_t IER_RXOVRIE = 0x8;        // Receive overrun error interrupt enable
    static constexpr uint32_t IER_TXUNRIE = 0x10;       // Transmit underrun error interrupt enable
    static constexpr uint32_t IER_RIE = 0x20;           // Receive interrupt enable
    static constexpr uint32_t IER_TIE = 0x40;           // Transmit interrupt enable
    static constexpr uint32_t IER_TCIE = 0x80;          // Transmit complete interrupt enable
    static constexpr uint32_t IER_SRIE = 0x100;         // Slave resume interrupt enable
    static constexpr uint32_t IER_RDYIE = 0x800;        // Transceiver ready interrupt enable
    static const uint32_t IER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RFL_RFL =                 // Receive frame length (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t RFL_RESET_VALUE = 0x0;


    static const uint32_t TDR_RESET_VALUE = 0x0;


    static const uint32_t RDR_RESET_VALUE = 0x0;

    static constexpr uint32_t OR_SWP_TBYP = 0x1;       // SWP transceiver bypass
    static constexpr uint32_t OR_SWP_CLASS = 0x2;      // SWP class selection
    static const uint32_t OR_RESET_VALUE = 0x0;
};

static swpmi_t& SWPMI = *reinterpret_cast<swpmi_t*>(0x40008800);

#define HAVE_PERIPHERAL_SWPMI


////
//
//    General purpose timers
//
////

struct tim2_t
{
    volatile uint32_t    CR1;                  // [Read-write] control register 1
    volatile uint32_t    CR2;                  // [Read-write] control register 2
    volatile uint32_t    SMCR;                 // [Read-write] slave mode control register
    volatile uint32_t    DIER;                 // [Read-write] DMA/Interrupt enable register
    volatile uint32_t    SR;                   // [Read-write] status register
    volatile uint32_t    EGR;                  // [Write-only] event generation register
    volatile uint32_t    CCMR1;                // [Read-write] capture/compare mode register 1 (output mode)
    volatile uint32_t    CCMR2;                // [Read-write] capture/compare mode register 2 (output mode)
    volatile uint32_t    CCER;                 // [Read-write] capture/compare enable register
    volatile uint32_t    CNT;                  // [Read-write] counter
    volatile uint32_t    PSC;                  // [Read-write] prescaler
    volatile uint32_t    ARR;                  // [Read-write] auto-reload register
    reserved_t<1>        _0;
    volatile uint32_t    CCR1;                 // [Read-write] capture/compare register 1
    volatile uint32_t    CCR2;                 // [Read-write] capture/compare register 2
    volatile uint32_t    CCR3;                 // [Read-write] capture/compare register 3
    volatile uint32_t    CCR4;                 // [Read-write] capture/compare register 4
    reserved_t<1>        _1;
    volatile uint32_t    DCR;                  // [Read-write] DMA control register
    volatile uint32_t    DMAR;                 // [Read-write] DMA address for full transfer
    reserved_t<4>        _2;
    volatile uint32_t    AF1;                  // [Read-write] TIM alternate function option register 1
    reserved_t<1>        _3;
    volatile uint32_t    TISEL;                // [Read-write] TIM timer input selection register

    static constexpr uint32_t CR1_UIFREMAP = 0x800;     // UIF status bit remapping
    template<uint32_t X>
    static constexpr uint32_t CR1_CKD =                 // Clock division (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t CR1_ARPE = 0x80;          // Auto-reload preload enable
    template<uint32_t X>
    static constexpr uint32_t CR1_CMS =                 // Center-aligned mode selection (2 bits)
        bit_field_t<5, 0x3>::value<X>();
    static constexpr uint32_t CR1_DIR = 0x10;           // Direction
    static constexpr uint32_t CR1_OPM = 0x8;            // One-pulse mode
    static constexpr uint32_t CR1_URS = 0x4;            // Update request source
    static constexpr uint32_t CR1_UDIS = 0x2;           // Update disable
    static constexpr uint32_t CR1_CEN = 0x1;            // Counter enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CR2_TI1S = 0x80;          // TI1 selection
    template<uint32_t X>
    static constexpr uint32_t CR2_MMS =                 // Master mode selection (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CR2_CCDS = 0x8;           // Capture/compare DMA selection
    static const uint32_t CR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SMCR_TS_4_3 =              // Trigger selection (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    static constexpr uint32_t SMCR_SMS_3 = 0x10000;      // Slave mode selection - bit 3
    static constexpr uint32_t SMCR_ETP = 0x8000;         // External trigger polarity
    static constexpr uint32_t SMCR_ECE = 0x4000;         // External clock enable
    template<uint32_t X>
    static constexpr uint32_t SMCR_ETPS =                // External trigger prescaler (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMCR_ETF =                 // External trigger filter (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    static constexpr uint32_t SMCR_MSM = 0x80;           // Master/Slave mode
    template<uint32_t X>
    static constexpr uint32_t SMCR_TS =                  // Trigger selection (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMCR_SMS =                 // Slave mode selection (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t SMCR_RESET_VALUE = 0x0;

    static constexpr uint32_t DIER_TDE = 0x4000;         // Trigger DMA request enable
    static constexpr uint32_t DIER_CC4DE = 0x1000;       // Capture/Compare 4 DMA request enable
    static constexpr uint32_t DIER_CC3DE = 0x800;        // Capture/Compare 3 DMA request enable
    static constexpr uint32_t DIER_CC2DE = 0x400;        // Capture/Compare 2 DMA request enable
    static constexpr uint32_t DIER_CC1DE = 0x200;        // Capture/Compare 1 DMA request enable
    static constexpr uint32_t DIER_UDE = 0x100;          // Update DMA request enable
    static constexpr uint32_t DIER_TIE = 0x40;           // Trigger interrupt enable
    static constexpr uint32_t DIER_CC4IE = 0x10;         // Capture/Compare 4 interrupt enable
    static constexpr uint32_t DIER_CC3IE = 0x8;          // Capture/Compare 3 interrupt enable
    static constexpr uint32_t DIER_CC2IE = 0x4;          // Capture/Compare 2 interrupt enable
    static constexpr uint32_t DIER_CC1IE = 0x2;          // Capture/Compare 1 interrupt enable
    static constexpr uint32_t DIER_UIE = 0x1;            // Update interrupt enable
    static const uint32_t DIER_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_CC4OF = 0x1000;       // Capture/Compare 4 overcapture flag
    static constexpr uint32_t SR_CC3OF = 0x800;        // Capture/Compare 3 overcapture flag
    static constexpr uint32_t SR_CC2OF = 0x400;        // Capture/compare 2 overcapture flag
    static constexpr uint32_t SR_CC1OF = 0x200;        // Capture/Compare 1 overcapture flag
    static constexpr uint32_t SR_TIF = 0x40;           // Trigger interrupt flag
    static constexpr uint32_t SR_CC4IF = 0x10;         // Capture/Compare 4 interrupt flag
    static constexpr uint32_t SR_CC3IF = 0x8;          // Capture/Compare 3 interrupt flag
    static constexpr uint32_t SR_CC2IF = 0x4;          // Capture/Compare 2 interrupt flag
    static constexpr uint32_t SR_CC1IF = 0x2;          // Capture/compare 1 interrupt flag
    static constexpr uint32_t SR_UIF = 0x1;            // Update interrupt flag
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint32_t EGR_TG = 0x40;            // Trigger generation
    static constexpr uint32_t EGR_CC4G = 0x10;          // Capture/compare 4 generation
    static constexpr uint32_t EGR_CC3G = 0x8;           // Capture/compare 3 generation
    static constexpr uint32_t EGR_CC2G = 0x4;           // Capture/compare 2 generation
    static constexpr uint32_t EGR_CC1G = 0x2;           // Capture/compare 1 generation
    static constexpr uint32_t EGR_UG = 0x1;             // Update generation
    static const uint32_t EGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCMR1_CC1S =                // CC1S (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_CC2S =                // CC2S (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC1F =                // Input capture 1 filter (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC2F =                // Input capture 2 filter (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC2PCS =              // Input capture 2 prescaler (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_ICPCS =               // Input capture 1 prescaler (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t CCMR1_OC1CE = 0x80;         // OC1CE
    static constexpr uint32_t CCMR1_OC1FE = 0x4;          // OC1FE
    template<uint32_t X>
    static constexpr uint32_t CCMR1_OC1M =                // OC1M (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR1_OC1M_3 = 0x10000;     // Output Compare 1 mode - bit 3
    static constexpr uint32_t CCMR1_OC1PE = 0x8;          // OC1PE
    static constexpr uint32_t CCMR1_OC2CE = 0x8000;       // OC2CE
    static constexpr uint32_t CCMR1_OC2FE = 0x400;        // OC2FE
    template<uint32_t X>
    static constexpr uint32_t CCMR1_OC2M =                // OC2M (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    static constexpr uint32_t CCMR1_OC2M_3 = 0x1000000;   // Output Compare 2 mode - bit 3
    static constexpr uint32_t CCMR1_OC2PE = 0x800;        // OC2PE
    static const uint32_t CCMR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCMR2_CC3S =                // CC3S (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_CC4S =                // CC4S (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC3F =                // Input capture 3 filter (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC3PSC =              // Input capture 3 prescaler (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC4F =                // Input capture 4 filter (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC4PSC =              // Input capture 4 prescaler (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    static constexpr uint32_t CCMR2_O24CE = 0x8000;       // O24CE
    static constexpr uint32_t CCMR2_OC3CE = 0x80;         // OC3CE
    static constexpr uint32_t CCMR2_OC3FE = 0x4;          // OC3FE
    template<uint32_t X>
    static constexpr uint32_t CCMR2_OC3M =                // OC3M (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR2_OC3M_3 = 0x10000;     // Output Compare 1 mode - bit 3
    static constexpr uint32_t CCMR2_OC3PE = 0x8;          // OC3PE
    static constexpr uint32_t CCMR2_OC4FE = 0x400;        // OC4FE
    template<uint32_t X>
    static constexpr uint32_t CCMR2_OC4M =                // OC4M (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    static constexpr uint32_t CCMR2_OC4M_3 = 0x1000000;   // Output Compare 2 mode - bit 3
    static constexpr uint32_t CCMR2_OC4PE = 0x800;        // OC4PE
    static const uint32_t CCMR2_RESET_VALUE = 0x0;

    static constexpr uint32_t CCER_CC4NP = 0x8000;       // Capture/Compare 4 output Polarity
    static constexpr uint32_t CCER_CC4P = 0x2000;        // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC4E = 0x1000;        // Capture/Compare 4 output enable
    static constexpr uint32_t CCER_CC3NP = 0x800;        // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC3P = 0x200;         // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC3E = 0x100;         // Capture/Compare 3 output enable
    static constexpr uint32_t CCER_CC2NP = 0x80;         // Capture/Compare 2 output Polarity
    static constexpr uint32_t CCER_CC2P = 0x20;          // Capture/Compare 2 output Polarity
    static constexpr uint32_t CCER_CC2E = 0x10;          // Capture/Compare 2 output enable
    static constexpr uint32_t CCER_CC1NP = 0x8;          // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1P = 0x2;           // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1E = 0x1;           // Capture/Compare 1 output enable
    static const uint32_t CCER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CNT_CNT_L =               // low counter value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CNT_CNT_H =               // High counter value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t CNT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PSC_PSC =                 // Prescaler value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t PSC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ARR_ARR_H =               // High Auto-reload value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ARR_ARR_L =               // Low Auto-reload value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t ARR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR1_CCR1_H =              // High Capture/Compare 1 value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR1_CCR1_L =              // Low Capture/Compare 1 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR2_CCR2_H =              // High Capture/Compare 2 value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR2_CCR2_L =              // Low Capture/Compare 2 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR3_CCR3_H =              // High Capture/Compare value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR3_CCR3_L =              // Low Capture/Compare value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR4_CCR4_H =              // High Capture/Compare value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR4_CCR4_L =              // Low Capture/Compare value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DCR_DBL =                 // DMA burst length (5 bits)
        bit_field_t<8, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DCR_DBA =                 // DMA base address (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t DCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DMAR_DMAB =                // DMA register for burst accesses (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DMAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AF1_ETRSEL =              // ETR source selection (4 bits)
        bit_field_t<14, 0xf>::value<X>();
    static const uint32_t AF1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TISEL_TI1SEL =              // TI1[0] to TI1[15] input selection (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TISEL_TI2SEL =              // TI2[0] to TI2[15] input selection (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TISEL_TI3SEL =              // TI3[0] to TI3[15] input selection (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TISEL_TI4SEL =              // TI4[0] to TI4[15] input selection (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    static const uint32_t TISEL_RESET_VALUE = 0x0;

    static constexpr uint8_t SWPMI1 = 115; // SWPMI global interrupt
    static constexpr uint8_t TIM2 = 28; // TIM2 global interrupt
};

static tim2_t& TIM2 = *reinterpret_cast<tim2_t*>(0x40000000);

#define HAVE_PERIPHERAL_TIM2


////
//
//    General purpose timers
//
////

struct tim3_t
{
    volatile uint32_t    CR1;                  // [Read-write] control register 1
    volatile uint32_t    CR2;                  // [Read-write] control register 2
    volatile uint32_t    SMCR;                 // [Read-write] slave mode control register
    volatile uint32_t    DIER;                 // [Read-write] DMA/Interrupt enable register
    volatile uint32_t    SR;                   // [Read-write] status register
    volatile uint32_t    EGR;                  // [Write-only] event generation register
    volatile uint32_t    CCMR1;                // [Read-write] capture/compare mode register 1 (output mode)
    volatile uint32_t    CCMR2;                // [Read-write] capture/compare mode register 2 (output mode)
    volatile uint32_t    CCER;                 // [Read-write] capture/compare enable register
    volatile uint32_t    CNT;                  // [Read-write] counter
    volatile uint32_t    PSC;                  // [Read-write] prescaler
    volatile uint32_t    ARR;                  // [Read-write] auto-reload register
    reserved_t<1>        _0;
    volatile uint32_t    CCR1;                 // [Read-write] capture/compare register 1
    volatile uint32_t    CCR2;                 // [Read-write] capture/compare register 2
    volatile uint32_t    CCR3;                 // [Read-write] capture/compare register 3
    volatile uint32_t    CCR4;                 // [Read-write] capture/compare register 4
    reserved_t<1>        _1;
    volatile uint32_t    DCR;                  // [Read-write] DMA control register
    volatile uint32_t    DMAR;                 // [Read-write] DMA address for full transfer
    reserved_t<4>        _2;
    volatile uint32_t    AF1;                  // [Read-write] TIM alternate function option register 1
    reserved_t<1>        _3;
    volatile uint32_t    TISEL;                // [Read-write] TIM timer input selection register

    static constexpr uint32_t CR1_UIFREMAP = 0x800;     // UIF status bit remapping
    template<uint32_t X>
    static constexpr uint32_t CR1_CKD =                 // Clock division (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t CR1_ARPE = 0x80;          // Auto-reload preload enable
    template<uint32_t X>
    static constexpr uint32_t CR1_CMS =                 // Center-aligned mode selection (2 bits)
        bit_field_t<5, 0x3>::value<X>();
    static constexpr uint32_t CR1_DIR = 0x10;           // Direction
    static constexpr uint32_t CR1_OPM = 0x8;            // One-pulse mode
    static constexpr uint32_t CR1_URS = 0x4;            // Update request source
    static constexpr uint32_t CR1_UDIS = 0x2;           // Update disable
    static constexpr uint32_t CR1_CEN = 0x1;            // Counter enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CR2_TI1S = 0x80;          // TI1 selection
    template<uint32_t X>
    static constexpr uint32_t CR2_MMS =                 // Master mode selection (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CR2_CCDS = 0x8;           // Capture/compare DMA selection
    static const uint32_t CR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SMCR_TS_4_3 =              // Trigger selection (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    static constexpr uint32_t SMCR_SMS_3 = 0x10000;      // Slave mode selection - bit 3
    static constexpr uint32_t SMCR_ETP = 0x8000;         // External trigger polarity
    static constexpr uint32_t SMCR_ECE = 0x4000;         // External clock enable
    template<uint32_t X>
    static constexpr uint32_t SMCR_ETPS =                // External trigger prescaler (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMCR_ETF =                 // External trigger filter (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    static constexpr uint32_t SMCR_MSM = 0x80;           // Master/Slave mode
    template<uint32_t X>
    static constexpr uint32_t SMCR_TS =                  // Trigger selection (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMCR_SMS =                 // Slave mode selection (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t SMCR_RESET_VALUE = 0x0;

    static constexpr uint32_t DIER_TDE = 0x4000;         // Trigger DMA request enable
    static constexpr uint32_t DIER_CC4DE = 0x1000;       // Capture/Compare 4 DMA request enable
    static constexpr uint32_t DIER_CC3DE = 0x800;        // Capture/Compare 3 DMA request enable
    static constexpr uint32_t DIER_CC2DE = 0x400;        // Capture/Compare 2 DMA request enable
    static constexpr uint32_t DIER_CC1DE = 0x200;        // Capture/Compare 1 DMA request enable
    static constexpr uint32_t DIER_UDE = 0x100;          // Update DMA request enable
    static constexpr uint32_t DIER_TIE = 0x40;           // Trigger interrupt enable
    static constexpr uint32_t DIER_CC4IE = 0x10;         // Capture/Compare 4 interrupt enable
    static constexpr uint32_t DIER_CC3IE = 0x8;          // Capture/Compare 3 interrupt enable
    static constexpr uint32_t DIER_CC2IE = 0x4;          // Capture/Compare 2 interrupt enable
    static constexpr uint32_t DIER_CC1IE = 0x2;          // Capture/Compare 1 interrupt enable
    static constexpr uint32_t DIER_UIE = 0x1;            // Update interrupt enable
    static const uint32_t DIER_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_CC4OF = 0x1000;       // Capture/Compare 4 overcapture flag
    static constexpr uint32_t SR_CC3OF = 0x800;        // Capture/Compare 3 overcapture flag
    static constexpr uint32_t SR_CC2OF = 0x400;        // Capture/compare 2 overcapture flag
    static constexpr uint32_t SR_CC1OF = 0x200;        // Capture/Compare 1 overcapture flag
    static constexpr uint32_t SR_TIF = 0x40;           // Trigger interrupt flag
    static constexpr uint32_t SR_CC4IF = 0x10;         // Capture/Compare 4 interrupt flag
    static constexpr uint32_t SR_CC3IF = 0x8;          // Capture/Compare 3 interrupt flag
    static constexpr uint32_t SR_CC2IF = 0x4;          // Capture/Compare 2 interrupt flag
    static constexpr uint32_t SR_CC1IF = 0x2;          // Capture/compare 1 interrupt flag
    static constexpr uint32_t SR_UIF = 0x1;            // Update interrupt flag
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint32_t EGR_TG = 0x40;            // Trigger generation
    static constexpr uint32_t EGR_CC4G = 0x10;          // Capture/compare 4 generation
    static constexpr uint32_t EGR_CC3G = 0x8;           // Capture/compare 3 generation
    static constexpr uint32_t EGR_CC2G = 0x4;           // Capture/compare 2 generation
    static constexpr uint32_t EGR_CC1G = 0x2;           // Capture/compare 1 generation
    static constexpr uint32_t EGR_UG = 0x1;             // Update generation
    static const uint32_t EGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCMR1_CC1S =                // CC1S (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_CC2S =                // CC2S (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC1F =                // Input capture 1 filter (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC2F =                // Input capture 2 filter (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC2PCS =              // Input capture 2 prescaler (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_ICPCS =               // Input capture 1 prescaler (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t CCMR1_OC1CE = 0x80;         // OC1CE
    static constexpr uint32_t CCMR1_OC1FE = 0x4;          // OC1FE
    template<uint32_t X>
    static constexpr uint32_t CCMR1_OC1M =                // OC1M (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR1_OC1M_3 = 0x10000;     // Output Compare 1 mode - bit 3
    static constexpr uint32_t CCMR1_OC1PE = 0x8;          // OC1PE
    static constexpr uint32_t CCMR1_OC2CE = 0x8000;       // OC2CE
    static constexpr uint32_t CCMR1_OC2FE = 0x400;        // OC2FE
    template<uint32_t X>
    static constexpr uint32_t CCMR1_OC2M =                // OC2M (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    static constexpr uint32_t CCMR1_OC2M_3 = 0x1000000;   // Output Compare 2 mode - bit 3
    static constexpr uint32_t CCMR1_OC2PE = 0x800;        // OC2PE
    static const uint32_t CCMR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCMR2_CC3S =                // CC3S (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_CC4S =                // CC4S (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC3F =                // Input capture 3 filter (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC3PSC =              // Input capture 3 prescaler (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC4F =                // Input capture 4 filter (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC4PSC =              // Input capture 4 prescaler (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    static constexpr uint32_t CCMR2_O24CE = 0x8000;       // O24CE
    static constexpr uint32_t CCMR2_OC3CE = 0x80;         // OC3CE
    static constexpr uint32_t CCMR2_OC3FE = 0x4;          // OC3FE
    template<uint32_t X>
    static constexpr uint32_t CCMR2_OC3M =                // OC3M (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR2_OC3M_3 = 0x10000;     // Output Compare 1 mode - bit 3
    static constexpr uint32_t CCMR2_OC3PE = 0x8;          // OC3PE
    static constexpr uint32_t CCMR2_OC4FE = 0x400;        // OC4FE
    template<uint32_t X>
    static constexpr uint32_t CCMR2_OC4M =                // OC4M (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    static constexpr uint32_t CCMR2_OC4M_3 = 0x1000000;   // Output Compare 2 mode - bit 3
    static constexpr uint32_t CCMR2_OC4PE = 0x800;        // OC4PE
    static const uint32_t CCMR2_RESET_VALUE = 0x0;

    static constexpr uint32_t CCER_CC4NP = 0x8000;       // Capture/Compare 4 output Polarity
    static constexpr uint32_t CCER_CC4P = 0x2000;        // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC4E = 0x1000;        // Capture/Compare 4 output enable
    static constexpr uint32_t CCER_CC3NP = 0x800;        // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC3P = 0x200;         // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC3E = 0x100;         // Capture/Compare 3 output enable
    static constexpr uint32_t CCER_CC2NP = 0x80;         // Capture/Compare 2 output Polarity
    static constexpr uint32_t CCER_CC2P = 0x20;          // Capture/Compare 2 output Polarity
    static constexpr uint32_t CCER_CC2E = 0x10;          // Capture/Compare 2 output enable
    static constexpr uint32_t CCER_CC1NP = 0x8;          // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1P = 0x2;           // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1E = 0x1;           // Capture/Compare 1 output enable
    static const uint32_t CCER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CNT_CNT_L =               // low counter value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CNT_CNT_H =               // High counter value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t CNT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PSC_PSC =                 // Prescaler value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t PSC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ARR_ARR_H =               // High Auto-reload value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ARR_ARR_L =               // Low Auto-reload value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t ARR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR1_CCR1_H =              // High Capture/Compare 1 value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR1_CCR1_L =              // Low Capture/Compare 1 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR2_CCR2_H =              // High Capture/Compare 2 value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR2_CCR2_L =              // Low Capture/Compare 2 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR3_CCR3_H =              // High Capture/Compare value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR3_CCR3_L =              // Low Capture/Compare value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR4_CCR4_H =              // High Capture/Compare value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR4_CCR4_L =              // Low Capture/Compare value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DCR_DBL =                 // DMA burst length (5 bits)
        bit_field_t<8, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DCR_DBA =                 // DMA base address (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t DCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DMAR_DMAB =                // DMA register for burst accesses (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DMAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AF1_ETRSEL =              // ETR source selection (4 bits)
        bit_field_t<14, 0xf>::value<X>();
    static const uint32_t AF1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TISEL_TI1SEL =              // TI1[0] to TI1[15] input selection (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TISEL_TI2SEL =              // TI2[0] to TI2[15] input selection (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TISEL_TI3SEL =              // TI3[0] to TI3[15] input selection (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TISEL_TI4SEL =              // TI4[0] to TI4[15] input selection (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    static const uint32_t TISEL_RESET_VALUE = 0x0;

    static constexpr uint8_t TIM3 = 29; // TIM3 global interrupt
};

static tim3_t& TIM3 = *reinterpret_cast<tim3_t*>(0x40000400);

#define HAVE_PERIPHERAL_TIM3


////
//
//    General purpose timers
//
////

struct tim4_t
{
    volatile uint32_t    CR1;                  // [Read-write] control register 1
    volatile uint32_t    CR2;                  // [Read-write] control register 2
    volatile uint32_t    SMCR;                 // [Read-write] slave mode control register
    volatile uint32_t    DIER;                 // [Read-write] DMA/Interrupt enable register
    volatile uint32_t    SR;                   // [Read-write] status register
    volatile uint32_t    EGR;                  // [Write-only] event generation register
    volatile uint32_t    CCMR1;                // [Read-write] capture/compare mode register 1 (output mode)
    volatile uint32_t    CCMR2;                // [Read-write] capture/compare mode register 2 (output mode)
    volatile uint32_t    CCER;                 // [Read-write] capture/compare enable register
    volatile uint32_t    CNT;                  // [Read-write] counter
    volatile uint32_t    PSC;                  // [Read-write] prescaler
    volatile uint32_t    ARR;                  // [Read-write] auto-reload register
    reserved_t<1>        _0;
    volatile uint32_t    CCR1;                 // [Read-write] capture/compare register 1
    volatile uint32_t    CCR2;                 // [Read-write] capture/compare register 2
    volatile uint32_t    CCR3;                 // [Read-write] capture/compare register 3
    volatile uint32_t    CCR4;                 // [Read-write] capture/compare register 4
    reserved_t<1>        _1;
    volatile uint32_t    DCR;                  // [Read-write] DMA control register
    volatile uint32_t    DMAR;                 // [Read-write] DMA address for full transfer
    reserved_t<4>        _2;
    volatile uint32_t    AF1;                  // [Read-write] TIM alternate function option register 1
    reserved_t<1>        _3;
    volatile uint32_t    TISEL;                // [Read-write] TIM timer input selection register

    static constexpr uint32_t CR1_UIFREMAP = 0x800;     // UIF status bit remapping
    template<uint32_t X>
    static constexpr uint32_t CR1_CKD =                 // Clock division (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t CR1_ARPE = 0x80;          // Auto-reload preload enable
    template<uint32_t X>
    static constexpr uint32_t CR1_CMS =                 // Center-aligned mode selection (2 bits)
        bit_field_t<5, 0x3>::value<X>();
    static constexpr uint32_t CR1_DIR = 0x10;           // Direction
    static constexpr uint32_t CR1_OPM = 0x8;            // One-pulse mode
    static constexpr uint32_t CR1_URS = 0x4;            // Update request source
    static constexpr uint32_t CR1_UDIS = 0x2;           // Update disable
    static constexpr uint32_t CR1_CEN = 0x1;            // Counter enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CR2_TI1S = 0x80;          // TI1 selection
    template<uint32_t X>
    static constexpr uint32_t CR2_MMS =                 // Master mode selection (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CR2_CCDS = 0x8;           // Capture/compare DMA selection
    static const uint32_t CR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SMCR_TS_4_3 =              // Trigger selection (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    static constexpr uint32_t SMCR_SMS_3 = 0x10000;      // Slave mode selection - bit 3
    static constexpr uint32_t SMCR_ETP = 0x8000;         // External trigger polarity
    static constexpr uint32_t SMCR_ECE = 0x4000;         // External clock enable
    template<uint32_t X>
    static constexpr uint32_t SMCR_ETPS =                // External trigger prescaler (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMCR_ETF =                 // External trigger filter (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    static constexpr uint32_t SMCR_MSM = 0x80;           // Master/Slave mode
    template<uint32_t X>
    static constexpr uint32_t SMCR_TS =                  // Trigger selection (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMCR_SMS =                 // Slave mode selection (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t SMCR_RESET_VALUE = 0x0;

    static constexpr uint32_t DIER_TDE = 0x4000;         // Trigger DMA request enable
    static constexpr uint32_t DIER_CC4DE = 0x1000;       // Capture/Compare 4 DMA request enable
    static constexpr uint32_t DIER_CC3DE = 0x800;        // Capture/Compare 3 DMA request enable
    static constexpr uint32_t DIER_CC2DE = 0x400;        // Capture/Compare 2 DMA request enable
    static constexpr uint32_t DIER_CC1DE = 0x200;        // Capture/Compare 1 DMA request enable
    static constexpr uint32_t DIER_UDE = 0x100;          // Update DMA request enable
    static constexpr uint32_t DIER_TIE = 0x40;           // Trigger interrupt enable
    static constexpr uint32_t DIER_CC4IE = 0x10;         // Capture/Compare 4 interrupt enable
    static constexpr uint32_t DIER_CC3IE = 0x8;          // Capture/Compare 3 interrupt enable
    static constexpr uint32_t DIER_CC2IE = 0x4;          // Capture/Compare 2 interrupt enable
    static constexpr uint32_t DIER_CC1IE = 0x2;          // Capture/Compare 1 interrupt enable
    static constexpr uint32_t DIER_UIE = 0x1;            // Update interrupt enable
    static const uint32_t DIER_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_CC4OF = 0x1000;       // Capture/Compare 4 overcapture flag
    static constexpr uint32_t SR_CC3OF = 0x800;        // Capture/Compare 3 overcapture flag
    static constexpr uint32_t SR_CC2OF = 0x400;        // Capture/compare 2 overcapture flag
    static constexpr uint32_t SR_CC1OF = 0x200;        // Capture/Compare 1 overcapture flag
    static constexpr uint32_t SR_TIF = 0x40;           // Trigger interrupt flag
    static constexpr uint32_t SR_CC4IF = 0x10;         // Capture/Compare 4 interrupt flag
    static constexpr uint32_t SR_CC3IF = 0x8;          // Capture/Compare 3 interrupt flag
    static constexpr uint32_t SR_CC2IF = 0x4;          // Capture/Compare 2 interrupt flag
    static constexpr uint32_t SR_CC1IF = 0x2;          // Capture/compare 1 interrupt flag
    static constexpr uint32_t SR_UIF = 0x1;            // Update interrupt flag
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint32_t EGR_TG = 0x40;            // Trigger generation
    static constexpr uint32_t EGR_CC4G = 0x10;          // Capture/compare 4 generation
    static constexpr uint32_t EGR_CC3G = 0x8;           // Capture/compare 3 generation
    static constexpr uint32_t EGR_CC2G = 0x4;           // Capture/compare 2 generation
    static constexpr uint32_t EGR_CC1G = 0x2;           // Capture/compare 1 generation
    static constexpr uint32_t EGR_UG = 0x1;             // Update generation
    static const uint32_t EGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCMR1_CC1S =                // CC1S (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_CC2S =                // CC2S (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC1F =                // Input capture 1 filter (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC2F =                // Input capture 2 filter (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC2PCS =              // Input capture 2 prescaler (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_ICPCS =               // Input capture 1 prescaler (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t CCMR1_OC1CE = 0x80;         // OC1CE
    static constexpr uint32_t CCMR1_OC1FE = 0x4;          // OC1FE
    template<uint32_t X>
    static constexpr uint32_t CCMR1_OC1M =                // OC1M (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR1_OC1M_3 = 0x10000;     // Output Compare 1 mode - bit 3
    static constexpr uint32_t CCMR1_OC1PE = 0x8;          // OC1PE
    static constexpr uint32_t CCMR1_OC2CE = 0x8000;       // OC2CE
    static constexpr uint32_t CCMR1_OC2FE = 0x400;        // OC2FE
    template<uint32_t X>
    static constexpr uint32_t CCMR1_OC2M =                // OC2M (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    static constexpr uint32_t CCMR1_OC2M_3 = 0x1000000;   // Output Compare 2 mode - bit 3
    static constexpr uint32_t CCMR1_OC2PE = 0x800;        // OC2PE
    static const uint32_t CCMR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCMR2_CC3S =                // CC3S (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_CC4S =                // CC4S (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC3F =                // Input capture 3 filter (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC3PSC =              // Input capture 3 prescaler (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC4F =                // Input capture 4 filter (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC4PSC =              // Input capture 4 prescaler (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    static constexpr uint32_t CCMR2_O24CE = 0x8000;       // O24CE
    static constexpr uint32_t CCMR2_OC3CE = 0x80;         // OC3CE
    static constexpr uint32_t CCMR2_OC3FE = 0x4;          // OC3FE
    template<uint32_t X>
    static constexpr uint32_t CCMR2_OC3M =                // OC3M (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR2_OC3M_3 = 0x10000;     // Output Compare 1 mode - bit 3
    static constexpr uint32_t CCMR2_OC3PE = 0x8;          // OC3PE
    static constexpr uint32_t CCMR2_OC4FE = 0x400;        // OC4FE
    template<uint32_t X>
    static constexpr uint32_t CCMR2_OC4M =                // OC4M (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    static constexpr uint32_t CCMR2_OC4M_3 = 0x1000000;   // Output Compare 2 mode - bit 3
    static constexpr uint32_t CCMR2_OC4PE = 0x800;        // OC4PE
    static const uint32_t CCMR2_RESET_VALUE = 0x0;

    static constexpr uint32_t CCER_CC4NP = 0x8000;       // Capture/Compare 4 output Polarity
    static constexpr uint32_t CCER_CC4P = 0x2000;        // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC4E = 0x1000;        // Capture/Compare 4 output enable
    static constexpr uint32_t CCER_CC3NP = 0x800;        // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC3P = 0x200;         // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC3E = 0x100;         // Capture/Compare 3 output enable
    static constexpr uint32_t CCER_CC2NP = 0x80;         // Capture/Compare 2 output Polarity
    static constexpr uint32_t CCER_CC2P = 0x20;          // Capture/Compare 2 output Polarity
    static constexpr uint32_t CCER_CC2E = 0x10;          // Capture/Compare 2 output enable
    static constexpr uint32_t CCER_CC1NP = 0x8;          // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1P = 0x2;           // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1E = 0x1;           // Capture/Compare 1 output enable
    static const uint32_t CCER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CNT_CNT_L =               // low counter value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CNT_CNT_H =               // High counter value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t CNT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PSC_PSC =                 // Prescaler value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t PSC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ARR_ARR_H =               // High Auto-reload value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ARR_ARR_L =               // Low Auto-reload value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t ARR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR1_CCR1_H =              // High Capture/Compare 1 value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR1_CCR1_L =              // Low Capture/Compare 1 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR2_CCR2_H =              // High Capture/Compare 2 value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR2_CCR2_L =              // Low Capture/Compare 2 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR3_CCR3_H =              // High Capture/Compare value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR3_CCR3_L =              // Low Capture/Compare value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR4_CCR4_H =              // High Capture/Compare value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR4_CCR4_L =              // Low Capture/Compare value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DCR_DBL =                 // DMA burst length (5 bits)
        bit_field_t<8, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DCR_DBA =                 // DMA base address (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t DCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DMAR_DMAB =                // DMA register for burst accesses (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DMAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AF1_ETRSEL =              // ETR source selection (4 bits)
        bit_field_t<14, 0xf>::value<X>();
    static const uint32_t AF1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TISEL_TI1SEL =              // TI1[0] to TI1[15] input selection (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TISEL_TI2SEL =              // TI2[0] to TI2[15] input selection (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TISEL_TI3SEL =              // TI3[0] to TI3[15] input selection (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TISEL_TI4SEL =              // TI4[0] to TI4[15] input selection (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    static const uint32_t TISEL_RESET_VALUE = 0x0;
};

static tim4_t& TIM4 = *reinterpret_cast<tim4_t*>(0x40000800);

#define HAVE_PERIPHERAL_TIM4


////
//
//    General purpose timers
//
////

struct tim5_t
{
    volatile uint32_t    CR1;                  // [Read-write] control register 1
    volatile uint32_t    CR2;                  // [Read-write] control register 2
    volatile uint32_t    SMCR;                 // [Read-write] slave mode control register
    volatile uint32_t    DIER;                 // [Read-write] DMA/Interrupt enable register
    volatile uint32_t    SR;                   // [Read-write] status register
    volatile uint32_t    EGR;                  // [Write-only] event generation register
    volatile uint32_t    CCMR1;                // [Read-write] capture/compare mode register 1 (output mode)
    volatile uint32_t    CCMR2;                // [Read-write] capture/compare mode register 2 (output mode)
    volatile uint32_t    CCER;                 // [Read-write] capture/compare enable register
    volatile uint32_t    CNT;                  // [Read-write] counter
    volatile uint32_t    PSC;                  // [Read-write] prescaler
    volatile uint32_t    ARR;                  // [Read-write] auto-reload register
    reserved_t<1>        _0;
    volatile uint32_t    CCR1;                 // [Read-write] capture/compare register 1
    volatile uint32_t    CCR2;                 // [Read-write] capture/compare register 2
    volatile uint32_t    CCR3;                 // [Read-write] capture/compare register 3
    volatile uint32_t    CCR4;                 // [Read-write] capture/compare register 4
    reserved_t<1>        _1;
    volatile uint32_t    DCR;                  // [Read-write] DMA control register
    volatile uint32_t    DMAR;                 // [Read-write] DMA address for full transfer
    reserved_t<4>        _2;
    volatile uint32_t    AF1;                  // [Read-write] TIM alternate function option register 1
    reserved_t<1>        _3;
    volatile uint32_t    TISEL;                // [Read-write] TIM timer input selection register

    static constexpr uint32_t CR1_UIFREMAP = 0x800;     // UIF status bit remapping
    template<uint32_t X>
    static constexpr uint32_t CR1_CKD =                 // Clock division (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t CR1_ARPE = 0x80;          // Auto-reload preload enable
    template<uint32_t X>
    static constexpr uint32_t CR1_CMS =                 // Center-aligned mode selection (2 bits)
        bit_field_t<5, 0x3>::value<X>();
    static constexpr uint32_t CR1_DIR = 0x10;           // Direction
    static constexpr uint32_t CR1_OPM = 0x8;            // One-pulse mode
    static constexpr uint32_t CR1_URS = 0x4;            // Update request source
    static constexpr uint32_t CR1_UDIS = 0x2;           // Update disable
    static constexpr uint32_t CR1_CEN = 0x1;            // Counter enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CR2_TI1S = 0x80;          // TI1 selection
    template<uint32_t X>
    static constexpr uint32_t CR2_MMS =                 // Master mode selection (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CR2_CCDS = 0x8;           // Capture/compare DMA selection
    static const uint32_t CR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SMCR_TS_4_3 =              // Trigger selection (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    static constexpr uint32_t SMCR_SMS_3 = 0x10000;      // Slave mode selection - bit 3
    static constexpr uint32_t SMCR_ETP = 0x8000;         // External trigger polarity
    static constexpr uint32_t SMCR_ECE = 0x4000;         // External clock enable
    template<uint32_t X>
    static constexpr uint32_t SMCR_ETPS =                // External trigger prescaler (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMCR_ETF =                 // External trigger filter (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    static constexpr uint32_t SMCR_MSM = 0x80;           // Master/Slave mode
    template<uint32_t X>
    static constexpr uint32_t SMCR_TS =                  // Trigger selection (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMCR_SMS =                 // Slave mode selection (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t SMCR_RESET_VALUE = 0x0;

    static constexpr uint32_t DIER_TDE = 0x4000;         // Trigger DMA request enable
    static constexpr uint32_t DIER_CC4DE = 0x1000;       // Capture/Compare 4 DMA request enable
    static constexpr uint32_t DIER_CC3DE = 0x800;        // Capture/Compare 3 DMA request enable
    static constexpr uint32_t DIER_CC2DE = 0x400;        // Capture/Compare 2 DMA request enable
    static constexpr uint32_t DIER_CC1DE = 0x200;        // Capture/Compare 1 DMA request enable
    static constexpr uint32_t DIER_UDE = 0x100;          // Update DMA request enable
    static constexpr uint32_t DIER_TIE = 0x40;           // Trigger interrupt enable
    static constexpr uint32_t DIER_CC4IE = 0x10;         // Capture/Compare 4 interrupt enable
    static constexpr uint32_t DIER_CC3IE = 0x8;          // Capture/Compare 3 interrupt enable
    static constexpr uint32_t DIER_CC2IE = 0x4;          // Capture/Compare 2 interrupt enable
    static constexpr uint32_t DIER_CC1IE = 0x2;          // Capture/Compare 1 interrupt enable
    static constexpr uint32_t DIER_UIE = 0x1;            // Update interrupt enable
    static const uint32_t DIER_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_CC4OF = 0x1000;       // Capture/Compare 4 overcapture flag
    static constexpr uint32_t SR_CC3OF = 0x800;        // Capture/Compare 3 overcapture flag
    static constexpr uint32_t SR_CC2OF = 0x400;        // Capture/compare 2 overcapture flag
    static constexpr uint32_t SR_CC1OF = 0x200;        // Capture/Compare 1 overcapture flag
    static constexpr uint32_t SR_TIF = 0x40;           // Trigger interrupt flag
    static constexpr uint32_t SR_CC4IF = 0x10;         // Capture/Compare 4 interrupt flag
    static constexpr uint32_t SR_CC3IF = 0x8;          // Capture/Compare 3 interrupt flag
    static constexpr uint32_t SR_CC2IF = 0x4;          // Capture/Compare 2 interrupt flag
    static constexpr uint32_t SR_CC1IF = 0x2;          // Capture/compare 1 interrupt flag
    static constexpr uint32_t SR_UIF = 0x1;            // Update interrupt flag
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint32_t EGR_TG = 0x40;            // Trigger generation
    static constexpr uint32_t EGR_CC4G = 0x10;          // Capture/compare 4 generation
    static constexpr uint32_t EGR_CC3G = 0x8;           // Capture/compare 3 generation
    static constexpr uint32_t EGR_CC2G = 0x4;           // Capture/compare 2 generation
    static constexpr uint32_t EGR_CC1G = 0x2;           // Capture/compare 1 generation
    static constexpr uint32_t EGR_UG = 0x1;             // Update generation
    static const uint32_t EGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCMR1_CC1S =                // CC1S (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_CC2S =                // CC2S (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC1F =                // Input capture 1 filter (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC2F =                // Input capture 2 filter (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC2PCS =              // Input capture 2 prescaler (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_ICPCS =               // Input capture 1 prescaler (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t CCMR1_OC1CE = 0x80;         // OC1CE
    static constexpr uint32_t CCMR1_OC1FE = 0x4;          // OC1FE
    template<uint32_t X>
    static constexpr uint32_t CCMR1_OC1M =                // OC1M (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR1_OC1M_3 = 0x10000;     // Output Compare 1 mode - bit 3
    static constexpr uint32_t CCMR1_OC1PE = 0x8;          // OC1PE
    static constexpr uint32_t CCMR1_OC2CE = 0x8000;       // OC2CE
    static constexpr uint32_t CCMR1_OC2FE = 0x400;        // OC2FE
    template<uint32_t X>
    static constexpr uint32_t CCMR1_OC2M =                // OC2M (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    static constexpr uint32_t CCMR1_OC2M_3 = 0x1000000;   // Output Compare 2 mode - bit 3
    static constexpr uint32_t CCMR1_OC2PE = 0x800;        // OC2PE
    static const uint32_t CCMR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCMR2_CC3S =                // CC3S (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_CC4S =                // CC4S (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC3F =                // Input capture 3 filter (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC3PSC =              // Input capture 3 prescaler (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC4F =                // Input capture 4 filter (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC4PSC =              // Input capture 4 prescaler (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    static constexpr uint32_t CCMR2_O24CE = 0x8000;       // O24CE
    static constexpr uint32_t CCMR2_OC3CE = 0x80;         // OC3CE
    static constexpr uint32_t CCMR2_OC3FE = 0x4;          // OC3FE
    template<uint32_t X>
    static constexpr uint32_t CCMR2_OC3M =                // OC3M (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR2_OC3M_3 = 0x10000;     // Output Compare 1 mode - bit 3
    static constexpr uint32_t CCMR2_OC3PE = 0x8;          // OC3PE
    static constexpr uint32_t CCMR2_OC4FE = 0x400;        // OC4FE
    template<uint32_t X>
    static constexpr uint32_t CCMR2_OC4M =                // OC4M (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    static constexpr uint32_t CCMR2_OC4M_3 = 0x1000000;   // Output Compare 2 mode - bit 3
    static constexpr uint32_t CCMR2_OC4PE = 0x800;        // OC4PE
    static const uint32_t CCMR2_RESET_VALUE = 0x0;

    static constexpr uint32_t CCER_CC4NP = 0x8000;       // Capture/Compare 4 output Polarity
    static constexpr uint32_t CCER_CC4P = 0x2000;        // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC4E = 0x1000;        // Capture/Compare 4 output enable
    static constexpr uint32_t CCER_CC3NP = 0x800;        // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC3P = 0x200;         // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC3E = 0x100;         // Capture/Compare 3 output enable
    static constexpr uint32_t CCER_CC2NP = 0x80;         // Capture/Compare 2 output Polarity
    static constexpr uint32_t CCER_CC2P = 0x20;          // Capture/Compare 2 output Polarity
    static constexpr uint32_t CCER_CC2E = 0x10;          // Capture/Compare 2 output enable
    static constexpr uint32_t CCER_CC1NP = 0x8;          // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1P = 0x2;           // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1E = 0x1;           // Capture/Compare 1 output enable
    static const uint32_t CCER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CNT_CNT_L =               // low counter value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CNT_CNT_H =               // High counter value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t CNT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PSC_PSC =                 // Prescaler value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t PSC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ARR_ARR_H =               // High Auto-reload value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ARR_ARR_L =               // Low Auto-reload value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t ARR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR1_CCR1_H =              // High Capture/Compare 1 value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR1_CCR1_L =              // Low Capture/Compare 1 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR2_CCR2_H =              // High Capture/Compare 2 value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR2_CCR2_L =              // Low Capture/Compare 2 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR3_CCR3_H =              // High Capture/Compare value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR3_CCR3_L =              // Low Capture/Compare value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR4_CCR4_H =              // High Capture/Compare value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR4_CCR4_L =              // Low Capture/Compare value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DCR_DBL =                 // DMA burst length (5 bits)
        bit_field_t<8, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DCR_DBA =                 // DMA base address (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t DCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DMAR_DMAB =                // DMA register for burst accesses (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DMAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AF1_ETRSEL =              // ETR source selection (4 bits)
        bit_field_t<14, 0xf>::value<X>();
    static const uint32_t AF1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TISEL_TI1SEL =              // TI1[0] to TI1[15] input selection (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TISEL_TI2SEL =              // TI2[0] to TI2[15] input selection (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TISEL_TI3SEL =              // TI3[0] to TI3[15] input selection (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TISEL_TI4SEL =              // TI4[0] to TI4[15] input selection (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    static const uint32_t TISEL_RESET_VALUE = 0x0;

    static constexpr uint8_t TIM4 = 30; // TIM4 global interrupt
    static constexpr uint8_t TIM5 = 50; // TIM5 global interrupt
};

static tim5_t& TIM5 = *reinterpret_cast<tim5_t*>(0x40000c00);

#define HAVE_PERIPHERAL_TIM5


////
//
//    General purpose timers
//
////

struct tim12_t
{
    volatile uint32_t    CR1;                  // [Read-write] control register 1
    volatile uint32_t    CR2;                  // [Read-write] control register 2
    volatile uint32_t    SMCR;                 // [Read-write] slave mode control register
    volatile uint32_t    DIER;                 // [Read-write] DMA/Interrupt enable register
    volatile uint32_t    SR;                   // [Read-write] status register
    volatile uint32_t    EGR;                  // [Write-only] event generation register
    volatile uint32_t    CCMR1;                // [Read-write] capture/compare mode register 1 (output mode)
    volatile uint32_t    CCMR2;                // [Read-write] capture/compare mode register 2 (output mode)
    volatile uint32_t    CCER;                 // [Read-write] capture/compare enable register
    volatile uint32_t    CNT;                  // [Read-write] counter
    volatile uint32_t    PSC;                  // [Read-write] prescaler
    volatile uint32_t    ARR;                  // [Read-write] auto-reload register
    reserved_t<1>        _0;
    volatile uint32_t    CCR1;                 // [Read-write] capture/compare register 1
    volatile uint32_t    CCR2;                 // [Read-write] capture/compare register 2
    volatile uint32_t    CCR3;                 // [Read-write] capture/compare register 3
    volatile uint32_t    CCR4;                 // [Read-write] capture/compare register 4
    reserved_t<1>        _1;
    volatile uint32_t    DCR;                  // [Read-write] DMA control register
    volatile uint32_t    DMAR;                 // [Read-write] DMA address for full transfer
    reserved_t<4>        _2;
    volatile uint32_t    AF1;                  // [Read-write] TIM alternate function option register 1
    reserved_t<1>        _3;
    volatile uint32_t    TISEL;                // [Read-write] TIM timer input selection register

    static constexpr uint32_t CR1_UIFREMAP = 0x800;     // UIF status bit remapping
    template<uint32_t X>
    static constexpr uint32_t CR1_CKD =                 // Clock division (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t CR1_ARPE = 0x80;          // Auto-reload preload enable
    template<uint32_t X>
    static constexpr uint32_t CR1_CMS =                 // Center-aligned mode selection (2 bits)
        bit_field_t<5, 0x3>::value<X>();
    static constexpr uint32_t CR1_DIR = 0x10;           // Direction
    static constexpr uint32_t CR1_OPM = 0x8;            // One-pulse mode
    static constexpr uint32_t CR1_URS = 0x4;            // Update request source
    static constexpr uint32_t CR1_UDIS = 0x2;           // Update disable
    static constexpr uint32_t CR1_CEN = 0x1;            // Counter enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CR2_TI1S = 0x80;          // TI1 selection
    template<uint32_t X>
    static constexpr uint32_t CR2_MMS =                 // Master mode selection (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CR2_CCDS = 0x8;           // Capture/compare DMA selection
    static const uint32_t CR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SMCR_TS_4_3 =              // Trigger selection (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    static constexpr uint32_t SMCR_SMS_3 = 0x10000;      // Slave mode selection - bit 3
    static constexpr uint32_t SMCR_ETP = 0x8000;         // External trigger polarity
    static constexpr uint32_t SMCR_ECE = 0x4000;         // External clock enable
    template<uint32_t X>
    static constexpr uint32_t SMCR_ETPS =                // External trigger prescaler (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMCR_ETF =                 // External trigger filter (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    static constexpr uint32_t SMCR_MSM = 0x80;           // Master/Slave mode
    template<uint32_t X>
    static constexpr uint32_t SMCR_TS =                  // Trigger selection (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMCR_SMS =                 // Slave mode selection (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t SMCR_RESET_VALUE = 0x0;

    static constexpr uint32_t DIER_TDE = 0x4000;         // Trigger DMA request enable
    static constexpr uint32_t DIER_CC4DE = 0x1000;       // Capture/Compare 4 DMA request enable
    static constexpr uint32_t DIER_CC3DE = 0x800;        // Capture/Compare 3 DMA request enable
    static constexpr uint32_t DIER_CC2DE = 0x400;        // Capture/Compare 2 DMA request enable
    static constexpr uint32_t DIER_CC1DE = 0x200;        // Capture/Compare 1 DMA request enable
    static constexpr uint32_t DIER_UDE = 0x100;          // Update DMA request enable
    static constexpr uint32_t DIER_TIE = 0x40;           // Trigger interrupt enable
    static constexpr uint32_t DIER_CC4IE = 0x10;         // Capture/Compare 4 interrupt enable
    static constexpr uint32_t DIER_CC3IE = 0x8;          // Capture/Compare 3 interrupt enable
    static constexpr uint32_t DIER_CC2IE = 0x4;          // Capture/Compare 2 interrupt enable
    static constexpr uint32_t DIER_CC1IE = 0x2;          // Capture/Compare 1 interrupt enable
    static constexpr uint32_t DIER_UIE = 0x1;            // Update interrupt enable
    static const uint32_t DIER_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_CC4OF = 0x1000;       // Capture/Compare 4 overcapture flag
    static constexpr uint32_t SR_CC3OF = 0x800;        // Capture/Compare 3 overcapture flag
    static constexpr uint32_t SR_CC2OF = 0x400;        // Capture/compare 2 overcapture flag
    static constexpr uint32_t SR_CC1OF = 0x200;        // Capture/Compare 1 overcapture flag
    static constexpr uint32_t SR_TIF = 0x40;           // Trigger interrupt flag
    static constexpr uint32_t SR_CC4IF = 0x10;         // Capture/Compare 4 interrupt flag
    static constexpr uint32_t SR_CC3IF = 0x8;          // Capture/Compare 3 interrupt flag
    static constexpr uint32_t SR_CC2IF = 0x4;          // Capture/Compare 2 interrupt flag
    static constexpr uint32_t SR_CC1IF = 0x2;          // Capture/compare 1 interrupt flag
    static constexpr uint32_t SR_UIF = 0x1;            // Update interrupt flag
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint32_t EGR_TG = 0x40;            // Trigger generation
    static constexpr uint32_t EGR_CC4G = 0x10;          // Capture/compare 4 generation
    static constexpr uint32_t EGR_CC3G = 0x8;           // Capture/compare 3 generation
    static constexpr uint32_t EGR_CC2G = 0x4;           // Capture/compare 2 generation
    static constexpr uint32_t EGR_CC1G = 0x2;           // Capture/compare 1 generation
    static constexpr uint32_t EGR_UG = 0x1;             // Update generation
    static const uint32_t EGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCMR1_CC1S =                // CC1S (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_CC2S =                // CC2S (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC1F =                // Input capture 1 filter (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC2F =                // Input capture 2 filter (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC2PCS =              // Input capture 2 prescaler (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_ICPCS =               // Input capture 1 prescaler (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t CCMR1_OC1CE = 0x80;         // OC1CE
    static constexpr uint32_t CCMR1_OC1FE = 0x4;          // OC1FE
    template<uint32_t X>
    static constexpr uint32_t CCMR1_OC1M =                // OC1M (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR1_OC1M_3 = 0x10000;     // Output Compare 1 mode - bit 3
    static constexpr uint32_t CCMR1_OC1PE = 0x8;          // OC1PE
    static constexpr uint32_t CCMR1_OC2CE = 0x8000;       // OC2CE
    static constexpr uint32_t CCMR1_OC2FE = 0x400;        // OC2FE
    template<uint32_t X>
    static constexpr uint32_t CCMR1_OC2M =                // OC2M (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    static constexpr uint32_t CCMR1_OC2M_3 = 0x1000000;   // Output Compare 2 mode - bit 3
    static constexpr uint32_t CCMR1_OC2PE = 0x800;        // OC2PE
    static const uint32_t CCMR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCMR2_CC3S =                // CC3S (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_CC4S =                // CC4S (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC3F =                // Input capture 3 filter (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC3PSC =              // Input capture 3 prescaler (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC4F =                // Input capture 4 filter (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC4PSC =              // Input capture 4 prescaler (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    static constexpr uint32_t CCMR2_O24CE = 0x8000;       // O24CE
    static constexpr uint32_t CCMR2_OC3CE = 0x80;         // OC3CE
    static constexpr uint32_t CCMR2_OC3FE = 0x4;          // OC3FE
    template<uint32_t X>
    static constexpr uint32_t CCMR2_OC3M =                // OC3M (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR2_OC3M_3 = 0x10000;     // Output Compare 1 mode - bit 3
    static constexpr uint32_t CCMR2_OC3PE = 0x8;          // OC3PE
    static constexpr uint32_t CCMR2_OC4FE = 0x400;        // OC4FE
    template<uint32_t X>
    static constexpr uint32_t CCMR2_OC4M =                // OC4M (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    static constexpr uint32_t CCMR2_OC4M_3 = 0x1000000;   // Output Compare 2 mode - bit 3
    static constexpr uint32_t CCMR2_OC4PE = 0x800;        // OC4PE
    static const uint32_t CCMR2_RESET_VALUE = 0x0;

    static constexpr uint32_t CCER_CC4NP = 0x8000;       // Capture/Compare 4 output Polarity
    static constexpr uint32_t CCER_CC4P = 0x2000;        // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC4E = 0x1000;        // Capture/Compare 4 output enable
    static constexpr uint32_t CCER_CC3NP = 0x800;        // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC3P = 0x200;         // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC3E = 0x100;         // Capture/Compare 3 output enable
    static constexpr uint32_t CCER_CC2NP = 0x80;         // Capture/Compare 2 output Polarity
    static constexpr uint32_t CCER_CC2P = 0x20;          // Capture/Compare 2 output Polarity
    static constexpr uint32_t CCER_CC2E = 0x10;          // Capture/Compare 2 output enable
    static constexpr uint32_t CCER_CC1NP = 0x8;          // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1P = 0x2;           // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1E = 0x1;           // Capture/Compare 1 output enable
    static const uint32_t CCER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CNT_CNT_L =               // low counter value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CNT_CNT_H =               // High counter value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t CNT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PSC_PSC =                 // Prescaler value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t PSC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ARR_ARR_H =               // High Auto-reload value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ARR_ARR_L =               // Low Auto-reload value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t ARR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR1_CCR1_H =              // High Capture/Compare 1 value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR1_CCR1_L =              // Low Capture/Compare 1 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR2_CCR2_H =              // High Capture/Compare 2 value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR2_CCR2_L =              // Low Capture/Compare 2 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR3_CCR3_H =              // High Capture/Compare value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR3_CCR3_L =              // Low Capture/Compare value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR4_CCR4_H =              // High Capture/Compare value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR4_CCR4_L =              // Low Capture/Compare value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DCR_DBL =                 // DMA burst length (5 bits)
        bit_field_t<8, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DCR_DBA =                 // DMA base address (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t DCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DMAR_DMAB =                // DMA register for burst accesses (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DMAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AF1_ETRSEL =              // ETR source selection (4 bits)
        bit_field_t<14, 0xf>::value<X>();
    static const uint32_t AF1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TISEL_TI1SEL =              // TI1[0] to TI1[15] input selection (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TISEL_TI2SEL =              // TI2[0] to TI2[15] input selection (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TISEL_TI3SEL =              // TI3[0] to TI3[15] input selection (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TISEL_TI4SEL =              // TI4[0] to TI4[15] input selection (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    static const uint32_t TISEL_RESET_VALUE = 0x0;

    static constexpr uint8_t TIM8_BRK_TIM12 = 43; // TIM8 and 12 break global
};

static tim12_t& TIM12 = *reinterpret_cast<tim12_t*>(0x40001800);

#define HAVE_PERIPHERAL_TIM12


////
//
//    General purpose timers
//
////

struct tim13_t
{
    volatile uint32_t    CR1;                  // [Read-write] control register 1
    volatile uint32_t    CR2;                  // [Read-write] control register 2
    volatile uint32_t    SMCR;                 // [Read-write] slave mode control register
    volatile uint32_t    DIER;                 // [Read-write] DMA/Interrupt enable register
    volatile uint32_t    SR;                   // [Read-write] status register
    volatile uint32_t    EGR;                  // [Write-only] event generation register
    volatile uint32_t    CCMR1;                // [Read-write] capture/compare mode register 1 (output mode)
    volatile uint32_t    CCMR2;                // [Read-write] capture/compare mode register 2 (output mode)
    volatile uint32_t    CCER;                 // [Read-write] capture/compare enable register
    volatile uint32_t    CNT;                  // [Read-write] counter
    volatile uint32_t    PSC;                  // [Read-write] prescaler
    volatile uint32_t    ARR;                  // [Read-write] auto-reload register
    reserved_t<1>        _0;
    volatile uint32_t    CCR1;                 // [Read-write] capture/compare register 1
    volatile uint32_t    CCR2;                 // [Read-write] capture/compare register 2
    volatile uint32_t    CCR3;                 // [Read-write] capture/compare register 3
    volatile uint32_t    CCR4;                 // [Read-write] capture/compare register 4
    reserved_t<1>        _1;
    volatile uint32_t    DCR;                  // [Read-write] DMA control register
    volatile uint32_t    DMAR;                 // [Read-write] DMA address for full transfer
    reserved_t<4>        _2;
    volatile uint32_t    AF1;                  // [Read-write] TIM alternate function option register 1
    reserved_t<1>        _3;
    volatile uint32_t    TISEL;                // [Read-write] TIM timer input selection register

    static constexpr uint32_t CR1_UIFREMAP = 0x800;     // UIF status bit remapping
    template<uint32_t X>
    static constexpr uint32_t CR1_CKD =                 // Clock division (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t CR1_ARPE = 0x80;          // Auto-reload preload enable
    template<uint32_t X>
    static constexpr uint32_t CR1_CMS =                 // Center-aligned mode selection (2 bits)
        bit_field_t<5, 0x3>::value<X>();
    static constexpr uint32_t CR1_DIR = 0x10;           // Direction
    static constexpr uint32_t CR1_OPM = 0x8;            // One-pulse mode
    static constexpr uint32_t CR1_URS = 0x4;            // Update request source
    static constexpr uint32_t CR1_UDIS = 0x2;           // Update disable
    static constexpr uint32_t CR1_CEN = 0x1;            // Counter enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CR2_TI1S = 0x80;          // TI1 selection
    template<uint32_t X>
    static constexpr uint32_t CR2_MMS =                 // Master mode selection (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CR2_CCDS = 0x8;           // Capture/compare DMA selection
    static const uint32_t CR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SMCR_TS_4_3 =              // Trigger selection (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    static constexpr uint32_t SMCR_SMS_3 = 0x10000;      // Slave mode selection - bit 3
    static constexpr uint32_t SMCR_ETP = 0x8000;         // External trigger polarity
    static constexpr uint32_t SMCR_ECE = 0x4000;         // External clock enable
    template<uint32_t X>
    static constexpr uint32_t SMCR_ETPS =                // External trigger prescaler (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMCR_ETF =                 // External trigger filter (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    static constexpr uint32_t SMCR_MSM = 0x80;           // Master/Slave mode
    template<uint32_t X>
    static constexpr uint32_t SMCR_TS =                  // Trigger selection (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMCR_SMS =                 // Slave mode selection (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t SMCR_RESET_VALUE = 0x0;

    static constexpr uint32_t DIER_TDE = 0x4000;         // Trigger DMA request enable
    static constexpr uint32_t DIER_CC4DE = 0x1000;       // Capture/Compare 4 DMA request enable
    static constexpr uint32_t DIER_CC3DE = 0x800;        // Capture/Compare 3 DMA request enable
    static constexpr uint32_t DIER_CC2DE = 0x400;        // Capture/Compare 2 DMA request enable
    static constexpr uint32_t DIER_CC1DE = 0x200;        // Capture/Compare 1 DMA request enable
    static constexpr uint32_t DIER_UDE = 0x100;          // Update DMA request enable
    static constexpr uint32_t DIER_TIE = 0x40;           // Trigger interrupt enable
    static constexpr uint32_t DIER_CC4IE = 0x10;         // Capture/Compare 4 interrupt enable
    static constexpr uint32_t DIER_CC3IE = 0x8;          // Capture/Compare 3 interrupt enable
    static constexpr uint32_t DIER_CC2IE = 0x4;          // Capture/Compare 2 interrupt enable
    static constexpr uint32_t DIER_CC1IE = 0x2;          // Capture/Compare 1 interrupt enable
    static constexpr uint32_t DIER_UIE = 0x1;            // Update interrupt enable
    static const uint32_t DIER_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_CC4OF = 0x1000;       // Capture/Compare 4 overcapture flag
    static constexpr uint32_t SR_CC3OF = 0x800;        // Capture/Compare 3 overcapture flag
    static constexpr uint32_t SR_CC2OF = 0x400;        // Capture/compare 2 overcapture flag
    static constexpr uint32_t SR_CC1OF = 0x200;        // Capture/Compare 1 overcapture flag
    static constexpr uint32_t SR_TIF = 0x40;           // Trigger interrupt flag
    static constexpr uint32_t SR_CC4IF = 0x10;         // Capture/Compare 4 interrupt flag
    static constexpr uint32_t SR_CC3IF = 0x8;          // Capture/Compare 3 interrupt flag
    static constexpr uint32_t SR_CC2IF = 0x4;          // Capture/Compare 2 interrupt flag
    static constexpr uint32_t SR_CC1IF = 0x2;          // Capture/compare 1 interrupt flag
    static constexpr uint32_t SR_UIF = 0x1;            // Update interrupt flag
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint32_t EGR_TG = 0x40;            // Trigger generation
    static constexpr uint32_t EGR_CC4G = 0x10;          // Capture/compare 4 generation
    static constexpr uint32_t EGR_CC3G = 0x8;           // Capture/compare 3 generation
    static constexpr uint32_t EGR_CC2G = 0x4;           // Capture/compare 2 generation
    static constexpr uint32_t EGR_CC1G = 0x2;           // Capture/compare 1 generation
    static constexpr uint32_t EGR_UG = 0x1;             // Update generation
    static const uint32_t EGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCMR1_CC1S =                // CC1S (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_CC2S =                // CC2S (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC1F =                // Input capture 1 filter (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC2F =                // Input capture 2 filter (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC2PCS =              // Input capture 2 prescaler (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_ICPCS =               // Input capture 1 prescaler (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t CCMR1_OC1CE = 0x80;         // OC1CE
    static constexpr uint32_t CCMR1_OC1FE = 0x4;          // OC1FE
    template<uint32_t X>
    static constexpr uint32_t CCMR1_OC1M =                // OC1M (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR1_OC1M_3 = 0x10000;     // Output Compare 1 mode - bit 3
    static constexpr uint32_t CCMR1_OC1PE = 0x8;          // OC1PE
    static constexpr uint32_t CCMR1_OC2CE = 0x8000;       // OC2CE
    static constexpr uint32_t CCMR1_OC2FE = 0x400;        // OC2FE
    template<uint32_t X>
    static constexpr uint32_t CCMR1_OC2M =                // OC2M (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    static constexpr uint32_t CCMR1_OC2M_3 = 0x1000000;   // Output Compare 2 mode - bit 3
    static constexpr uint32_t CCMR1_OC2PE = 0x800;        // OC2PE
    static const uint32_t CCMR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCMR2_CC3S =                // CC3S (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_CC4S =                // CC4S (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC3F =                // Input capture 3 filter (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC3PSC =              // Input capture 3 prescaler (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC4F =                // Input capture 4 filter (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC4PSC =              // Input capture 4 prescaler (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    static constexpr uint32_t CCMR2_O24CE = 0x8000;       // O24CE
    static constexpr uint32_t CCMR2_OC3CE = 0x80;         // OC3CE
    static constexpr uint32_t CCMR2_OC3FE = 0x4;          // OC3FE
    template<uint32_t X>
    static constexpr uint32_t CCMR2_OC3M =                // OC3M (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR2_OC3M_3 = 0x10000;     // Output Compare 1 mode - bit 3
    static constexpr uint32_t CCMR2_OC3PE = 0x8;          // OC3PE
    static constexpr uint32_t CCMR2_OC4FE = 0x400;        // OC4FE
    template<uint32_t X>
    static constexpr uint32_t CCMR2_OC4M =                // OC4M (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    static constexpr uint32_t CCMR2_OC4M_3 = 0x1000000;   // Output Compare 2 mode - bit 3
    static constexpr uint32_t CCMR2_OC4PE = 0x800;        // OC4PE
    static const uint32_t CCMR2_RESET_VALUE = 0x0;

    static constexpr uint32_t CCER_CC4NP = 0x8000;       // Capture/Compare 4 output Polarity
    static constexpr uint32_t CCER_CC4P = 0x2000;        // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC4E = 0x1000;        // Capture/Compare 4 output enable
    static constexpr uint32_t CCER_CC3NP = 0x800;        // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC3P = 0x200;         // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC3E = 0x100;         // Capture/Compare 3 output enable
    static constexpr uint32_t CCER_CC2NP = 0x80;         // Capture/Compare 2 output Polarity
    static constexpr uint32_t CCER_CC2P = 0x20;          // Capture/Compare 2 output Polarity
    static constexpr uint32_t CCER_CC2E = 0x10;          // Capture/Compare 2 output enable
    static constexpr uint32_t CCER_CC1NP = 0x8;          // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1P = 0x2;           // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1E = 0x1;           // Capture/Compare 1 output enable
    static const uint32_t CCER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CNT_CNT_L =               // low counter value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CNT_CNT_H =               // High counter value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t CNT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PSC_PSC =                 // Prescaler value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t PSC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ARR_ARR_H =               // High Auto-reload value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ARR_ARR_L =               // Low Auto-reload value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t ARR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR1_CCR1_H =              // High Capture/Compare 1 value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR1_CCR1_L =              // Low Capture/Compare 1 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR2_CCR2_H =              // High Capture/Compare 2 value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR2_CCR2_L =              // Low Capture/Compare 2 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR3_CCR3_H =              // High Capture/Compare value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR3_CCR3_L =              // Low Capture/Compare value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR4_CCR4_H =              // High Capture/Compare value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR4_CCR4_L =              // Low Capture/Compare value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DCR_DBL =                 // DMA burst length (5 bits)
        bit_field_t<8, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DCR_DBA =                 // DMA base address (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t DCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DMAR_DMAB =                // DMA register for burst accesses (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DMAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AF1_ETRSEL =              // ETR source selection (4 bits)
        bit_field_t<14, 0xf>::value<X>();
    static const uint32_t AF1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TISEL_TI1SEL =              // TI1[0] to TI1[15] input selection (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TISEL_TI2SEL =              // TI2[0] to TI2[15] input selection (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TISEL_TI3SEL =              // TI3[0] to TI3[15] input selection (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TISEL_TI4SEL =              // TI4[0] to TI4[15] input selection (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    static const uint32_t TISEL_RESET_VALUE = 0x0;

    static constexpr uint8_t TIM8_UP_TIM13 = 44; // TIM8 and 13 update global
};

static tim13_t& TIM13 = *reinterpret_cast<tim13_t*>(0x40001c00);

#define HAVE_PERIPHERAL_TIM13


////
//
//    General purpose timers
//
////

struct tim14_t
{
    volatile uint32_t    CR1;                  // [Read-write] control register 1
    volatile uint32_t    CR2;                  // [Read-write] control register 2
    volatile uint32_t    SMCR;                 // [Read-write] slave mode control register
    volatile uint32_t    DIER;                 // [Read-write] DMA/Interrupt enable register
    volatile uint32_t    SR;                   // [Read-write] status register
    volatile uint32_t    EGR;                  // [Write-only] event generation register
    volatile uint32_t    CCMR1;                // [Read-write] capture/compare mode register 1 (output mode)
    volatile uint32_t    CCMR2;                // [Read-write] capture/compare mode register 2 (output mode)
    volatile uint32_t    CCER;                 // [Read-write] capture/compare enable register
    volatile uint32_t    CNT;                  // [Read-write] counter
    volatile uint32_t    PSC;                  // [Read-write] prescaler
    volatile uint32_t    ARR;                  // [Read-write] auto-reload register
    reserved_t<1>        _0;
    volatile uint32_t    CCR1;                 // [Read-write] capture/compare register 1
    volatile uint32_t    CCR2;                 // [Read-write] capture/compare register 2
    volatile uint32_t    CCR3;                 // [Read-write] capture/compare register 3
    volatile uint32_t    CCR4;                 // [Read-write] capture/compare register 4
    reserved_t<1>        _1;
    volatile uint32_t    DCR;                  // [Read-write] DMA control register
    volatile uint32_t    DMAR;                 // [Read-write] DMA address for full transfer
    reserved_t<4>        _2;
    volatile uint32_t    AF1;                  // [Read-write] TIM alternate function option register 1
    reserved_t<1>        _3;
    volatile uint32_t    TISEL;                // [Read-write] TIM timer input selection register

    static constexpr uint32_t CR1_UIFREMAP = 0x800;     // UIF status bit remapping
    template<uint32_t X>
    static constexpr uint32_t CR1_CKD =                 // Clock division (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t CR1_ARPE = 0x80;          // Auto-reload preload enable
    template<uint32_t X>
    static constexpr uint32_t CR1_CMS =                 // Center-aligned mode selection (2 bits)
        bit_field_t<5, 0x3>::value<X>();
    static constexpr uint32_t CR1_DIR = 0x10;           // Direction
    static constexpr uint32_t CR1_OPM = 0x8;            // One-pulse mode
    static constexpr uint32_t CR1_URS = 0x4;            // Update request source
    static constexpr uint32_t CR1_UDIS = 0x2;           // Update disable
    static constexpr uint32_t CR1_CEN = 0x1;            // Counter enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CR2_TI1S = 0x80;          // TI1 selection
    template<uint32_t X>
    static constexpr uint32_t CR2_MMS =                 // Master mode selection (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CR2_CCDS = 0x8;           // Capture/compare DMA selection
    static const uint32_t CR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SMCR_TS_4_3 =              // Trigger selection (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    static constexpr uint32_t SMCR_SMS_3 = 0x10000;      // Slave mode selection - bit 3
    static constexpr uint32_t SMCR_ETP = 0x8000;         // External trigger polarity
    static constexpr uint32_t SMCR_ECE = 0x4000;         // External clock enable
    template<uint32_t X>
    static constexpr uint32_t SMCR_ETPS =                // External trigger prescaler (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMCR_ETF =                 // External trigger filter (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    static constexpr uint32_t SMCR_MSM = 0x80;           // Master/Slave mode
    template<uint32_t X>
    static constexpr uint32_t SMCR_TS =                  // Trigger selection (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMCR_SMS =                 // Slave mode selection (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t SMCR_RESET_VALUE = 0x0;

    static constexpr uint32_t DIER_TDE = 0x4000;         // Trigger DMA request enable
    static constexpr uint32_t DIER_CC4DE = 0x1000;       // Capture/Compare 4 DMA request enable
    static constexpr uint32_t DIER_CC3DE = 0x800;        // Capture/Compare 3 DMA request enable
    static constexpr uint32_t DIER_CC2DE = 0x400;        // Capture/Compare 2 DMA request enable
    static constexpr uint32_t DIER_CC1DE = 0x200;        // Capture/Compare 1 DMA request enable
    static constexpr uint32_t DIER_UDE = 0x100;          // Update DMA request enable
    static constexpr uint32_t DIER_TIE = 0x40;           // Trigger interrupt enable
    static constexpr uint32_t DIER_CC4IE = 0x10;         // Capture/Compare 4 interrupt enable
    static constexpr uint32_t DIER_CC3IE = 0x8;          // Capture/Compare 3 interrupt enable
    static constexpr uint32_t DIER_CC2IE = 0x4;          // Capture/Compare 2 interrupt enable
    static constexpr uint32_t DIER_CC1IE = 0x2;          // Capture/Compare 1 interrupt enable
    static constexpr uint32_t DIER_UIE = 0x1;            // Update interrupt enable
    static const uint32_t DIER_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_CC4OF = 0x1000;       // Capture/Compare 4 overcapture flag
    static constexpr uint32_t SR_CC3OF = 0x800;        // Capture/Compare 3 overcapture flag
    static constexpr uint32_t SR_CC2OF = 0x400;        // Capture/compare 2 overcapture flag
    static constexpr uint32_t SR_CC1OF = 0x200;        // Capture/Compare 1 overcapture flag
    static constexpr uint32_t SR_TIF = 0x40;           // Trigger interrupt flag
    static constexpr uint32_t SR_CC4IF = 0x10;         // Capture/Compare 4 interrupt flag
    static constexpr uint32_t SR_CC3IF = 0x8;          // Capture/Compare 3 interrupt flag
    static constexpr uint32_t SR_CC2IF = 0x4;          // Capture/Compare 2 interrupt flag
    static constexpr uint32_t SR_CC1IF = 0x2;          // Capture/compare 1 interrupt flag
    static constexpr uint32_t SR_UIF = 0x1;            // Update interrupt flag
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint32_t EGR_TG = 0x40;            // Trigger generation
    static constexpr uint32_t EGR_CC4G = 0x10;          // Capture/compare 4 generation
    static constexpr uint32_t EGR_CC3G = 0x8;           // Capture/compare 3 generation
    static constexpr uint32_t EGR_CC2G = 0x4;           // Capture/compare 2 generation
    static constexpr uint32_t EGR_CC1G = 0x2;           // Capture/compare 1 generation
    static constexpr uint32_t EGR_UG = 0x1;             // Update generation
    static const uint32_t EGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCMR1_CC1S =                // CC1S (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_CC2S =                // CC2S (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC1F =                // Input capture 1 filter (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC2F =                // Input capture 2 filter (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC2PCS =              // Input capture 2 prescaler (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_ICPCS =               // Input capture 1 prescaler (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t CCMR1_OC1CE = 0x80;         // OC1CE
    static constexpr uint32_t CCMR1_OC1FE = 0x4;          // OC1FE
    template<uint32_t X>
    static constexpr uint32_t CCMR1_OC1M =                // OC1M (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR1_OC1M_3 = 0x10000;     // Output Compare 1 mode - bit 3
    static constexpr uint32_t CCMR1_OC1PE = 0x8;          // OC1PE
    static constexpr uint32_t CCMR1_OC2CE = 0x8000;       // OC2CE
    static constexpr uint32_t CCMR1_OC2FE = 0x400;        // OC2FE
    template<uint32_t X>
    static constexpr uint32_t CCMR1_OC2M =                // OC2M (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    static constexpr uint32_t CCMR1_OC2M_3 = 0x1000000;   // Output Compare 2 mode - bit 3
    static constexpr uint32_t CCMR1_OC2PE = 0x800;        // OC2PE
    static const uint32_t CCMR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCMR2_CC3S =                // CC3S (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_CC4S =                // CC4S (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC3F =                // Input capture 3 filter (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC3PSC =              // Input capture 3 prescaler (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC4F =                // Input capture 4 filter (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC4PSC =              // Input capture 4 prescaler (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    static constexpr uint32_t CCMR2_O24CE = 0x8000;       // O24CE
    static constexpr uint32_t CCMR2_OC3CE = 0x80;         // OC3CE
    static constexpr uint32_t CCMR2_OC3FE = 0x4;          // OC3FE
    template<uint32_t X>
    static constexpr uint32_t CCMR2_OC3M =                // OC3M (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR2_OC3M_3 = 0x10000;     // Output Compare 1 mode - bit 3
    static constexpr uint32_t CCMR2_OC3PE = 0x8;          // OC3PE
    static constexpr uint32_t CCMR2_OC4FE = 0x400;        // OC4FE
    template<uint32_t X>
    static constexpr uint32_t CCMR2_OC4M =                // OC4M (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    static constexpr uint32_t CCMR2_OC4M_3 = 0x1000000;   // Output Compare 2 mode - bit 3
    static constexpr uint32_t CCMR2_OC4PE = 0x800;        // OC4PE
    static const uint32_t CCMR2_RESET_VALUE = 0x0;

    static constexpr uint32_t CCER_CC4NP = 0x8000;       // Capture/Compare 4 output Polarity
    static constexpr uint32_t CCER_CC4P = 0x2000;        // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC4E = 0x1000;        // Capture/Compare 4 output enable
    static constexpr uint32_t CCER_CC3NP = 0x800;        // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC3P = 0x200;         // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC3E = 0x100;         // Capture/Compare 3 output enable
    static constexpr uint32_t CCER_CC2NP = 0x80;         // Capture/Compare 2 output Polarity
    static constexpr uint32_t CCER_CC2P = 0x20;          // Capture/Compare 2 output Polarity
    static constexpr uint32_t CCER_CC2E = 0x10;          // Capture/Compare 2 output enable
    static constexpr uint32_t CCER_CC1NP = 0x8;          // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1P = 0x2;           // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1E = 0x1;           // Capture/Compare 1 output enable
    static const uint32_t CCER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CNT_CNT_L =               // low counter value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CNT_CNT_H =               // High counter value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t CNT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PSC_PSC =                 // Prescaler value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t PSC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ARR_ARR_H =               // High Auto-reload value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ARR_ARR_L =               // Low Auto-reload value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t ARR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR1_CCR1_H =              // High Capture/Compare 1 value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR1_CCR1_L =              // Low Capture/Compare 1 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR2_CCR2_H =              // High Capture/Compare 2 value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR2_CCR2_L =              // Low Capture/Compare 2 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR3_CCR3_H =              // High Capture/Compare value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR3_CCR3_L =              // Low Capture/Compare value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR4_CCR4_H =              // High Capture/Compare value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR4_CCR4_L =              // Low Capture/Compare value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DCR_DBL =                 // DMA burst length (5 bits)
        bit_field_t<8, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DCR_DBA =                 // DMA base address (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t DCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DMAR_DMAB =                // DMA register for burst accesses (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DMAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AF1_ETRSEL =              // ETR source selection (4 bits)
        bit_field_t<14, 0xf>::value<X>();
    static const uint32_t AF1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TISEL_TI1SEL =              // TI1[0] to TI1[15] input selection (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TISEL_TI2SEL =              // TI2[0] to TI2[15] input selection (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TISEL_TI3SEL =              // TI3[0] to TI3[15] input selection (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TISEL_TI4SEL =              // TI4[0] to TI4[15] input selection (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    static const uint32_t TISEL_RESET_VALUE = 0x0;

    static constexpr uint8_t TIM8_TRG_COM_TIM14 = 45; // TIM8 and 14 trigger /commutation and global
};

static tim14_t& TIM14 = *reinterpret_cast<tim14_t*>(0x40002000);

#define HAVE_PERIPHERAL_TIM14


////
//
//    Basic timers
//
////

struct tim6_t
{
    volatile uint32_t    CR1;                  // [Read-write] control register 1
    volatile uint32_t    CR2;                  // [Read-write] control register 2
    reserved_t<1>        _0;
    volatile uint32_t    DIER;                 // [Read-write] DMA/Interrupt enable register
    volatile uint32_t    SR;                   // [Read-write] status register
    volatile uint32_t    EGR;                  // [Write-only] event generation register
    reserved_t<3>        _1;
    volatile uint32_t    CNT;                  // [Read-write] counter
    volatile uint32_t    PSC;                  // [Read-write] prescaler
    volatile uint32_t    ARR;                  // [Read-write] auto-reload register

    static constexpr uint32_t CR1_UIFREMAP = 0x800;     // UIF status bit remapping
    static constexpr uint32_t CR1_ARPE = 0x80;          // Auto-reload preload enable
    static constexpr uint32_t CR1_OPM = 0x8;            // One-pulse mode
    static constexpr uint32_t CR1_URS = 0x4;            // Update request source
    static constexpr uint32_t CR1_UDIS = 0x2;           // Update disable
    static constexpr uint32_t CR1_CEN = 0x1;            // Counter enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CR2_MMS =                 // Master mode selection (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static const uint32_t CR2_RESET_VALUE = 0x0;

    static constexpr uint32_t DIER_UDE = 0x100;          // Update DMA request enable
    static constexpr uint32_t DIER_UIE = 0x1;            // Update interrupt enable
    static const uint32_t DIER_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_UIF = 0x1;            // Update interrupt flag
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint32_t EGR_UG = 0x1;             // Update generation
    static const uint32_t EGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CNT_CNT =                 // Low counter value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static constexpr uint32_t CNT_UIFCPY = 0x80000000;  // UIF Copy
    static const uint32_t CNT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PSC_PSC =                 // Prescaler value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t PSC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ARR_ARR =                 // Low Auto-reload value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t ARR_RESET_VALUE = 0x0;

    static constexpr uint8_t TIM6_DAC = 54; // TIM6 global interrupt
};

static tim6_t& TIM6 = *reinterpret_cast<tim6_t*>(0x40001000);

#define HAVE_PERIPHERAL_TIM6


////
//
//    Basic timers
//
////

struct tim7_t
{
    volatile uint32_t    CR1;                  // [Read-write] control register 1
    volatile uint32_t    CR2;                  // [Read-write] control register 2
    reserved_t<1>        _0;
    volatile uint32_t    DIER;                 // [Read-write] DMA/Interrupt enable register
    volatile uint32_t    SR;                   // [Read-write] status register
    volatile uint32_t    EGR;                  // [Write-only] event generation register
    reserved_t<3>        _1;
    volatile uint32_t    CNT;                  // [Read-write] counter
    volatile uint32_t    PSC;                  // [Read-write] prescaler
    volatile uint32_t    ARR;                  // [Read-write] auto-reload register

    static constexpr uint32_t CR1_UIFREMAP = 0x800;     // UIF status bit remapping
    static constexpr uint32_t CR1_ARPE = 0x80;          // Auto-reload preload enable
    static constexpr uint32_t CR1_OPM = 0x8;            // One-pulse mode
    static constexpr uint32_t CR1_URS = 0x4;            // Update request source
    static constexpr uint32_t CR1_UDIS = 0x2;           // Update disable
    static constexpr uint32_t CR1_CEN = 0x1;            // Counter enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CR2_MMS =                 // Master mode selection (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static const uint32_t CR2_RESET_VALUE = 0x0;

    static constexpr uint32_t DIER_UDE = 0x100;          // Update DMA request enable
    static constexpr uint32_t DIER_UIE = 0x1;            // Update interrupt enable
    static const uint32_t DIER_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_UIF = 0x1;            // Update interrupt flag
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint32_t EGR_UG = 0x1;             // Update generation
    static const uint32_t EGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CNT_CNT =                 // Low counter value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static constexpr uint32_t CNT_UIFCPY = 0x80000000;  // UIF Copy
    static const uint32_t CNT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PSC_PSC =                 // Prescaler value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t PSC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ARR_ARR =                 // Low Auto-reload value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t ARR_RESET_VALUE = 0x0;

    static constexpr uint8_t TIM7 = 55; // TIM7 global interrupt
};

static tim7_t& TIM7 = *reinterpret_cast<tim7_t*>(0x40001400);

#define HAVE_PERIPHERAL_TIM7


////
//
//    Nested Vectored Interrupt Controller
//
////

struct nvic_t
{
    volatile uint32_t    ISER0;                // [Read-write] Interrupt Set-Enable Register
    volatile uint32_t    ISER1;                // [Read-write] Interrupt Set-Enable Register
    volatile uint32_t    ISER2;                // [Read-write] Interrupt Set-Enable Register
    volatile uint32_t    ISER3;                // [Read-write] Interrupt Set-Enable Register
    volatile uint32_t    ISER4;                // [Read-write] Interrupt Set-Enable Register
    reserved_t<27>       _0;
    volatile uint32_t    ICER0;                // [Read-write] Interrupt Clear-Enable Register
    volatile uint32_t    ICER1;                // [Read-write] Interrupt Clear-Enable Register
    volatile uint32_t    ICER2;                // [Read-write] Interrupt Clear-Enable Register
    volatile uint32_t    ICER3;                // [Read-write] Interrupt Clear-Enable Register
    volatile uint32_t    ICER4;                // [Read-write] Interrupt Clear-Enable Register
    reserved_t<27>       _1;
    volatile uint32_t    ISPR0;                // [Read-write] Interrupt Set-Pending Register
    volatile uint32_t    ISPR1;                // [Read-write] Interrupt Set-Pending Register
    volatile uint32_t    ISPR2;                // [Read-write] Interrupt Set-Pending Register
    volatile uint32_t    ISPR3;                // [Read-write] Interrupt Set-Pending Register
    volatile uint32_t    ISPR4;                // [Read-write] Interrupt Set-Pending Register
    reserved_t<27>       _2;
    volatile uint32_t    ICPR0;                // [Read-write] Interrupt Clear-Pending Register
    volatile uint32_t    ICPR1;                // [Read-write] Interrupt Clear-Pending Register
    volatile uint32_t    ICPR2;                // [Read-write] Interrupt Clear-Pending Register
    reserved_t<13>       _3;
    volatile uint32_t    ICPR3;                // [Read-write] Interrupt Clear-Pending Register
    volatile uint32_t    ICPR4;                // [Read-write] Interrupt Clear-Pending Register
    reserved_t<14>       _4;
    volatile uint32_t    IABR0;                // [Read-only] Interrupt Active Bit Register
    volatile uint32_t    IABR1;                // [Read-only] Interrupt Active Bit Register
    volatile uint32_t    IABR2;                // [Read-only] Interrupt Active Bit Register
    volatile uint32_t    IABR3;                // [Read-write] Interrupt Active Bit Register
    volatile uint32_t    IABR4;                // [Read-write] Interrupt Active Bit Register
    reserved_t<59>       _5;
    volatile uint32_t    IPR0;                 // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR1;                 // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR2;                 // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR3;                 // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR4;                 // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR5;                 // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR6;                 // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR7;                 // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR8;                 // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR9;                 // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR10;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR11;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR12;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR13;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR14;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR15;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR16;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR17;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR18;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR19;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR20;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR21;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR22;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR23;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR24;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR25;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR26;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR27;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR28;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR29;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR30;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR31;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR32;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR33;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR34;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR35;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR36;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR37;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR38;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR39;                // [Read-write] Interrupt Priority Register


    static const uint32_t ISER0_RESET_VALUE = 0x0;


    static const uint32_t ISER1_RESET_VALUE = 0x0;


    static const uint32_t ISER2_RESET_VALUE = 0x0;

    static const uint32_t ISER3_RESET_VALUE = 0x0;

    static const uint32_t ISER4_RESET_VALUE = 0x0;


    static const uint32_t ICER0_RESET_VALUE = 0x0;


    static const uint32_t ICER1_RESET_VALUE = 0x0;


    static const uint32_t ICER2_RESET_VALUE = 0x0;

    static const uint32_t ICER3_RESET_VALUE = 0x0;

    static const uint32_t ICER4_RESET_VALUE = 0x0;


    static const uint32_t ISPR0_RESET_VALUE = 0x0;


    static const uint32_t ISPR1_RESET_VALUE = 0x0;


    static const uint32_t ISPR2_RESET_VALUE = 0x0;

    static const uint32_t ISPR3_RESET_VALUE = 0x0;

    static const uint32_t ISPR4_RESET_VALUE = 0x0;


    static const uint32_t ICPR0_RESET_VALUE = 0x0;


    static const uint32_t ICPR1_RESET_VALUE = 0x0;


    static const uint32_t ICPR2_RESET_VALUE = 0x0;

    static const uint32_t ICPR3_RESET_VALUE = 0x0;

    static const uint32_t ICPR4_RESET_VALUE = 0x0;


    static const uint32_t IABR0_RESET_VALUE = 0x0;


    static const uint32_t IABR1_RESET_VALUE = 0x0;


    static const uint32_t IABR2_RESET_VALUE = 0x0;

    static const uint32_t IABR3_RESET_VALUE = 0x0;

    static const uint32_t IABR4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR0_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR0_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR0_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR0_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR0_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR1_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR1_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR1_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR1_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR2_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR2_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR2_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR2_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR3_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR3_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR3_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR3_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR4_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR4_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR4_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR4_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR5_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR5_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR5_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR5_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR6_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR6_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR6_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR6_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR6_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR7_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR7_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR7_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR7_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR7_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR8_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR8_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR8_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR8_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR8_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR9_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR9_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR9_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR9_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR9_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR10_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR10_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR10_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR10_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR10_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR11_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR11_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR11_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR11_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR11_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR12_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR12_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR12_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR12_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR12_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR13_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR13_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR13_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR13_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR13_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR14_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR14_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR14_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR14_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR14_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR15_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR15_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR15_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR15_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR15_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR16_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR16_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR16_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR16_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR16_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR17_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR17_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR17_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR17_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR17_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR18_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR18_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR18_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR18_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR18_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR19_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR19_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR19_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR19_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR19_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR20_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR20_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR20_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR20_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR20_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR21_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR21_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR21_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR21_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR21_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR22_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR22_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR22_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR22_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR22_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR23_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR23_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR23_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR23_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR23_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR24_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR24_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR24_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR24_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR24_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR25_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR25_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR25_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR25_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR25_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR26_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR26_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR26_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR26_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR26_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR27_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR27_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR27_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR27_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR27_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR28_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR28_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR28_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR28_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR28_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR29_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR29_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR29_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR29_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR29_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR30_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR30_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR30_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR30_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR30_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR31_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR31_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR31_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR31_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR31_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR32_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR32_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR32_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR32_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR32_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR33_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR33_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR33_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR33_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR33_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR34_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR34_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR34_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR34_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR34_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR35_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR35_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR35_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR35_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR35_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR36_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR36_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR36_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR36_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR36_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR37_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR37_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR37_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR37_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR37_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR38_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR38_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR38_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR38_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR38_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR39_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR39_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR39_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR39_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR39_RESET_VALUE = 0x0;
};

static nvic_t& NVIC = *reinterpret_cast<nvic_t*>(0xe000e100);

#define HAVE_PERIPHERAL_NVIC


////
//
//    Memory protection unit
//
////

struct mpu_t
{
    volatile uint32_t    TYPER;                // [Read-only] MPU type register
    volatile uint32_t    CTRL;                 // [Read-only] MPU control register
    volatile uint32_t    RNR;                  // [Read-write] MPU region number register
    volatile uint32_t    RBAR;                 // [Read-write] MPU region base address register
    volatile uint32_t    RASR;                 // [Read-write] MPU region attribute and size register

    static constexpr uint32_t TYPER_SEPARATE = 0x1;       // Separate flag
    template<uint32_t X>
    static constexpr uint32_t TYPER_DREGION =             // Number of MPU data regions (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TYPER_IREGION =             // Number of MPU instruction regions (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static const uint32_t TYPER_RESET_VALUE = 0x800;

    static constexpr uint32_t CTRL_ENABLE = 0x1;         // Enables the MPU
    static constexpr uint32_t CTRL_HFNMIENA = 0x2;       // Enables the operation of MPU during hard fault
    static constexpr uint32_t CTRL_PRIVDEFENA = 0x4;     // Enable priviliged software access to default memory map
    static const uint32_t CTRL_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RNR_REGION =              // MPU region (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t RNR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RBAR_REGION =              // MPU region field (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static constexpr uint32_t RBAR_VALID = 0x10;         // MPU region number valid
    template<uint32_t X>
    static constexpr uint32_t RBAR_ADDR =                // Region base address field (27 bits)
        bit_field_t<5, 0x7ffffff>::value<X>();
    static const uint32_t RBAR_RESET_VALUE = 0x0;

    static constexpr uint32_t RASR_ENABLE = 0x1;         // Region enable bit.
    template<uint32_t X>
    static constexpr uint32_t RASR_SIZE =                // Size of the MPU protection region (5 bits)
        bit_field_t<1, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RASR_SRD =                 // Subregion disable bits (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t RASR_B = 0x10000;          // memory attribute
    static constexpr uint32_t RASR_C = 0x20000;          // memory attribute
    static constexpr uint32_t RASR_S = 0x40000;          // Shareable memory attribute
    template<uint32_t X>
    static constexpr uint32_t RASR_TEX =                 // memory attribute (3 bits)
        bit_field_t<19, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RASR_AP =                  // Access permission (3 bits)
        bit_field_t<24, 0x7>::value<X>();
    static constexpr uint32_t RASR_XN = 0x10000000;      // Instruction access disable bit
    static const uint32_t RASR_RESET_VALUE = 0x0;
};

static mpu_t& MPU = *reinterpret_cast<mpu_t*>(0xe000ed90);

#define HAVE_PERIPHERAL_MPU


////
//
//    SysTick timer
//
////

struct stk_t
{
    volatile uint32_t    CSR;                  // [Read-write] SysTick control and status register
    volatile uint32_t    RVR;                  // [Read-write] SysTick reload value register
    volatile uint32_t    CVR;                  // [Read-write] SysTick current value register
    volatile uint32_t    CALIB;                // [Read-write] SysTick calibration value register

    static constexpr uint32_t CSR_ENABLE = 0x1;         // Counter enable
    static constexpr uint32_t CSR_TICKINT = 0x2;        // SysTick exception request enable
    static constexpr uint32_t CSR_CLKSOURCE = 0x4;      // Clock source selection
    static constexpr uint32_t CSR_COUNTFLAG = 0x10000;  // COUNTFLAG
    static const uint32_t CSR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RVR_RELOAD =              // RELOAD value (24 bits)
        bit_field_t<0, 0xffffff>::value<X>();
    static const uint32_t RVR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CVR_CURRENT =             // Current counter value (24 bits)
        bit_field_t<0, 0xffffff>::value<X>();
    static const uint32_t CVR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CALIB_TENMS =               // Calibration value (24 bits)
        bit_field_t<0, 0xffffff>::value<X>();
    static constexpr uint32_t CALIB_SKEW = 0x40000000;    // SKEW flag: Indicates whether the TENMS value is exact
    static constexpr uint32_t CALIB_NOREF = 0x80000000;   // NOREF flag. Reads as zero
    static const uint32_t CALIB_RESET_VALUE = 0x0;
};

static stk_t& STK = *reinterpret_cast<stk_t*>(0xe000e010);

#define HAVE_PERIPHERAL_STK


////
//
//    Nested vectored interrupt controller
//
////

struct nvic_stir_t
{
    volatile uint32_t    STIR;                 // [Read-write] Software trigger interrupt register

    template<uint32_t X>
    static constexpr uint32_t STIR_INTID =               // Software generated interrupt ID (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static const uint32_t STIR_RESET_VALUE = 0x0;
};

static nvic_stir_t& NVIC_STIR = *reinterpret_cast<nvic_stir_t*>(0xe000ef00);

#define HAVE_PERIPHERAL_NVIC_STIR


////
//
//    Floating point unit CPACR
//
////

struct fpu_cpacr_t
{
    volatile uint32_t    CPACR;                // [Read-write] Coprocessor access control register

    template<uint32_t X>
    static constexpr uint32_t CPACR_CP =                  // CP (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    static const uint32_t CPACR_RESET_VALUE = 0x0;
};

static fpu_cpacr_t& FPU_CPACR = *reinterpret_cast<fpu_cpacr_t*>(0xe000ed88);

#define HAVE_PERIPHERAL_FPU_CPACR


////
//
//    System control block ACTLR
//
////

struct scb_actrl_t
{
    volatile uint32_t    ACTRL;                // [Read-write] Auxiliary control register

    static constexpr uint32_t ACTRL_DISFOLD = 0x4;        // DISFOLD
    static constexpr uint32_t ACTRL_FPEXCODIS = 0x400;    // FPEXCODIS
    static constexpr uint32_t ACTRL_DISRAMODE = 0x800;    // DISRAMODE
    static constexpr uint32_t ACTRL_DISITMATBFLUSH = 0x1000;// DISITMATBFLUSH
    static const uint32_t ACTRL_RESET_VALUE = 0x0;
};

static scb_actrl_t& SCB_ACTRL = *reinterpret_cast<scb_actrl_t*>(0xe000e008);

#define HAVE_PERIPHERAL_SCB_ACTRL


////
//
//    Floting point unit
//
////

struct fpu_t
{
    volatile uint32_t    FPCCR;                // [Read-write] Floating-point context control register
    volatile uint32_t    FPCAR;                // [Read-write] Floating-point context address register
    volatile uint32_t    FPSCR;                // [Read-write] Floating-point status control register

    static constexpr uint32_t FPCCR_LSPACT = 0x1;         // LSPACT
    static constexpr uint32_t FPCCR_USER = 0x2;           // USER
    static constexpr uint32_t FPCCR_THREAD = 0x8;         // THREAD
    static constexpr uint32_t FPCCR_HFRDY = 0x10;         // HFRDY
    static constexpr uint32_t FPCCR_MMRDY = 0x20;         // MMRDY
    static constexpr uint32_t FPCCR_BFRDY = 0x40;         // BFRDY
    static constexpr uint32_t FPCCR_MONRDY = 0x100;       // MONRDY
    static constexpr uint32_t FPCCR_LSPEN = 0x40000000;   // LSPEN
    static constexpr uint32_t FPCCR_ASPEN = 0x80000000;   // ASPEN
    static const uint32_t FPCCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t FPCAR_ADDRESS =             // Location of unpopulated floating-point (29 bits)
        bit_field_t<3, 0x1fffffff>::value<X>();
    static const uint32_t FPCAR_RESET_VALUE = 0x0;

    static constexpr uint32_t FPSCR_IOC = 0x1;            // Invalid operation cumulative exception bit
    static constexpr uint32_t FPSCR_DZC = 0x2;            // Division by zero cumulative exception bit.
    static constexpr uint32_t FPSCR_OFC = 0x4;            // Overflow cumulative exception bit
    static constexpr uint32_t FPSCR_UFC = 0x8;            // Underflow cumulative exception bit
    static constexpr uint32_t FPSCR_IXC = 0x10;           // Inexact cumulative exception bit
    static constexpr uint32_t FPSCR_IDC = 0x80;           // Input denormal cumulative exception bit.
    template<uint32_t X>
    static constexpr uint32_t FPSCR_RMode =               // Rounding Mode control field (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    static constexpr uint32_t FPSCR_FZ = 0x1000000;       // Flush-to-zero mode control bit:
    static constexpr uint32_t FPSCR_DN = 0x2000000;       // Default NaN mode control bit
    static constexpr uint32_t FPSCR_AHP = 0x4000000;      // Alternative half-precision control bit
    static constexpr uint32_t FPSCR_V = 0x10000000;       // Overflow condition code flag
    static constexpr uint32_t FPSCR_C = 0x20000000;       // Carry condition code flag
    static constexpr uint32_t FPSCR_Z = 0x40000000;       // Zero condition code flag
    static constexpr uint32_t FPSCR_N = 0x80000000;       // Negative condition code flag
    static const uint32_t FPSCR_RESET_VALUE = 0x0;

    static constexpr uint8_t FPU = 81; // Floating point unit interrupt
};

static fpu_t& FPU = *reinterpret_cast<fpu_t*>(0xe000ef34);

#define HAVE_PERIPHERAL_FPU


////
//
//    System control block
//
////

struct scb_t
{
    volatile uint32_t    CPUID;                // [Read-only] CPUID base register
    volatile uint32_t    ICSR;                 // [Read-write] Interrupt control and state register
    volatile uint32_t    VTOR;                 // [Read-write] Vector table offset register
    volatile uint32_t    AIRCR;                // [Read-write] Application interrupt and reset control register
    volatile uint32_t    SCR;                  // [Read-write] System control register
    volatile uint32_t    CCR;                  // [Read-write] Configuration and control register
    volatile uint32_t    SHPR1;                // [Read-write] System handler priority registers
    volatile uint32_t    SHPR2;                // [Read-write] System handler priority registers
    volatile uint32_t    SHPR3;                // [Read-write] System handler priority registers
    volatile uint32_t    SHCRS;                // [Read-write] System handler control and state register
    volatile uint32_t    CFSR_UFSR_BFSR_MMFSR; // [Read-write] Configurable fault status register
    volatile uint32_t    HFSR;                 // [Read-write] Hard fault status register
    reserved_t<1>        _0;
    volatile uint32_t    MMFAR;                // [Read-write] Memory management fault address register
    volatile uint32_t    BFAR;                 // [Read-write] Bus fault address register

    template<uint32_t X>
    static constexpr uint32_t CPUID_Revision =            // Revision number (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CPUID_PartNo =              // Part number of the processor (12 bits)
        bit_field_t<4, 0xfff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CPUID_Constant =            // Reads as 0xF (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CPUID_Variant =             // Variant number (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CPUID_Implementer =         // Implementer code (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t CPUID_RESET_VALUE = 0x410fc241;

    template<uint32_t X>
    static constexpr uint32_t ICSR_VECTACTIVE =          // Active vector (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static constexpr uint32_t ICSR_RETTOBASE = 0x800;    // Return to base level
    template<uint32_t X>
    static constexpr uint32_t ICSR_VECTPENDING =         // Pending vector (7 bits)
        bit_field_t<12, 0x7f>::value<X>();
    static constexpr uint32_t ICSR_ISRPENDING = 0x400000;// Interrupt pending flag
    static constexpr uint32_t ICSR_PENDSTCLR = 0x2000000;// SysTick exception clear-pending bit
    static constexpr uint32_t ICSR_PENDSTSET = 0x4000000;// SysTick exception set-pending bit
    static constexpr uint32_t ICSR_PENDSVCLR = 0x8000000;// PendSV clear-pending bit
    static constexpr uint32_t ICSR_PENDSVSET = 0x10000000;// PendSV set-pending bit
    static constexpr uint32_t ICSR_NMIPENDSET = 0x80000000;// NMI set-pending bit.
    static const uint32_t ICSR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t VTOR_TBLOFF =              // Vector table base offset field (21 bits)
        bit_field_t<9, 0x1fffff>::value<X>();
    static const uint32_t VTOR_RESET_VALUE = 0x0;

    static constexpr uint32_t AIRCR_VECTRESET = 0x1;      // VECTRESET
    static constexpr uint32_t AIRCR_VECTCLRACTIVE = 0x2;  // VECTCLRACTIVE
    static constexpr uint32_t AIRCR_SYSRESETREQ = 0x4;    // SYSRESETREQ
    template<uint32_t X>
    static constexpr uint32_t AIRCR_PRIGROUP =            // PRIGROUP (3 bits)
        bit_field_t<8, 0x7>::value<X>();
    static constexpr uint32_t AIRCR_ENDIANESS = 0x8000;   // ENDIANESS
    template<uint32_t X>
    static constexpr uint32_t AIRCR_VECTKEYSTAT =         // Register key (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t AIRCR_RESET_VALUE = 0x0;

    static constexpr uint32_t SCR_SLEEPONEXIT = 0x2;    // SLEEPONEXIT
    static constexpr uint32_t SCR_SLEEPDEEP = 0x4;      // SLEEPDEEP
    static constexpr uint32_t SCR_SEVEONPEND = 0x10;    // Send Event on Pending bit
    static const uint32_t SCR_RESET_VALUE = 0x0;

    static constexpr uint32_t CCR_NONBASETHRDENA = 0x1; // Configures how the processor enters Thread mode
    static constexpr uint32_t CCR_USERSETMPEND = 0x2;   // USERSETMPEND
    static constexpr uint32_t CCR_UNALIGN__TRP = 0x8;   // UNALIGN_ TRP
    static constexpr uint32_t CCR_DIV_0_TRP = 0x10;     // DIV_0_TRP
    static constexpr uint32_t CCR_BFHFNMIGN = 0x100;    // BFHFNMIGN
    static constexpr uint32_t CCR_STKALIGN = 0x200;     // STKALIGN
    static constexpr uint32_t CCR_DC = 0x10000;         // DC
    static constexpr uint32_t CCR_IC = 0x20000;         // IC
    static constexpr uint32_t CCR_BP = 0x40000;         // BP
    static const uint32_t CCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SHPR1_PRI_4 =               // Priority of system handler 4 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SHPR1_PRI_5 =               // Priority of system handler 5 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SHPR1_PRI_6 =               // Priority of system handler 6 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static const uint32_t SHPR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SHPR2_PRI_11 =              // Priority of system handler 11 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t SHPR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SHPR3_PRI_14 =              // Priority of system handler 14 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SHPR3_PRI_15 =              // Priority of system handler 15 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t SHPR3_RESET_VALUE = 0x0;

    static constexpr uint32_t SHCRS_MEMFAULTACT = 0x1;    // Memory management fault exception active bit
    static constexpr uint32_t SHCRS_BUSFAULTACT = 0x2;    // Bus fault exception active bit
    static constexpr uint32_t SHCRS_USGFAULTACT = 0x8;    // Usage fault exception active bit
    static constexpr uint32_t SHCRS_SVCALLACT = 0x80;     // SVC call active bit
    static constexpr uint32_t SHCRS_MONITORACT = 0x100;   // Debug monitor active bit
    static constexpr uint32_t SHCRS_PENDSVACT = 0x400;    // PendSV exception active bit
    static constexpr uint32_t SHCRS_SYSTICKACT = 0x800;   // SysTick exception active bit
    static constexpr uint32_t SHCRS_USGFAULTPENDED = 0x1000;// Usage fault exception pending bit
    static constexpr uint32_t SHCRS_MEMFAULTPENDED = 0x2000;// Memory management fault exception pending bit
    static constexpr uint32_t SHCRS_BUSFAULTPENDED = 0x4000;// Bus fault exception pending bit
    static constexpr uint32_t SHCRS_SVCALLPENDED = 0x8000;// SVC call pending bit
    static constexpr uint32_t SHCRS_MEMFAULTENA = 0x10000;// Memory management fault enable bit
    static constexpr uint32_t SHCRS_BUSFAULTENA = 0x20000;// Bus fault enable bit
    static constexpr uint32_t SHCRS_USGFAULTENA = 0x40000;// Usage fault enable bit
    static const uint32_t SHCRS_RESET_VALUE = 0x0;

    static constexpr uint32_t CFSR_UFSR_BFSR_MMFSR_IACCVIOL = 0x1;       // IACCVIOL
    static constexpr uint32_t CFSR_UFSR_BFSR_MMFSR_DACCVIOL = 0x2;       // DACCVIOL
    static constexpr uint32_t CFSR_UFSR_BFSR_MMFSR_MUNSTKERR = 0x8;      // MUNSTKERR
    static constexpr uint32_t CFSR_UFSR_BFSR_MMFSR_MSTKERR = 0x10;       // MSTKERR
    static constexpr uint32_t CFSR_UFSR_BFSR_MMFSR_MLSPERR = 0x20;       // MLSPERR
    static constexpr uint32_t CFSR_UFSR_BFSR_MMFSR_MMARVALID = 0x80;     // MMARVALID
    static constexpr uint32_t CFSR_UFSR_BFSR_MMFSR_IBUSERR = 0x100;      // Instruction bus error
    static constexpr uint32_t CFSR_UFSR_BFSR_MMFSR_PRECISERR = 0x200;    // Precise data bus error
    static constexpr uint32_t CFSR_UFSR_BFSR_MMFSR_IMPRECISERR = 0x400;  // Imprecise data bus error
    static constexpr uint32_t CFSR_UFSR_BFSR_MMFSR_UNSTKERR = 0x800;     // Bus fault on unstacking for a return from exception
    static constexpr uint32_t CFSR_UFSR_BFSR_MMFSR_STKERR = 0x1000;      // Bus fault on stacking for exception entry
    static constexpr uint32_t CFSR_UFSR_BFSR_MMFSR_LSPERR = 0x2000;      // Bus fault on floating-point lazy state preservation
    static constexpr uint32_t CFSR_UFSR_BFSR_MMFSR_BFARVALID = 0x8000;   // Bus Fault Address Register (BFAR) valid flag
    static constexpr uint32_t CFSR_UFSR_BFSR_MMFSR_UNDEFINSTR = 0x10000; // Undefined instruction usage fault
    static constexpr uint32_t CFSR_UFSR_BFSR_MMFSR_INVSTATE = 0x20000;   // Invalid state usage fault
    static constexpr uint32_t CFSR_UFSR_BFSR_MMFSR_INVPC = 0x40000;      // Invalid PC load usage fault
    static constexpr uint32_t CFSR_UFSR_BFSR_MMFSR_NOCP = 0x80000;       // No coprocessor usage fault.
    static constexpr uint32_t CFSR_UFSR_BFSR_MMFSR_UNALIGNED = 0x1000000;// Unaligned access usage fault
    static constexpr uint32_t CFSR_UFSR_BFSR_MMFSR_DIVBYZERO = 0x2000000;// Divide by zero usage fault
    static const uint32_t CFSR_UFSR_BFSR_MMFSR_RESET_VALUE = 0x0;

    static constexpr uint32_t HFSR_VECTTBL = 0x2;        // Vector table hard fault
    static constexpr uint32_t HFSR_FORCED = 0x40000000;  // Forced hard fault
    static constexpr uint32_t HFSR_DEBUG_VT = 0x80000000;// Reserved for Debug use
    static const uint32_t HFSR_RESET_VALUE = 0x0;


    static const uint32_t MMFAR_RESET_VALUE = 0x0;


    static const uint32_t BFAR_RESET_VALUE = 0x0;
};

static scb_t& SCB = *reinterpret_cast<scb_t*>(0xe000ed00);

#define HAVE_PERIPHERAL_SCB


////
//
//    Processor features
//
////

struct pf_t
{
    volatile uint32_t    CLIDR;                // [Read-only] Cache Level ID register
    volatile uint32_t    CTR;                  // [Read-only] Cache Type register
    volatile uint32_t    CCSIDR;               // [Read-only] Cache Size ID register

    template<uint32_t X>
    static constexpr uint32_t CLIDR_CL1 =                 // CL1 (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CLIDR_CL2 =                 // CL2 (3 bits)
        bit_field_t<3, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CLIDR_CL3 =                 // CL3 (3 bits)
        bit_field_t<6, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CLIDR_CL4 =                 // CL4 (3 bits)
        bit_field_t<9, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CLIDR_CL5 =                 // CL5 (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CLIDR_CL6 =                 // CL6 (3 bits)
        bit_field_t<15, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CLIDR_CL7 =                 // CL7 (3 bits)
        bit_field_t<18, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CLIDR_LoUIS =               // LoUIS (3 bits)
        bit_field_t<21, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CLIDR_LoC =                 // LoC (3 bits)
        bit_field_t<24, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CLIDR_LoU =                 // LoU (3 bits)
        bit_field_t<27, 0x7>::value<X>();
    static const uint32_t CLIDR_RESET_VALUE = 0x9000003;

    template<uint32_t X>
    static constexpr uint32_t CTR__IminLine =           // IminLine (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CTR_DMinLine =            // DMinLine (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CTR_ERG =                 // ERG (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CTR_CWG =                 // CWG (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CTR_Format =              // Format (3 bits)
        bit_field_t<29, 0x7>::value<X>();
    static const uint32_t CTR_RESET_VALUE = 0x8303c003;

    template<uint32_t X>
    static constexpr uint32_t CCSIDR_LineSize =            // LineSize (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCSIDR_Associativity =       // Associativity (10 bits)
        bit_field_t<3, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCSIDR_NumSets =             // NumSets (15 bits)
        bit_field_t<13, 0x7fff>::value<X>();
    static constexpr uint32_t CCSIDR_WA = 0x10000000;      // WA
    static constexpr uint32_t CCSIDR_RA = 0x20000000;      // RA
    static constexpr uint32_t CCSIDR_WB = 0x40000000;      // WB
    static constexpr uint32_t CCSIDR_WT = 0x80000000;      // WT
    static const uint32_t CCSIDR_RESET_VALUE = 0x0;
};

static pf_t& PF = *reinterpret_cast<pf_t*>(0xe000ed78);

#define HAVE_PERIPHERAL_PF


////
//
//    Access control
//
////

struct ac_t
{
    volatile uint32_t    ITCMCR;               // [Read-write] Instruction and Data Tightly-Coupled Memory Control Registers
    volatile uint32_t    DTCMCR;               // [Read-write] Instruction and Data Tightly-Coupled Memory Control Registers
    volatile uint32_t    AHBPCR;               // [Read-write] AHBP Control register
    volatile uint32_t    CACR;                 // [Read-write] Auxiliary Cache Control register
    volatile uint32_t    AHBSCR;               // [Read-write] AHB Slave Control register
    reserved_t<1>        _0;
    volatile uint32_t    ABFSR;                // [Read-write] Auxiliary Bus Fault Status register

    static constexpr uint32_t ITCMCR_EN = 0x1;             // EN
    static constexpr uint32_t ITCMCR_RMW = 0x2;            // RMW
    static constexpr uint32_t ITCMCR_RETEN = 0x4;          // RETEN
    template<uint32_t X>
    static constexpr uint32_t ITCMCR_SZ =                  // SZ (4 bits)
        bit_field_t<3, 0xf>::value<X>();
    static const uint32_t ITCMCR_RESET_VALUE = 0x0;

    static constexpr uint32_t DTCMCR_EN = 0x1;             // EN
    static constexpr uint32_t DTCMCR_RMW = 0x2;            // RMW
    static constexpr uint32_t DTCMCR_RETEN = 0x4;          // RETEN
    template<uint32_t X>
    static constexpr uint32_t DTCMCR_SZ =                  // SZ (4 bits)
        bit_field_t<3, 0xf>::value<X>();
    static const uint32_t DTCMCR_RESET_VALUE = 0x0;

    static constexpr uint32_t AHBPCR_EN = 0x1;             // EN
    template<uint32_t X>
    static constexpr uint32_t AHBPCR_SZ =                  // SZ (3 bits)
        bit_field_t<1, 0x7>::value<X>();
    static const uint32_t AHBPCR_RESET_VALUE = 0x0;

    static constexpr uint32_t CACR_SIWT = 0x1;           // SIWT
    static constexpr uint32_t CACR_ECCEN = 0x2;          // ECCEN
    static constexpr uint32_t CACR_FORCEWT = 0x4;        // FORCEWT
    static const uint32_t CACR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AHBSCR_CTL =                 // CTL (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AHBSCR_TPRI =                // TPRI (9 bits)
        bit_field_t<2, 0x1ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AHBSCR_INITCOUNT =           // INITCOUNT (5 bits)
        bit_field_t<11, 0x1f>::value<X>();
    static const uint32_t AHBSCR_RESET_VALUE = 0x0;

    static constexpr uint32_t ABFSR_ITCM = 0x1;           // ITCM
    static constexpr uint32_t ABFSR_DTCM = 0x2;           // DTCM
    static constexpr uint32_t ABFSR_AHBP = 0x4;           // AHBP
    static constexpr uint32_t ABFSR_AXIM = 0x8;           // AXIM
    static constexpr uint32_t ABFSR_EPPB = 0x10;          // EPPB
    template<uint32_t X>
    static constexpr uint32_t ABFSR_AXIMTYPE =            // AXIMTYPE (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static const uint32_t ABFSR_RESET_VALUE = 0x0;
};

static ac_t& AC = *reinterpret_cast<ac_t*>(0xe000ef90);

#define HAVE_PERIPHERAL_AC


template<typename PERIPHERAL> struct peripheral_traits {};

template<> struct peripheral_traits<crs_t>
{
    static void enable() { RCC.APB1HENR |= rcc_t::APB1HENR_CRSEN; }
    static void disable() { RCC.APB1HENR &= ~rcc_t::APB1HENR_CRSEN; }
    static void reset() { RCC.APB1HRSTR |= rcc_t::APB1HRSTR_CRSRST; }
};

template<> struct peripheral_traits<bdma_t>
{
    static void enable() { RCC.AHB4ENR |= rcc_t::AHB4ENR_BDMAEN; }
    static void disable() { RCC.AHB4ENR &= ~rcc_t::AHB4ENR_BDMAEN; }
    static void reset() { RCC.AHB4RSTR |= rcc_t::AHB4RSTR_BDMARST; }
};

template<> struct peripheral_traits<dma2d_t>
{
    static void enable() { RCC.AHB3ENR |= rcc_t::AHB3ENR_DMA2DEN; }
    static void disable() { RCC.AHB3ENR &= ~rcc_t::AHB3ENR_DMA2DEN; }
    static void reset() { RCC.AHB3RSTR |= rcc_t::AHB3RSTR_DMA2DRST; }
};

template<> struct peripheral_traits<fmc_t>
{
    static void enable() { RCC.AHB3ENR |= rcc_t::AHB3ENR_FMCEN; }
    static void disable() { RCC.AHB3ENR &= ~rcc_t::AHB3ENR_FMCEN; }
    static void reset() { RCC.AHB3RSTR |= rcc_t::AHB3RSTR_FMCRST; }
};

template<> struct peripheral_traits<cec_t>
{
    static void enable() { RCC.APB1LENR |= rcc_t::APB1LENR_CECEN; }
    static void disable() { RCC.APB1LENR &= ~rcc_t::APB1LENR_CECEN; }
    static void reset() { RCC.APB1LRSTR |= rcc_t::APB1LRSTR_CECRST; }
};

template<> struct peripheral_traits<hsem_t>
{
    static void enable() { RCC.AHB4ENR |= rcc_t::AHB4ENR_HSEMEN; }
    static void disable() { RCC.AHB4ENR &= ~rcc_t::AHB4ENR_HSEMEN; }
    static void reset() { RCC.AHB4RSTR |= rcc_t::AHB4RSTR_HSEMRST; }
};

template<> struct peripheral_traits<i2c1_t>
{
    static void enable() { RCC.APB1LENR |= rcc_t::APB1LENR_I2C1EN; }
    static void disable() { RCC.APB1LENR &= ~rcc_t::APB1LENR_I2C1EN; }
    static void reset() { RCC.APB1LRSTR |= rcc_t::APB1LRSTR_I2C1RST; }
};

template<> struct peripheral_traits<i2c2_t>
{
    static void enable() { RCC.APB1LENR |= rcc_t::APB1LENR_I2C2EN; }
    static void disable() { RCC.APB1LENR &= ~rcc_t::APB1LENR_I2C2EN; }
    static void reset() { RCC.APB1LRSTR |= rcc_t::APB1LRSTR_I2C2RST; }
};

template<> struct peripheral_traits<i2c3_t>
{
    static void enable() { RCC.APB1LENR |= rcc_t::APB1LENR_I2C3EN; }
    static void disable() { RCC.APB1LENR &= ~rcc_t::APB1LENR_I2C3EN; }
    static void reset() { RCC.APB1LRSTR |= rcc_t::APB1LRSTR_I2C3RST; }
};

template<> struct peripheral_traits<i2c4_t>
{
    static void enable() { RCC.APB4ENR |= rcc_t::APB4ENR_I2C4EN; }
    static void disable() { RCC.APB4ENR &= ~rcc_t::APB4ENR_I2C4EN; }
    static void reset() { RCC.APB4RSTR |= rcc_t::APB4RSTR_I2C4RST; }
};

template<> struct peripheral_traits<gpioa_t>
{
    static void enable() { RCC.AHB4ENR |= rcc_t::AHB4ENR_GPIOAEN; }
    static void disable() { RCC.AHB4ENR &= ~rcc_t::AHB4ENR_GPIOAEN; }
    static void reset() { RCC.AHB4RSTR |= rcc_t::AHB4RSTR_GPIOARST; }
};

template<> struct peripheral_traits<gpiob_t>
{
    static void enable() { RCC.AHB4ENR |= rcc_t::AHB4ENR_GPIOBEN; }
    static void disable() { RCC.AHB4ENR &= ~rcc_t::AHB4ENR_GPIOBEN; }
    static void reset() { RCC.AHB4RSTR |= rcc_t::AHB4RSTR_GPIOBRST; }
};

template<> struct peripheral_traits<gpioc_t>
{
    static void enable() { RCC.AHB4ENR |= rcc_t::AHB4ENR_GPIOCEN; }
    static void disable() { RCC.AHB4ENR &= ~rcc_t::AHB4ENR_GPIOCEN; }
    static void reset() { RCC.AHB4RSTR |= rcc_t::AHB4RSTR_GPIOCRST; }
};

template<> struct peripheral_traits<gpiod_t>
{
    static void enable() { RCC.AHB4ENR |= rcc_t::AHB4ENR_GPIODEN; }
    static void disable() { RCC.AHB4ENR &= ~rcc_t::AHB4ENR_GPIODEN; }
    static void reset() { RCC.AHB4RSTR |= rcc_t::AHB4RSTR_GPIODRST; }
};

template<> struct peripheral_traits<gpioe_t>
{
    static void enable() { RCC.AHB4ENR |= rcc_t::AHB4ENR_GPIOEEN; }
    static void disable() { RCC.AHB4ENR &= ~rcc_t::AHB4ENR_GPIOEEN; }
    static void reset() { RCC.AHB4RSTR |= rcc_t::AHB4RSTR_GPIOERST; }
};

template<> struct peripheral_traits<gpiof_t>
{
    static void enable() { RCC.AHB4ENR |= rcc_t::AHB4ENR_GPIOFEN; }
    static void disable() { RCC.AHB4ENR &= ~rcc_t::AHB4ENR_GPIOFEN; }
    static void reset() { RCC.AHB4RSTR |= rcc_t::AHB4RSTR_GPIOFRST; }
};

template<> struct peripheral_traits<gpiog_t>
{
    static void enable() { RCC.AHB4ENR |= rcc_t::AHB4ENR_GPIOGEN; }
    static void disable() { RCC.AHB4ENR &= ~rcc_t::AHB4ENR_GPIOGEN; }
    static void reset() { RCC.AHB4RSTR |= rcc_t::AHB4RSTR_GPIOGRST; }
};

template<> struct peripheral_traits<gpioh_t>
{
    static void enable() { RCC.AHB4ENR |= rcc_t::AHB4ENR_GPIOHEN; }
    static void disable() { RCC.AHB4ENR &= ~rcc_t::AHB4ENR_GPIOHEN; }
    static void reset() { RCC.AHB4RSTR |= rcc_t::AHB4RSTR_GPIOHRST; }
};

template<> struct peripheral_traits<gpioi_t>
{
    static void enable() { RCC.AHB4ENR |= rcc_t::AHB4ENR_GPIOIEN; }
    static void disable() { RCC.AHB4ENR &= ~rcc_t::AHB4ENR_GPIOIEN; }
    static void reset() { RCC.AHB4RSTR |= rcc_t::AHB4RSTR_GPIOIRST; }
};

template<> struct peripheral_traits<gpioj_t>
{
    static void enable() { RCC.AHB4ENR |= rcc_t::AHB4ENR_GPIOJEN; }
    static void disable() { RCC.AHB4ENR &= ~rcc_t::AHB4ENR_GPIOJEN; }
    static void reset() { RCC.AHB4RSTR |= rcc_t::AHB4RSTR_GPIOJRST; }
};

template<> struct peripheral_traits<gpiok_t>
{
    static void enable() { RCC.AHB4ENR |= rcc_t::AHB4ENR_GPIOKEN; }
    static void disable() { RCC.AHB4ENR &= ~rcc_t::AHB4ENR_GPIOKEN; }
    static void reset() { RCC.AHB4RSTR |= rcc_t::AHB4RSTR_GPIOKRST; }
};

template<> struct peripheral_traits<mdma_t>
{
    static void enable() { RCC.AHB3ENR |= rcc_t::AHB3ENR_MDMAEN; }
    static void disable() { RCC.AHB3ENR &= ~rcc_t::AHB3ENR_MDMAEN; }
    static void reset() { RCC.AHB3RSTR |= rcc_t::AHB3RSTR_MDMARST; }
};

template<> struct peripheral_traits<rng_t>
{
    static void enable() { RCC.AHB2ENR |= rcc_t::AHB2ENR_RNGEN; }
    static void disable() { RCC.AHB2ENR &= ~rcc_t::AHB2ENR_RNGEN; }
    static void reset() { RCC.AHB2RSTR |= rcc_t::AHB2RSTR_RNGRST; }
};

template<> struct peripheral_traits<sai4_t>
{
    static void enable() { RCC.APB4ENR |= rcc_t::APB4ENR_SAI4EN; }
    static void disable() { RCC.APB4ENR &= ~rcc_t::APB4ENR_SAI4EN; }
    static void reset() { RCC.APB4RSTR |= rcc_t::APB4RSTR_SAI4RST; }
};

template<> struct peripheral_traits<sai1_t>
{
    static void enable() { RCC.APB2ENR |= rcc_t::APB2ENR_SAI1EN; }
    static void disable() { RCC.APB2ENR &= ~rcc_t::APB2ENR_SAI1EN; }
    static void reset() { RCC.APB2RSTR |= rcc_t::APB2RSTR_SAI1RST; }
};

template<> struct peripheral_traits<sai2_t>
{
    static void enable() { RCC.APB2ENR |= rcc_t::APB2ENR_SAI2EN; }
    static void disable() { RCC.APB2ENR &= ~rcc_t::APB2ENR_SAI2EN; }
    static void reset() { RCC.APB2RSTR |= rcc_t::APB2RSTR_SAI2RST; }
};

template<> struct peripheral_traits<sai3_t>
{
    static void enable() { RCC.APB2ENR |= rcc_t::APB2ENR_SAI3EN; }
    static void disable() { RCC.APB2ENR &= ~rcc_t::APB2ENR_SAI3EN; }
    static void reset() { RCC.APB2RSTR |= rcc_t::APB2RSTR_SAI3RST; }
};

template<> struct peripheral_traits<sdmmc1_t>
{
    static void enable() { RCC.AHB3ENR |= rcc_t::AHB3ENR_SDMMC1EN; }
    static void disable() { RCC.AHB3ENR &= ~rcc_t::AHB3ENR_SDMMC1EN; }
    static void reset() { RCC.AHB3RSTR |= rcc_t::AHB3RSTR_SDMMC1RST; }
};

template<> struct peripheral_traits<sdmmc2_t>
{
    static void enable() { RCC.AHB2ENR |= rcc_t::AHB2ENR_SDMMC2EN; }
    static void disable() { RCC.AHB2ENR &= ~rcc_t::AHB2ENR_SDMMC2EN; }
    static void reset() { RCC.AHB2RSTR |= rcc_t::AHB2RSTR_SDMMC2RST; }
};

template<> struct peripheral_traits<wwdg_t>
{
    static void enable() { RCC.APB3ENR |= rcc_t::APB3ENR_WWDG1EN; }
    static void disable() { RCC.APB3ENR &= ~rcc_t::APB3ENR_WWDG1EN; }
};

template<> struct peripheral_traits<spi1_t>
{
    static void enable() { RCC.APB2ENR |= rcc_t::APB2ENR_SPI1EN; }
    static void disable() { RCC.APB2ENR &= ~rcc_t::APB2ENR_SPI1EN; }
    static void reset() { RCC.APB2RSTR |= rcc_t::APB2RSTR_SPI1RST; }
};

template<> struct peripheral_traits<spi2_t>
{
    static void enable() { RCC.APB1LENR |= rcc_t::APB1LENR_SPI2EN; }
    static void disable() { RCC.APB1LENR &= ~rcc_t::APB1LENR_SPI2EN; }
    static void reset() { RCC.APB1LRSTR |= rcc_t::APB1LRSTR_SPI2RST; }
};

template<> struct peripheral_traits<spi3_t>
{
    static void enable() { RCC.APB1LENR |= rcc_t::APB1LENR_SPI3EN; }
    static void disable() { RCC.APB1LENR &= ~rcc_t::APB1LENR_SPI3EN; }
    static void reset() { RCC.APB1LRSTR |= rcc_t::APB1LRSTR_SPI3RST; }
};

template<> struct peripheral_traits<spi4_t>
{
    static void enable() { RCC.APB2ENR |= rcc_t::APB2ENR_SPI4EN; }
    static void disable() { RCC.APB2ENR &= ~rcc_t::APB2ENR_SPI4EN; }
    static void reset() { RCC.APB2RSTR |= rcc_t::APB2RSTR_SPI4RST; }
};

template<> struct peripheral_traits<spi5_t>
{
    static void enable() { RCC.APB2ENR |= rcc_t::APB2ENR_SPI5EN; }
    static void disable() { RCC.APB2ENR &= ~rcc_t::APB2ENR_SPI5EN; }
    static void reset() { RCC.APB2RSTR |= rcc_t::APB2RSTR_SPI5RST; }
};

template<> struct peripheral_traits<spi6_t>
{
    static void enable() { RCC.APB4ENR |= rcc_t::APB4ENR_SPI6EN; }
    static void disable() { RCC.APB4ENR &= ~rcc_t::APB4ENR_SPI6EN; }
    static void reset() { RCC.APB4RSTR |= rcc_t::APB4RSTR_SPI6RST; }
};

template<> struct peripheral_traits<ltdc_t>
{
    static void enable() { RCC.APB3ENR |= rcc_t::APB3ENR_LTDCEN; }
    static void disable() { RCC.APB3ENR &= ~rcc_t::APB3ENR_LTDCEN; }
    static void reset() { RCC.APB3RSTR |= rcc_t::APB3RSTR_LTDCRST; }
};

template<> struct peripheral_traits<spdifrx_t>
{
    static void enable() { RCC.APB1LENR |= rcc_t::APB1LENR_SPDIFRXEN; }
    static void disable() { RCC.APB1LENR &= ~rcc_t::APB1LENR_SPDIFRXEN; }
    static void reset() { RCC.APB1LRSTR |= rcc_t::APB1LRSTR_SPDIFRXRST; }
};

template<> struct peripheral_traits<adc3_t>
{
    static void enable() { RCC.AHB4ENR |= rcc_t::AHB4ENR_ADC3EN; }
    static void disable() { RCC.AHB4ENR &= ~rcc_t::AHB4ENR_ADC3EN; }
    static void reset() { RCC.AHB4RSTR |= rcc_t::AHB4RSTR_ADC3RST; }
};

template<> struct peripheral_traits<adc12_common_t>
{
    static void enable() { RCC.AHB1ENR |= rcc_t::AHB1ENR_ADC12EN; }
    static void disable() { RCC.AHB1ENR &= ~rcc_t::AHB1ENR_ADC12EN; }
    static void reset() { RCC.AHB1RSTR |= rcc_t::AHB1RSTR_ADC12RST; }
};

template<> struct peripheral_traits<crc_t>
{
    static void enable() { RCC.AHB4ENR |= rcc_t::AHB4ENR_CRCEN; }
    static void disable() { RCC.AHB4ENR &= ~rcc_t::AHB4ENR_CRCEN; }
    static void reset() { RCC.AHB4RSTR |= rcc_t::AHB4RSTR_CRCRST; }
};

template<> struct peripheral_traits<lptim1_t>
{
    static void enable() { RCC.APB1LENR |= rcc_t::APB1LENR_LPTIM1EN; }
    static void disable() { RCC.APB1LENR &= ~rcc_t::APB1LENR_LPTIM1EN; }
    static void reset() { RCC.APB1LRSTR |= rcc_t::APB1LRSTR_LPTIM1RST; }
};

template<> struct peripheral_traits<lptim2_t>
{
    static void enable() { RCC.APB4ENR |= rcc_t::APB4ENR_LPTIM2EN; }
    static void disable() { RCC.APB4ENR &= ~rcc_t::APB4ENR_LPTIM2EN; }
    static void reset() { RCC.APB4RSTR |= rcc_t::APB4RSTR_LPTIM2RST; }
};

template<> struct peripheral_traits<lptim3_t>
{
    static void enable() { RCC.APB4ENR |= rcc_t::APB4ENR_LPTIM3EN; }
    static void disable() { RCC.APB4ENR &= ~rcc_t::APB4ENR_LPTIM3EN; }
    static void reset() { RCC.APB4RSTR |= rcc_t::APB4RSTR_LPTIM3RST; }
};

template<> struct peripheral_traits<lptim4_t>
{
    static void enable() { RCC.APB4ENR |= rcc_t::APB4ENR_LPTIM4EN; }
    static void disable() { RCC.APB4ENR &= ~rcc_t::APB4ENR_LPTIM4EN; }
    static void reset() { RCC.APB4RSTR |= rcc_t::APB4RSTR_LPTIM4RST; }
};

template<> struct peripheral_traits<lptim5_t>
{
    static void enable() { RCC.APB4ENR |= rcc_t::APB4ENR_LPTIM5EN; }
    static void disable() { RCC.APB4ENR &= ~rcc_t::APB4ENR_LPTIM5EN; }
    static void reset() { RCC.APB4RSTR |= rcc_t::APB4RSTR_LPTIM5RST; }
};

template<> struct peripheral_traits<lpuart1_t>
{
    static void enable() { RCC.APB4ENR |= rcc_t::APB4ENR_LPUART1EN; }
    static void disable() { RCC.APB4ENR &= ~rcc_t::APB4ENR_LPUART1EN; }
    static void reset() { RCC.APB4RSTR |= rcc_t::APB4RSTR_LPUART1RST; }
};

template<> struct peripheral_traits<syscfg_t>
{
    static void enable() { RCC.APB4ENR |= rcc_t::APB4ENR_SYSCFGEN; }
    static void disable() { RCC.APB4ENR &= ~rcc_t::APB4ENR_SYSCFGEN; }
    static void reset() { RCC.APB4RSTR |= rcc_t::APB4RSTR_SYSCFGRST; }
};

template<> struct peripheral_traits<hash_t>
{
    static void enable() { RCC.AHB2ENR |= rcc_t::AHB2ENR_HASHEN; }
    static void disable() { RCC.AHB2ENR &= ~rcc_t::AHB2ENR_HASHEN; }
    static void reset() { RCC.AHB2RSTR |= rcc_t::AHB2RSTR_HASHRST; }
};

template<> struct peripheral_traits<dma1_t>
{
    static void enable() { RCC.AHB1ENR |= rcc_t::AHB1ENR_DMA1EN; }
    static void disable() { RCC.AHB1ENR &= ~rcc_t::AHB1ENR_DMA1EN; }
    static void reset() { RCC.AHB1RSTR |= rcc_t::AHB1RSTR_DMA1RST; }
};

template<> struct peripheral_traits<dma2_t>
{
    static void enable() { RCC.AHB1ENR |= rcc_t::AHB1ENR_DMA2EN; }
    static void disable() { RCC.AHB1ENR &= ~rcc_t::AHB1ENR_DMA2EN; }
    static void reset() { RCC.AHB1RSTR |= rcc_t::AHB1RSTR_DMA2RST; }
};

template<> struct peripheral_traits<dfsdm_t>
{
    static void enable() { RCC.APB2ENR |= rcc_t::APB2ENR_DFSDM1EN; }
    static void disable() { RCC.APB2ENR &= ~rcc_t::APB2ENR_DFSDM1EN; }
    static void reset() { RCC.APB2RSTR |= rcc_t::APB2RSTR_DFSDM1RST; }
};

template<> struct peripheral_traits<tim16_t>
{
    static void enable() { RCC.APB2ENR |= rcc_t::APB2ENR_TIM16EN; }
    static void disable() { RCC.APB2ENR &= ~rcc_t::APB2ENR_TIM16EN; }
    static void reset() { RCC.APB2RSTR |= rcc_t::APB2RSTR_TIM16RST; }
};

template<> struct peripheral_traits<tim17_t>
{
    static void enable() { RCC.APB2ENR |= rcc_t::APB2ENR_TIM17EN; }
    static void disable() { RCC.APB2ENR &= ~rcc_t::APB2ENR_TIM17EN; }
    static void reset() { RCC.APB2RSTR |= rcc_t::APB2RSTR_TIM17RST; }
};

template<> struct peripheral_traits<tim15_t>
{
    static void enable() { RCC.APB2ENR |= rcc_t::APB2ENR_TIM15EN; }
    static void disable() { RCC.APB2ENR &= ~rcc_t::APB2ENR_TIM15EN; }
    static void reset() { RCC.APB2RSTR |= rcc_t::APB2RSTR_TIM15RST; }
};

template<> struct peripheral_traits<usart1_t>
{
    static void enable() { RCC.APB2ENR |= rcc_t::APB2ENR_USART1EN; }
    static void disable() { RCC.APB2ENR &= ~rcc_t::APB2ENR_USART1EN; }
    static void reset() { RCC.APB2RSTR |= rcc_t::APB2RSTR_USART1RST; }
};

template<> struct peripheral_traits<usart2_t>
{
    static void enable() { RCC.APB1LENR |= rcc_t::APB1LENR_USART2EN; }
    static void disable() { RCC.APB1LENR &= ~rcc_t::APB1LENR_USART2EN; }
    static void reset() { RCC.APB1LRSTR |= rcc_t::APB1LRSTR_USART2RST; }
};

template<> struct peripheral_traits<usart3_t>
{
    static void enable() { RCC.APB1LENR |= rcc_t::APB1LENR_USART3EN; }
    static void disable() { RCC.APB1LENR &= ~rcc_t::APB1LENR_USART3EN; }
    static void reset() { RCC.APB1LRSTR |= rcc_t::APB1LRSTR_USART3RST; }
};

template<> struct peripheral_traits<uart4_t>
{
    static void enable() { RCC.APB1LENR |= rcc_t::APB1LENR_UART4EN; }
    static void disable() { RCC.APB1LENR &= ~rcc_t::APB1LENR_UART4EN; }
    static void reset() { RCC.APB1LRSTR |= rcc_t::APB1LRSTR_UART4RST; }
};

template<> struct peripheral_traits<uart5_t>
{
    static void enable() { RCC.APB1LENR |= rcc_t::APB1LENR_UART5EN; }
    static void disable() { RCC.APB1LENR &= ~rcc_t::APB1LENR_UART5EN; }
    static void reset() { RCC.APB1LRSTR |= rcc_t::APB1LRSTR_UART5RST; }
};

template<> struct peripheral_traits<usart6_t>
{
    static void enable() { RCC.APB2ENR |= rcc_t::APB2ENR_USART6EN; }
    static void disable() { RCC.APB2ENR &= ~rcc_t::APB2ENR_USART6EN; }
    static void reset() { RCC.APB2RSTR |= rcc_t::APB2RSTR_USART6RST; }
};

template<> struct peripheral_traits<tim1_t>
{
    static void enable() { RCC.APB2ENR |= rcc_t::APB2ENR_TIM1EN; }
    static void disable() { RCC.APB2ENR &= ~rcc_t::APB2ENR_TIM1EN; }
    static void reset() { RCC.APB2RSTR |= rcc_t::APB2RSTR_TIM1RST; }
};

template<> struct peripheral_traits<tim8_t>
{
    static void enable() { RCC.APB2ENR |= rcc_t::APB2ENR_TIM8EN; }
    static void disable() { RCC.APB2ENR &= ~rcc_t::APB2ENR_TIM8EN; }
    static void reset() { RCC.APB2RSTR |= rcc_t::APB2RSTR_TIM8RST; }
};

template<> struct peripheral_traits<mdios_t>
{
    static void enable() { RCC.APB1HENR |= rcc_t::APB1HENR_MDIOSEN; }
    static void disable() { RCC.APB1HENR &= ~rcc_t::APB1HENR_MDIOSEN; }
    static void reset() { RCC.APB1HRSTR |= rcc_t::APB1HRSTR_MDIOSRST; }
};

template<> struct peripheral_traits<opamp_t>
{
    static void enable() { RCC.APB1HENR |= rcc_t::APB1HENR_OPAMPEN; }
    static void disable() { RCC.APB1HENR &= ~rcc_t::APB1HENR_OPAMPEN; }
    static void reset() { RCC.APB1HRSTR |= rcc_t::APB1HRSTR_OPAMPRST; }
};

template<> struct peripheral_traits<tim2_t>
{
    static void enable() { RCC.APB1LENR |= rcc_t::APB1LENR_TIM2EN; }
    static void disable() { RCC.APB1LENR &= ~rcc_t::APB1LENR_TIM2EN; }
    static void reset() { RCC.APB1LRSTR |= rcc_t::APB1LRSTR_TIM2RST; }
};

template<> struct peripheral_traits<tim3_t>
{
    static void enable() { RCC.APB1LENR |= rcc_t::APB1LENR_TIM3EN; }
    static void disable() { RCC.APB1LENR &= ~rcc_t::APB1LENR_TIM3EN; }
    static void reset() { RCC.APB1LRSTR |= rcc_t::APB1LRSTR_TIM3RST; }
};

template<> struct peripheral_traits<tim4_t>
{
    static void enable() { RCC.APB1LENR |= rcc_t::APB1LENR_TIM4EN; }
    static void disable() { RCC.APB1LENR &= ~rcc_t::APB1LENR_TIM4EN; }
    static void reset() { RCC.APB1LRSTR |= rcc_t::APB1LRSTR_TIM4RST; }
};

template<> struct peripheral_traits<tim5_t>
{
    static void enable() { RCC.APB1LENR |= rcc_t::APB1LENR_TIM5EN; }
    static void disable() { RCC.APB1LENR &= ~rcc_t::APB1LENR_TIM5EN; }
    static void reset() { RCC.APB1LRSTR |= rcc_t::APB1LRSTR_TIM5RST; }
};

template<> struct peripheral_traits<tim12_t>
{
    static void enable() { RCC.APB1LENR |= rcc_t::APB1LENR_TIM12EN; }
    static void disable() { RCC.APB1LENR &= ~rcc_t::APB1LENR_TIM12EN; }
    static void reset() { RCC.APB1LRSTR |= rcc_t::APB1LRSTR_TIM12RST; }
};

template<> struct peripheral_traits<tim13_t>
{
    static void enable() { RCC.APB1LENR |= rcc_t::APB1LENR_TIM13EN; }
    static void disable() { RCC.APB1LENR &= ~rcc_t::APB1LENR_TIM13EN; }
    static void reset() { RCC.APB1LRSTR |= rcc_t::APB1LRSTR_TIM13RST; }
};

template<> struct peripheral_traits<tim14_t>
{
    static void enable() { RCC.APB1LENR |= rcc_t::APB1LENR_TIM14EN; }
    static void disable() { RCC.APB1LENR &= ~rcc_t::APB1LENR_TIM14EN; }
    static void reset() { RCC.APB1LRSTR |= rcc_t::APB1LRSTR_TIM14RST; }
};

template<> struct peripheral_traits<tim6_t>
{
    static void enable() { RCC.APB1LENR |= rcc_t::APB1LENR_TIM6EN; }
    static void disable() { RCC.APB1LENR &= ~rcc_t::APB1LENR_TIM6EN; }
    static void reset() { RCC.APB1LRSTR |= rcc_t::APB1LRSTR_TIM6RST; }
};

template<> struct peripheral_traits<tim7_t>
{
    static void enable() { RCC.APB1LENR |= rcc_t::APB1LENR_TIM7EN; }
    static void disable() { RCC.APB1LENR &= ~rcc_t::APB1LENR_TIM7EN; }
    static void reset() { RCC.APB1LRSTR |= rcc_t::APB1LRSTR_TIM7RST; }
};

}

struct interrupt
{
    static inline void enable() { __asm volatile ("cpsie i"); }
    static inline void disable() { __asm volatile ("cpsid i"); }

    enum interrupt_t
    { RESET = -15
    , NMI = -14
    , HARDFAULT = -13
    , MEMMANAGE = -12
    , BUSFAULT = -11
    , USAGEFAULT = -10
    , SVCALL = -5
    , DEBUG = -4
    , PENDSV = -2
    , SYSTICK = -1
    , WWDG1 = 0
    , PVD_PVM = 1
    , RTC_TAMP_STAMP_CSS_LSE = 2
    , RTC_WKUP = 3
    , FLASH = 4
    , RCC = 5
    , EXTI0 = 6
    , EXTI1 = 7
    , EXTI2 = 8
    , EXTI3 = 9
    , EXTI4 = 10
    , DMA_STR0 = 11
    , DMA_STR1 = 12
    , DMA_STR2 = 13
    , DMA_STR3 = 14
    , DMA_STR4 = 15
    , DMA_STR5 = 16
    , DMA_STR6 = 17
    , ADC1_2 = 18
    , FDCAN1_IT0 = 19
    , FDCAN2_IT0 = 20
    , FDCAN1_IT1 = 21
    , FDCAN2_IT1 = 22
    , EXTI9_5 = 23
    , TIM1_BRK = 24
    , TIM1_UP = 25
    , TIM1_TRG_COM = 26
    , TIM_CC = 27
    , TIM2 = 28
    , TIM3 = 29
    , TIM4 = 30
    , I2C1_EV = 31
    , I2C1_ER = 32
    , I2C2_EV = 33
    , I2C2_ER = 34
    , SPI1 = 35
    , SPI2 = 36
    , USART1 = 37
    , USART2 = 38
    , USART3 = 39
    , EXTI15_10 = 40
    , RTC_ALARM = 41
    , TIM8_BRK_TIM12 = 43
    , TIM8_UP_TIM13 = 44
    , TIM8_TRG_COM_TIM14 = 45
    , TIM8_CC = 46
    , DMA1_STR7 = 47
    , FMC = 48
    , SDMMC1 = 49
    , TIM5 = 50
    , SPI3 = 51
    , UART4 = 52
    , UART5 = 53
    , TIM6_DAC = 54
    , TIM7 = 55
    , DMA2_STR0 = 56
    , DMA2_STR1 = 57
    , DMA2_STR2 = 58
    , DMA2_STR3 = 59
    , DMA2_STR4 = 60
    , ETH = 61
    , ETH_WKUP = 62
    , FDCAN_CAL = 63
    , DMA2_STR5 = 68
    , DMA2_STR6 = 69
    , DMA2_STR7 = 70
    , USART6 = 71
    , I2C3_EV = 72
    , I2C3_ER = 73
    , OTG_HS_EP1_OUT = 74
    , OTG_HS_EP1_IN = 75
    , OTG_HS_WKUP = 76
    , OTG_HS = 77
    , DCMI = 78
    , CRYP = 79
    , HASH_RNG = 80
    , FPU = 81
    , UART7 = 82
    , UART8 = 83
    , SPI4 = 84
    , SPI5 = 85
    , SPI6 = 86
    , SAI1 = 87
    , LTDC = 88
    , LTDC_ER = 89
    , DMA2D = 90
    , SAI2 = 91
    , QUADSPI = 92
    , LPTIM1 = 93
    , CEC = 94
    , I2C4_EV = 95
    , I2C4_ER = 96
    , SPDIF = 97
    , OTG_FS_EP1_OUT = 98
    , OTG_FS_EP1_IN = 99
    , OTG_FS_WKUP = 100
    , OTG_FS = 101
    , DMAMUX1_OV = 102
    , HRTIM1_MST = 103
    , HRTIM1_TIMA = 104
    , HRTIM_TIMB = 105
    , HRTIM1_TIMC = 106
    , HRTIM1_TIMD = 107
    , HRTIM_TIME = 108
    , HRTIM1_FLT = 109
    , DFSDM1_FLT0 = 110
    , DFSDM1_FLT1 = 111
    , DFSDM1_FLT2 = 112
    , DFSDM1_FLT3 = 113
    , SAI3 = 114
    , SWPMI1 = 115
    , TIM15 = 116
    , TIM16 = 117
    , TIM17 = 118
    , MDIOS_WKUP = 119
    , MDIOS = 120
    , JPEG = 121
    , MDMA = 122
    , SDMMC = 124
    , HSEM0 = 125
    , ADC3 = 127
    , DMAMUX2_OVR = 128
    , BDMA_CH1 = 129
    , BDMA_CH2 = 130
    , BDMA_CH3 = 131
    , BDMA_CH4 = 132
    , BDMA_CH5 = 133
    , BDMA_CH6 = 134
    , BDMA_CH7 = 135
    , BDMA_CH8 = 136
    , COMP = 137
    , LPTIM2 = 138
    , LPTIM3 = 139
    , LPTIM4 = 140
    , LPTIM5 = 141
    , LPUART = 142
    , WWDG1_RST = 143
    , CRS = 144
    , SAI4 = 146
    , WKUP = 149
    };
};
