#pragma once

#include <stdint.h>

////
//
//    STM32F7x7
//
//       schema-version : 1.1
//       vendor         : 
//       series         : 
//       device-version : 1.9
//       address-unit   : 8 bits
//       device-width   : 32
//       device-size    : 32
//
////

namespace stm32f7x7
{

template<int N> class reserved_t { private: uint32_t m_pad[N]; };

template<uint8_t POS, uint32_t MASK>
struct bit_field_t
{
    template <uint32_t X>
    static constexpr uint32_t value()
    {
        static_assert((X & ~MASK) == 0, "field value too large");
        return X << POS;
    }
};

////
//
//    Random number generator
//
////

struct rng_t
{
    volatile uint32_t    CR;                   // [Read-write] control register
    volatile uint32_t    SR;                   // status register
    volatile uint32_t    DR;                   // [Read-only] data register

    static constexpr uint32_t CR_IE = 0x8;             // Interrupt enable
    static constexpr uint32_t CR_RNGEN = 0x4;          // Random number generator enable
    static const uint32_t CR_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_SEIS = 0x40;          // Seed error interrupt status, Read-write
    static constexpr uint32_t SR_CEIS = 0x20;          // Clock error interrupt status, Read-write
    static constexpr uint32_t SR_SECS = 0x4;           // Seed error current status, Read-only
    static constexpr uint32_t SR_CECS = 0x2;           // Clock error current status, Read-only
    static constexpr uint32_t SR_DRDY = 0x1;           // Data ready, Read-only
    static const uint32_t SR_RESET_VALUE = 0x0;


    static const uint32_t DR_RESET_VALUE = 0x0;

    static constexpr uint8_t HASH_RNG = 80; // Hash and Rng global interrupt
};

static rng_t& RNG = *reinterpret_cast<rng_t*>(0x50060800);

#define HAVE_PERIPHERAL_RNG


////
//
//    Hash processor
//
////

struct hash_t
{
    volatile uint32_t    CR;                   // control register
    volatile uint32_t    DIN;                  // [Read-write] data input register
    volatile uint32_t    STR;                  // start register
    volatile uint32_t    _HR0;                 // [Read-only] digest registers
    volatile uint32_t    _HR1;                 // [Read-only] digest registers
    volatile uint32_t    _HR2;                 // [Read-only] digest registers
    volatile uint32_t    _HR3;                 // [Read-only] digest registers
    volatile uint32_t    _HR4;                 // [Read-only] digest registers
    volatile uint32_t    IMR;                  // [Read-write] interrupt enable register
    volatile uint32_t    SR;                   // status register
    reserved_t<52>       _0;
    volatile uint32_t    CSR0;                 // [Read-write] context swap registers
    volatile uint32_t    CSR1;                 // [Read-write] context swap registers
    volatile uint32_t    CSR2;                 // [Read-write] context swap registers
    volatile uint32_t    CSR3;                 // [Read-write] context swap registers
    volatile uint32_t    CSR4;                 // [Read-write] context swap registers
    volatile uint32_t    CSR5;                 // [Read-write] context swap registers
    volatile uint32_t    CSR6;                 // [Read-write] context swap registers
    volatile uint32_t    CSR7;                 // [Read-write] context swap registers
    volatile uint32_t    CSR8;                 // [Read-write] context swap registers
    volatile uint32_t    CSR9;                 // [Read-write] context swap registers
    volatile uint32_t    CSR10;                // [Read-write] context swap registers
    volatile uint32_t    CSR11;                // [Read-write] context swap registers
    volatile uint32_t    CSR12;                // [Read-write] context swap registers
    volatile uint32_t    CSR13;                // [Read-write] context swap registers
    volatile uint32_t    CSR14;                // [Read-write] context swap registers
    volatile uint32_t    CSR15;                // [Read-write] context swap registers
    volatile uint32_t    CSR16;                // [Read-write] context swap registers
    volatile uint32_t    CSR17;                // [Read-write] context swap registers
    volatile uint32_t    CSR18;                // [Read-write] context swap registers
    volatile uint32_t    CSR19;                // [Read-write] context swap registers
    volatile uint32_t    CSR20;                // [Read-write] context swap registers
    volatile uint32_t    CSR21;                // [Read-write] context swap registers
    volatile uint32_t    CSR22;                // [Read-write] context swap registers
    volatile uint32_t    CSR23;                // [Read-write] context swap registers
    volatile uint32_t    CSR24;                // [Read-write] context swap registers
    volatile uint32_t    CSR25;                // [Read-write] context swap registers
    volatile uint32_t    CSR26;                // [Read-write] context swap registers
    volatile uint32_t    CSR27;                // [Read-write] context swap registers
    volatile uint32_t    CSR28;                // [Read-write] context swap registers
    volatile uint32_t    CSR29;                // [Read-write] context swap registers
    volatile uint32_t    CSR30;                // [Read-write] context swap registers
    volatile uint32_t    CSR31;                // [Read-write] context swap registers
    volatile uint32_t    CSR32;                // [Read-write] context swap registers
    volatile uint32_t    CSR33;                // [Read-write] context swap registers
    volatile uint32_t    CSR34;                // [Read-write] context swap registers
    volatile uint32_t    CSR35;                // [Read-write] context swap registers
    volatile uint32_t    CSR36;                // [Read-write] context swap registers
    volatile uint32_t    CSR37;                // [Read-write] context swap registers
    volatile uint32_t    CSR38;                // [Read-write] context swap registers
    volatile uint32_t    CSR39;                // [Read-write] context swap registers
    volatile uint32_t    CSR40;                // [Read-write] context swap registers
    volatile uint32_t    CSR41;                // [Read-write] context swap registers
    volatile uint32_t    CSR42;                // [Read-write] context swap registers
    volatile uint32_t    CSR43;                // [Read-write] context swap registers
    volatile uint32_t    CSR44;                // [Read-write] context swap registers
    volatile uint32_t    CSR45;                // [Read-write] context swap registers
    volatile uint32_t    CSR46;                // [Read-write] context swap registers
    volatile uint32_t    CSR47;                // [Read-write] context swap registers
    volatile uint32_t    CSR48;                // [Read-write] context swap registers
    volatile uint32_t    CSR49;                // [Read-write] context swap registers
    volatile uint32_t    CSR50;                // [Read-write] context swap registers
    volatile uint32_t    CSR51;                // [Read-write] context swap registers
    volatile uint32_t    CSR52;                // [Read-write] context swap registers
    volatile uint32_t    CSR53;                // [Read-write] context swap registers
    reserved_t<80>       _1;
    volatile uint32_t    HR0;                  // [Read-only] HASH digest register
    volatile uint32_t    HR1;                  // [Read-only] read-only
    volatile uint32_t    HR2;                  // [Read-only] read-only
    volatile uint32_t    HR3;                  // [Read-only] read-only
    volatile uint32_t    HR4;                  // [Read-only] read-only
    volatile uint32_t    HR5;                  // [Read-only] read-only
    volatile uint32_t    HR6;                  // [Read-only] read-only
    volatile uint32_t    HR7;                  // [Read-only] read-only

    static constexpr uint32_t CR_INIT = 0x4;           // Initialize message digest calculation, Write-only
    static constexpr uint32_t CR_DMAE = 0x8;           // DMA enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t CR_DATATYPE =            // Data type selection (2 bits), Read-write
        bit_field_t<4, 0x3>::value<X>();
    static constexpr uint32_t CR_MODE = 0x40;          // Mode selection, Read-write
    static constexpr uint32_t CR_ALGO0 = 0x80;         // Algorithm selection, Read-write
    template<uint32_t X>
    static constexpr uint32_t CR_NBW =                 // Number of words already pushed (4 bits), Read-only
        bit_field_t<8, 0xf>::value<X>();
    static constexpr uint32_t CR_DINNE = 0x1000;       // DIN not empty, Read-only
    static constexpr uint32_t CR_MDMAT = 0x2000;       // Multiple DMA Transfers, Read-write
    static constexpr uint32_t CR_LKEY = 0x10000;       // Long key selection, Read-write
    static constexpr uint32_t CR_ALGO1 = 0x40000;      // ALGO, Read-write
    static const uint32_t CR_RESET_VALUE = 0x0;


    static const uint32_t DIN_RESET_VALUE = 0x0;

    static constexpr uint32_t STR_DCAL = 0x100;         // Digest calculation, Write-only
    template<uint32_t X>
    static constexpr uint32_t STR_NBLW =                // Number of valid bits in the last word of the message (5 bits), Read-write
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t STR_RESET_VALUE = 0x0;


    static const uint32_t _HR0_RESET_VALUE = 0x0;


    static const uint32_t _HR1_RESET_VALUE = 0x0;


    static const uint32_t _HR2_RESET_VALUE = 0x0;


    static const uint32_t _HR3_RESET_VALUE = 0x0;


    static const uint32_t _HR4_RESET_VALUE = 0x0;

    static constexpr uint32_t IMR_DCIE = 0x2;           // Digest calculation completion interrupt enable
    static constexpr uint32_t IMR_DINIE = 0x1;          // Data input interrupt enable
    static const uint32_t IMR_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_BUSY = 0x8;           // Busy bit, Read-only
    static constexpr uint32_t SR_DMAS = 0x4;           // DMA Status, Read-only
    static constexpr uint32_t SR_DCIS = 0x2;           // Digest calculation completion interrupt status, Read-write
    static constexpr uint32_t SR_DINIS = 0x1;          // Data input interrupt status, Read-write
    static const uint32_t SR_RESET_VALUE = 0x1;


    static const uint32_t CSR0_RESET_VALUE = 0x0;


    static const uint32_t CSR1_RESET_VALUE = 0x0;


    static const uint32_t CSR2_RESET_VALUE = 0x0;


    static const uint32_t CSR3_RESET_VALUE = 0x0;


    static const uint32_t CSR4_RESET_VALUE = 0x0;


    static const uint32_t CSR5_RESET_VALUE = 0x0;


    static const uint32_t CSR6_RESET_VALUE = 0x0;


    static const uint32_t CSR7_RESET_VALUE = 0x0;


    static const uint32_t CSR8_RESET_VALUE = 0x0;


    static const uint32_t CSR9_RESET_VALUE = 0x0;


    static const uint32_t CSR10_RESET_VALUE = 0x0;


    static const uint32_t CSR11_RESET_VALUE = 0x0;


    static const uint32_t CSR12_RESET_VALUE = 0x0;


    static const uint32_t CSR13_RESET_VALUE = 0x0;


    static const uint32_t CSR14_RESET_VALUE = 0x0;


    static const uint32_t CSR15_RESET_VALUE = 0x0;


    static const uint32_t CSR16_RESET_VALUE = 0x0;


    static const uint32_t CSR17_RESET_VALUE = 0x0;


    static const uint32_t CSR18_RESET_VALUE = 0x0;


    static const uint32_t CSR19_RESET_VALUE = 0x0;


    static const uint32_t CSR20_RESET_VALUE = 0x0;


    static const uint32_t CSR21_RESET_VALUE = 0x0;


    static const uint32_t CSR22_RESET_VALUE = 0x0;


    static const uint32_t CSR23_RESET_VALUE = 0x0;


    static const uint32_t CSR24_RESET_VALUE = 0x0;


    static const uint32_t CSR25_RESET_VALUE = 0x0;


    static const uint32_t CSR26_RESET_VALUE = 0x0;


    static const uint32_t CSR27_RESET_VALUE = 0x0;


    static const uint32_t CSR28_RESET_VALUE = 0x0;


    static const uint32_t CSR29_RESET_VALUE = 0x0;


    static const uint32_t CSR30_RESET_VALUE = 0x0;


    static const uint32_t CSR31_RESET_VALUE = 0x0;


    static const uint32_t CSR32_RESET_VALUE = 0x0;


    static const uint32_t CSR33_RESET_VALUE = 0x0;


    static const uint32_t CSR34_RESET_VALUE = 0x0;


    static const uint32_t CSR35_RESET_VALUE = 0x0;


    static const uint32_t CSR36_RESET_VALUE = 0x0;


    static const uint32_t CSR37_RESET_VALUE = 0x0;


    static const uint32_t CSR38_RESET_VALUE = 0x0;


    static const uint32_t CSR39_RESET_VALUE = 0x0;


    static const uint32_t CSR40_RESET_VALUE = 0x0;


    static const uint32_t CSR41_RESET_VALUE = 0x0;


    static const uint32_t CSR42_RESET_VALUE = 0x0;


    static const uint32_t CSR43_RESET_VALUE = 0x0;


    static const uint32_t CSR44_RESET_VALUE = 0x0;


    static const uint32_t CSR45_RESET_VALUE = 0x0;


    static const uint32_t CSR46_RESET_VALUE = 0x0;


    static const uint32_t CSR47_RESET_VALUE = 0x0;


    static const uint32_t CSR48_RESET_VALUE = 0x0;


    static const uint32_t CSR49_RESET_VALUE = 0x0;


    static const uint32_t CSR50_RESET_VALUE = 0x0;


    static const uint32_t CSR51_RESET_VALUE = 0x0;


    static const uint32_t CSR52_RESET_VALUE = 0x0;


    static const uint32_t CSR53_RESET_VALUE = 0x0;


    static const uint32_t HR0_RESET_VALUE = 0x0;


    static const uint32_t HR1_RESET_VALUE = 0x0;


    static const uint32_t HR2_RESET_VALUE = 0x0;


    static const uint32_t HR3_RESET_VALUE = 0x0;


    static const uint32_t HR4_RESET_VALUE = 0x0;


    static const uint32_t HR5_RESET_VALUE = 0x0;


    static const uint32_t HR6_RESET_VALUE = 0x0;


    static const uint32_t HR7_RESET_VALUE = 0x0;
};

static hash_t& HASH = *reinterpret_cast<hash_t*>(0x50060400);

#define HAVE_PERIPHERAL_HASH


////
//
//    Cryptographic processor
//
////

struct cryp_t
{
    volatile uint32_t    CR;                   // control register
    volatile uint32_t    SR;                   // [Read-only] status register
    volatile uint32_t    DIN;                  // [Read-write] data input register
    volatile uint32_t    DOUT;                 // [Read-only] data output register
    volatile uint32_t    DMACR;                // [Read-write] DMA control register
    volatile uint32_t    IMSCR;                // [Read-write] interrupt mask set/clear register
    volatile uint32_t    RISR;                 // [Read-only] raw interrupt status register
    volatile uint32_t    MISR;                 // [Read-only] masked interrupt status register
    volatile uint32_t    K0LR;                 // [Write-only] key registers
    volatile uint32_t    K0RR;                 // [Write-only] key registers
    volatile uint32_t    K1LR;                 // [Write-only] key registers
    volatile uint32_t    K1RR;                 // [Write-only] key registers
    volatile uint32_t    K2LR;                 // [Write-only] key registers
    volatile uint32_t    K2RR;                 // [Write-only] key registers
    volatile uint32_t    K3LR;                 // [Write-only] key registers
    volatile uint32_t    K3RR;                 // [Write-only] key registers
    volatile uint32_t    IV0LR;                // [Read-write] initialization vector registers
    volatile uint32_t    IV0RR;                // [Read-write] initialization vector registers
    volatile uint32_t    IV1LR;                // [Read-write] initialization vector registers
    volatile uint32_t    IV1RR;                // [Read-write] initialization vector registers
    volatile uint32_t    CSGCMCCM0R;           // [Read-write] context swap register
    volatile uint32_t    CSGCMCCM1R;           // [Read-write] context swap register
    volatile uint32_t    CSGCMCCM2R;           // [Read-write] context swap register
    volatile uint32_t    CSGCMCCM3R;           // [Read-write] context swap register
    volatile uint32_t    CSGCMCCM4R;           // [Read-write] context swap register
    volatile uint32_t    CSGCMCCM5R;           // [Read-write] context swap register
    volatile uint32_t    CSGCMCCM6R;           // [Read-write] context swap register
    volatile uint32_t    CSGCMCCM7R;           // [Read-write] context swap register
    volatile uint32_t    CSGCM0R;              // [Read-write] context swap register
    volatile uint32_t    CSGCM1R;              // [Read-write] context swap register
    volatile uint32_t    CSGCM2R;              // [Read-write] context swap register
    volatile uint32_t    CSGCM3R;              // [Read-write] context swap register
    volatile uint32_t    CSGCM4R;              // [Read-write] context swap register
    volatile uint32_t    CSGCM5R;              // [Read-write] context swap register
    volatile uint32_t    CSGCM6R;              // [Read-write] context swap register
    volatile uint32_t    CSGCM7R;              // [Read-write] context swap register

    static constexpr uint32_t CR_ALGODIR = 0x4;        // Algorithm direction, Read-write
    template<uint32_t X>
    static constexpr uint32_t CR_ALGOMODE0 =           // Algorithm mode (3 bits), Read-write
        bit_field_t<3, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR_DATATYPE =            // Data type selection (2 bits), Read-write
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR_KEYSIZE =             // Key size selection (AES mode only) (2 bits), Read-write
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t CR_FFLUSH = 0x4000;      // FIFO flush, Write-only
    static constexpr uint32_t CR_CRYPEN = 0x8000;      // Cryptographic processor enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t CR_GCM_CCMPH =           // GCM_CCMPH (2 bits), Read-write
        bit_field_t<16, 0x3>::value<X>();
    static constexpr uint32_t CR_ALGOMODE3 = 0x80000;  // ALGOMODE, Read-write
    static const uint32_t CR_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_BUSY = 0x10;          // Busy bit
    static constexpr uint32_t SR_OFFU = 0x8;           // Output FIFO full
    static constexpr uint32_t SR_OFNE = 0x4;           // Output FIFO not empty
    static constexpr uint32_t SR_IFNF = 0x2;           // Input FIFO not full
    static constexpr uint32_t SR_IFEM = 0x1;           // Input FIFO empty
    static const uint32_t SR_RESET_VALUE = 0x3;


    static const uint32_t DIN_RESET_VALUE = 0x0;


    static const uint32_t DOUT_RESET_VALUE = 0x0;

    static constexpr uint32_t DMACR_DOEN = 0x2;           // DMA output enable
    static constexpr uint32_t DMACR_DIEN = 0x1;           // DMA input enable
    static const uint32_t DMACR_RESET_VALUE = 0x0;

    static constexpr uint32_t IMSCR_OUTIM = 0x2;          // Output FIFO service interrupt mask
    static constexpr uint32_t IMSCR_INIM = 0x1;           // Input FIFO service interrupt mask
    static const uint32_t IMSCR_RESET_VALUE = 0x0;

    static constexpr uint32_t RISR_OUTRIS = 0x2;         // Output FIFO service raw interrupt status
    static constexpr uint32_t RISR_INRIS = 0x1;          // Input FIFO service raw interrupt status
    static const uint32_t RISR_RESET_VALUE = 0x1;

    static constexpr uint32_t MISR_OUTMIS = 0x2;         // Output FIFO service masked interrupt status
    static constexpr uint32_t MISR_INMIS = 0x1;          // Input FIFO service masked interrupt status
    static const uint32_t MISR_RESET_VALUE = 0x0;

    static constexpr uint32_t K0LR_b224 = 0x1;           // b224
    static constexpr uint32_t K0LR_b225 = 0x2;           // b225
    static constexpr uint32_t K0LR_b226 = 0x4;           // b226
    static constexpr uint32_t K0LR_b227 = 0x8;           // b227
    static constexpr uint32_t K0LR_b228 = 0x10;          // b228
    static constexpr uint32_t K0LR_b229 = 0x20;          // b229
    static constexpr uint32_t K0LR_b230 = 0x40;          // b230
    static constexpr uint32_t K0LR_b231 = 0x80;          // b231
    static constexpr uint32_t K0LR_b232 = 0x100;         // b232
    static constexpr uint32_t K0LR_b233 = 0x200;         // b233
    static constexpr uint32_t K0LR_b234 = 0x400;         // b234
    static constexpr uint32_t K0LR_b235 = 0x800;         // b235
    static constexpr uint32_t K0LR_b236 = 0x1000;        // b236
    static constexpr uint32_t K0LR_b237 = 0x2000;        // b237
    static constexpr uint32_t K0LR_b238 = 0x4000;        // b238
    static constexpr uint32_t K0LR_b239 = 0x8000;        // b239
    static constexpr uint32_t K0LR_b240 = 0x10000;       // b240
    static constexpr uint32_t K0LR_b241 = 0x20000;       // b241
    static constexpr uint32_t K0LR_b242 = 0x40000;       // b242
    static constexpr uint32_t K0LR_b243 = 0x80000;       // b243
    static constexpr uint32_t K0LR_b244 = 0x100000;      // b244
    static constexpr uint32_t K0LR_b245 = 0x200000;      // b245
    static constexpr uint32_t K0LR_b246 = 0x400000;      // b246
    static constexpr uint32_t K0LR_b247 = 0x800000;      // b247
    static constexpr uint32_t K0LR_b248 = 0x1000000;     // b248
    static constexpr uint32_t K0LR_b249 = 0x2000000;     // b249
    static constexpr uint32_t K0LR_b250 = 0x4000000;     // b250
    static constexpr uint32_t K0LR_b251 = 0x8000000;     // b251
    static constexpr uint32_t K0LR_b252 = 0x10000000;    // b252
    static constexpr uint32_t K0LR_b253 = 0x20000000;    // b253
    static constexpr uint32_t K0LR_b254 = 0x40000000;    // b254
    static constexpr uint32_t K0LR_b255 = 0x80000000;    // b255
    static const uint32_t K0LR_RESET_VALUE = 0x0;

    static constexpr uint32_t K0RR_b192 = 0x1;           // b192
    static constexpr uint32_t K0RR_b193 = 0x2;           // b193
    static constexpr uint32_t K0RR_b194 = 0x4;           // b194
    static constexpr uint32_t K0RR_b195 = 0x8;           // b195
    static constexpr uint32_t K0RR_b196 = 0x10;          // b196
    static constexpr uint32_t K0RR_b197 = 0x20;          // b197
    static constexpr uint32_t K0RR_b198 = 0x40;          // b198
    static constexpr uint32_t K0RR_b199 = 0x80;          // b199
    static constexpr uint32_t K0RR_b200 = 0x100;         // b200
    static constexpr uint32_t K0RR_b201 = 0x200;         // b201
    static constexpr uint32_t K0RR_b202 = 0x400;         // b202
    static constexpr uint32_t K0RR_b203 = 0x800;         // b203
    static constexpr uint32_t K0RR_b204 = 0x1000;        // b204
    static constexpr uint32_t K0RR_b205 = 0x2000;        // b205
    static constexpr uint32_t K0RR_b206 = 0x4000;        // b206
    static constexpr uint32_t K0RR_b207 = 0x8000;        // b207
    static constexpr uint32_t K0RR_b208 = 0x10000;       // b208
    static constexpr uint32_t K0RR_b209 = 0x20000;       // b209
    static constexpr uint32_t K0RR_b210 = 0x40000;       // b210
    static constexpr uint32_t K0RR_b211 = 0x80000;       // b211
    static constexpr uint32_t K0RR_b212 = 0x100000;      // b212
    static constexpr uint32_t K0RR_b213 = 0x200000;      // b213
    static constexpr uint32_t K0RR_b214 = 0x400000;      // b214
    static constexpr uint32_t K0RR_b215 = 0x800000;      // b215
    static constexpr uint32_t K0RR_b216 = 0x1000000;     // b216
    static constexpr uint32_t K0RR_b217 = 0x2000000;     // b217
    static constexpr uint32_t K0RR_b218 = 0x4000000;     // b218
    static constexpr uint32_t K0RR_b219 = 0x8000000;     // b219
    static constexpr uint32_t K0RR_b220 = 0x10000000;    // b220
    static constexpr uint32_t K0RR_b221 = 0x20000000;    // b221
    static constexpr uint32_t K0RR_b222 = 0x40000000;    // b222
    static constexpr uint32_t K0RR_b223 = 0x80000000;    // b223
    static const uint32_t K0RR_RESET_VALUE = 0x0;

    static constexpr uint32_t K1LR_b160 = 0x1;           // b160
    static constexpr uint32_t K1LR_b161 = 0x2;           // b161
    static constexpr uint32_t K1LR_b162 = 0x4;           // b162
    static constexpr uint32_t K1LR_b163 = 0x8;           // b163
    static constexpr uint32_t K1LR_b164 = 0x10;          // b164
    static constexpr uint32_t K1LR_b165 = 0x20;          // b165
    static constexpr uint32_t K1LR_b166 = 0x40;          // b166
    static constexpr uint32_t K1LR_b167 = 0x80;          // b167
    static constexpr uint32_t K1LR_b168 = 0x100;         // b168
    static constexpr uint32_t K1LR_b169 = 0x200;         // b169
    static constexpr uint32_t K1LR_b170 = 0x400;         // b170
    static constexpr uint32_t K1LR_b171 = 0x800;         // b171
    static constexpr uint32_t K1LR_b172 = 0x1000;        // b172
    static constexpr uint32_t K1LR_b173 = 0x2000;        // b173
    static constexpr uint32_t K1LR_b174 = 0x4000;        // b174
    static constexpr uint32_t K1LR_b175 = 0x8000;        // b175
    static constexpr uint32_t K1LR_b176 = 0x10000;       // b176
    static constexpr uint32_t K1LR_b177 = 0x20000;       // b177
    static constexpr uint32_t K1LR_b178 = 0x40000;       // b178
    static constexpr uint32_t K1LR_b179 = 0x80000;       // b179
    static constexpr uint32_t K1LR_b180 = 0x100000;      // b180
    static constexpr uint32_t K1LR_b181 = 0x200000;      // b181
    static constexpr uint32_t K1LR_b182 = 0x400000;      // b182
    static constexpr uint32_t K1LR_b183 = 0x800000;      // b183
    static constexpr uint32_t K1LR_b184 = 0x1000000;     // b184
    static constexpr uint32_t K1LR_b185 = 0x2000000;     // b185
    static constexpr uint32_t K1LR_b186 = 0x4000000;     // b186
    static constexpr uint32_t K1LR_b187 = 0x8000000;     // b187
    static constexpr uint32_t K1LR_b188 = 0x10000000;    // b188
    static constexpr uint32_t K1LR_b189 = 0x20000000;    // b189
    static constexpr uint32_t K1LR_b190 = 0x40000000;    // b190
    static constexpr uint32_t K1LR_b191 = 0x80000000;    // b191
    static const uint32_t K1LR_RESET_VALUE = 0x0;

    static constexpr uint32_t K1RR_b128 = 0x1;           // b128
    static constexpr uint32_t K1RR_b129 = 0x2;           // b129
    static constexpr uint32_t K1RR_b130 = 0x4;           // b130
    static constexpr uint32_t K1RR_b131 = 0x8;           // b131
    static constexpr uint32_t K1RR_b132 = 0x10;          // b132
    static constexpr uint32_t K1RR_b133 = 0x20;          // b133
    static constexpr uint32_t K1RR_b134 = 0x40;          // b134
    static constexpr uint32_t K1RR_b135 = 0x80;          // b135
    static constexpr uint32_t K1RR_b136 = 0x100;         // b136
    static constexpr uint32_t K1RR_b137 = 0x200;         // b137
    static constexpr uint32_t K1RR_b138 = 0x400;         // b138
    static constexpr uint32_t K1RR_b139 = 0x800;         // b139
    static constexpr uint32_t K1RR_b140 = 0x1000;        // b140
    static constexpr uint32_t K1RR_b141 = 0x2000;        // b141
    static constexpr uint32_t K1RR_b142 = 0x4000;        // b142
    static constexpr uint32_t K1RR_b143 = 0x8000;        // b143
    static constexpr uint32_t K1RR_b144 = 0x10000;       // b144
    static constexpr uint32_t K1RR_b145 = 0x20000;       // b145
    static constexpr uint32_t K1RR_b146 = 0x40000;       // b146
    static constexpr uint32_t K1RR_b147 = 0x80000;       // b147
    static constexpr uint32_t K1RR_b148 = 0x100000;      // b148
    static constexpr uint32_t K1RR_b149 = 0x200000;      // b149
    static constexpr uint32_t K1RR_b150 = 0x400000;      // b150
    static constexpr uint32_t K1RR_b151 = 0x800000;      // b151
    static constexpr uint32_t K1RR_b152 = 0x1000000;     // b152
    static constexpr uint32_t K1RR_b153 = 0x2000000;     // b153
    static constexpr uint32_t K1RR_b154 = 0x4000000;     // b154
    static constexpr uint32_t K1RR_b155 = 0x8000000;     // b155
    static constexpr uint32_t K1RR_b156 = 0x10000000;    // b156
    static constexpr uint32_t K1RR_b157 = 0x20000000;    // b157
    static constexpr uint32_t K1RR_b158 = 0x40000000;    // b158
    static constexpr uint32_t K1RR_b159 = 0x80000000;    // b159
    static const uint32_t K1RR_RESET_VALUE = 0x0;

    static constexpr uint32_t K2LR_b96 = 0x1;            // b96
    static constexpr uint32_t K2LR_b97 = 0x2;            // b97
    static constexpr uint32_t K2LR_b98 = 0x4;            // b98
    static constexpr uint32_t K2LR_b99 = 0x8;            // b99
    static constexpr uint32_t K2LR_b100 = 0x10;          // b100
    static constexpr uint32_t K2LR_b101 = 0x20;          // b101
    static constexpr uint32_t K2LR_b102 = 0x40;          // b102
    static constexpr uint32_t K2LR_b103 = 0x80;          // b103
    static constexpr uint32_t K2LR_b104 = 0x100;         // b104
    static constexpr uint32_t K2LR_b105 = 0x200;         // b105
    static constexpr uint32_t K2LR_b106 = 0x400;         // b106
    static constexpr uint32_t K2LR_b107 = 0x800;         // b107
    static constexpr uint32_t K2LR_b108 = 0x1000;        // b108
    static constexpr uint32_t K2LR_b109 = 0x2000;        // b109
    static constexpr uint32_t K2LR_b110 = 0x4000;        // b110
    static constexpr uint32_t K2LR_b111 = 0x8000;        // b111
    static constexpr uint32_t K2LR_b112 = 0x10000;       // b112
    static constexpr uint32_t K2LR_b113 = 0x20000;       // b113
    static constexpr uint32_t K2LR_b114 = 0x40000;       // b114
    static constexpr uint32_t K2LR_b115 = 0x80000;       // b115
    static constexpr uint32_t K2LR_b116 = 0x100000;      // b116
    static constexpr uint32_t K2LR_b117 = 0x200000;      // b117
    static constexpr uint32_t K2LR_b118 = 0x400000;      // b118
    static constexpr uint32_t K2LR_b119 = 0x800000;      // b119
    static constexpr uint32_t K2LR_b120 = 0x1000000;     // b120
    static constexpr uint32_t K2LR_b121 = 0x2000000;     // b121
    static constexpr uint32_t K2LR_b122 = 0x4000000;     // b122
    static constexpr uint32_t K2LR_b123 = 0x8000000;     // b123
    static constexpr uint32_t K2LR_b124 = 0x10000000;    // b124
    static constexpr uint32_t K2LR_b125 = 0x20000000;    // b125
    static constexpr uint32_t K2LR_b126 = 0x40000000;    // b126
    static constexpr uint32_t K2LR_b127 = 0x80000000;    // b127
    static const uint32_t K2LR_RESET_VALUE = 0x0;

    static constexpr uint32_t K2RR_b64 = 0x1;            // b64
    static constexpr uint32_t K2RR_b65 = 0x2;            // b65
    static constexpr uint32_t K2RR_b66 = 0x4;            // b66
    static constexpr uint32_t K2RR_b67 = 0x8;            // b67
    static constexpr uint32_t K2RR_b68 = 0x10;           // b68
    static constexpr uint32_t K2RR_b69 = 0x20;           // b69
    static constexpr uint32_t K2RR_b70 = 0x40;           // b70
    static constexpr uint32_t K2RR_b71 = 0x80;           // b71
    static constexpr uint32_t K2RR_b72 = 0x100;          // b72
    static constexpr uint32_t K2RR_b73 = 0x200;          // b73
    static constexpr uint32_t K2RR_b74 = 0x400;          // b74
    static constexpr uint32_t K2RR_b75 = 0x800;          // b75
    static constexpr uint32_t K2RR_b76 = 0x1000;         // b76
    static constexpr uint32_t K2RR_b77 = 0x2000;         // b77
    static constexpr uint32_t K2RR_b78 = 0x4000;         // b78
    static constexpr uint32_t K2RR_b79 = 0x8000;         // b79
    static constexpr uint32_t K2RR_b80 = 0x10000;        // b80
    static constexpr uint32_t K2RR_b81 = 0x20000;        // b81
    static constexpr uint32_t K2RR_b82 = 0x40000;        // b82
    static constexpr uint32_t K2RR_b83 = 0x80000;        // b83
    static constexpr uint32_t K2RR_b84 = 0x100000;       // b84
    static constexpr uint32_t K2RR_b85 = 0x200000;       // b85
    static constexpr uint32_t K2RR_b86 = 0x400000;       // b86
    static constexpr uint32_t K2RR_b87 = 0x800000;       // b87
    static constexpr uint32_t K2RR_b88 = 0x1000000;      // b88
    static constexpr uint32_t K2RR_b89 = 0x2000000;      // b89
    static constexpr uint32_t K2RR_b90 = 0x4000000;      // b90
    static constexpr uint32_t K2RR_b91 = 0x8000000;      // b91
    static constexpr uint32_t K2RR_b92 = 0x10000000;     // b92
    static constexpr uint32_t K2RR_b93 = 0x20000000;     // b93
    static constexpr uint32_t K2RR_b94 = 0x40000000;     // b94
    static constexpr uint32_t K2RR_b95 = 0x80000000;     // b95
    static const uint32_t K2RR_RESET_VALUE = 0x0;

    static constexpr uint32_t K3LR_b32 = 0x1;            // b32
    static constexpr uint32_t K3LR_b33 = 0x2;            // b33
    static constexpr uint32_t K3LR_b34 = 0x4;            // b34
    static constexpr uint32_t K3LR_b35 = 0x8;            // b35
    static constexpr uint32_t K3LR_b36 = 0x10;           // b36
    static constexpr uint32_t K3LR_b37 = 0x20;           // b37
    static constexpr uint32_t K3LR_b38 = 0x40;           // b38
    static constexpr uint32_t K3LR_b39 = 0x80;           // b39
    static constexpr uint32_t K3LR_b40 = 0x100;          // b40
    static constexpr uint32_t K3LR_b41 = 0x200;          // b41
    static constexpr uint32_t K3LR_b42 = 0x400;          // b42
    static constexpr uint32_t K3LR_b43 = 0x800;          // b43
    static constexpr uint32_t K3LR_b44 = 0x1000;         // b44
    static constexpr uint32_t K3LR_b45 = 0x2000;         // b45
    static constexpr uint32_t K3LR_b46 = 0x4000;         // b46
    static constexpr uint32_t K3LR_b47 = 0x8000;         // b47
    static constexpr uint32_t K3LR_b48 = 0x10000;        // b48
    static constexpr uint32_t K3LR_b49 = 0x20000;        // b49
    static constexpr uint32_t K3LR_b50 = 0x40000;        // b50
    static constexpr uint32_t K3LR_b51 = 0x80000;        // b51
    static constexpr uint32_t K3LR_b52 = 0x100000;       // b52
    static constexpr uint32_t K3LR_b53 = 0x200000;       // b53
    static constexpr uint32_t K3LR_b54 = 0x400000;       // b54
    static constexpr uint32_t K3LR_b55 = 0x800000;       // b55
    static constexpr uint32_t K3LR_b56 = 0x1000000;      // b56
    static constexpr uint32_t K3LR_b57 = 0x2000000;      // b57
    static constexpr uint32_t K3LR_b58 = 0x4000000;      // b58
    static constexpr uint32_t K3LR_b59 = 0x8000000;      // b59
    static constexpr uint32_t K3LR_b60 = 0x10000000;     // b60
    static constexpr uint32_t K3LR_b61 = 0x20000000;     // b61
    static constexpr uint32_t K3LR_b62 = 0x40000000;     // b62
    static constexpr uint32_t K3LR_b63 = 0x80000000;     // b63
    static const uint32_t K3LR_RESET_VALUE = 0x0;

    static constexpr uint32_t K3RR_b0 = 0x1;             // b0
    static constexpr uint32_t K3RR_b1 = 0x2;             // b1
    static constexpr uint32_t K3RR_b2 = 0x4;             // b2
    static constexpr uint32_t K3RR_b3 = 0x8;             // b3
    static constexpr uint32_t K3RR_b4 = 0x10;            // b4
    static constexpr uint32_t K3RR_b5 = 0x20;            // b5
    static constexpr uint32_t K3RR_b6 = 0x40;            // b6
    static constexpr uint32_t K3RR_b7 = 0x80;            // b7
    static constexpr uint32_t K3RR_b8 = 0x100;           // b8
    static constexpr uint32_t K3RR_b9 = 0x200;           // b9
    static constexpr uint32_t K3RR_b10 = 0x400;          // b10
    static constexpr uint32_t K3RR_b11 = 0x800;          // b11
    static constexpr uint32_t K3RR_b12 = 0x1000;         // b12
    static constexpr uint32_t K3RR_b13 = 0x2000;         // b13
    static constexpr uint32_t K3RR_b14 = 0x4000;         // b14
    static constexpr uint32_t K3RR_b15 = 0x8000;         // b15
    static constexpr uint32_t K3RR_b16 = 0x10000;        // b16
    static constexpr uint32_t K3RR_b17 = 0x20000;        // b17
    static constexpr uint32_t K3RR_b18 = 0x40000;        // b18
    static constexpr uint32_t K3RR_b19 = 0x80000;        // b19
    static constexpr uint32_t K3RR_b20 = 0x100000;       // b20
    static constexpr uint32_t K3RR_b21 = 0x200000;       // b21
    static constexpr uint32_t K3RR_b22 = 0x400000;       // b22
    static constexpr uint32_t K3RR_b23 = 0x800000;       // b23
    static constexpr uint32_t K3RR_b24 = 0x1000000;      // b24
    static constexpr uint32_t K3RR_b25 = 0x2000000;      // b25
    static constexpr uint32_t K3RR_b26 = 0x4000000;      // b26
    static constexpr uint32_t K3RR_b27 = 0x8000000;      // b27
    static constexpr uint32_t K3RR_b28 = 0x10000000;     // b28
    static constexpr uint32_t K3RR_b29 = 0x20000000;     // b29
    static constexpr uint32_t K3RR_b30 = 0x40000000;     // b30
    static constexpr uint32_t K3RR_b31 = 0x80000000;     // b31
    static const uint32_t K3RR_RESET_VALUE = 0x0;

    static constexpr uint32_t IV0LR_IV31 = 0x1;           // IV31
    static constexpr uint32_t IV0LR_IV30 = 0x2;           // IV30
    static constexpr uint32_t IV0LR_IV29 = 0x4;           // IV29
    static constexpr uint32_t IV0LR_IV28 = 0x8;           // IV28
    static constexpr uint32_t IV0LR_IV27 = 0x10;          // IV27
    static constexpr uint32_t IV0LR_IV26 = 0x20;          // IV26
    static constexpr uint32_t IV0LR_IV25 = 0x40;          // IV25
    static constexpr uint32_t IV0LR_IV24 = 0x80;          // IV24
    static constexpr uint32_t IV0LR_IV23 = 0x100;         // IV23
    static constexpr uint32_t IV0LR_IV22 = 0x200;         // IV22
    static constexpr uint32_t IV0LR_IV21 = 0x400;         // IV21
    static constexpr uint32_t IV0LR_IV20 = 0x800;         // IV20
    static constexpr uint32_t IV0LR_IV19 = 0x1000;        // IV19
    static constexpr uint32_t IV0LR_IV18 = 0x2000;        // IV18
    static constexpr uint32_t IV0LR_IV17 = 0x4000;        // IV17
    static constexpr uint32_t IV0LR_IV16 = 0x8000;        // IV16
    static constexpr uint32_t IV0LR_IV15 = 0x10000;       // IV15
    static constexpr uint32_t IV0LR_IV14 = 0x20000;       // IV14
    static constexpr uint32_t IV0LR_IV13 = 0x40000;       // IV13
    static constexpr uint32_t IV0LR_IV12 = 0x80000;       // IV12
    static constexpr uint32_t IV0LR_IV11 = 0x100000;      // IV11
    static constexpr uint32_t IV0LR_IV10 = 0x200000;      // IV10
    static constexpr uint32_t IV0LR_IV9 = 0x400000;       // IV9
    static constexpr uint32_t IV0LR_IV8 = 0x800000;       // IV8
    static constexpr uint32_t IV0LR_IV7 = 0x1000000;      // IV7
    static constexpr uint32_t IV0LR_IV6 = 0x2000000;      // IV6
    static constexpr uint32_t IV0LR_IV5 = 0x4000000;      // IV5
    static constexpr uint32_t IV0LR_IV4 = 0x8000000;      // IV4
    static constexpr uint32_t IV0LR_IV3 = 0x10000000;     // IV3
    static constexpr uint32_t IV0LR_IV2 = 0x20000000;     // IV2
    static constexpr uint32_t IV0LR_IV1 = 0x40000000;     // IV1
    static constexpr uint32_t IV0LR_IV0 = 0x80000000;     // IV0
    static const uint32_t IV0LR_RESET_VALUE = 0x0;

    static constexpr uint32_t IV0RR_IV63 = 0x1;           // IV63
    static constexpr uint32_t IV0RR_IV62 = 0x2;           // IV62
    static constexpr uint32_t IV0RR_IV61 = 0x4;           // IV61
    static constexpr uint32_t IV0RR_IV60 = 0x8;           // IV60
    static constexpr uint32_t IV0RR_IV59 = 0x10;          // IV59
    static constexpr uint32_t IV0RR_IV58 = 0x20;          // IV58
    static constexpr uint32_t IV0RR_IV57 = 0x40;          // IV57
    static constexpr uint32_t IV0RR_IV56 = 0x80;          // IV56
    static constexpr uint32_t IV0RR_IV55 = 0x100;         // IV55
    static constexpr uint32_t IV0RR_IV54 = 0x200;         // IV54
    static constexpr uint32_t IV0RR_IV53 = 0x400;         // IV53
    static constexpr uint32_t IV0RR_IV52 = 0x800;         // IV52
    static constexpr uint32_t IV0RR_IV51 = 0x1000;        // IV51
    static constexpr uint32_t IV0RR_IV50 = 0x2000;        // IV50
    static constexpr uint32_t IV0RR_IV49 = 0x4000;        // IV49
    static constexpr uint32_t IV0RR_IV48 = 0x8000;        // IV48
    static constexpr uint32_t IV0RR_IV47 = 0x10000;       // IV47
    static constexpr uint32_t IV0RR_IV46 = 0x20000;       // IV46
    static constexpr uint32_t IV0RR_IV45 = 0x40000;       // IV45
    static constexpr uint32_t IV0RR_IV44 = 0x80000;       // IV44
    static constexpr uint32_t IV0RR_IV43 = 0x100000;      // IV43
    static constexpr uint32_t IV0RR_IV42 = 0x200000;      // IV42
    static constexpr uint32_t IV0RR_IV41 = 0x400000;      // IV41
    static constexpr uint32_t IV0RR_IV40 = 0x800000;      // IV40
    static constexpr uint32_t IV0RR_IV39 = 0x1000000;     // IV39
    static constexpr uint32_t IV0RR_IV38 = 0x2000000;     // IV38
    static constexpr uint32_t IV0RR_IV37 = 0x4000000;     // IV37
    static constexpr uint32_t IV0RR_IV36 = 0x8000000;     // IV36
    static constexpr uint32_t IV0RR_IV35 = 0x10000000;    // IV35
    static constexpr uint32_t IV0RR_IV34 = 0x20000000;    // IV34
    static constexpr uint32_t IV0RR_IV33 = 0x40000000;    // IV33
    static constexpr uint32_t IV0RR_IV32 = 0x80000000;    // IV32
    static const uint32_t IV0RR_RESET_VALUE = 0x0;

    static constexpr uint32_t IV1LR_IV95 = 0x1;           // IV95
    static constexpr uint32_t IV1LR_IV94 = 0x2;           // IV94
    static constexpr uint32_t IV1LR_IV93 = 0x4;           // IV93
    static constexpr uint32_t IV1LR_IV92 = 0x8;           // IV92
    static constexpr uint32_t IV1LR_IV91 = 0x10;          // IV91
    static constexpr uint32_t IV1LR_IV90 = 0x20;          // IV90
    static constexpr uint32_t IV1LR_IV89 = 0x40;          // IV89
    static constexpr uint32_t IV1LR_IV88 = 0x80;          // IV88
    static constexpr uint32_t IV1LR_IV87 = 0x100;         // IV87
    static constexpr uint32_t IV1LR_IV86 = 0x200;         // IV86
    static constexpr uint32_t IV1LR_IV85 = 0x400;         // IV85
    static constexpr uint32_t IV1LR_IV84 = 0x800;         // IV84
    static constexpr uint32_t IV1LR_IV83 = 0x1000;        // IV83
    static constexpr uint32_t IV1LR_IV82 = 0x2000;        // IV82
    static constexpr uint32_t IV1LR_IV81 = 0x4000;        // IV81
    static constexpr uint32_t IV1LR_IV80 = 0x8000;        // IV80
    static constexpr uint32_t IV1LR_IV79 = 0x10000;       // IV79
    static constexpr uint32_t IV1LR_IV78 = 0x20000;       // IV78
    static constexpr uint32_t IV1LR_IV77 = 0x40000;       // IV77
    static constexpr uint32_t IV1LR_IV76 = 0x80000;       // IV76
    static constexpr uint32_t IV1LR_IV75 = 0x100000;      // IV75
    static constexpr uint32_t IV1LR_IV74 = 0x200000;      // IV74
    static constexpr uint32_t IV1LR_IV73 = 0x400000;      // IV73
    static constexpr uint32_t IV1LR_IV72 = 0x800000;      // IV72
    static constexpr uint32_t IV1LR_IV71 = 0x1000000;     // IV71
    static constexpr uint32_t IV1LR_IV70 = 0x2000000;     // IV70
    static constexpr uint32_t IV1LR_IV69 = 0x4000000;     // IV69
    static constexpr uint32_t IV1LR_IV68 = 0x8000000;     // IV68
    static constexpr uint32_t IV1LR_IV67 = 0x10000000;    // IV67
    static constexpr uint32_t IV1LR_IV66 = 0x20000000;    // IV66
    static constexpr uint32_t IV1LR_IV65 = 0x40000000;    // IV65
    static constexpr uint32_t IV1LR_IV64 = 0x80000000;    // IV64
    static const uint32_t IV1LR_RESET_VALUE = 0x0;

    static constexpr uint32_t IV1RR_IV127 = 0x1;          // IV127
    static constexpr uint32_t IV1RR_IV126 = 0x2;          // IV126
    static constexpr uint32_t IV1RR_IV125 = 0x4;          // IV125
    static constexpr uint32_t IV1RR_IV124 = 0x8;          // IV124
    static constexpr uint32_t IV1RR_IV123 = 0x10;         // IV123
    static constexpr uint32_t IV1RR_IV122 = 0x20;         // IV122
    static constexpr uint32_t IV1RR_IV121 = 0x40;         // IV121
    static constexpr uint32_t IV1RR_IV120 = 0x80;         // IV120
    static constexpr uint32_t IV1RR_IV119 = 0x100;        // IV119
    static constexpr uint32_t IV1RR_IV118 = 0x200;        // IV118
    static constexpr uint32_t IV1RR_IV117 = 0x400;        // IV117
    static constexpr uint32_t IV1RR_IV116 = 0x800;        // IV116
    static constexpr uint32_t IV1RR_IV115 = 0x1000;       // IV115
    static constexpr uint32_t IV1RR_IV114 = 0x2000;       // IV114
    static constexpr uint32_t IV1RR_IV113 = 0x4000;       // IV113
    static constexpr uint32_t IV1RR_IV112 = 0x8000;       // IV112
    static constexpr uint32_t IV1RR_IV111 = 0x10000;      // IV111
    static constexpr uint32_t IV1RR_IV110 = 0x20000;      // IV110
    static constexpr uint32_t IV1RR_IV109 = 0x40000;      // IV109
    static constexpr uint32_t IV1RR_IV108 = 0x80000;      // IV108
    static constexpr uint32_t IV1RR_IV107 = 0x100000;     // IV107
    static constexpr uint32_t IV1RR_IV106 = 0x200000;     // IV106
    static constexpr uint32_t IV1RR_IV105 = 0x400000;     // IV105
    static constexpr uint32_t IV1RR_IV104 = 0x800000;     // IV104
    static constexpr uint32_t IV1RR_IV103 = 0x1000000;    // IV103
    static constexpr uint32_t IV1RR_IV102 = 0x2000000;    // IV102
    static constexpr uint32_t IV1RR_IV101 = 0x4000000;    // IV101
    static constexpr uint32_t IV1RR_IV100 = 0x8000000;    // IV100
    static constexpr uint32_t IV1RR_IV99 = 0x10000000;    // IV99
    static constexpr uint32_t IV1RR_IV98 = 0x20000000;    // IV98
    static constexpr uint32_t IV1RR_IV97 = 0x40000000;    // IV97
    static constexpr uint32_t IV1RR_IV96 = 0x80000000;    // IV96
    static const uint32_t IV1RR_RESET_VALUE = 0x0;


    static const uint32_t CSGCMCCM0R_RESET_VALUE = 0x0;


    static const uint32_t CSGCMCCM1R_RESET_VALUE = 0x0;


    static const uint32_t CSGCMCCM2R_RESET_VALUE = 0x0;


    static const uint32_t CSGCMCCM3R_RESET_VALUE = 0x0;


    static const uint32_t CSGCMCCM4R_RESET_VALUE = 0x0;


    static const uint32_t CSGCMCCM5R_RESET_VALUE = 0x0;


    static const uint32_t CSGCMCCM6R_RESET_VALUE = 0x0;


    static const uint32_t CSGCMCCM7R_RESET_VALUE = 0x0;


    static const uint32_t CSGCM0R_RESET_VALUE = 0x0;


    static const uint32_t CSGCM1R_RESET_VALUE = 0x0;


    static const uint32_t CSGCM2R_RESET_VALUE = 0x0;


    static const uint32_t CSGCM3R_RESET_VALUE = 0x0;


    static const uint32_t CSGCM4R_RESET_VALUE = 0x0;


    static const uint32_t CSGCM5R_RESET_VALUE = 0x0;


    static const uint32_t CSGCM6R_RESET_VALUE = 0x0;


    static const uint32_t CSGCM7R_RESET_VALUE = 0x0;

    static constexpr uint8_t CRYP = 79; // CRYP crypto global interrupt
};

static cryp_t& CRYP = *reinterpret_cast<cryp_t*>(0x50060000);

#define HAVE_PERIPHERAL_CRYP


////
//
//    Digital camera interface
//
////

struct dcmi_t
{
    volatile uint32_t    CR;                   // [Read-write] control register 1
    volatile uint32_t    SR;                   // [Read-only] status register
    volatile uint32_t    RIS;                  // [Read-only] raw interrupt status register
    volatile uint32_t    IER;                  // [Read-write] interrupt enable register
    volatile uint32_t    MIS;                  // [Read-only] masked interrupt status register
    volatile uint32_t    ICR;                  // [Write-only] interrupt clear register
    volatile uint32_t    ESCR;                 // [Read-write] embedded synchronization code register
    volatile uint32_t    ESUR;                 // [Read-write] embedded synchronization unmask register
    volatile uint32_t    CWSTRT;               // [Read-write] crop window start
    volatile uint32_t    CWSIZE;               // [Read-write] crop window size
    volatile uint32_t    DR;                   // [Read-only] data register

    static constexpr uint32_t CR_ENABLE = 0x4000;      // DCMI enable
    template<uint32_t X>
    static constexpr uint32_t CR_EDM =                 // Extended data mode (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR_FCRC =                // Frame capture rate control (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t CR_VSPOL = 0x80;         // Vertical synchronization polarity
    static constexpr uint32_t CR_HSPOL = 0x40;         // Horizontal synchronization polarity
    static constexpr uint32_t CR_PCKPOL = 0x20;        // Pixel clock polarity
    static constexpr uint32_t CR_ESS = 0x10;           // Embedded synchronization select
    static constexpr uint32_t CR_JPEG = 0x8;           // JPEG format
    static constexpr uint32_t CR_CROP = 0x4;           // Crop feature
    static constexpr uint32_t CR_CM = 0x2;             // Capture mode
    static constexpr uint32_t CR_CAPTURE = 0x1;        // Capture enable
    static const uint32_t CR_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_FNE = 0x4;            // FIFO not empty
    static constexpr uint32_t SR_VSYNC = 0x2;          // VSYNC
    static constexpr uint32_t SR_HSYNC = 0x1;          // HSYNC
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint32_t RIS_LINE_RIS = 0x10;      // Line raw interrupt status
    static constexpr uint32_t RIS_VSYNC_RIS = 0x8;      // VSYNC raw interrupt status
    static constexpr uint32_t RIS_ERR_RIS = 0x4;        // Synchronization error raw interrupt status
    static constexpr uint32_t RIS_OVR_RIS = 0x2;        // Overrun raw interrupt status
    static constexpr uint32_t RIS_FRAME_RIS = 0x1;      // Capture complete raw interrupt status
    static const uint32_t RIS_RESET_VALUE = 0x0;

    static constexpr uint32_t IER_LINE_IE = 0x10;       // Line interrupt enable
    static constexpr uint32_t IER_VSYNC_IE = 0x8;       // VSYNC interrupt enable
    static constexpr uint32_t IER_ERR_IE = 0x4;         // Synchronization error interrupt enable
    static constexpr uint32_t IER_OVR_IE = 0x2;         // Overrun interrupt enable
    static constexpr uint32_t IER_FRAME_IE = 0x1;       // Capture complete interrupt enable
    static const uint32_t IER_RESET_VALUE = 0x0;

    static constexpr uint32_t MIS_LINE_MIS = 0x10;      // Line masked interrupt status
    static constexpr uint32_t MIS_VSYNC_MIS = 0x8;      // VSYNC masked interrupt status
    static constexpr uint32_t MIS_ERR_MIS = 0x4;        // Synchronization error masked interrupt status
    static constexpr uint32_t MIS_OVR_MIS = 0x2;        // Overrun masked interrupt status
    static constexpr uint32_t MIS_FRAME_MIS = 0x1;      // Capture complete masked interrupt status
    static const uint32_t MIS_RESET_VALUE = 0x0;

    static constexpr uint32_t ICR_LINE_ISC = 0x10;      // line interrupt status clear
    static constexpr uint32_t ICR_VSYNC_ISC = 0x8;      // Vertical synch interrupt status clear
    static constexpr uint32_t ICR_ERR_ISC = 0x4;        // Synchronization error interrupt status clear
    static constexpr uint32_t ICR_OVR_ISC = 0x2;        // Overrun interrupt status clear
    static constexpr uint32_t ICR_FRAME_ISC = 0x1;      // Capture complete interrupt status clear
    static const uint32_t ICR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ESCR_FEC =                 // Frame end delimiter code (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ESCR_LEC =                 // Line end delimiter code (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ESCR_LSC =                 // Line start delimiter code (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ESCR_FSC =                 // Frame start delimiter code (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t ESCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ESUR_FEU =                 // Frame end delimiter unmask (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ESUR_LEU =                 // Line end delimiter unmask (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ESUR_LSU =                 // Line start delimiter unmask (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ESUR_FSU =                 // Frame start delimiter unmask (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t ESUR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CWSTRT_VST =                 // Vertical start line count (13 bits)
        bit_field_t<16, 0x1fff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CWSTRT_HOFFCNT =             // Horizontal offset count (14 bits)
        bit_field_t<0, 0x3fff>::value<X>();
    static const uint32_t CWSTRT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CWSIZE_VLINE =               // Vertical line count (14 bits)
        bit_field_t<16, 0x3fff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CWSIZE_CAPCNT =              // Capture count (14 bits)
        bit_field_t<0, 0x3fff>::value<X>();
    static const uint32_t CWSIZE_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DR_Byte3 =               // Data byte 3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DR_Byte2 =               // Data byte 2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DR_Byte1 =               // Data byte 1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DR_Byte0 =               // Data byte 0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t DR_RESET_VALUE = 0x0;

    static constexpr uint8_t DCMI = 78; // DCMI global interrupt
};

static dcmi_t& DCMI = *reinterpret_cast<dcmi_t*>(0x50050000);

#define HAVE_PERIPHERAL_DCMI


////
//
//    Flexible memory controller
//
////

struct fmc_t
{
    volatile uint32_t    BCR1;                 // [Read-write] SRAM/NOR-Flash chip-select control register 1
    volatile uint32_t    BTR1;                 // [Read-write] SRAM/NOR-Flash chip-select timing register 1
    volatile uint32_t    BCR2;                 // [Read-write] SRAM/NOR-Flash chip-select control register 2
    volatile uint32_t    BTR2;                 // [Read-write] SRAM/NOR-Flash chip-select timing register 2
    volatile uint32_t    BCR3;                 // [Read-write] SRAM/NOR-Flash chip-select control register 3
    volatile uint32_t    BTR3;                 // [Read-write] SRAM/NOR-Flash chip-select timing register 3
    volatile uint32_t    BCR4;                 // [Read-write] SRAM/NOR-Flash chip-select control register 4
    volatile uint32_t    BTR4;                 // [Read-write] SRAM/NOR-Flash chip-select timing register 4
    reserved_t<24>       _0;
    volatile uint32_t    PCR;                  // [Read-write] PC Card/NAND Flash control register
    volatile uint32_t    SR;                   // FIFO status and interrupt register
    volatile uint32_t    PMEM;                 // [Read-write] Common memory space timing register
    volatile uint32_t    PATT;                 // [Read-write] Attribute memory space timing register
    reserved_t<1>        _1;
    volatile uint32_t    ECCR;                 // [Read-only] ECC result register
    reserved_t<27>       _2;
    volatile uint32_t    BWTR1;                // [Read-write] SRAM/NOR-Flash write timing registers 1
    reserved_t<1>        _3;
    volatile uint32_t    BWTR2;                // [Read-write] SRAM/NOR-Flash write timing registers 2
    reserved_t<1>        _4;
    volatile uint32_t    BWTR3;                // [Read-write] SRAM/NOR-Flash write timing registers 3
    reserved_t<1>        _5;
    volatile uint32_t    BWTR4;                // [Read-write] SRAM/NOR-Flash write timing registers 4
    reserved_t<8>        _6;
    volatile uint32_t    SDCR1;                // [Read-write] SDRAM Control Register 1
    volatile uint32_t    SDCR2;                // [Read-write] SDRAM Control Register 2
    volatile uint32_t    SDTR1;                // [Read-write] SDRAM Timing register 1
    volatile uint32_t    SDTR2;                // [Read-write] SDRAM Timing register 2
    volatile uint32_t    SDCMR;                // SDRAM Command Mode register
    volatile uint32_t    SDRTR;                // SDRAM Refresh Timer register
    volatile uint32_t    SDSR;                 // [Read-only] SDRAM Status register

    static constexpr uint32_t BCR1_CCLKEN = 0x100000;    // CCLKEN
    static constexpr uint32_t BCR1_CBURSTRW = 0x80000;   // CBURSTRW
    static constexpr uint32_t BCR1_ASYNCWAIT = 0x8000;   // ASYNCWAIT
    static constexpr uint32_t BCR1_EXTMOD = 0x4000;      // EXTMOD
    static constexpr uint32_t BCR1_WAITEN = 0x2000;      // WAITEN
    static constexpr uint32_t BCR1_WREN = 0x1000;        // WREN
    static constexpr uint32_t BCR1_WAITCFG = 0x800;      // WAITCFG
    static constexpr uint32_t BCR1_WAITPOL = 0x200;      // WAITPOL
    static constexpr uint32_t BCR1_BURSTEN = 0x100;      // BURSTEN
    static constexpr uint32_t BCR1_FACCEN = 0x40;        // FACCEN
    template<uint32_t X>
    static constexpr uint32_t BCR1_MWID =                // MWID (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BCR1_MTYP =                // MTYP (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t BCR1_MUXEN = 0x2;          // MUXEN
    static constexpr uint32_t BCR1_MBKEN = 0x1;          // MBKEN
    static const uint32_t BCR1_RESET_VALUE = 0x30d0;

    template<uint32_t X>
    static constexpr uint32_t BTR1_ACCMOD =              // ACCMOD (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR1_DATLAT =              // DATLAT (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR1_CLKDIV =              // CLKDIV (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR1_BUSTURN =             // BUSTURN (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR1_DATAST =              // DATAST (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR1_ADDHLD =              // ADDHLD (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR1_ADDSET =              // ADDSET (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t BTR1_RESET_VALUE = 0xffffffff;

    static constexpr uint32_t BCR2_CBURSTRW = 0x80000;   // CBURSTRW
    static constexpr uint32_t BCR2_ASYNCWAIT = 0x8000;   // ASYNCWAIT
    static constexpr uint32_t BCR2_EXTMOD = 0x4000;      // EXTMOD
    static constexpr uint32_t BCR2_WAITEN = 0x2000;      // WAITEN
    static constexpr uint32_t BCR2_WREN = 0x1000;        // WREN
    static constexpr uint32_t BCR2_WAITCFG = 0x800;      // WAITCFG
    static constexpr uint32_t BCR2_WRAPMOD = 0x400;      // WRAPMOD
    static constexpr uint32_t BCR2_WAITPOL = 0x200;      // WAITPOL
    static constexpr uint32_t BCR2_BURSTEN = 0x100;      // BURSTEN
    static constexpr uint32_t BCR2_FACCEN = 0x40;        // FACCEN
    template<uint32_t X>
    static constexpr uint32_t BCR2_MWID =                // MWID (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BCR2_MTYP =                // MTYP (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t BCR2_MUXEN = 0x2;          // MUXEN
    static constexpr uint32_t BCR2_MBKEN = 0x1;          // MBKEN
    static const uint32_t BCR2_RESET_VALUE = 0x30d0;

    template<uint32_t X>
    static constexpr uint32_t BTR2_ACCMOD =              // ACCMOD (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR2_DATLAT =              // DATLAT (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR2_CLKDIV =              // CLKDIV (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR2_BUSTURN =             // BUSTURN (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR2_DATAST =              // DATAST (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR2_ADDHLD =              // ADDHLD (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR2_ADDSET =              // ADDSET (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t BTR2_RESET_VALUE = 0xffffffff;

    static constexpr uint32_t BCR3_CBURSTRW = 0x80000;   // CBURSTRW
    static constexpr uint32_t BCR3_ASYNCWAIT = 0x8000;   // ASYNCWAIT
    static constexpr uint32_t BCR3_EXTMOD = 0x4000;      // EXTMOD
    static constexpr uint32_t BCR3_WAITEN = 0x2000;      // WAITEN
    static constexpr uint32_t BCR3_WREN = 0x1000;        // WREN
    static constexpr uint32_t BCR3_WAITCFG = 0x800;      // WAITCFG
    static constexpr uint32_t BCR3_WRAPMOD = 0x400;      // WRAPMOD
    static constexpr uint32_t BCR3_WAITPOL = 0x200;      // WAITPOL
    static constexpr uint32_t BCR3_BURSTEN = 0x100;      // BURSTEN
    static constexpr uint32_t BCR3_FACCEN = 0x40;        // FACCEN
    template<uint32_t X>
    static constexpr uint32_t BCR3_MWID =                // MWID (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BCR3_MTYP =                // MTYP (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t BCR3_MUXEN = 0x2;          // MUXEN
    static constexpr uint32_t BCR3_MBKEN = 0x1;          // MBKEN
    static const uint32_t BCR3_RESET_VALUE = 0x30d0;

    template<uint32_t X>
    static constexpr uint32_t BTR3_ACCMOD =              // ACCMOD (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR3_DATLAT =              // DATLAT (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR3_CLKDIV =              // CLKDIV (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR3_BUSTURN =             // BUSTURN (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR3_DATAST =              // DATAST (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR3_ADDHLD =              // ADDHLD (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR3_ADDSET =              // ADDSET (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t BTR3_RESET_VALUE = 0xffffffff;

    static constexpr uint32_t BCR4_CBURSTRW = 0x80000;   // CBURSTRW
    static constexpr uint32_t BCR4_ASYNCWAIT = 0x8000;   // ASYNCWAIT
    static constexpr uint32_t BCR4_EXTMOD = 0x4000;      // EXTMOD
    static constexpr uint32_t BCR4_WAITEN = 0x2000;      // WAITEN
    static constexpr uint32_t BCR4_WREN = 0x1000;        // WREN
    static constexpr uint32_t BCR4_WAITCFG = 0x800;      // WAITCFG
    static constexpr uint32_t BCR4_WRAPMOD = 0x400;      // WRAPMOD
    static constexpr uint32_t BCR4_WAITPOL = 0x200;      // WAITPOL
    static constexpr uint32_t BCR4_BURSTEN = 0x100;      // BURSTEN
    static constexpr uint32_t BCR4_FACCEN = 0x40;        // FACCEN
    template<uint32_t X>
    static constexpr uint32_t BCR4_MWID =                // MWID (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BCR4_MTYP =                // MTYP (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t BCR4_MUXEN = 0x2;          // MUXEN
    static constexpr uint32_t BCR4_MBKEN = 0x1;          // MBKEN
    static const uint32_t BCR4_RESET_VALUE = 0x30d0;

    template<uint32_t X>
    static constexpr uint32_t BTR4_ACCMOD =              // ACCMOD (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR4_DATLAT =              // DATLAT (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR4_CLKDIV =              // CLKDIV (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR4_BUSTURN =             // BUSTURN (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR4_DATAST =              // DATAST (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR4_ADDHLD =              // ADDHLD (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR4_ADDSET =              // ADDSET (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t BTR4_RESET_VALUE = 0xffffffff;

    template<uint32_t X>
    static constexpr uint32_t PCR_ECCPS =               // ECCPS (3 bits)
        bit_field_t<17, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PCR_TAR =                 // TAR (4 bits)
        bit_field_t<13, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PCR_TCLR =                // TCLR (4 bits)
        bit_field_t<9, 0xf>::value<X>();
    static constexpr uint32_t PCR_ECCEN = 0x40;         // ECCEN
    template<uint32_t X>
    static constexpr uint32_t PCR_PWID =                // PWID (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static constexpr uint32_t PCR_PTYP = 0x8;           // PTYP
    static constexpr uint32_t PCR_PBKEN = 0x4;          // PBKEN
    static constexpr uint32_t PCR_PWAITEN = 0x2;        // PWAITEN
    static const uint32_t PCR_RESET_VALUE = 0x18;

    static constexpr uint32_t SR_FEMPT = 0x40;         // FEMPT, Read-only
    static constexpr uint32_t SR_IFEN = 0x20;          // IFEN, Read-write
    static constexpr uint32_t SR_ILEN = 0x10;          // ILEN, Read-write
    static constexpr uint32_t SR_IREN = 0x8;           // IREN, Read-write
    static constexpr uint32_t SR_IFS = 0x4;            // IFS, Read-write
    static constexpr uint32_t SR_ILS = 0x2;            // ILS, Read-write
    static constexpr uint32_t SR_IRS = 0x1;            // IRS, Read-write
    static const uint32_t SR_RESET_VALUE = 0x40;

    template<uint32_t X>
    static constexpr uint32_t PMEM_MEMHIZx =             // MEMHIZx (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PMEM_MEMHOLDx =            // MEMHOLDx (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PMEM_MEMWAITx =            // MEMWAITx (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PMEM_MEMSETx =             // MEMSETx (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t PMEM_RESET_VALUE = 0xfcfcfcfc;

    template<uint32_t X>
    static constexpr uint32_t PATT_ATTHIZx =             // ATTHIZx (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PATT_ATTHOLDx =            // ATTHOLDx (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PATT_ATTWAITx =            // ATTWAITx (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PATT_ATTSETx =             // ATTSETx (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t PATT_RESET_VALUE = 0xfcfcfcfc;


    static const uint32_t ECCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BWTR1_ACCMOD =              // ACCMOD (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BWTR1_DATLAT =              // DATLAT (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BWTR1_CLKDIV =              // CLKDIV (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BWTR1_DATAST =              // DATAST (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BWTR1_ADDHLD =              // ADDHLD (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BWTR1_ADDSET =              // ADDSET (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t BWTR1_RESET_VALUE = 0xfffffff;

    template<uint32_t X>
    static constexpr uint32_t BWTR2_ACCMOD =              // ACCMOD (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BWTR2_DATLAT =              // DATLAT (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BWTR2_CLKDIV =              // CLKDIV (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BWTR2_DATAST =              // DATAST (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BWTR2_ADDHLD =              // ADDHLD (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BWTR2_ADDSET =              // ADDSET (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t BWTR2_RESET_VALUE = 0xfffffff;

    template<uint32_t X>
    static constexpr uint32_t BWTR3_ACCMOD =              // ACCMOD (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BWTR3_DATLAT =              // DATLAT (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BWTR3_CLKDIV =              // CLKDIV (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BWTR3_DATAST =              // DATAST (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BWTR3_ADDHLD =              // ADDHLD (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BWTR3_ADDSET =              // ADDSET (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t BWTR3_RESET_VALUE = 0xfffffff;

    template<uint32_t X>
    static constexpr uint32_t BWTR4_ACCMOD =              // ACCMOD (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BWTR4_DATLAT =              // DATLAT (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BWTR4_CLKDIV =              // CLKDIV (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BWTR4_DATAST =              // DATAST (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BWTR4_ADDHLD =              // ADDHLD (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BWTR4_ADDSET =              // ADDSET (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t BWTR4_RESET_VALUE = 0xfffffff;

    template<uint32_t X>
    static constexpr uint32_t SDCR1_NC =                  // Number of column address bits (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SDCR1_NR =                  // Number of row address bits (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SDCR1_MWID =                // Memory data bus width (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static constexpr uint32_t SDCR1_NB = 0x40;            // Number of internal banks
    template<uint32_t X>
    static constexpr uint32_t SDCR1_CAS =                 // CAS latency (2 bits)
        bit_field_t<7, 0x3>::value<X>();
    static constexpr uint32_t SDCR1_WP = 0x200;           // Write protection
    template<uint32_t X>
    static constexpr uint32_t SDCR1_SDCLK =               // SDRAM clock configuration (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    static constexpr uint32_t SDCR1_RBURST = 0x1000;      // Burst read
    template<uint32_t X>
    static constexpr uint32_t SDCR1_RPIPE =               // Read pipe (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    static const uint32_t SDCR1_RESET_VALUE = 0x2d0;

    template<uint32_t X>
    static constexpr uint32_t SDCR2_NC =                  // Number of column address bits (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SDCR2_NR =                  // Number of row address bits (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SDCR2_MWID =                // Memory data bus width (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static constexpr uint32_t SDCR2_NB = 0x40;            // Number of internal banks
    template<uint32_t X>
    static constexpr uint32_t SDCR2_CAS =                 // CAS latency (2 bits)
        bit_field_t<7, 0x3>::value<X>();
    static constexpr uint32_t SDCR2_WP = 0x200;           // Write protection
    template<uint32_t X>
    static constexpr uint32_t SDCR2_SDCLK =               // SDRAM clock configuration (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    static constexpr uint32_t SDCR2_RBURST = 0x1000;      // Burst read
    template<uint32_t X>
    static constexpr uint32_t SDCR2_RPIPE =               // Read pipe (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    static const uint32_t SDCR2_RESET_VALUE = 0x2d0;

    template<uint32_t X>
    static constexpr uint32_t SDTR1_TMRD =                // Load Mode Register to Active (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SDTR1_TXSR =                // Exit self-refresh delay (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SDTR1_TRAS =                // Self refresh time (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SDTR1_TRC =                 // Row cycle delay (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SDTR1_TWR =                 // Recovery delay (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SDTR1_TRP =                 // Row precharge delay (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SDTR1_TRCD =                // Row to column delay (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    static const uint32_t SDTR1_RESET_VALUE = 0xfffffff;

    template<uint32_t X>
    static constexpr uint32_t SDTR2_TMRD =                // Load Mode Register to Active (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SDTR2_TXSR =                // Exit self-refresh delay (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SDTR2_TRAS =                // Self refresh time (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SDTR2_TRC =                 // Row cycle delay (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SDTR2_TWR =                 // Recovery delay (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SDTR2_TRP =                 // Row precharge delay (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SDTR2_TRCD =                // Row to column delay (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    static const uint32_t SDTR2_RESET_VALUE = 0xfffffff;

    template<uint32_t X>
    static constexpr uint32_t SDCMR_MODE =                // Command mode (3 bits), Write-only
        bit_field_t<0, 0x7>::value<X>();
    static constexpr uint32_t SDCMR_CTB2 = 0x8;           // Command target bank 2, Write-only
    static constexpr uint32_t SDCMR_CTB1 = 0x10;          // Command target bank 1, Write-only
    template<uint32_t X>
    static constexpr uint32_t SDCMR_NRFS =                // Number of Auto-refresh (4 bits), Read-write
        bit_field_t<5, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SDCMR_MRD =                 // Mode Register definition (13 bits), Read-write
        bit_field_t<9, 0x1fff>::value<X>();
    static const uint32_t SDCMR_RESET_VALUE = 0x0;

    static constexpr uint32_t SDRTR_CRE = 0x1;            // Clear Refresh error flag, Write-only
    template<uint32_t X>
    static constexpr uint32_t SDRTR_COUNT =               // Refresh Timer Count (13 bits), Read-write
        bit_field_t<1, 0x1fff>::value<X>();
    static constexpr uint32_t SDRTR_REIE = 0x4000;        // RES Interrupt Enable, Read-write
    static const uint32_t SDRTR_RESET_VALUE = 0x0;

    static constexpr uint32_t SDSR_RE = 0x1;             // Refresh error flag
    template<uint32_t X>
    static constexpr uint32_t SDSR_MODES1 =              // Status Mode for Bank 1 (2 bits)
        bit_field_t<1, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SDSR_MODES2 =              // Status Mode for Bank 2 (2 bits)
        bit_field_t<3, 0x3>::value<X>();
    static constexpr uint32_t SDSR_BUSY = 0x20;          // Busy status
    static const uint32_t SDSR_RESET_VALUE = 0x0;

    static constexpr uint8_t FMC = 48; // FMC global interrupt
};

static fmc_t& FMC = *reinterpret_cast<fmc_t*>(0xa0000000);

#define HAVE_PERIPHERAL_FMC


////
//
//    DMA controller
//
////

struct dma2_t
{
    volatile uint32_t    LISR;                 // [Read-only] low interrupt status register
    volatile uint32_t    HISR;                 // [Read-only] high interrupt status register
    volatile uint32_t    LIFCR;                // [Read-write] low interrupt flag clear register
    volatile uint32_t    HIFCR;                // [Read-write] high interrupt flag clear register
    volatile uint32_t    S0CR;                 // [Read-write] stream x configuration register
    volatile uint32_t    S0NDTR;               // [Read-write] stream x number of data register
    volatile uint32_t    S0PAR;                // [Read-write] stream x peripheral address register
    volatile uint32_t    S0M0AR;               // [Read-write] stream x memory 0 address register
    volatile uint32_t    S0M1AR;               // [Read-write] stream x memory 1 address register
    volatile uint32_t    S0FCR;                // stream x FIFO control register
    volatile uint32_t    S1CR;                 // [Read-write] stream x configuration register
    volatile uint32_t    S1NDTR;               // [Read-write] stream x number of data register
    volatile uint32_t    S1PAR;                // [Read-write] stream x peripheral address register
    volatile uint32_t    S1M0AR;               // [Read-write] stream x memory 0 address register
    volatile uint32_t    S1M1AR;               // [Read-write] stream x memory 1 address register
    volatile uint32_t    S1FCR;                // stream x FIFO control register
    volatile uint32_t    S2CR;                 // [Read-write] stream x configuration register
    volatile uint32_t    S2NDTR;               // [Read-write] stream x number of data register
    volatile uint32_t    S2PAR;                // [Read-write] stream x peripheral address register
    volatile uint32_t    S2M0AR;               // [Read-write] stream x memory 0 address register
    volatile uint32_t    S2M1AR;               // [Read-write] stream x memory 1 address register
    volatile uint32_t    S2FCR;                // stream x FIFO control register
    volatile uint32_t    S3CR;                 // [Read-write] stream x configuration register
    volatile uint32_t    S3NDTR;               // [Read-write] stream x number of data register
    volatile uint32_t    S3PAR;                // [Read-write] stream x peripheral address register
    volatile uint32_t    S3M0AR;               // [Read-write] stream x memory 0 address register
    volatile uint32_t    S3M1AR;               // [Read-write] stream x memory 1 address register
    volatile uint32_t    S3FCR;                // stream x FIFO control register
    volatile uint32_t    S4CR;                 // [Read-write] stream x configuration register
    volatile uint32_t    S4NDTR;               // [Read-write] stream x number of data register
    volatile uint32_t    S4PAR;                // [Read-write] stream x peripheral address register
    volatile uint32_t    S4M0AR;               // [Read-write] stream x memory 0 address register
    volatile uint32_t    S4M1AR;               // [Read-write] stream x memory 1 address register
    volatile uint32_t    S4FCR;                // stream x FIFO control register
    volatile uint32_t    S5CR;                 // [Read-write] stream x configuration register
    volatile uint32_t    S5NDTR;               // [Read-write] stream x number of data register
    volatile uint32_t    S5PAR;                // [Read-write] stream x peripheral address register
    volatile uint32_t    S5M0AR;               // [Read-write] stream x memory 0 address register
    volatile uint32_t    S5M1AR;               // [Read-write] stream x memory 1 address register
    volatile uint32_t    S5FCR;                // stream x FIFO control register
    volatile uint32_t    S6CR;                 // [Read-write] stream x configuration register
    volatile uint32_t    S6NDTR;               // [Read-write] stream x number of data register
    volatile uint32_t    S6PAR;                // [Read-write] stream x peripheral address register
    volatile uint32_t    S6M0AR;               // [Read-write] stream x memory 0 address register
    volatile uint32_t    S6M1AR;               // [Read-write] stream x memory 1 address register
    volatile uint32_t    S6FCR;                // stream x FIFO control register
    volatile uint32_t    S7CR;                 // [Read-write] stream x configuration register
    volatile uint32_t    S7NDTR;               // [Read-write] stream x number of data register
    volatile uint32_t    S7PAR;                // [Read-write] stream x peripheral address register
    volatile uint32_t    S7M0AR;               // [Read-write] stream x memory 0 address register
    volatile uint32_t    S7M1AR;               // [Read-write] stream x memory 1 address register
    volatile uint32_t    S7FCR;                // stream x FIFO control register

    static constexpr uint32_t LISR_TCIF3 = 0x8000000;    // Stream x transfer complete interrupt flag (x = 3..0)
    static constexpr uint32_t LISR_HTIF3 = 0x4000000;    // Stream x half transfer interrupt flag (x=3..0)
    static constexpr uint32_t LISR_TEIF3 = 0x2000000;    // Stream x transfer error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_DMEIF3 = 0x1000000;   // Stream x direct mode error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_FEIF3 = 0x400000;     // Stream x FIFO error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_TCIF2 = 0x200000;     // Stream x transfer complete interrupt flag (x = 3..0)
    static constexpr uint32_t LISR_HTIF2 = 0x100000;     // Stream x half transfer interrupt flag (x=3..0)
    static constexpr uint32_t LISR_TEIF2 = 0x80000;      // Stream x transfer error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_DMEIF2 = 0x40000;     // Stream x direct mode error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_FEIF2 = 0x10000;      // Stream x FIFO error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_TCIF1 = 0x800;        // Stream x transfer complete interrupt flag (x = 3..0)
    static constexpr uint32_t LISR_HTIF1 = 0x400;        // Stream x half transfer interrupt flag (x=3..0)
    static constexpr uint32_t LISR_TEIF1 = 0x200;        // Stream x transfer error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_DMEIF1 = 0x100;       // Stream x direct mode error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_FEIF1 = 0x40;         // Stream x FIFO error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_TCIF0 = 0x20;         // Stream x transfer complete interrupt flag (x = 3..0)
    static constexpr uint32_t LISR_HTIF0 = 0x10;         // Stream x half transfer interrupt flag (x=3..0)
    static constexpr uint32_t LISR_TEIF0 = 0x8;          // Stream x transfer error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_DMEIF0 = 0x4;         // Stream x direct mode error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_FEIF0 = 0x1;          // Stream x FIFO error interrupt flag (x=3..0)
    static const uint32_t LISR_RESET_VALUE = 0x0;

    static constexpr uint32_t HISR_TCIF7 = 0x8000000;    // Stream x transfer complete interrupt flag (x=7..4)
    static constexpr uint32_t HISR_HTIF7 = 0x4000000;    // Stream x half transfer interrupt flag (x=7..4)
    static constexpr uint32_t HISR_TEIF7 = 0x2000000;    // Stream x transfer error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_DMEIF7 = 0x1000000;   // Stream x direct mode error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_FEIF7 = 0x400000;     // Stream x FIFO error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_TCIF6 = 0x200000;     // Stream x transfer complete interrupt flag (x=7..4)
    static constexpr uint32_t HISR_HTIF6 = 0x100000;     // Stream x half transfer interrupt flag (x=7..4)
    static constexpr uint32_t HISR_TEIF6 = 0x80000;      // Stream x transfer error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_DMEIF6 = 0x40000;     // Stream x direct mode error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_FEIF6 = 0x10000;      // Stream x FIFO error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_TCIF5 = 0x800;        // Stream x transfer complete interrupt flag (x=7..4)
    static constexpr uint32_t HISR_HTIF5 = 0x400;        // Stream x half transfer interrupt flag (x=7..4)
    static constexpr uint32_t HISR_TEIF5 = 0x200;        // Stream x transfer error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_DMEIF5 = 0x100;       // Stream x direct mode error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_FEIF5 = 0x40;         // Stream x FIFO error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_TCIF4 = 0x20;         // Stream x transfer complete interrupt flag (x=7..4)
    static constexpr uint32_t HISR_HTIF4 = 0x10;         // Stream x half transfer interrupt flag (x=7..4)
    static constexpr uint32_t HISR_TEIF4 = 0x8;          // Stream x transfer error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_DMEIF4 = 0x4;         // Stream x direct mode error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_FEIF4 = 0x1;          // Stream x FIFO error interrupt flag (x=7..4)
    static const uint32_t HISR_RESET_VALUE = 0x0;

    static constexpr uint32_t LIFCR_CTCIF3 = 0x8000000;   // Stream x clear transfer complete interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CHTIF3 = 0x4000000;   // Stream x clear half transfer interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CTEIF3 = 0x2000000;   // Stream x clear transfer error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CDMEIF3 = 0x1000000;  // Stream x clear direct mode error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CFEIF3 = 0x400000;    // Stream x clear FIFO error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CTCIF2 = 0x200000;    // Stream x clear transfer complete interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CHTIF2 = 0x100000;    // Stream x clear half transfer interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CTEIF2 = 0x80000;     // Stream x clear transfer error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CDMEIF2 = 0x40000;    // Stream x clear direct mode error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CFEIF2 = 0x10000;     // Stream x clear FIFO error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CTCIF1 = 0x800;       // Stream x clear transfer complete interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CHTIF1 = 0x400;       // Stream x clear half transfer interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CTEIF1 = 0x200;       // Stream x clear transfer error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CDMEIF1 = 0x100;      // Stream x clear direct mode error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CFEIF1 = 0x40;        // Stream x clear FIFO error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CTCIF0 = 0x20;        // Stream x clear transfer complete interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CHTIF0 = 0x10;        // Stream x clear half transfer interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CTEIF0 = 0x8;         // Stream x clear transfer error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CDMEIF0 = 0x4;        // Stream x clear direct mode error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CFEIF0 = 0x1;         // Stream x clear FIFO error interrupt flag (x = 3..0)
    static const uint32_t LIFCR_RESET_VALUE = 0x0;

    static constexpr uint32_t HIFCR_CTCIF7 = 0x8000000;   // Stream x clear transfer complete interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CHTIF7 = 0x4000000;   // Stream x clear half transfer interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CTEIF7 = 0x2000000;   // Stream x clear transfer error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CDMEIF7 = 0x1000000;  // Stream x clear direct mode error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CFEIF7 = 0x400000;    // Stream x clear FIFO error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CTCIF6 = 0x200000;    // Stream x clear transfer complete interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CHTIF6 = 0x100000;    // Stream x clear half transfer interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CTEIF6 = 0x80000;     // Stream x clear transfer error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CDMEIF6 = 0x40000;    // Stream x clear direct mode error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CFEIF6 = 0x10000;     // Stream x clear FIFO error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CTCIF5 = 0x800;       // Stream x clear transfer complete interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CHTIF5 = 0x400;       // Stream x clear half transfer interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CTEIF5 = 0x200;       // Stream x clear transfer error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CDMEIF5 = 0x100;      // Stream x clear direct mode error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CFEIF5 = 0x40;        // Stream x clear FIFO error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CTCIF4 = 0x20;        // Stream x clear transfer complete interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CHTIF4 = 0x10;        // Stream x clear half transfer interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CTEIF4 = 0x8;         // Stream x clear transfer error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CDMEIF4 = 0x4;        // Stream x clear direct mode error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CFEIF4 = 0x1;         // Stream x clear FIFO error interrupt flag (x = 7..4)
    static const uint32_t HIFCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t S0CR_CHSEL =               // Channel selection (4 bits)
        bit_field_t<25, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S0CR_MBURST =              // Memory burst transfer configuration (2 bits)
        bit_field_t<23, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S0CR_PBURST =              // Peripheral burst transfer configuration (2 bits)
        bit_field_t<21, 0x3>::value<X>();
    static constexpr uint32_t S0CR_CT = 0x80000;         // Current target (only in double buffer mode)
    static constexpr uint32_t S0CR_DBM = 0x40000;        // Double buffer mode
    template<uint32_t X>
    static constexpr uint32_t S0CR_PL =                  // Priority level (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    static constexpr uint32_t S0CR_PINCOS = 0x8000;      // Peripheral increment offset size
    template<uint32_t X>
    static constexpr uint32_t S0CR_MSIZE =               // Memory data size (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S0CR_PSIZE =               // Peripheral data size (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    static constexpr uint32_t S0CR_MINC = 0x400;         // Memory increment mode
    static constexpr uint32_t S0CR_PINC = 0x200;         // Peripheral increment mode
    static constexpr uint32_t S0CR_CIRC = 0x100;         // Circular mode
    template<uint32_t X>
    static constexpr uint32_t S0CR_DIR =                 // Data transfer direction (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t S0CR_PFCTRL = 0x20;        // Peripheral flow controller
    static constexpr uint32_t S0CR_TCIE = 0x10;          // Transfer complete interrupt enable
    static constexpr uint32_t S0CR_HTIE = 0x8;           // Half transfer interrupt enable
    static constexpr uint32_t S0CR_TEIE = 0x4;           // Transfer error interrupt enable
    static constexpr uint32_t S0CR_DMEIE = 0x2;          // Direct mode error interrupt enable
    static constexpr uint32_t S0CR_EN = 0x1;             // Stream enable / flag stream ready when read low
    static const uint32_t S0CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t S0NDTR_NDT =                 // Number of data items to transfer (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t S0NDTR_RESET_VALUE = 0x0;


    static const uint32_t S0PAR_RESET_VALUE = 0x0;


    static const uint32_t S0M0AR_RESET_VALUE = 0x0;


    static const uint32_t S0M1AR_RESET_VALUE = 0x0;

    static constexpr uint32_t S0FCR_FEIE = 0x80;          // FIFO error interrupt enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S0FCR_FS =                  // FIFO status (3 bits), Read-only
        bit_field_t<3, 0x7>::value<X>();
    static constexpr uint32_t S0FCR_DMDIS = 0x4;          // Direct mode disable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S0FCR_FTH =                 // FIFO threshold selection (2 bits), Read-write
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t S0FCR_RESET_VALUE = 0x21;

    template<uint32_t X>
    static constexpr uint32_t S1CR_CHSEL =               // Channel selection (4 bits)
        bit_field_t<25, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S1CR_MBURST =              // Memory burst transfer configuration (2 bits)
        bit_field_t<23, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S1CR_PBURST =              // Peripheral burst transfer configuration (2 bits)
        bit_field_t<21, 0x3>::value<X>();
    static constexpr uint32_t S1CR_ACK = 0x100000;       // ACK
    static constexpr uint32_t S1CR_CT = 0x80000;         // Current target (only in double buffer mode)
    static constexpr uint32_t S1CR_DBM = 0x40000;        // Double buffer mode
    template<uint32_t X>
    static constexpr uint32_t S1CR_PL =                  // Priority level (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    static constexpr uint32_t S1CR_PINCOS = 0x8000;      // Peripheral increment offset size
    template<uint32_t X>
    static constexpr uint32_t S1CR_MSIZE =               // Memory data size (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S1CR_PSIZE =               // Peripheral data size (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    static constexpr uint32_t S1CR_MINC = 0x400;         // Memory increment mode
    static constexpr uint32_t S1CR_PINC = 0x200;         // Peripheral increment mode
    static constexpr uint32_t S1CR_CIRC = 0x100;         // Circular mode
    template<uint32_t X>
    static constexpr uint32_t S1CR_DIR =                 // Data transfer direction (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t S1CR_PFCTRL = 0x20;        // Peripheral flow controller
    static constexpr uint32_t S1CR_TCIE = 0x10;          // Transfer complete interrupt enable
    static constexpr uint32_t S1CR_HTIE = 0x8;           // Half transfer interrupt enable
    static constexpr uint32_t S1CR_TEIE = 0x4;           // Transfer error interrupt enable
    static constexpr uint32_t S1CR_DMEIE = 0x2;          // Direct mode error interrupt enable
    static constexpr uint32_t S1CR_EN = 0x1;             // Stream enable / flag stream ready when read low
    static const uint32_t S1CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t S1NDTR_NDT =                 // Number of data items to transfer (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t S1NDTR_RESET_VALUE = 0x0;


    static const uint32_t S1PAR_RESET_VALUE = 0x0;


    static const uint32_t S1M0AR_RESET_VALUE = 0x0;


    static const uint32_t S1M1AR_RESET_VALUE = 0x0;

    static constexpr uint32_t S1FCR_FEIE = 0x80;          // FIFO error interrupt enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S1FCR_FS =                  // FIFO status (3 bits), Read-only
        bit_field_t<3, 0x7>::value<X>();
    static constexpr uint32_t S1FCR_DMDIS = 0x4;          // Direct mode disable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S1FCR_FTH =                 // FIFO threshold selection (2 bits), Read-write
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t S1FCR_RESET_VALUE = 0x21;

    template<uint32_t X>
    static constexpr uint32_t S2CR_CHSEL =               // Channel selection (4 bits)
        bit_field_t<25, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S2CR_MBURST =              // Memory burst transfer configuration (2 bits)
        bit_field_t<23, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S2CR_PBURST =              // Peripheral burst transfer configuration (2 bits)
        bit_field_t<21, 0x3>::value<X>();
    static constexpr uint32_t S2CR_ACK = 0x100000;       // ACK
    static constexpr uint32_t S2CR_CT = 0x80000;         // Current target (only in double buffer mode)
    static constexpr uint32_t S2CR_DBM = 0x40000;        // Double buffer mode
    template<uint32_t X>
    static constexpr uint32_t S2CR_PL =                  // Priority level (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    static constexpr uint32_t S2CR_PINCOS = 0x8000;      // Peripheral increment offset size
    template<uint32_t X>
    static constexpr uint32_t S2CR_MSIZE =               // Memory data size (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S2CR_PSIZE =               // Peripheral data size (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    static constexpr uint32_t S2CR_MINC = 0x400;         // Memory increment mode
    static constexpr uint32_t S2CR_PINC = 0x200;         // Peripheral increment mode
    static constexpr uint32_t S2CR_CIRC = 0x100;         // Circular mode
    template<uint32_t X>
    static constexpr uint32_t S2CR_DIR =                 // Data transfer direction (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t S2CR_PFCTRL = 0x20;        // Peripheral flow controller
    static constexpr uint32_t S2CR_TCIE = 0x10;          // Transfer complete interrupt enable
    static constexpr uint32_t S2CR_HTIE = 0x8;           // Half transfer interrupt enable
    static constexpr uint32_t S2CR_TEIE = 0x4;           // Transfer error interrupt enable
    static constexpr uint32_t S2CR_DMEIE = 0x2;          // Direct mode error interrupt enable
    static constexpr uint32_t S2CR_EN = 0x1;             // Stream enable / flag stream ready when read low
    static const uint32_t S2CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t S2NDTR_NDT =                 // Number of data items to transfer (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t S2NDTR_RESET_VALUE = 0x0;


    static const uint32_t S2PAR_RESET_VALUE = 0x0;


    static const uint32_t S2M0AR_RESET_VALUE = 0x0;


    static const uint32_t S2M1AR_RESET_VALUE = 0x0;

    static constexpr uint32_t S2FCR_FEIE = 0x80;          // FIFO error interrupt enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S2FCR_FS =                  // FIFO status (3 bits), Read-only
        bit_field_t<3, 0x7>::value<X>();
    static constexpr uint32_t S2FCR_DMDIS = 0x4;          // Direct mode disable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S2FCR_FTH =                 // FIFO threshold selection (2 bits), Read-write
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t S2FCR_RESET_VALUE = 0x21;

    template<uint32_t X>
    static constexpr uint32_t S3CR_CHSEL =               // Channel selection (4 bits)
        bit_field_t<25, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S3CR_MBURST =              // Memory burst transfer configuration (2 bits)
        bit_field_t<23, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S3CR_PBURST =              // Peripheral burst transfer configuration (2 bits)
        bit_field_t<21, 0x3>::value<X>();
    static constexpr uint32_t S3CR_ACK = 0x100000;       // ACK
    static constexpr uint32_t S3CR_CT = 0x80000;         // Current target (only in double buffer mode)
    static constexpr uint32_t S3CR_DBM = 0x40000;        // Double buffer mode
    template<uint32_t X>
    static constexpr uint32_t S3CR_PL =                  // Priority level (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    static constexpr uint32_t S3CR_PINCOS = 0x8000;      // Peripheral increment offset size
    template<uint32_t X>
    static constexpr uint32_t S3CR_MSIZE =               // Memory data size (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S3CR_PSIZE =               // Peripheral data size (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    static constexpr uint32_t S3CR_MINC = 0x400;         // Memory increment mode
    static constexpr uint32_t S3CR_PINC = 0x200;         // Peripheral increment mode
    static constexpr uint32_t S3CR_CIRC = 0x100;         // Circular mode
    template<uint32_t X>
    static constexpr uint32_t S3CR_DIR =                 // Data transfer direction (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t S3CR_PFCTRL = 0x20;        // Peripheral flow controller
    static constexpr uint32_t S3CR_TCIE = 0x10;          // Transfer complete interrupt enable
    static constexpr uint32_t S3CR_HTIE = 0x8;           // Half transfer interrupt enable
    static constexpr uint32_t S3CR_TEIE = 0x4;           // Transfer error interrupt enable
    static constexpr uint32_t S3CR_DMEIE = 0x2;          // Direct mode error interrupt enable
    static constexpr uint32_t S3CR_EN = 0x1;             // Stream enable / flag stream ready when read low
    static const uint32_t S3CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t S3NDTR_NDT =                 // Number of data items to transfer (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t S3NDTR_RESET_VALUE = 0x0;


    static const uint32_t S3PAR_RESET_VALUE = 0x0;


    static const uint32_t S3M0AR_RESET_VALUE = 0x0;


    static const uint32_t S3M1AR_RESET_VALUE = 0x0;

    static constexpr uint32_t S3FCR_FEIE = 0x80;          // FIFO error interrupt enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S3FCR_FS =                  // FIFO status (3 bits), Read-only
        bit_field_t<3, 0x7>::value<X>();
    static constexpr uint32_t S3FCR_DMDIS = 0x4;          // Direct mode disable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S3FCR_FTH =                 // FIFO threshold selection (2 bits), Read-write
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t S3FCR_RESET_VALUE = 0x21;

    template<uint32_t X>
    static constexpr uint32_t S4CR_CHSEL =               // Channel selection (3 bits)
        bit_field_t<25, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S4CR_MBURST =              // Memory burst transfer configuration (2 bits)
        bit_field_t<23, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S4CR_PBURST =              // Peripheral burst transfer configuration (2 bits)
        bit_field_t<21, 0x3>::value<X>();
    static constexpr uint32_t S4CR_ACK = 0x100000;       // ACK
    static constexpr uint32_t S4CR_CT = 0x80000;         // Current target (only in double buffer mode)
    static constexpr uint32_t S4CR_DBM = 0x40000;        // Double buffer mode
    template<uint32_t X>
    static constexpr uint32_t S4CR_PL =                  // Priority level (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    static constexpr uint32_t S4CR_PINCOS = 0x8000;      // Peripheral increment offset size
    template<uint32_t X>
    static constexpr uint32_t S4CR_MSIZE =               // Memory data size (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S4CR_PSIZE =               // Peripheral data size (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    static constexpr uint32_t S4CR_MINC = 0x400;         // Memory increment mode
    static constexpr uint32_t S4CR_PINC = 0x200;         // Peripheral increment mode
    static constexpr uint32_t S4CR_CIRC = 0x100;         // Circular mode
    template<uint32_t X>
    static constexpr uint32_t S4CR_DIR =                 // Data transfer direction (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t S4CR_PFCTRL = 0x20;        // Peripheral flow controller
    static constexpr uint32_t S4CR_TCIE = 0x10;          // Transfer complete interrupt enable
    static constexpr uint32_t S4CR_HTIE = 0x8;           // Half transfer interrupt enable
    static constexpr uint32_t S4CR_TEIE = 0x4;           // Transfer error interrupt enable
    static constexpr uint32_t S4CR_DMEIE = 0x2;          // Direct mode error interrupt enable
    static constexpr uint32_t S4CR_EN = 0x1;             // Stream enable / flag stream ready when read low
    static const uint32_t S4CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t S4NDTR_NDT =                 // Number of data items to transfer (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t S4NDTR_RESET_VALUE = 0x0;


    static const uint32_t S4PAR_RESET_VALUE = 0x0;


    static const uint32_t S4M0AR_RESET_VALUE = 0x0;


    static const uint32_t S4M1AR_RESET_VALUE = 0x0;

    static constexpr uint32_t S4FCR_FEIE = 0x80;          // FIFO error interrupt enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S4FCR_FS =                  // FIFO status (3 bits), Read-only
        bit_field_t<3, 0x7>::value<X>();
    static constexpr uint32_t S4FCR_DMDIS = 0x4;          // Direct mode disable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S4FCR_FTH =                 // FIFO threshold selection (2 bits), Read-write
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t S4FCR_RESET_VALUE = 0x21;

    template<uint32_t X>
    static constexpr uint32_t S5CR_CHSEL =               // Channel selection (4 bits)
        bit_field_t<25, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S5CR_MBURST =              // Memory burst transfer configuration (2 bits)
        bit_field_t<23, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S5CR_PBURST =              // Peripheral burst transfer configuration (2 bits)
        bit_field_t<21, 0x3>::value<X>();
    static constexpr uint32_t S5CR_ACK = 0x100000;       // ACK
    static constexpr uint32_t S5CR_CT = 0x80000;         // Current target (only in double buffer mode)
    static constexpr uint32_t S5CR_DBM = 0x40000;        // Double buffer mode
    template<uint32_t X>
    static constexpr uint32_t S5CR_PL =                  // Priority level (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    static constexpr uint32_t S5CR_PINCOS = 0x8000;      // Peripheral increment offset size
    template<uint32_t X>
    static constexpr uint32_t S5CR_MSIZE =               // Memory data size (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S5CR_PSIZE =               // Peripheral data size (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    static constexpr uint32_t S5CR_MINC = 0x400;         // Memory increment mode
    static constexpr uint32_t S5CR_PINC = 0x200;         // Peripheral increment mode
    static constexpr uint32_t S5CR_CIRC = 0x100;         // Circular mode
    template<uint32_t X>
    static constexpr uint32_t S5CR_DIR =                 // Data transfer direction (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t S5CR_PFCTRL = 0x20;        // Peripheral flow controller
    static constexpr uint32_t S5CR_TCIE = 0x10;          // Transfer complete interrupt enable
    static constexpr uint32_t S5CR_HTIE = 0x8;           // Half transfer interrupt enable
    static constexpr uint32_t S5CR_TEIE = 0x4;           // Transfer error interrupt enable
    static constexpr uint32_t S5CR_DMEIE = 0x2;          // Direct mode error interrupt enable
    static constexpr uint32_t S5CR_EN = 0x1;             // Stream enable / flag stream ready when read low
    static const uint32_t S5CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t S5NDTR_NDT =                 // Number of data items to transfer (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t S5NDTR_RESET_VALUE = 0x0;


    static const uint32_t S5PAR_RESET_VALUE = 0x0;


    static const uint32_t S5M0AR_RESET_VALUE = 0x0;


    static const uint32_t S5M1AR_RESET_VALUE = 0x0;

    static constexpr uint32_t S5FCR_FEIE = 0x80;          // FIFO error interrupt enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S5FCR_FS =                  // FIFO status (3 bits), Read-only
        bit_field_t<3, 0x7>::value<X>();
    static constexpr uint32_t S5FCR_DMDIS = 0x4;          // Direct mode disable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S5FCR_FTH =                 // FIFO threshold selection (2 bits), Read-write
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t S5FCR_RESET_VALUE = 0x21;

    template<uint32_t X>
    static constexpr uint32_t S6CR_CHSEL =               // Channel selection (4 bits)
        bit_field_t<25, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S6CR_MBURST =              // Memory burst transfer configuration (2 bits)
        bit_field_t<23, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S6CR_PBURST =              // Peripheral burst transfer configuration (2 bits)
        bit_field_t<21, 0x3>::value<X>();
    static constexpr uint32_t S6CR_ACK = 0x100000;       // ACK
    static constexpr uint32_t S6CR_CT = 0x80000;         // Current target (only in double buffer mode)
    static constexpr uint32_t S6CR_DBM = 0x40000;        // Double buffer mode
    template<uint32_t X>
    static constexpr uint32_t S6CR_PL =                  // Priority level (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    static constexpr uint32_t S6CR_PINCOS = 0x8000;      // Peripheral increment offset size
    template<uint32_t X>
    static constexpr uint32_t S6CR_MSIZE =               // Memory data size (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S6CR_PSIZE =               // Peripheral data size (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    static constexpr uint32_t S6CR_MINC = 0x400;         // Memory increment mode
    static constexpr uint32_t S6CR_PINC = 0x200;         // Peripheral increment mode
    static constexpr uint32_t S6CR_CIRC = 0x100;         // Circular mode
    template<uint32_t X>
    static constexpr uint32_t S6CR_DIR =                 // Data transfer direction (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t S6CR_PFCTRL = 0x20;        // Peripheral flow controller
    static constexpr uint32_t S6CR_TCIE = 0x10;          // Transfer complete interrupt enable
    static constexpr uint32_t S6CR_HTIE = 0x8;           // Half transfer interrupt enable
    static constexpr uint32_t S6CR_TEIE = 0x4;           // Transfer error interrupt enable
    static constexpr uint32_t S6CR_DMEIE = 0x2;          // Direct mode error interrupt enable
    static constexpr uint32_t S6CR_EN = 0x1;             // Stream enable / flag stream ready when read low
    static const uint32_t S6CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t S6NDTR_NDT =                 // Number of data items to transfer (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t S6NDTR_RESET_VALUE = 0x0;


    static const uint32_t S6PAR_RESET_VALUE = 0x0;


    static const uint32_t S6M0AR_RESET_VALUE = 0x0;


    static const uint32_t S6M1AR_RESET_VALUE = 0x0;

    static constexpr uint32_t S6FCR_FEIE = 0x80;          // FIFO error interrupt enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S6FCR_FS =                  // FIFO status (3 bits), Read-only
        bit_field_t<3, 0x7>::value<X>();
    static constexpr uint32_t S6FCR_DMDIS = 0x4;          // Direct mode disable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S6FCR_FTH =                 // FIFO threshold selection (2 bits), Read-write
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t S6FCR_RESET_VALUE = 0x21;

    template<uint32_t X>
    static constexpr uint32_t S7CR_CHSEL =               // Channel selection (4 bits)
        bit_field_t<25, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S7CR_MBURST =              // Memory burst transfer configuration (2 bits)
        bit_field_t<23, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S7CR_PBURST =              // Peripheral burst transfer configuration (2 bits)
        bit_field_t<21, 0x3>::value<X>();
    static constexpr uint32_t S7CR_ACK = 0x100000;       // ACK
    static constexpr uint32_t S7CR_CT = 0x80000;         // Current target (only in double buffer mode)
    static constexpr uint32_t S7CR_DBM = 0x40000;        // Double buffer mode
    template<uint32_t X>
    static constexpr uint32_t S7CR_PL =                  // Priority level (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    static constexpr uint32_t S7CR_PINCOS = 0x8000;      // Peripheral increment offset size
    template<uint32_t X>
    static constexpr uint32_t S7CR_MSIZE =               // Memory data size (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S7CR_PSIZE =               // Peripheral data size (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    static constexpr uint32_t S7CR_MINC = 0x400;         // Memory increment mode
    static constexpr uint32_t S7CR_PINC = 0x200;         // Peripheral increment mode
    static constexpr uint32_t S7CR_CIRC = 0x100;         // Circular mode
    template<uint32_t X>
    static constexpr uint32_t S7CR_DIR =                 // Data transfer direction (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t S7CR_PFCTRL = 0x20;        // Peripheral flow controller
    static constexpr uint32_t S7CR_TCIE = 0x10;          // Transfer complete interrupt enable
    static constexpr uint32_t S7CR_HTIE = 0x8;           // Half transfer interrupt enable
    static constexpr uint32_t S7CR_TEIE = 0x4;           // Transfer error interrupt enable
    static constexpr uint32_t S7CR_DMEIE = 0x2;          // Direct mode error interrupt enable
    static constexpr uint32_t S7CR_EN = 0x1;             // Stream enable / flag stream ready when read low
    static const uint32_t S7CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t S7NDTR_NDT =                 // Number of data items to transfer (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t S7NDTR_RESET_VALUE = 0x0;


    static const uint32_t S7PAR_RESET_VALUE = 0x0;


    static const uint32_t S7M0AR_RESET_VALUE = 0x0;


    static const uint32_t S7M1AR_RESET_VALUE = 0x0;

    static constexpr uint32_t S7FCR_FEIE = 0x80;          // FIFO error interrupt enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S7FCR_FS =                  // FIFO status (3 bits), Read-only
        bit_field_t<3, 0x7>::value<X>();
    static constexpr uint32_t S7FCR_DMDIS = 0x4;          // Direct mode disable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S7FCR_FTH =                 // FIFO threshold selection (2 bits), Read-write
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t S7FCR_RESET_VALUE = 0x21;

    static constexpr uint8_t DMA2_STREAM0 = 56; // DMA2 Stream0 global interrupt
    static constexpr uint8_t DMA2_STREAM1 = 57; // DMA2 Stream1 global interrupt
    static constexpr uint8_t DMA2_STREAM2 = 58; // DMA2 Stream2 global interrupt
    static constexpr uint8_t DMA2_STREAM3 = 59; // DMA2 Stream3 global interrupt
    static constexpr uint8_t DMA2_STREAM4 = 60; // DMA2 Stream4 global interrupt
    static constexpr uint8_t DMA2_STREAM5 = 68; // DMA2 Stream5 global interrupt
    static constexpr uint8_t DMA2_STREAM6 = 69; // DMA2 Stream6 global interrupt
    static constexpr uint8_t DMA2_STREAM7 = 70; // DMA2 Stream7 global interrupt
};

static dma2_t& DMA2 = *reinterpret_cast<dma2_t*>(0x40026400);

#define HAVE_PERIPHERAL_DMA2


////
//
//    DMA controller
//
////

struct dma1_t
{
    volatile uint32_t    LISR;                 // [Read-only] low interrupt status register
    volatile uint32_t    HISR;                 // [Read-only] high interrupt status register
    volatile uint32_t    LIFCR;                // [Read-write] low interrupt flag clear register
    volatile uint32_t    HIFCR;                // [Read-write] high interrupt flag clear register
    volatile uint32_t    S0CR;                 // [Read-write] stream x configuration register
    volatile uint32_t    S0NDTR;               // [Read-write] stream x number of data register
    volatile uint32_t    S0PAR;                // [Read-write] stream x peripheral address register
    volatile uint32_t    S0M0AR;               // [Read-write] stream x memory 0 address register
    volatile uint32_t    S0M1AR;               // [Read-write] stream x memory 1 address register
    volatile uint32_t    S0FCR;                // stream x FIFO control register
    volatile uint32_t    S1CR;                 // [Read-write] stream x configuration register
    volatile uint32_t    S1NDTR;               // [Read-write] stream x number of data register
    volatile uint32_t    S1PAR;                // [Read-write] stream x peripheral address register
    volatile uint32_t    S1M0AR;               // [Read-write] stream x memory 0 address register
    volatile uint32_t    S1M1AR;               // [Read-write] stream x memory 1 address register
    volatile uint32_t    S1FCR;                // stream x FIFO control register
    volatile uint32_t    S2CR;                 // [Read-write] stream x configuration register
    volatile uint32_t    S2NDTR;               // [Read-write] stream x number of data register
    volatile uint32_t    S2PAR;                // [Read-write] stream x peripheral address register
    volatile uint32_t    S2M0AR;               // [Read-write] stream x memory 0 address register
    volatile uint32_t    S2M1AR;               // [Read-write] stream x memory 1 address register
    volatile uint32_t    S2FCR;                // stream x FIFO control register
    volatile uint32_t    S3CR;                 // [Read-write] stream x configuration register
    volatile uint32_t    S3NDTR;               // [Read-write] stream x number of data register
    volatile uint32_t    S3PAR;                // [Read-write] stream x peripheral address register
    volatile uint32_t    S3M0AR;               // [Read-write] stream x memory 0 address register
    volatile uint32_t    S3M1AR;               // [Read-write] stream x memory 1 address register
    volatile uint32_t    S3FCR;                // stream x FIFO control register
    volatile uint32_t    S4CR;                 // [Read-write] stream x configuration register
    volatile uint32_t    S4NDTR;               // [Read-write] stream x number of data register
    volatile uint32_t    S4PAR;                // [Read-write] stream x peripheral address register
    volatile uint32_t    S4M0AR;               // [Read-write] stream x memory 0 address register
    volatile uint32_t    S4M1AR;               // [Read-write] stream x memory 1 address register
    volatile uint32_t    S4FCR;                // stream x FIFO control register
    volatile uint32_t    S5CR;                 // [Read-write] stream x configuration register
    volatile uint32_t    S5NDTR;               // [Read-write] stream x number of data register
    volatile uint32_t    S5PAR;                // [Read-write] stream x peripheral address register
    volatile uint32_t    S5M0AR;               // [Read-write] stream x memory 0 address register
    volatile uint32_t    S5M1AR;               // [Read-write] stream x memory 1 address register
    volatile uint32_t    S5FCR;                // stream x FIFO control register
    volatile uint32_t    S6CR;                 // [Read-write] stream x configuration register
    volatile uint32_t    S6NDTR;               // [Read-write] stream x number of data register
    volatile uint32_t    S6PAR;                // [Read-write] stream x peripheral address register
    volatile uint32_t    S6M0AR;               // [Read-write] stream x memory 0 address register
    volatile uint32_t    S6M1AR;               // [Read-write] stream x memory 1 address register
    volatile uint32_t    S6FCR;                // stream x FIFO control register
    volatile uint32_t    S7CR;                 // [Read-write] stream x configuration register
    volatile uint32_t    S7NDTR;               // [Read-write] stream x number of data register
    volatile uint32_t    S7PAR;                // [Read-write] stream x peripheral address register
    volatile uint32_t    S7M0AR;               // [Read-write] stream x memory 0 address register
    volatile uint32_t    S7M1AR;               // [Read-write] stream x memory 1 address register
    volatile uint32_t    S7FCR;                // stream x FIFO control register

    static constexpr uint32_t LISR_TCIF3 = 0x8000000;    // Stream x transfer complete interrupt flag (x = 3..0)
    static constexpr uint32_t LISR_HTIF3 = 0x4000000;    // Stream x half transfer interrupt flag (x=3..0)
    static constexpr uint32_t LISR_TEIF3 = 0x2000000;    // Stream x transfer error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_DMEIF3 = 0x1000000;   // Stream x direct mode error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_FEIF3 = 0x400000;     // Stream x FIFO error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_TCIF2 = 0x200000;     // Stream x transfer complete interrupt flag (x = 3..0)
    static constexpr uint32_t LISR_HTIF2 = 0x100000;     // Stream x half transfer interrupt flag (x=3..0)
    static constexpr uint32_t LISR_TEIF2 = 0x80000;      // Stream x transfer error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_DMEIF2 = 0x40000;     // Stream x direct mode error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_FEIF2 = 0x10000;      // Stream x FIFO error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_TCIF1 = 0x800;        // Stream x transfer complete interrupt flag (x = 3..0)
    static constexpr uint32_t LISR_HTIF1 = 0x400;        // Stream x half transfer interrupt flag (x=3..0)
    static constexpr uint32_t LISR_TEIF1 = 0x200;        // Stream x transfer error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_DMEIF1 = 0x100;       // Stream x direct mode error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_FEIF1 = 0x40;         // Stream x FIFO error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_TCIF0 = 0x20;         // Stream x transfer complete interrupt flag (x = 3..0)
    static constexpr uint32_t LISR_HTIF0 = 0x10;         // Stream x half transfer interrupt flag (x=3..0)
    static constexpr uint32_t LISR_TEIF0 = 0x8;          // Stream x transfer error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_DMEIF0 = 0x4;         // Stream x direct mode error interrupt flag (x=3..0)
    static constexpr uint32_t LISR_FEIF0 = 0x1;          // Stream x FIFO error interrupt flag (x=3..0)
    static const uint32_t LISR_RESET_VALUE = 0x0;

    static constexpr uint32_t HISR_TCIF7 = 0x8000000;    // Stream x transfer complete interrupt flag (x=7..4)
    static constexpr uint32_t HISR_HTIF7 = 0x4000000;    // Stream x half transfer interrupt flag (x=7..4)
    static constexpr uint32_t HISR_TEIF7 = 0x2000000;    // Stream x transfer error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_DMEIF7 = 0x1000000;   // Stream x direct mode error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_FEIF7 = 0x400000;     // Stream x FIFO error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_TCIF6 = 0x200000;     // Stream x transfer complete interrupt flag (x=7..4)
    static constexpr uint32_t HISR_HTIF6 = 0x100000;     // Stream x half transfer interrupt flag (x=7..4)
    static constexpr uint32_t HISR_TEIF6 = 0x80000;      // Stream x transfer error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_DMEIF6 = 0x40000;     // Stream x direct mode error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_FEIF6 = 0x10000;      // Stream x FIFO error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_TCIF5 = 0x800;        // Stream x transfer complete interrupt flag (x=7..4)
    static constexpr uint32_t HISR_HTIF5 = 0x400;        // Stream x half transfer interrupt flag (x=7..4)
    static constexpr uint32_t HISR_TEIF5 = 0x200;        // Stream x transfer error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_DMEIF5 = 0x100;       // Stream x direct mode error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_FEIF5 = 0x40;         // Stream x FIFO error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_TCIF4 = 0x20;         // Stream x transfer complete interrupt flag (x=7..4)
    static constexpr uint32_t HISR_HTIF4 = 0x10;         // Stream x half transfer interrupt flag (x=7..4)
    static constexpr uint32_t HISR_TEIF4 = 0x8;          // Stream x transfer error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_DMEIF4 = 0x4;         // Stream x direct mode error interrupt flag (x=7..4)
    static constexpr uint32_t HISR_FEIF4 = 0x1;          // Stream x FIFO error interrupt flag (x=7..4)
    static const uint32_t HISR_RESET_VALUE = 0x0;

    static constexpr uint32_t LIFCR_CTCIF3 = 0x8000000;   // Stream x clear transfer complete interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CHTIF3 = 0x4000000;   // Stream x clear half transfer interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CTEIF3 = 0x2000000;   // Stream x clear transfer error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CDMEIF3 = 0x1000000;  // Stream x clear direct mode error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CFEIF3 = 0x400000;    // Stream x clear FIFO error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CTCIF2 = 0x200000;    // Stream x clear transfer complete interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CHTIF2 = 0x100000;    // Stream x clear half transfer interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CTEIF2 = 0x80000;     // Stream x clear transfer error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CDMEIF2 = 0x40000;    // Stream x clear direct mode error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CFEIF2 = 0x10000;     // Stream x clear FIFO error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CTCIF1 = 0x800;       // Stream x clear transfer complete interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CHTIF1 = 0x400;       // Stream x clear half transfer interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CTEIF1 = 0x200;       // Stream x clear transfer error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CDMEIF1 = 0x100;      // Stream x clear direct mode error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CFEIF1 = 0x40;        // Stream x clear FIFO error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CTCIF0 = 0x20;        // Stream x clear transfer complete interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CHTIF0 = 0x10;        // Stream x clear half transfer interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CTEIF0 = 0x8;         // Stream x clear transfer error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CDMEIF0 = 0x4;        // Stream x clear direct mode error interrupt flag (x = 3..0)
    static constexpr uint32_t LIFCR_CFEIF0 = 0x1;         // Stream x clear FIFO error interrupt flag (x = 3..0)
    static const uint32_t LIFCR_RESET_VALUE = 0x0;

    static constexpr uint32_t HIFCR_CTCIF7 = 0x8000000;   // Stream x clear transfer complete interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CHTIF7 = 0x4000000;   // Stream x clear half transfer interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CTEIF7 = 0x2000000;   // Stream x clear transfer error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CDMEIF7 = 0x1000000;  // Stream x clear direct mode error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CFEIF7 = 0x400000;    // Stream x clear FIFO error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CTCIF6 = 0x200000;    // Stream x clear transfer complete interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CHTIF6 = 0x100000;    // Stream x clear half transfer interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CTEIF6 = 0x80000;     // Stream x clear transfer error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CDMEIF6 = 0x40000;    // Stream x clear direct mode error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CFEIF6 = 0x10000;     // Stream x clear FIFO error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CTCIF5 = 0x800;       // Stream x clear transfer complete interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CHTIF5 = 0x400;       // Stream x clear half transfer interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CTEIF5 = 0x200;       // Stream x clear transfer error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CDMEIF5 = 0x100;      // Stream x clear direct mode error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CFEIF5 = 0x40;        // Stream x clear FIFO error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CTCIF4 = 0x20;        // Stream x clear transfer complete interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CHTIF4 = 0x10;        // Stream x clear half transfer interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CTEIF4 = 0x8;         // Stream x clear transfer error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CDMEIF4 = 0x4;        // Stream x clear direct mode error interrupt flag (x = 7..4)
    static constexpr uint32_t HIFCR_CFEIF4 = 0x1;         // Stream x clear FIFO error interrupt flag (x = 7..4)
    static const uint32_t HIFCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t S0CR_CHSEL =               // Channel selection (4 bits)
        bit_field_t<25, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S0CR_MBURST =              // Memory burst transfer configuration (2 bits)
        bit_field_t<23, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S0CR_PBURST =              // Peripheral burst transfer configuration (2 bits)
        bit_field_t<21, 0x3>::value<X>();
    static constexpr uint32_t S0CR_CT = 0x80000;         // Current target (only in double buffer mode)
    static constexpr uint32_t S0CR_DBM = 0x40000;        // Double buffer mode
    template<uint32_t X>
    static constexpr uint32_t S0CR_PL =                  // Priority level (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    static constexpr uint32_t S0CR_PINCOS = 0x8000;      // Peripheral increment offset size
    template<uint32_t X>
    static constexpr uint32_t S0CR_MSIZE =               // Memory data size (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S0CR_PSIZE =               // Peripheral data size (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    static constexpr uint32_t S0CR_MINC = 0x400;         // Memory increment mode
    static constexpr uint32_t S0CR_PINC = 0x200;         // Peripheral increment mode
    static constexpr uint32_t S0CR_CIRC = 0x100;         // Circular mode
    template<uint32_t X>
    static constexpr uint32_t S0CR_DIR =                 // Data transfer direction (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t S0CR_PFCTRL = 0x20;        // Peripheral flow controller
    static constexpr uint32_t S0CR_TCIE = 0x10;          // Transfer complete interrupt enable
    static constexpr uint32_t S0CR_HTIE = 0x8;           // Half transfer interrupt enable
    static constexpr uint32_t S0CR_TEIE = 0x4;           // Transfer error interrupt enable
    static constexpr uint32_t S0CR_DMEIE = 0x2;          // Direct mode error interrupt enable
    static constexpr uint32_t S0CR_EN = 0x1;             // Stream enable / flag stream ready when read low
    static const uint32_t S0CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t S0NDTR_NDT =                 // Number of data items to transfer (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t S0NDTR_RESET_VALUE = 0x0;


    static const uint32_t S0PAR_RESET_VALUE = 0x0;


    static const uint32_t S0M0AR_RESET_VALUE = 0x0;


    static const uint32_t S0M1AR_RESET_VALUE = 0x0;

    static constexpr uint32_t S0FCR_FEIE = 0x80;          // FIFO error interrupt enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S0FCR_FS =                  // FIFO status (3 bits), Read-only
        bit_field_t<3, 0x7>::value<X>();
    static constexpr uint32_t S0FCR_DMDIS = 0x4;          // Direct mode disable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S0FCR_FTH =                 // FIFO threshold selection (2 bits), Read-write
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t S0FCR_RESET_VALUE = 0x21;

    template<uint32_t X>
    static constexpr uint32_t S1CR_CHSEL =               // Channel selection (4 bits)
        bit_field_t<25, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S1CR_MBURST =              // Memory burst transfer configuration (2 bits)
        bit_field_t<23, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S1CR_PBURST =              // Peripheral burst transfer configuration (2 bits)
        bit_field_t<21, 0x3>::value<X>();
    static constexpr uint32_t S1CR_ACK = 0x100000;       // ACK
    static constexpr uint32_t S1CR_CT = 0x80000;         // Current target (only in double buffer mode)
    static constexpr uint32_t S1CR_DBM = 0x40000;        // Double buffer mode
    template<uint32_t X>
    static constexpr uint32_t S1CR_PL =                  // Priority level (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    static constexpr uint32_t S1CR_PINCOS = 0x8000;      // Peripheral increment offset size
    template<uint32_t X>
    static constexpr uint32_t S1CR_MSIZE =               // Memory data size (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S1CR_PSIZE =               // Peripheral data size (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    static constexpr uint32_t S1CR_MINC = 0x400;         // Memory increment mode
    static constexpr uint32_t S1CR_PINC = 0x200;         // Peripheral increment mode
    static constexpr uint32_t S1CR_CIRC = 0x100;         // Circular mode
    template<uint32_t X>
    static constexpr uint32_t S1CR_DIR =                 // Data transfer direction (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t S1CR_PFCTRL = 0x20;        // Peripheral flow controller
    static constexpr uint32_t S1CR_TCIE = 0x10;          // Transfer complete interrupt enable
    static constexpr uint32_t S1CR_HTIE = 0x8;           // Half transfer interrupt enable
    static constexpr uint32_t S1CR_TEIE = 0x4;           // Transfer error interrupt enable
    static constexpr uint32_t S1CR_DMEIE = 0x2;          // Direct mode error interrupt enable
    static constexpr uint32_t S1CR_EN = 0x1;             // Stream enable / flag stream ready when read low
    static const uint32_t S1CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t S1NDTR_NDT =                 // Number of data items to transfer (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t S1NDTR_RESET_VALUE = 0x0;


    static const uint32_t S1PAR_RESET_VALUE = 0x0;


    static const uint32_t S1M0AR_RESET_VALUE = 0x0;


    static const uint32_t S1M1AR_RESET_VALUE = 0x0;

    static constexpr uint32_t S1FCR_FEIE = 0x80;          // FIFO error interrupt enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S1FCR_FS =                  // FIFO status (3 bits), Read-only
        bit_field_t<3, 0x7>::value<X>();
    static constexpr uint32_t S1FCR_DMDIS = 0x4;          // Direct mode disable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S1FCR_FTH =                 // FIFO threshold selection (2 bits), Read-write
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t S1FCR_RESET_VALUE = 0x21;

    template<uint32_t X>
    static constexpr uint32_t S2CR_CHSEL =               // Channel selection (4 bits)
        bit_field_t<25, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S2CR_MBURST =              // Memory burst transfer configuration (2 bits)
        bit_field_t<23, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S2CR_PBURST =              // Peripheral burst transfer configuration (2 bits)
        bit_field_t<21, 0x3>::value<X>();
    static constexpr uint32_t S2CR_ACK = 0x100000;       // ACK
    static constexpr uint32_t S2CR_CT = 0x80000;         // Current target (only in double buffer mode)
    static constexpr uint32_t S2CR_DBM = 0x40000;        // Double buffer mode
    template<uint32_t X>
    static constexpr uint32_t S2CR_PL =                  // Priority level (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    static constexpr uint32_t S2CR_PINCOS = 0x8000;      // Peripheral increment offset size
    template<uint32_t X>
    static constexpr uint32_t S2CR_MSIZE =               // Memory data size (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S2CR_PSIZE =               // Peripheral data size (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    static constexpr uint32_t S2CR_MINC = 0x400;         // Memory increment mode
    static constexpr uint32_t S2CR_PINC = 0x200;         // Peripheral increment mode
    static constexpr uint32_t S2CR_CIRC = 0x100;         // Circular mode
    template<uint32_t X>
    static constexpr uint32_t S2CR_DIR =                 // Data transfer direction (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t S2CR_PFCTRL = 0x20;        // Peripheral flow controller
    static constexpr uint32_t S2CR_TCIE = 0x10;          // Transfer complete interrupt enable
    static constexpr uint32_t S2CR_HTIE = 0x8;           // Half transfer interrupt enable
    static constexpr uint32_t S2CR_TEIE = 0x4;           // Transfer error interrupt enable
    static constexpr uint32_t S2CR_DMEIE = 0x2;          // Direct mode error interrupt enable
    static constexpr uint32_t S2CR_EN = 0x1;             // Stream enable / flag stream ready when read low
    static const uint32_t S2CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t S2NDTR_NDT =                 // Number of data items to transfer (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t S2NDTR_RESET_VALUE = 0x0;


    static const uint32_t S2PAR_RESET_VALUE = 0x0;


    static const uint32_t S2M0AR_RESET_VALUE = 0x0;


    static const uint32_t S2M1AR_RESET_VALUE = 0x0;

    static constexpr uint32_t S2FCR_FEIE = 0x80;          // FIFO error interrupt enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S2FCR_FS =                  // FIFO status (3 bits), Read-only
        bit_field_t<3, 0x7>::value<X>();
    static constexpr uint32_t S2FCR_DMDIS = 0x4;          // Direct mode disable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S2FCR_FTH =                 // FIFO threshold selection (2 bits), Read-write
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t S2FCR_RESET_VALUE = 0x21;

    template<uint32_t X>
    static constexpr uint32_t S3CR_CHSEL =               // Channel selection (4 bits)
        bit_field_t<25, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S3CR_MBURST =              // Memory burst transfer configuration (2 bits)
        bit_field_t<23, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S3CR_PBURST =              // Peripheral burst transfer configuration (2 bits)
        bit_field_t<21, 0x3>::value<X>();
    static constexpr uint32_t S3CR_ACK = 0x100000;       // ACK
    static constexpr uint32_t S3CR_CT = 0x80000;         // Current target (only in double buffer mode)
    static constexpr uint32_t S3CR_DBM = 0x40000;        // Double buffer mode
    template<uint32_t X>
    static constexpr uint32_t S3CR_PL =                  // Priority level (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    static constexpr uint32_t S3CR_PINCOS = 0x8000;      // Peripheral increment offset size
    template<uint32_t X>
    static constexpr uint32_t S3CR_MSIZE =               // Memory data size (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S3CR_PSIZE =               // Peripheral data size (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    static constexpr uint32_t S3CR_MINC = 0x400;         // Memory increment mode
    static constexpr uint32_t S3CR_PINC = 0x200;         // Peripheral increment mode
    static constexpr uint32_t S3CR_CIRC = 0x100;         // Circular mode
    template<uint32_t X>
    static constexpr uint32_t S3CR_DIR =                 // Data transfer direction (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t S3CR_PFCTRL = 0x20;        // Peripheral flow controller
    static constexpr uint32_t S3CR_TCIE = 0x10;          // Transfer complete interrupt enable
    static constexpr uint32_t S3CR_HTIE = 0x8;           // Half transfer interrupt enable
    static constexpr uint32_t S3CR_TEIE = 0x4;           // Transfer error interrupt enable
    static constexpr uint32_t S3CR_DMEIE = 0x2;          // Direct mode error interrupt enable
    static constexpr uint32_t S3CR_EN = 0x1;             // Stream enable / flag stream ready when read low
    static const uint32_t S3CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t S3NDTR_NDT =                 // Number of data items to transfer (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t S3NDTR_RESET_VALUE = 0x0;


    static const uint32_t S3PAR_RESET_VALUE = 0x0;


    static const uint32_t S3M0AR_RESET_VALUE = 0x0;


    static const uint32_t S3M1AR_RESET_VALUE = 0x0;

    static constexpr uint32_t S3FCR_FEIE = 0x80;          // FIFO error interrupt enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S3FCR_FS =                  // FIFO status (3 bits), Read-only
        bit_field_t<3, 0x7>::value<X>();
    static constexpr uint32_t S3FCR_DMDIS = 0x4;          // Direct mode disable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S3FCR_FTH =                 // FIFO threshold selection (2 bits), Read-write
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t S3FCR_RESET_VALUE = 0x21;

    template<uint32_t X>
    static constexpr uint32_t S4CR_CHSEL =               // Channel selection (3 bits)
        bit_field_t<25, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S4CR_MBURST =              // Memory burst transfer configuration (2 bits)
        bit_field_t<23, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S4CR_PBURST =              // Peripheral burst transfer configuration (2 bits)
        bit_field_t<21, 0x3>::value<X>();
    static constexpr uint32_t S4CR_ACK = 0x100000;       // ACK
    static constexpr uint32_t S4CR_CT = 0x80000;         // Current target (only in double buffer mode)
    static constexpr uint32_t S4CR_DBM = 0x40000;        // Double buffer mode
    template<uint32_t X>
    static constexpr uint32_t S4CR_PL =                  // Priority level (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    static constexpr uint32_t S4CR_PINCOS = 0x8000;      // Peripheral increment offset size
    template<uint32_t X>
    static constexpr uint32_t S4CR_MSIZE =               // Memory data size (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S4CR_PSIZE =               // Peripheral data size (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    static constexpr uint32_t S4CR_MINC = 0x400;         // Memory increment mode
    static constexpr uint32_t S4CR_PINC = 0x200;         // Peripheral increment mode
    static constexpr uint32_t S4CR_CIRC = 0x100;         // Circular mode
    template<uint32_t X>
    static constexpr uint32_t S4CR_DIR =                 // Data transfer direction (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t S4CR_PFCTRL = 0x20;        // Peripheral flow controller
    static constexpr uint32_t S4CR_TCIE = 0x10;          // Transfer complete interrupt enable
    static constexpr uint32_t S4CR_HTIE = 0x8;           // Half transfer interrupt enable
    static constexpr uint32_t S4CR_TEIE = 0x4;           // Transfer error interrupt enable
    static constexpr uint32_t S4CR_DMEIE = 0x2;          // Direct mode error interrupt enable
    static constexpr uint32_t S4CR_EN = 0x1;             // Stream enable / flag stream ready when read low
    static const uint32_t S4CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t S4NDTR_NDT =                 // Number of data items to transfer (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t S4NDTR_RESET_VALUE = 0x0;


    static const uint32_t S4PAR_RESET_VALUE = 0x0;


    static const uint32_t S4M0AR_RESET_VALUE = 0x0;


    static const uint32_t S4M1AR_RESET_VALUE = 0x0;

    static constexpr uint32_t S4FCR_FEIE = 0x80;          // FIFO error interrupt enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S4FCR_FS =                  // FIFO status (3 bits), Read-only
        bit_field_t<3, 0x7>::value<X>();
    static constexpr uint32_t S4FCR_DMDIS = 0x4;          // Direct mode disable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S4FCR_FTH =                 // FIFO threshold selection (2 bits), Read-write
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t S4FCR_RESET_VALUE = 0x21;

    template<uint32_t X>
    static constexpr uint32_t S5CR_CHSEL =               // Channel selection (4 bits)
        bit_field_t<25, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S5CR_MBURST =              // Memory burst transfer configuration (2 bits)
        bit_field_t<23, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S5CR_PBURST =              // Peripheral burst transfer configuration (2 bits)
        bit_field_t<21, 0x3>::value<X>();
    static constexpr uint32_t S5CR_ACK = 0x100000;       // ACK
    static constexpr uint32_t S5CR_CT = 0x80000;         // Current target (only in double buffer mode)
    static constexpr uint32_t S5CR_DBM = 0x40000;        // Double buffer mode
    template<uint32_t X>
    static constexpr uint32_t S5CR_PL =                  // Priority level (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    static constexpr uint32_t S5CR_PINCOS = 0x8000;      // Peripheral increment offset size
    template<uint32_t X>
    static constexpr uint32_t S5CR_MSIZE =               // Memory data size (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S5CR_PSIZE =               // Peripheral data size (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    static constexpr uint32_t S5CR_MINC = 0x400;         // Memory increment mode
    static constexpr uint32_t S5CR_PINC = 0x200;         // Peripheral increment mode
    static constexpr uint32_t S5CR_CIRC = 0x100;         // Circular mode
    template<uint32_t X>
    static constexpr uint32_t S5CR_DIR =                 // Data transfer direction (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t S5CR_PFCTRL = 0x20;        // Peripheral flow controller
    static constexpr uint32_t S5CR_TCIE = 0x10;          // Transfer complete interrupt enable
    static constexpr uint32_t S5CR_HTIE = 0x8;           // Half transfer interrupt enable
    static constexpr uint32_t S5CR_TEIE = 0x4;           // Transfer error interrupt enable
    static constexpr uint32_t S5CR_DMEIE = 0x2;          // Direct mode error interrupt enable
    static constexpr uint32_t S5CR_EN = 0x1;             // Stream enable / flag stream ready when read low
    static const uint32_t S5CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t S5NDTR_NDT =                 // Number of data items to transfer (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t S5NDTR_RESET_VALUE = 0x0;


    static const uint32_t S5PAR_RESET_VALUE = 0x0;


    static const uint32_t S5M0AR_RESET_VALUE = 0x0;


    static const uint32_t S5M1AR_RESET_VALUE = 0x0;

    static constexpr uint32_t S5FCR_FEIE = 0x80;          // FIFO error interrupt enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S5FCR_FS =                  // FIFO status (3 bits), Read-only
        bit_field_t<3, 0x7>::value<X>();
    static constexpr uint32_t S5FCR_DMDIS = 0x4;          // Direct mode disable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S5FCR_FTH =                 // FIFO threshold selection (2 bits), Read-write
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t S5FCR_RESET_VALUE = 0x21;

    template<uint32_t X>
    static constexpr uint32_t S6CR_CHSEL =               // Channel selection (4 bits)
        bit_field_t<25, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S6CR_MBURST =              // Memory burst transfer configuration (2 bits)
        bit_field_t<23, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S6CR_PBURST =              // Peripheral burst transfer configuration (2 bits)
        bit_field_t<21, 0x3>::value<X>();
    static constexpr uint32_t S6CR_ACK = 0x100000;       // ACK
    static constexpr uint32_t S6CR_CT = 0x80000;         // Current target (only in double buffer mode)
    static constexpr uint32_t S6CR_DBM = 0x40000;        // Double buffer mode
    template<uint32_t X>
    static constexpr uint32_t S6CR_PL =                  // Priority level (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    static constexpr uint32_t S6CR_PINCOS = 0x8000;      // Peripheral increment offset size
    template<uint32_t X>
    static constexpr uint32_t S6CR_MSIZE =               // Memory data size (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S6CR_PSIZE =               // Peripheral data size (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    static constexpr uint32_t S6CR_MINC = 0x400;         // Memory increment mode
    static constexpr uint32_t S6CR_PINC = 0x200;         // Peripheral increment mode
    static constexpr uint32_t S6CR_CIRC = 0x100;         // Circular mode
    template<uint32_t X>
    static constexpr uint32_t S6CR_DIR =                 // Data transfer direction (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t S6CR_PFCTRL = 0x20;        // Peripheral flow controller
    static constexpr uint32_t S6CR_TCIE = 0x10;          // Transfer complete interrupt enable
    static constexpr uint32_t S6CR_HTIE = 0x8;           // Half transfer interrupt enable
    static constexpr uint32_t S6CR_TEIE = 0x4;           // Transfer error interrupt enable
    static constexpr uint32_t S6CR_DMEIE = 0x2;          // Direct mode error interrupt enable
    static constexpr uint32_t S6CR_EN = 0x1;             // Stream enable / flag stream ready when read low
    static const uint32_t S6CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t S6NDTR_NDT =                 // Number of data items to transfer (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t S6NDTR_RESET_VALUE = 0x0;


    static const uint32_t S6PAR_RESET_VALUE = 0x0;


    static const uint32_t S6M0AR_RESET_VALUE = 0x0;


    static const uint32_t S6M1AR_RESET_VALUE = 0x0;

    static constexpr uint32_t S6FCR_FEIE = 0x80;          // FIFO error interrupt enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S6FCR_FS =                  // FIFO status (3 bits), Read-only
        bit_field_t<3, 0x7>::value<X>();
    static constexpr uint32_t S6FCR_DMDIS = 0x4;          // Direct mode disable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S6FCR_FTH =                 // FIFO threshold selection (2 bits), Read-write
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t S6FCR_RESET_VALUE = 0x21;

    template<uint32_t X>
    static constexpr uint32_t S7CR_CHSEL =               // Channel selection (4 bits)
        bit_field_t<25, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S7CR_MBURST =              // Memory burst transfer configuration (2 bits)
        bit_field_t<23, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S7CR_PBURST =              // Peripheral burst transfer configuration (2 bits)
        bit_field_t<21, 0x3>::value<X>();
    static constexpr uint32_t S7CR_ACK = 0x100000;       // ACK
    static constexpr uint32_t S7CR_CT = 0x80000;         // Current target (only in double buffer mode)
    static constexpr uint32_t S7CR_DBM = 0x40000;        // Double buffer mode
    template<uint32_t X>
    static constexpr uint32_t S7CR_PL =                  // Priority level (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    static constexpr uint32_t S7CR_PINCOS = 0x8000;      // Peripheral increment offset size
    template<uint32_t X>
    static constexpr uint32_t S7CR_MSIZE =               // Memory data size (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t S7CR_PSIZE =               // Peripheral data size (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    static constexpr uint32_t S7CR_MINC = 0x400;         // Memory increment mode
    static constexpr uint32_t S7CR_PINC = 0x200;         // Peripheral increment mode
    static constexpr uint32_t S7CR_CIRC = 0x100;         // Circular mode
    template<uint32_t X>
    static constexpr uint32_t S7CR_DIR =                 // Data transfer direction (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t S7CR_PFCTRL = 0x20;        // Peripheral flow controller
    static constexpr uint32_t S7CR_TCIE = 0x10;          // Transfer complete interrupt enable
    static constexpr uint32_t S7CR_HTIE = 0x8;           // Half transfer interrupt enable
    static constexpr uint32_t S7CR_TEIE = 0x4;           // Transfer error interrupt enable
    static constexpr uint32_t S7CR_DMEIE = 0x2;          // Direct mode error interrupt enable
    static constexpr uint32_t S7CR_EN = 0x1;             // Stream enable / flag stream ready when read low
    static const uint32_t S7CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t S7NDTR_NDT =                 // Number of data items to transfer (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t S7NDTR_RESET_VALUE = 0x0;


    static const uint32_t S7PAR_RESET_VALUE = 0x0;


    static const uint32_t S7M0AR_RESET_VALUE = 0x0;


    static const uint32_t S7M1AR_RESET_VALUE = 0x0;

    static constexpr uint32_t S7FCR_FEIE = 0x80;          // FIFO error interrupt enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S7FCR_FS =                  // FIFO status (3 bits), Read-only
        bit_field_t<3, 0x7>::value<X>();
    static constexpr uint32_t S7FCR_DMDIS = 0x4;          // Direct mode disable, Read-write
    template<uint32_t X>
    static constexpr uint32_t S7FCR_FTH =                 // FIFO threshold selection (2 bits), Read-write
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t S7FCR_RESET_VALUE = 0x21;

    static constexpr uint8_t DMA1_STREAM0 = 11; // DMA1 Stream0 global interrupt
    static constexpr uint8_t DMA1_STREAM1 = 12; // DMA1 Stream1 global interrupt
    static constexpr uint8_t DMA1_STREAM2 = 13; // DMA1 Stream2 global interrupt
    static constexpr uint8_t DMA1_STREAM3 = 14; // DMA1 Stream3 global interrupt
    static constexpr uint8_t DMA1_STREAM4 = 15; // DMA1 Stream4 global interrupt
    static constexpr uint8_t DMA1_STREAM5 = 16; // DMA1 Stream5 global interrupt
    static constexpr uint8_t DMA1_STREAM6 = 17; // DMA1 Stream6 global interrupt
    static constexpr uint8_t DMA1_STREAM7 = 47; // DMA1 Stream7 global interrupt
};

static dma1_t& DMA1 = *reinterpret_cast<dma1_t*>(0x40026000);

#define HAVE_PERIPHERAL_DMA1


////
//
//    Reset and clock control
//
////

struct rcc_t
{
    volatile uint32_t    CR;                   // clock control register
    volatile uint32_t    PLLCFGR;              // [Read-write] PLL configuration register
    volatile uint32_t    CFGR;                 // clock configuration register
    volatile uint32_t    CIR;                  // clock interrupt register
    volatile uint32_t    AHB1RSTR;             // [Read-write] AHB1 peripheral reset register
    volatile uint32_t    AHB2RSTR;             // [Read-write] AHB2 peripheral reset register
    volatile uint32_t    AHB3RSTR;             // [Read-write] AHB3 peripheral reset register
    reserved_t<1>        _0;
    volatile uint32_t    APB1RSTR;             // [Read-write] APB1 peripheral reset register
    volatile uint32_t    APB2RSTR;             // [Read-write] APB2 peripheral reset register
    reserved_t<2>        _1;
    volatile uint32_t    AHB1ENR;              // [Read-write] AHB1 peripheral clock register
    volatile uint32_t    AHB2ENR;              // [Read-write] AHB2 peripheral clock enable register
    volatile uint32_t    AHB3ENR;              // [Read-write] AHB3 peripheral clock enable register
    reserved_t<1>        _2;
    volatile uint32_t    APB1ENR;              // [Read-write] APB1 peripheral clock enable register
    volatile uint32_t    APB2ENR;              // [Read-write] APB2 peripheral clock enable register
    reserved_t<2>        _3;
    volatile uint32_t    AHB1LPENR;            // [Read-write] AHB1 peripheral clock enable in low power mode register
    volatile uint32_t    AHB2LPENR;            // [Read-write] AHB2 peripheral clock enable in low power mode register
    volatile uint32_t    AHB3LPENR;            // [Read-write] AHB3 peripheral clock enable in low power mode register
    reserved_t<1>        _4;
    volatile uint32_t    APB1LPENR;            // [Read-write] APB1 peripheral clock enable in low power mode register
    volatile uint32_t    APB2LPENR;            // [Read-write] APB2 peripheral clock enabled in low power mode register
    reserved_t<2>        _5;
    volatile uint32_t    BDCR;                 // Backup domain control register
    volatile uint32_t    CSR;                  // clock control &amp; status register
    reserved_t<2>        _6;
    volatile uint32_t    SSCGR;                // [Read-write] spread spectrum clock generation register
    volatile uint32_t    PLLI2SCFGR;           // [Read-write] PLLI2S configuration register
    volatile uint32_t    PLLSAICFGR;           // [Read-write] PLL configuration register
    volatile uint32_t    DKCFGR1;              // [Read-write] dedicated clocks configuration register
    volatile uint32_t    DKCFGR2;              // [Read-write] dedicated clocks configuration register

    static constexpr uint32_t CR_PLLI2SRDY = 0x8000000;// PLLI2S clock ready flag, Read-only
    static constexpr uint32_t CR_PLLI2SON = 0x4000000; // PLLI2S enable, Read-write
    static constexpr uint32_t CR_PLLRDY = 0x2000000;   // Main PLL (PLL) clock ready flag, Read-only
    static constexpr uint32_t CR_PLLON = 0x1000000;    // Main PLL (PLL) enable, Read-write
    static constexpr uint32_t CR_CSSON = 0x80000;      // Clock security system enable, Read-write
    static constexpr uint32_t CR_HSEBYP = 0x40000;     // HSE clock bypass, Read-write
    static constexpr uint32_t CR_HSERDY = 0x20000;     // HSE clock ready flag, Read-only
    static constexpr uint32_t CR_HSEON = 0x10000;      // HSE clock enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t CR_HSICAL =              // Internal high-speed clock calibration (8 bits), Read-only
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR_HSITRIM =             // Internal high-speed clock trimming (5 bits), Read-write
        bit_field_t<3, 0x1f>::value<X>();
    static constexpr uint32_t CR_HSIRDY = 0x2;         // Internal high-speed clock ready flag, Read-only
    static constexpr uint32_t CR_HSION = 0x1;          // Internal high-speed clock enable, Read-write
    static const uint32_t CR_RESET_VALUE = 0x83;

    static constexpr uint32_t PLLCFGR_PLLQ3 = 0x8000000;    // Main PLL (PLL) division factor for USB OTG FS, SDIO and random number generator clocks
    static constexpr uint32_t PLLCFGR_PLLQ2 = 0x4000000;    // Main PLL (PLL) division factor for USB OTG FS, SDIO and random number generator clocks
    static constexpr uint32_t PLLCFGR_PLLQ1 = 0x2000000;    // Main PLL (PLL) division factor for USB OTG FS, SDIO and random number generator clocks
    static constexpr uint32_t PLLCFGR_PLLQ0 = 0x1000000;    // Main PLL (PLL) division factor for USB OTG FS, SDIO and random number generator clocks
    static constexpr uint32_t PLLCFGR_PLLSRC = 0x400000;    // Main PLL(PLL) and audio PLL (PLLI2S) entry clock source
    static constexpr uint32_t PLLCFGR_PLLP1 = 0x20000;      // Main PLL (PLL) division factor for main system clock
    static constexpr uint32_t PLLCFGR_PLLP0 = 0x10000;      // Main PLL (PLL) division factor for main system clock
    static constexpr uint32_t PLLCFGR_PLLN8 = 0x4000;       // Main PLL (PLL) multiplication factor for VCO
    static constexpr uint32_t PLLCFGR_PLLN7 = 0x2000;       // Main PLL (PLL) multiplication factor for VCO
    static constexpr uint32_t PLLCFGR_PLLN6 = 0x1000;       // Main PLL (PLL) multiplication factor for VCO
    static constexpr uint32_t PLLCFGR_PLLN5 = 0x800;        // Main PLL (PLL) multiplication factor for VCO
    static constexpr uint32_t PLLCFGR_PLLN4 = 0x400;        // Main PLL (PLL) multiplication factor for VCO
    static constexpr uint32_t PLLCFGR_PLLN3 = 0x200;        // Main PLL (PLL) multiplication factor for VCO
    static constexpr uint32_t PLLCFGR_PLLN2 = 0x100;        // Main PLL (PLL) multiplication factor for VCO
    static constexpr uint32_t PLLCFGR_PLLN1 = 0x80;         // Main PLL (PLL) multiplication factor for VCO
    static constexpr uint32_t PLLCFGR_PLLN0 = 0x40;         // Main PLL (PLL) multiplication factor for VCO
    static constexpr uint32_t PLLCFGR_PLLM5 = 0x20;         // Division factor for the main PLL (PLL) and audio PLL (PLLI2S) input clock
    static constexpr uint32_t PLLCFGR_PLLM4 = 0x10;         // Division factor for the main PLL (PLL) and audio PLL (PLLI2S) input clock
    static constexpr uint32_t PLLCFGR_PLLM3 = 0x8;          // Division factor for the main PLL (PLL) and audio PLL (PLLI2S) input clock
    static constexpr uint32_t PLLCFGR_PLLM2 = 0x4;          // Division factor for the main PLL (PLL) and audio PLL (PLLI2S) input clock
    static constexpr uint32_t PLLCFGR_PLLM1 = 0x2;          // Division factor for the main PLL (PLL) and audio PLL (PLLI2S) input clock
    static constexpr uint32_t PLLCFGR_PLLM0 = 0x1;          // Division factor for the main PLL (PLL) and audio PLL (PLLI2S) input clock
    static const uint32_t PLLCFGR_RESET_VALUE = 0x24003010;

    template<uint32_t X>
    static constexpr uint32_t CFGR_MCO2 =                // Microcontroller clock output 2 (2 bits), Read-write
        bit_field_t<30, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_MCO2PRE =             // MCO2 prescaler (3 bits), Read-write
        bit_field_t<27, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_MCO1PRE =             // MCO1 prescaler (3 bits), Read-write
        bit_field_t<24, 0x7>::value<X>();
    static constexpr uint32_t CFGR_I2SSRC = 0x800000;    // I2S clock selection, Read-write
    template<uint32_t X>
    static constexpr uint32_t CFGR_MCO1 =                // Microcontroller clock output 1 (2 bits), Read-write
        bit_field_t<21, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_RTCPRE =              // HSE division factor for RTC clock (5 bits), Read-write
        bit_field_t<16, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_PPRE2 =               // APB high-speed prescaler (APB2) (3 bits), Read-write
        bit_field_t<13, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_PPRE1 =               // APB Low speed prescaler (APB1) (3 bits), Read-write
        bit_field_t<10, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_HPRE =                // AHB prescaler (4 bits), Read-write
        bit_field_t<4, 0xf>::value<X>();
    static constexpr uint32_t CFGR_SWS1 = 0x8;           // System clock switch status, Read-only
    static constexpr uint32_t CFGR_SWS0 = 0x4;           // System clock switch status, Read-only
    static constexpr uint32_t CFGR_SW1 = 0x2;            // System clock switch, Read-write
    static constexpr uint32_t CFGR_SW0 = 0x1;            // System clock switch, Read-write
    static const uint32_t CFGR_RESET_VALUE = 0x0;

    static constexpr uint32_t CIR_CSSC = 0x800000;      // Clock security system interrupt clear, Write-only
    static constexpr uint32_t CIR_PLLSAIRDYC = 0x400000;// PLLSAI Ready Interrupt Clear, Write-only
    static constexpr uint32_t CIR_PLLI2SRDYC = 0x200000;// PLLI2S ready interrupt clear, Write-only
    static constexpr uint32_t CIR_PLLRDYC = 0x100000;   // Main PLL(PLL) ready interrupt clear, Write-only
    static constexpr uint32_t CIR_HSERDYC = 0x80000;    // HSE ready interrupt clear, Write-only
    static constexpr uint32_t CIR_HSIRDYC = 0x40000;    // HSI ready interrupt clear, Write-only
    static constexpr uint32_t CIR_LSERDYC = 0x20000;    // LSE ready interrupt clear, Write-only
    static constexpr uint32_t CIR_LSIRDYC = 0x10000;    // LSI ready interrupt clear, Write-only
    static constexpr uint32_t CIR_PLLSAIRDYIE = 0x4000; // PLLSAI Ready Interrupt Enable, Read-write
    static constexpr uint32_t CIR_PLLI2SRDYIE = 0x2000; // PLLI2S ready interrupt enable, Read-write
    static constexpr uint32_t CIR_PLLRDYIE = 0x1000;    // Main PLL (PLL) ready interrupt enable, Read-write
    static constexpr uint32_t CIR_HSERDYIE = 0x800;     // HSE ready interrupt enable, Read-write
    static constexpr uint32_t CIR_HSIRDYIE = 0x400;     // HSI ready interrupt enable, Read-write
    static constexpr uint32_t CIR_LSERDYIE = 0x200;     // LSE ready interrupt enable, Read-write
    static constexpr uint32_t CIR_LSIRDYIE = 0x100;     // LSI ready interrupt enable, Read-write
    static constexpr uint32_t CIR_CSSF = 0x80;          // Clock security system interrupt flag, Read-only
    static constexpr uint32_t CIR_PLLSAIRDYF = 0x40;    // PLLSAI ready interrupt flag, Read-only
    static constexpr uint32_t CIR_PLLI2SRDYF = 0x20;    // PLLI2S ready interrupt flag, Read-only
    static constexpr uint32_t CIR_PLLRDYF = 0x10;       // Main PLL (PLL) ready interrupt flag, Read-only
    static constexpr uint32_t CIR_HSERDYF = 0x8;        // HSE ready interrupt flag, Read-only
    static constexpr uint32_t CIR_HSIRDYF = 0x4;        // HSI ready interrupt flag, Read-only
    static constexpr uint32_t CIR_LSERDYF = 0x2;        // LSE ready interrupt flag, Read-only
    static constexpr uint32_t CIR_LSIRDYF = 0x1;        // LSI ready interrupt flag, Read-only
    static const uint32_t CIR_RESET_VALUE = 0x0;

    static constexpr uint32_t AHB1RSTR_OTGHSRST = 0x20000000;// USB OTG HS module reset
    static constexpr uint32_t AHB1RSTR_ETHMACRST = 0x2000000;// Ethernet MAC reset
    static constexpr uint32_t AHB1RSTR_DMA2DRST = 0x800000;  // DMA2D reset
    static constexpr uint32_t AHB1RSTR_DMA2RST = 0x400000;   // DMA2 reset
    static constexpr uint32_t AHB1RSTR_DMA1RST = 0x200000;   // DMA2 reset
    static constexpr uint32_t AHB1RSTR_CRCRST = 0x1000;      // CRC reset
    static constexpr uint32_t AHB1RSTR_GPIOKRST = 0x400;     // IO port K reset
    static constexpr uint32_t AHB1RSTR_GPIOJRST = 0x200;     // IO port J reset
    static constexpr uint32_t AHB1RSTR_GPIOIRST = 0x100;     // IO port I reset
    static constexpr uint32_t AHB1RSTR_GPIOHRST = 0x80;      // IO port H reset
    static constexpr uint32_t AHB1RSTR_GPIOGRST = 0x40;      // IO port G reset
    static constexpr uint32_t AHB1RSTR_GPIOFRST = 0x20;      // IO port F reset
    static constexpr uint32_t AHB1RSTR_GPIOERST = 0x10;      // IO port E reset
    static constexpr uint32_t AHB1RSTR_GPIODRST = 0x8;       // IO port D reset
    static constexpr uint32_t AHB1RSTR_GPIOCRST = 0x4;       // IO port C reset
    static constexpr uint32_t AHB1RSTR_GPIOBRST = 0x2;       // IO port B reset
    static constexpr uint32_t AHB1RSTR_GPIOARST = 0x1;       // IO port A reset
    static const uint32_t AHB1RSTR_RESET_VALUE = 0x0;

    static constexpr uint32_t AHB2RSTR_OTGFSRST = 0x80;      // USB OTG FS module reset
    static constexpr uint32_t AHB2RSTR_RNGRST = 0x40;        // Random number generator module reset
    static constexpr uint32_t AHB2RSTR_HSAHRST = 0x20;       // Hash module reset
    static constexpr uint32_t AHB2RSTR_CRYPRST = 0x10;       // Cryptographic module reset
    static constexpr uint32_t AHB2RSTR_DCMIRST = 0x1;        // Camera interface reset
    static const uint32_t AHB2RSTR_RESET_VALUE = 0x0;

    static constexpr uint32_t AHB3RSTR_FMCRST = 0x1;         // Flexible memory controller module reset
    static constexpr uint32_t AHB3RSTR_QSPIRST = 0x2;        // Quad SPI memory controller reset
    static const uint32_t AHB3RSTR_RESET_VALUE = 0x0;

    static constexpr uint32_t APB1RSTR_TIM2RST = 0x1;        // TIM2 reset
    static constexpr uint32_t APB1RSTR_TIM3RST = 0x2;        // TIM3 reset
    static constexpr uint32_t APB1RSTR_TIM4RST = 0x4;        // TIM4 reset
    static constexpr uint32_t APB1RSTR_TIM5RST = 0x8;        // TIM5 reset
    static constexpr uint32_t APB1RSTR_TIM6RST = 0x10;       // TIM6 reset
    static constexpr uint32_t APB1RSTR_TIM7RST = 0x20;       // TIM7 reset
    static constexpr uint32_t APB1RSTR_TIM12RST = 0x40;      // TIM12 reset
    static constexpr uint32_t APB1RSTR_TIM13RST = 0x80;      // TIM13 reset
    static constexpr uint32_t APB1RSTR_TIM14RST = 0x100;     // TIM14 reset
    static constexpr uint32_t APB1RSTR_WWDGRST = 0x800;      // Window watchdog reset
    static constexpr uint32_t APB1RSTR_SPI2RST = 0x4000;     // SPI 2 reset
    static constexpr uint32_t APB1RSTR_SPI3RST = 0x8000;     // SPI 3 reset
    static constexpr uint32_t APB1RSTR_UART2RST = 0x20000;   // USART 2 reset
    static constexpr uint32_t APB1RSTR_UART3RST = 0x40000;   // USART 3 reset
    static constexpr uint32_t APB1RSTR_UART4RST = 0x80000;   // USART 4 reset
    static constexpr uint32_t APB1RSTR_UART5RST = 0x100000;  // USART 5 reset
    static constexpr uint32_t APB1RSTR_I2C1RST = 0x200000;   // I2C 1 reset
    static constexpr uint32_t APB1RSTR_I2C2RST = 0x400000;   // I2C 2 reset
    static constexpr uint32_t APB1RSTR_I2C3RST = 0x800000;   // I2C3 reset
    static constexpr uint32_t APB1RSTR_CAN1RST = 0x2000000;  // CAN1 reset
    static constexpr uint32_t APB1RSTR_CAN2RST = 0x4000000;  // CAN2 reset
    static constexpr uint32_t APB1RSTR_PWRRST = 0x10000000;  // Power interface reset
    static constexpr uint32_t APB1RSTR_DACRST = 0x20000000;  // DAC reset
    static constexpr uint32_t APB1RSTR_UART7RST = 0x40000000;// UART7 reset
    static constexpr uint32_t APB1RSTR_UART8RST = 0x80000000;// UART8 reset
    static constexpr uint32_t APB1RSTR_SPDIFRXRST = 0x10000; // SPDIF-RX reset
    static constexpr uint32_t APB1RSTR_CECRST = 0x8000000;   // HDMI-CEC reset
    static constexpr uint32_t APB1RSTR_LPTIM1RST = 0x200;    // Low power timer 1 reset
    static constexpr uint32_t APB1RSTR_I2C4RST = 0x1000000;  // I2C 4 reset
    static const uint32_t APB1RSTR_RESET_VALUE = 0x0;

    static constexpr uint32_t APB2RSTR_TIM1RST = 0x1;        // TIM1 reset
    static constexpr uint32_t APB2RSTR_TIM8RST = 0x2;        // TIM8 reset
    static constexpr uint32_t APB2RSTR_USART1RST = 0x10;     // USART1 reset
    static constexpr uint32_t APB2RSTR_USART6RST = 0x20;     // USART6 reset
    static constexpr uint32_t APB2RSTR_ADCRST = 0x100;       // ADC interface reset (common to all ADCs)
    static constexpr uint32_t APB2RSTR_SPI1RST = 0x1000;     // SPI 1 reset
    static constexpr uint32_t APB2RSTR_SPI4RST = 0x2000;     // SPI4 reset
    static constexpr uint32_t APB2RSTR_SYSCFGRST = 0x4000;   // System configuration controller reset
    static constexpr uint32_t APB2RSTR_TIM9RST = 0x10000;    // TIM9 reset
    static constexpr uint32_t APB2RSTR_TIM10RST = 0x20000;   // TIM10 reset
    static constexpr uint32_t APB2RSTR_TIM11RST = 0x40000;   // TIM11 reset
    static constexpr uint32_t APB2RSTR_SPI5RST = 0x100000;   // SPI5 reset
    static constexpr uint32_t APB2RSTR_SPI6RST = 0x200000;   // SPI6 reset
    static constexpr uint32_t APB2RSTR_SAI1RST = 0x400000;   // SAI1 reset
    static constexpr uint32_t APB2RSTR_LTDCRST = 0x4000000;  // LTDC reset
    static constexpr uint32_t APB2RSTR_SAI2RST = 0x800000;   // SAI2 reset
    static constexpr uint32_t APB2RSTR_SDMMC1RST = 0x800;    // SDMMC1 reset
    static const uint32_t APB2RSTR_RESET_VALUE = 0x0;

    static constexpr uint32_t AHB1ENR_OTGHSULPIEN = 0x40000000;// USB OTG HSULPI clock enable
    static constexpr uint32_t AHB1ENR_OTGHSEN = 0x20000000; // USB OTG HS clock enable
    static constexpr uint32_t AHB1ENR_ETHMACPTPEN = 0x10000000;// Ethernet PTP clock enable
    static constexpr uint32_t AHB1ENR_ETHMACRXEN = 0x8000000;// Ethernet Reception clock enable
    static constexpr uint32_t AHB1ENR_ETHMACTXEN = 0x4000000;// Ethernet Transmission clock enable
    static constexpr uint32_t AHB1ENR_ETHMACEN = 0x2000000; // Ethernet MAC clock enable
    static constexpr uint32_t AHB1ENR_DMA2DEN = 0x800000;   // DMA2D clock enable
    static constexpr uint32_t AHB1ENR_DMA2EN = 0x400000;    // DMA2 clock enable
    static constexpr uint32_t AHB1ENR_DMA1EN = 0x200000;    // DMA1 clock enable
    static constexpr uint32_t AHB1ENR_CCMDATARAMEN = 0x100000;// CCM data RAM clock enable
    static constexpr uint32_t AHB1ENR_BKPSRAMEN = 0x40000;  // Backup SRAM interface clock enable
    static constexpr uint32_t AHB1ENR_CRCEN = 0x1000;       // CRC clock enable
    static constexpr uint32_t AHB1ENR_GPIOKEN = 0x400;      // IO port K clock enable
    static constexpr uint32_t AHB1ENR_GPIOJEN = 0x200;      // IO port J clock enable
    static constexpr uint32_t AHB1ENR_GPIOIEN = 0x100;      // IO port I clock enable
    static constexpr uint32_t AHB1ENR_GPIOHEN = 0x80;       // IO port H clock enable
    static constexpr uint32_t AHB1ENR_GPIOGEN = 0x40;       // IO port G clock enable
    static constexpr uint32_t AHB1ENR_GPIOFEN = 0x20;       // IO port F clock enable
    static constexpr uint32_t AHB1ENR_GPIOEEN = 0x10;       // IO port E clock enable
    static constexpr uint32_t AHB1ENR_GPIODEN = 0x8;        // IO port D clock enable
    static constexpr uint32_t AHB1ENR_GPIOCEN = 0x4;        // IO port C clock enable
    static constexpr uint32_t AHB1ENR_GPIOBEN = 0x2;        // IO port B clock enable
    static constexpr uint32_t AHB1ENR_GPIOAEN = 0x1;        // IO port A clock enable
    static const uint32_t AHB1ENR_RESET_VALUE = 0x100000;

    static constexpr uint32_t AHB2ENR_OTGFSEN = 0x80;       // USB OTG FS clock enable
    static constexpr uint32_t AHB2ENR_RNGEN = 0x40;         // Random number generator clock enable
    static constexpr uint32_t AHB2ENR_HASHEN = 0x20;        // Hash modules clock enable
    static constexpr uint32_t AHB2ENR_CRYPEN = 0x10;        // Cryptographic modules clock enable
    static constexpr uint32_t AHB2ENR_DCMIEN = 0x1;         // Camera interface enable
    static const uint32_t AHB2ENR_RESET_VALUE = 0x0;

    static constexpr uint32_t AHB3ENR_FMCEN = 0x1;          // Flexible memory controller module clock enable
    static constexpr uint32_t AHB3ENR_QSPIEN = 0x2;         // Quad SPI memory controller clock enable
    static const uint32_t AHB3ENR_RESET_VALUE = 0x0;

    static constexpr uint32_t APB1ENR_TIM2EN = 0x1;         // TIM2 clock enable
    static constexpr uint32_t APB1ENR_TIM3EN = 0x2;         // TIM3 clock enable
    static constexpr uint32_t APB1ENR_TIM4EN = 0x4;         // TIM4 clock enable
    static constexpr uint32_t APB1ENR_TIM5EN = 0x8;         // TIM5 clock enable
    static constexpr uint32_t APB1ENR_TIM6EN = 0x10;        // TIM6 clock enable
    static constexpr uint32_t APB1ENR_TIM7EN = 0x20;        // TIM7 clock enable
    static constexpr uint32_t APB1ENR_TIM12EN = 0x40;       // TIM12 clock enable
    static constexpr uint32_t APB1ENR_TIM13EN = 0x80;       // TIM13 clock enable
    static constexpr uint32_t APB1ENR_TIM14EN = 0x100;      // TIM14 clock enable
    static constexpr uint32_t APB1ENR_WWDGEN = 0x800;       // Window watchdog clock enable
    static constexpr uint32_t APB1ENR_SPI2EN = 0x4000;      // SPI2 clock enable
    static constexpr uint32_t APB1ENR_SPI3EN = 0x8000;      // SPI3 clock enable
    static constexpr uint32_t APB1ENR_USART2EN = 0x20000;   // USART 2 clock enable
    static constexpr uint32_t APB1ENR_USART3EN = 0x40000;   // USART3 clock enable
    static constexpr uint32_t APB1ENR_UART4EN = 0x80000;    // UART4 clock enable
    static constexpr uint32_t APB1ENR_UART5EN = 0x100000;   // UART5 clock enable
    static constexpr uint32_t APB1ENR_I2C1EN = 0x200000;    // I2C1 clock enable
    static constexpr uint32_t APB1ENR_I2C2EN = 0x400000;    // I2C2 clock enable
    static constexpr uint32_t APB1ENR_I2C3EN = 0x800000;    // I2C3 clock enable
    static constexpr uint32_t APB1ENR_CAN1EN = 0x2000000;   // CAN 1 clock enable
    static constexpr uint32_t APB1ENR_CAN2EN = 0x4000000;   // CAN 2 clock enable
    static constexpr uint32_t APB1ENR_PWREN = 0x10000000;   // Power interface clock enable
    static constexpr uint32_t APB1ENR_DACEN = 0x20000000;   // DAC interface clock enable
    static constexpr uint32_t APB1ENR_UART7ENR = 0x40000000;// UART7 clock enable
    static constexpr uint32_t APB1ENR_UART8ENR = 0x80000000;// UART8 clock enable
    static constexpr uint32_t APB1ENR_SPDIFRXEN = 0x10000;  // SPDIF-RX clock enable
    static constexpr uint32_t APB1ENR_CECEN = 0x8000000;    // HDMI-CEN clock enable
    static constexpr uint32_t APB1ENR_LPTMI1EN = 0x200;     // Low power timer 1 clock enable
    static constexpr uint32_t APB1ENR_I2C4EN = 0x1000000;   // I2C4 clock enable
    static const uint32_t APB1ENR_RESET_VALUE = 0x0;

    static constexpr uint32_t APB2ENR_TIM1EN = 0x1;         // TIM1 clock enable
    static constexpr uint32_t APB2ENR_TIM8EN = 0x2;         // TIM8 clock enable
    static constexpr uint32_t APB2ENR_USART1EN = 0x10;      // USART1 clock enable
    static constexpr uint32_t APB2ENR_USART6EN = 0x20;      // USART6 clock enable
    static constexpr uint32_t APB2ENR_ADC1EN = 0x100;       // ADC1 clock enable
    static constexpr uint32_t APB2ENR_ADC2EN = 0x200;       // ADC2 clock enable
    static constexpr uint32_t APB2ENR_ADC3EN = 0x400;       // ADC3 clock enable
    static constexpr uint32_t APB2ENR_SPI1EN = 0x1000;      // SPI1 clock enable
    static constexpr uint32_t APB2ENR_SPI4ENR = 0x2000;     // SPI4 clock enable
    static constexpr uint32_t APB2ENR_SYSCFGEN = 0x4000;    // System configuration controller clock enable
    static constexpr uint32_t APB2ENR_TIM9EN = 0x10000;     // TIM9 clock enable
    static constexpr uint32_t APB2ENR_TIM10EN = 0x20000;    // TIM10 clock enable
    static constexpr uint32_t APB2ENR_TIM11EN = 0x40000;    // TIM11 clock enable
    static constexpr uint32_t APB2ENR_SPI5ENR = 0x100000;   // SPI5 clock enable
    static constexpr uint32_t APB2ENR_SPI6ENR = 0x200000;   // SPI6 clock enable
    static constexpr uint32_t APB2ENR_SAI1EN = 0x400000;    // SAI1 clock enable
    static constexpr uint32_t APB2ENR_LTDCEN = 0x4000000;   // LTDC clock enable
    static constexpr uint32_t APB2ENR_SAI2EN = 0x800000;    // SAI2 clock enable
    static constexpr uint32_t APB2ENR_SDMMC1EN = 0x800;     // SDMMC1 clock enable
    static const uint32_t APB2ENR_RESET_VALUE = 0x0;

    static constexpr uint32_t AHB1LPENR_GPIOALPEN = 0x1;      // IO port A clock enable during sleep mode
    static constexpr uint32_t AHB1LPENR_GPIOBLPEN = 0x2;      // IO port B clock enable during Sleep mode
    static constexpr uint32_t AHB1LPENR_GPIOCLPEN = 0x4;      // IO port C clock enable during Sleep mode
    static constexpr uint32_t AHB1LPENR_GPIODLPEN = 0x8;      // IO port D clock enable during Sleep mode
    static constexpr uint32_t AHB1LPENR_GPIOELPEN = 0x10;     // IO port E clock enable during Sleep mode
    static constexpr uint32_t AHB1LPENR_GPIOFLPEN = 0x20;     // IO port F clock enable during Sleep mode
    static constexpr uint32_t AHB1LPENR_GPIOGLPEN = 0x40;     // IO port G clock enable during Sleep mode
    static constexpr uint32_t AHB1LPENR_GPIOHLPEN = 0x80;     // IO port H clock enable during Sleep mode
    static constexpr uint32_t AHB1LPENR_GPIOILPEN = 0x100;    // IO port I clock enable during Sleep mode
    static constexpr uint32_t AHB1LPENR_GPIOJLPEN = 0x200;    // IO port J clock enable during Sleep mode
    static constexpr uint32_t AHB1LPENR_GPIOKLPEN = 0x400;    // IO port K clock enable during Sleep mode
    static constexpr uint32_t AHB1LPENR_CRCLPEN = 0x1000;     // CRC clock enable during Sleep mode
    static constexpr uint32_t AHB1LPENR_FLITFLPEN = 0x8000;   // Flash interface clock enable during Sleep mode
    static constexpr uint32_t AHB1LPENR_SRAM1LPEN = 0x10000;  // SRAM 1interface clock enable during Sleep mode
    static constexpr uint32_t AHB1LPENR_SRAM2LPEN = 0x20000;  // SRAM 2 interface clock enable during Sleep mode
    static constexpr uint32_t AHB1LPENR_BKPSRAMLPEN = 0x40000;// Backup SRAM interface clock enable during Sleep mode
    static constexpr uint32_t AHB1LPENR_SRAM3LPEN = 0x80000;  // SRAM 3 interface clock enable during Sleep mode
    static constexpr uint32_t AHB1LPENR_DMA1LPEN = 0x200000;  // DMA1 clock enable during Sleep mode
    static constexpr uint32_t AHB1LPENR_DMA2LPEN = 0x400000;  // DMA2 clock enable during Sleep mode
    static constexpr uint32_t AHB1LPENR_DMA2DLPEN = 0x800000; // DMA2D clock enable during Sleep mode
    static constexpr uint32_t AHB1LPENR_ETHMACLPEN = 0x2000000;// Ethernet MAC clock enable during Sleep mode
    static constexpr uint32_t AHB1LPENR_ETHMACTXLPEN = 0x4000000;// Ethernet transmission clock enable during Sleep mode
    static constexpr uint32_t AHB1LPENR_ETHMACRXLPEN = 0x8000000;// Ethernet reception clock enable during Sleep mode
    static constexpr uint32_t AHB1LPENR_ETHMACPTPLPEN = 0x10000000;// Ethernet PTP clock enable during Sleep mode
    static constexpr uint32_t AHB1LPENR_OTGHSLPEN = 0x20000000;// USB OTG HS clock enable during Sleep mode
    static constexpr uint32_t AHB1LPENR_OTGHSULPILPEN = 0x40000000;// USB OTG HS ULPI clock enable during Sleep mode
    static const uint32_t AHB1LPENR_RESET_VALUE = 0x7e6791ff;

    static constexpr uint32_t AHB2LPENR_OTGFSLPEN = 0x80;     // USB OTG FS clock enable during Sleep mode
    static constexpr uint32_t AHB2LPENR_RNGLPEN = 0x40;       // Random number generator clock enable during Sleep mode
    static constexpr uint32_t AHB2LPENR_HASHLPEN = 0x20;      // Hash modules clock enable during Sleep mode
    static constexpr uint32_t AHB2LPENR_CRYPLPEN = 0x10;      // Cryptography modules clock enable during Sleep mode
    static constexpr uint32_t AHB2LPENR_DCMILPEN = 0x1;       // Camera interface enable during Sleep mode
    static const uint32_t AHB2LPENR_RESET_VALUE = 0xf1;

    static constexpr uint32_t AHB3LPENR_FMCLPEN = 0x1;        // Flexible memory controller module clock enable during Sleep mode
    static constexpr uint32_t AHB3LPENR_QSPILPEN = 0x2;       // Quand SPI memory controller clock enable during Sleep mode
    static const uint32_t AHB3LPENR_RESET_VALUE = 0x1;

    static constexpr uint32_t APB1LPENR_TIM2LPEN = 0x1;       // TIM2 clock enable during Sleep mode
    static constexpr uint32_t APB1LPENR_TIM3LPEN = 0x2;       // TIM3 clock enable during Sleep mode
    static constexpr uint32_t APB1LPENR_TIM4LPEN = 0x4;       // TIM4 clock enable during Sleep mode
    static constexpr uint32_t APB1LPENR_TIM5LPEN = 0x8;       // TIM5 clock enable during Sleep mode
    static constexpr uint32_t APB1LPENR_TIM6LPEN = 0x10;      // TIM6 clock enable during Sleep mode
    static constexpr uint32_t APB1LPENR_TIM7LPEN = 0x20;      // TIM7 clock enable during Sleep mode
    static constexpr uint32_t APB1LPENR_TIM12LPEN = 0x40;     // TIM12 clock enable during Sleep mode
    static constexpr uint32_t APB1LPENR_TIM13LPEN = 0x80;     // TIM13 clock enable during Sleep mode
    static constexpr uint32_t APB1LPENR_TIM14LPEN = 0x100;    // TIM14 clock enable during Sleep mode
    static constexpr uint32_t APB1LPENR_WWDGLPEN = 0x800;     // Window watchdog clock enable during Sleep mode
    static constexpr uint32_t APB1LPENR_SPI2LPEN = 0x4000;    // SPI2 clock enable during Sleep mode
    static constexpr uint32_t APB1LPENR_SPI3LPEN = 0x8000;    // SPI3 clock enable during Sleep mode
    static constexpr uint32_t APB1LPENR_USART2LPEN = 0x20000; // USART2 clock enable during Sleep mode
    static constexpr uint32_t APB1LPENR_USART3LPEN = 0x40000; // USART3 clock enable during Sleep mode
    static constexpr uint32_t APB1LPENR_UART4LPEN = 0x80000;  // UART4 clock enable during Sleep mode
    static constexpr uint32_t APB1LPENR_UART5LPEN = 0x100000; // UART5 clock enable during Sleep mode
    static constexpr uint32_t APB1LPENR_I2C1LPEN = 0x200000;  // I2C1 clock enable during Sleep mode
    static constexpr uint32_t APB1LPENR_I2C2LPEN = 0x400000;  // I2C2 clock enable during Sleep mode
    static constexpr uint32_t APB1LPENR_I2C3LPEN = 0x800000;  // I2C3 clock enable during Sleep mode
    static constexpr uint32_t APB1LPENR_CAN1LPEN = 0x2000000; // CAN 1 clock enable during Sleep mode
    static constexpr uint32_t APB1LPENR_CAN2LPEN = 0x4000000; // CAN 2 clock enable during Sleep mode
    static constexpr uint32_t APB1LPENR_PWRLPEN = 0x10000000; // Power interface clock enable during Sleep mode
    static constexpr uint32_t APB1LPENR_DACLPEN = 0x20000000; // DAC interface clock enable during Sleep mode
    static constexpr uint32_t APB1LPENR_UART7LPEN = 0x40000000;// UART7 clock enable during Sleep mode
    static constexpr uint32_t APB1LPENR_UART8LPEN = 0x80000000;// UART8 clock enable during Sleep mode
    static constexpr uint32_t APB1LPENR_SPDIFRXLPEN = 0x10000;// SPDIF-RX clock enable during sleep mode
    static constexpr uint32_t APB1LPENR_CECLPEN = 0x8000000;  // HDMI-CEN clock enable during Sleep mode
    static constexpr uint32_t APB1LPENR_LPTIM1LPEN = 0x200;   // low power timer 1 clock enable during Sleep mode
    static constexpr uint32_t APB1LPENR_I2C4LPEN = 0x1000000; // I2C4 clock enable during Sleep mode
    static const uint32_t APB1LPENR_RESET_VALUE = 0x36fec9ff;

    static constexpr uint32_t APB2LPENR_TIM1LPEN = 0x1;       // TIM1 clock enable during Sleep mode
    static constexpr uint32_t APB2LPENR_TIM8LPEN = 0x2;       // TIM8 clock enable during Sleep mode
    static constexpr uint32_t APB2LPENR_USART1LPEN = 0x10;    // USART1 clock enable during Sleep mode
    static constexpr uint32_t APB2LPENR_USART6LPEN = 0x20;    // USART6 clock enable during Sleep mode
    static constexpr uint32_t APB2LPENR_ADC1LPEN = 0x100;     // ADC1 clock enable during Sleep mode
    static constexpr uint32_t APB2LPENR_ADC2LPEN = 0x200;     // ADC2 clock enable during Sleep mode
    static constexpr uint32_t APB2LPENR_ADC3LPEN = 0x400;     // ADC 3 clock enable during Sleep mode
    static constexpr uint32_t APB2LPENR_SPI1LPEN = 0x1000;    // SPI 1 clock enable during Sleep mode
    static constexpr uint32_t APB2LPENR_SPI4LPEN = 0x2000;    // SPI 4 clock enable during Sleep mode
    static constexpr uint32_t APB2LPENR_SYSCFGLPEN = 0x4000;  // System configuration controller clock enable during Sleep mode
    static constexpr uint32_t APB2LPENR_TIM9LPEN = 0x10000;   // TIM9 clock enable during sleep mode
    static constexpr uint32_t APB2LPENR_TIM10LPEN = 0x20000;  // TIM10 clock enable during Sleep mode
    static constexpr uint32_t APB2LPENR_TIM11LPEN = 0x40000;  // TIM11 clock enable during Sleep mode
    static constexpr uint32_t APB2LPENR_SPI5LPEN = 0x100000;  // SPI 5 clock enable during Sleep mode
    static constexpr uint32_t APB2LPENR_SPI6LPEN = 0x200000;  // SPI 6 clock enable during Sleep mode
    static constexpr uint32_t APB2LPENR_SAI1LPEN = 0x400000;  // SAI1 clock enable during sleep mode
    static constexpr uint32_t APB2LPENR_LTDCLPEN = 0x4000000; // LTDC clock enable during sleep mode
    static constexpr uint32_t APB2LPENR_SAI2LPEN = 0x800000;  // SAI2 clock enable during sleep mode
    static constexpr uint32_t APB2LPENR_SDMMC1LPEN = 0x800;   // SDMMC1 clock enable during Sleep mode
    static const uint32_t APB2LPENR_RESET_VALUE = 0x75f33;

    static constexpr uint32_t BDCR_BDRST = 0x10000;      // Backup domain software reset, Read-write
    static constexpr uint32_t BDCR_RTCEN = 0x8000;       // RTC clock enable, Read-write
    static constexpr uint32_t BDCR_RTCSEL1 = 0x200;      // RTC clock source selection, Read-write
    static constexpr uint32_t BDCR_RTCSEL0 = 0x100;      // RTC clock source selection, Read-write
    static constexpr uint32_t BDCR_LSEBYP = 0x4;         // External low-speed oscillator bypass, Read-write
    static constexpr uint32_t BDCR_LSERDY = 0x2;         // External low-speed oscillator ready, Read-only
    static constexpr uint32_t BDCR_LSEON = 0x1;          // External low-speed oscillator enable, Read-write
    static const uint32_t BDCR_RESET_VALUE = 0x0;

    static constexpr uint32_t CSR_LPWRRSTF = 0x80000000;// Low-power reset flag, Read-write
    static constexpr uint32_t CSR_WWDGRSTF = 0x40000000;// Window watchdog reset flag, Read-write
    static constexpr uint32_t CSR_WDGRSTF = 0x20000000; // Independent watchdog reset flag, Read-write
    static constexpr uint32_t CSR_SFTRSTF = 0x10000000; // Software reset flag, Read-write
    static constexpr uint32_t CSR_PORRSTF = 0x8000000;  // POR/PDR reset flag, Read-write
    static constexpr uint32_t CSR_PADRSTF = 0x4000000;  // PIN reset flag, Read-write
    static constexpr uint32_t CSR_BORRSTF = 0x2000000;  // BOR reset flag, Read-write
    static constexpr uint32_t CSR_RMVF = 0x1000000;     // Remove reset flag, Read-write
    static constexpr uint32_t CSR_LSIRDY = 0x2;         // Internal low-speed oscillator ready, Read-only
    static constexpr uint32_t CSR_LSION = 0x1;          // Internal low-speed oscillator enable, Read-write
    static const uint32_t CSR_RESET_VALUE = 0xe000000;

    static constexpr uint32_t SSCGR_SSCGEN = 0x80000000;  // Spread spectrum modulation enable
    static constexpr uint32_t SSCGR_SPREADSEL = 0x40000000;// Spread Select
    template<uint32_t X>
    static constexpr uint32_t SSCGR_INCSTEP =             // Incrementation step (15 bits)
        bit_field_t<13, 0x7fff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SSCGR_MODPER =              // Modulation period (13 bits)
        bit_field_t<0, 0x1fff>::value<X>();
    static const uint32_t SSCGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PLLI2SCFGR_PLLI2SR =             // PLLI2S division factor for I2S clocks (3 bits)
        bit_field_t<28, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PLLI2SCFGR_PLLI2SQ =             // PLLI2S division factor for SAI1 clock (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PLLI2SCFGR_PLLI2SN =             // PLLI2S multiplication factor for VCO (9 bits)
        bit_field_t<6, 0x1ff>::value<X>();
    static const uint32_t PLLI2SCFGR_RESET_VALUE = 0x20003000;

    template<uint32_t X>
    static constexpr uint32_t PLLSAICFGR_PLLSAIN =             // PLLSAI division factor for VCO (9 bits)
        bit_field_t<6, 0x1ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PLLSAICFGR_PLLSAIP =             // PLLSAI division factor for 48MHz clock (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PLLSAICFGR_PLLSAIQ =             // PLLSAI division factor for SAI clock (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PLLSAICFGR_PLLSAIR =             // PLLSAI division factor for LCD clock (3 bits)
        bit_field_t<28, 0x7>::value<X>();
    static const uint32_t PLLSAICFGR_RESET_VALUE = 0x20003000;

    template<uint32_t X>
    static constexpr uint32_t DKCFGR1_PLLI2SDIV =           // PLLI2S division factor for SAI1 clock (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DKCFGR1_PLLSAIDIVQ =          // PLLSAI division factor for SAI1 clock (5 bits)
        bit_field_t<8, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DKCFGR1_PLLSAIDIVR =          // division factor for LCD_CLK (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DKCFGR1_SAI1SEL =             // SAI1 clock source selection (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DKCFGR1_SAI2SEL =             // SAI2 clock source selection (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    static constexpr uint32_t DKCFGR1_TIMPRE = 0x1000000;   // Timers clocks prescalers selection
    static const uint32_t DKCFGR1_RESET_VALUE = 0x20003000;

    template<uint32_t X>
    static constexpr uint32_t DKCFGR2_USART1SEL =           // USART 1 clock source selection (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DKCFGR2_USART2SEL =           // USART 2 clock source selection (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DKCFGR2_USART3SEL =           // USART 3 clock source selection (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DKCFGR2_UART4SEL =            // UART 4 clock source selection (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DKCFGR2_UART5SEL =            // UART 5 clock source selection (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DKCFGR2_USART6SEL =           // USART 6 clock source selection (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DKCFGR2_UART7SEL =            // UART 7 clock source selection (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DKCFGR2_UART8SEL =            // UART 8 clock source selection (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DKCFGR2_I2C1SEL =             // I2C1 clock source selection (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DKCFGR2_I2C2SEL =             // I2C2 clock source selection (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DKCFGR2_I2C3SEL =             // I2C3 clock source selection (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DKCFGR2_I2C4SEL =             // I2C4 clock source selection (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DKCFGR2_LPTIM1SEL =           // Low power timer 1 clock source selection (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    static constexpr uint32_t DKCFGR2_CECSEL = 0x4000000;   // HDMI-CEC clock source selection
    static constexpr uint32_t DKCFGR2_CK48MSEL = 0x8000000; // 48MHz clock source selection
    static constexpr uint32_t DKCFGR2_SDMMCSEL = 0x10000000;// SDMMC clock source selection
    static const uint32_t DKCFGR2_RESET_VALUE = 0x20003000;

    static constexpr uint8_t RCC = 5; // RCC global interrupt
};

static rcc_t& RCC = *reinterpret_cast<rcc_t*>(0x40023800);

#define HAVE_PERIPHERAL_RCC


////
//
//    General-purpose I/Os
//
////

struct gpiod_t
{
    volatile uint32_t    MODER;                // [Read-write] GPIO port mode register
    volatile uint32_t    OTYPER;               // [Read-write] GPIO port output type register
    volatile uint32_t    GPIOB_OSPEEDR;        // [Read-write] GPIO port output speed register
    volatile uint32_t    PUPDR;                // [Read-write] GPIO port pull-up/pull-down register
    volatile uint32_t    IDR;                  // [Read-only] GPIO port input data register
    volatile uint32_t    ODR;                  // [Read-write] GPIO port output data register
    volatile uint32_t    BSRR;                 // [Write-only] GPIO port bit set/reset register
    volatile uint32_t    LCKR;                 // [Read-write] GPIO port configuration lock register
    volatile uint32_t    AFRL;                 // [Read-write] GPIO alternate function lowregister
    volatile uint32_t    AFRH;                 // [Read-write] GPIO alternate function high register
    volatile uint32_t    BRR;                  // [Read-write] GPIO port bit reset register

    template<uint32_t X>
    static constexpr uint32_t MODER_MODER15 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER14 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER13 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER12 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER11 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER10 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER9 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER8 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER7 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER6 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER5 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER4 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER3 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER2 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER1 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER0 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t MODER_RESET_VALUE = 0x0;

    static constexpr uint32_t OTYPER_OT15 = 0x8000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT14 = 0x4000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT13 = 0x2000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT12 = 0x1000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT11 = 0x800;         // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT10 = 0x400;         // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT9 = 0x200;          // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT8 = 0x100;          // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT7 = 0x80;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT6 = 0x40;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT5 = 0x20;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT4 = 0x10;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT3 = 0x8;            // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT2 = 0x4;            // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT1 = 0x2;            // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT0 = 0x1;            // Port x configuration bits (y = 0..15)
    static const uint32_t OTYPER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR15 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR14 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR13 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR12 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR11 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR10 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR9 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR8 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR7 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR6 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR5 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR4 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR3 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR2 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR1 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR0 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t GPIOB_OSPEEDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR15 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR14 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR13 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR12 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR11 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR10 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR9 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR8 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR7 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR6 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR5 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR4 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR3 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR2 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR1 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR0 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t PUPDR_RESET_VALUE = 0x0;

    static constexpr uint32_t IDR_IDR15 = 0x8000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR14 = 0x4000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR13 = 0x2000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR12 = 0x1000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR11 = 0x800;        // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR10 = 0x400;        // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR9 = 0x200;         // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR8 = 0x100;         // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR7 = 0x80;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR6 = 0x40;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR5 = 0x20;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR4 = 0x10;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR3 = 0x8;           // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR2 = 0x4;           // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR1 = 0x2;           // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR0 = 0x1;           // Port input data (y = 0..15)
    static const uint32_t IDR_RESET_VALUE = 0x0;

    static constexpr uint32_t ODR_ODR15 = 0x8000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR14 = 0x4000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR13 = 0x2000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR12 = 0x1000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR11 = 0x800;        // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR10 = 0x400;        // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR9 = 0x200;         // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR8 = 0x100;         // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR7 = 0x80;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR6 = 0x40;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR5 = 0x20;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR4 = 0x10;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR3 = 0x8;           // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR2 = 0x4;           // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR1 = 0x2;           // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR0 = 0x1;           // Port output data (y = 0..15)
    static const uint32_t ODR_RESET_VALUE = 0x0;

    static constexpr uint32_t BSRR_BR15 = 0x80000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR14 = 0x40000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR13 = 0x20000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR12 = 0x10000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR11 = 0x8000000;     // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR10 = 0x4000000;     // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR9 = 0x2000000;      // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR8 = 0x1000000;      // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR7 = 0x800000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR6 = 0x400000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR5 = 0x200000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR4 = 0x100000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR3 = 0x80000;        // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR2 = 0x40000;        // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR1 = 0x20000;        // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR0 = 0x10000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS15 = 0x8000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS14 = 0x4000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS13 = 0x2000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS12 = 0x1000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS11 = 0x800;         // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS10 = 0x400;         // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS9 = 0x200;          // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS8 = 0x100;          // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS7 = 0x80;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS6 = 0x40;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS5 = 0x20;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS4 = 0x10;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS3 = 0x8;            // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS2 = 0x4;            // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS1 = 0x2;            // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS0 = 0x1;            // Port x set bit y (y= 0..15)
    static const uint32_t BSRR_RESET_VALUE = 0x0;

    static constexpr uint32_t LCKR_LCKK = 0x10000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK15 = 0x8000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK14 = 0x4000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK13 = 0x2000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK12 = 0x1000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK11 = 0x800;        // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK10 = 0x400;        // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK9 = 0x200;         // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK8 = 0x100;         // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK7 = 0x80;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK6 = 0x40;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK5 = 0x20;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK4 = 0x10;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK3 = 0x8;           // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK2 = 0x4;           // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK1 = 0x2;           // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK0 = 0x1;           // Port x lock bit y (y= 0..15)
    static const uint32_t LCKR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL7 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL6 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL5 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL4 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL3 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL2 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL1 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL0 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t AFRL_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH15 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH14 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH13 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH12 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH11 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH10 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH9 =               // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH8 =               // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t AFRH_RESET_VALUE = 0x0;

    static constexpr uint32_t BRR_BR0 = 0x1;            // Port D Reset bit 0
    static constexpr uint32_t BRR_BR1 = 0x2;            // Port D Reset bit 1
    static constexpr uint32_t BRR_BR2 = 0x4;            // Port D Reset bit 2
    static constexpr uint32_t BRR_BR3 = 0x8;            // Port D Reset bit 3
    static constexpr uint32_t BRR_BR4 = 0x10;           // Port D Reset bit 4
    static constexpr uint32_t BRR_BR5 = 0x20;           // Port D Reset bit 5
    static constexpr uint32_t BRR_BR6 = 0x40;           // Port D Reset bit 6
    static constexpr uint32_t BRR_BR7 = 0x80;           // Port D Reset bit 7
    static constexpr uint32_t BRR_BR8 = 0x100;          // Port D Reset bit 8
    static constexpr uint32_t BRR_BR9 = 0x200;          // Port D Reset bit 9
    static constexpr uint32_t BRR_BR10 = 0x400;         // Port D Reset bit 10
    static constexpr uint32_t BRR_BR11 = 0x800;         // Port D Reset bit 11
    static constexpr uint32_t BRR_BR12 = 0x1000;        // Port D Reset bit 12
    static constexpr uint32_t BRR_BR13 = 0x2000;        // Port D Reset bit 13
    static constexpr uint32_t BRR_BR14 = 0x4000;        // Port D Reset bit 14
    static constexpr uint32_t BRR_BR15 = 0x8000;        // Port D Reset bit 15
    static const uint32_t BRR_RESET_VALUE = 0x0;
};

static gpiod_t& GPIOD = *reinterpret_cast<gpiod_t*>(0x40020c00);

#define HAVE_PERIPHERAL_GPIOD


////
//
//    General-purpose I/Os
//
////

struct gpioc_t
{
    volatile uint32_t    MODER;                // [Read-write] GPIO port mode register
    volatile uint32_t    OTYPER;               // [Read-write] GPIO port output type register
    volatile uint32_t    GPIOB_OSPEEDR;        // [Read-write] GPIO port output speed register
    volatile uint32_t    PUPDR;                // [Read-write] GPIO port pull-up/pull-down register
    volatile uint32_t    IDR;                  // [Read-only] GPIO port input data register
    volatile uint32_t    ODR;                  // [Read-write] GPIO port output data register
    volatile uint32_t    BSRR;                 // [Write-only] GPIO port bit set/reset register
    volatile uint32_t    LCKR;                 // [Read-write] GPIO port configuration lock register
    volatile uint32_t    AFRL;                 // [Read-write] GPIO alternate function lowregister
    volatile uint32_t    AFRH;                 // [Read-write] GPIO alternate function high register
    volatile uint32_t    BRR;                  // [Read-write] GPIO port bit reset register

    template<uint32_t X>
    static constexpr uint32_t MODER_MODER15 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER14 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER13 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER12 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER11 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER10 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER9 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER8 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER7 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER6 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER5 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER4 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER3 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER2 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER1 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER0 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t MODER_RESET_VALUE = 0x0;

    static constexpr uint32_t OTYPER_OT15 = 0x8000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT14 = 0x4000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT13 = 0x2000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT12 = 0x1000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT11 = 0x800;         // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT10 = 0x400;         // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT9 = 0x200;          // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT8 = 0x100;          // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT7 = 0x80;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT6 = 0x40;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT5 = 0x20;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT4 = 0x10;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT3 = 0x8;            // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT2 = 0x4;            // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT1 = 0x2;            // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT0 = 0x1;            // Port x configuration bits (y = 0..15)
    static const uint32_t OTYPER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR15 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR14 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR13 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR12 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR11 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR10 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR9 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR8 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR7 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR6 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR5 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR4 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR3 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR2 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR1 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR0 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t GPIOB_OSPEEDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR15 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR14 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR13 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR12 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR11 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR10 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR9 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR8 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR7 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR6 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR5 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR4 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR3 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR2 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR1 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR0 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t PUPDR_RESET_VALUE = 0x0;

    static constexpr uint32_t IDR_IDR15 = 0x8000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR14 = 0x4000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR13 = 0x2000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR12 = 0x1000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR11 = 0x800;        // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR10 = 0x400;        // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR9 = 0x200;         // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR8 = 0x100;         // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR7 = 0x80;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR6 = 0x40;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR5 = 0x20;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR4 = 0x10;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR3 = 0x8;           // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR2 = 0x4;           // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR1 = 0x2;           // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR0 = 0x1;           // Port input data (y = 0..15)
    static const uint32_t IDR_RESET_VALUE = 0x0;

    static constexpr uint32_t ODR_ODR15 = 0x8000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR14 = 0x4000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR13 = 0x2000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR12 = 0x1000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR11 = 0x800;        // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR10 = 0x400;        // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR9 = 0x200;         // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR8 = 0x100;         // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR7 = 0x80;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR6 = 0x40;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR5 = 0x20;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR4 = 0x10;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR3 = 0x8;           // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR2 = 0x4;           // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR1 = 0x2;           // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR0 = 0x1;           // Port output data (y = 0..15)
    static const uint32_t ODR_RESET_VALUE = 0x0;

    static constexpr uint32_t BSRR_BR15 = 0x80000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR14 = 0x40000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR13 = 0x20000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR12 = 0x10000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR11 = 0x8000000;     // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR10 = 0x4000000;     // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR9 = 0x2000000;      // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR8 = 0x1000000;      // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR7 = 0x800000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR6 = 0x400000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR5 = 0x200000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR4 = 0x100000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR3 = 0x80000;        // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR2 = 0x40000;        // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR1 = 0x20000;        // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR0 = 0x10000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS15 = 0x8000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS14 = 0x4000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS13 = 0x2000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS12 = 0x1000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS11 = 0x800;         // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS10 = 0x400;         // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS9 = 0x200;          // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS8 = 0x100;          // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS7 = 0x80;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS6 = 0x40;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS5 = 0x20;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS4 = 0x10;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS3 = 0x8;            // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS2 = 0x4;            // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS1 = 0x2;            // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS0 = 0x1;            // Port x set bit y (y= 0..15)
    static const uint32_t BSRR_RESET_VALUE = 0x0;

    static constexpr uint32_t LCKR_LCKK = 0x10000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK15 = 0x8000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK14 = 0x4000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK13 = 0x2000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK12 = 0x1000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK11 = 0x800;        // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK10 = 0x400;        // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK9 = 0x200;         // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK8 = 0x100;         // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK7 = 0x80;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK6 = 0x40;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK5 = 0x20;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK4 = 0x10;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK3 = 0x8;           // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK2 = 0x4;           // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK1 = 0x2;           // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK0 = 0x1;           // Port x lock bit y (y= 0..15)
    static const uint32_t LCKR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL7 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL6 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL5 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL4 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL3 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL2 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL1 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL0 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t AFRL_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH15 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH14 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH13 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH12 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH11 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH10 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH9 =               // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH8 =               // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t AFRH_RESET_VALUE = 0x0;

    static constexpr uint32_t BRR_BR0 = 0x1;            // Port D Reset bit 0
    static constexpr uint32_t BRR_BR1 = 0x2;            // Port D Reset bit 1
    static constexpr uint32_t BRR_BR2 = 0x4;            // Port D Reset bit 2
    static constexpr uint32_t BRR_BR3 = 0x8;            // Port D Reset bit 3
    static constexpr uint32_t BRR_BR4 = 0x10;           // Port D Reset bit 4
    static constexpr uint32_t BRR_BR5 = 0x20;           // Port D Reset bit 5
    static constexpr uint32_t BRR_BR6 = 0x40;           // Port D Reset bit 6
    static constexpr uint32_t BRR_BR7 = 0x80;           // Port D Reset bit 7
    static constexpr uint32_t BRR_BR8 = 0x100;          // Port D Reset bit 8
    static constexpr uint32_t BRR_BR9 = 0x200;          // Port D Reset bit 9
    static constexpr uint32_t BRR_BR10 = 0x400;         // Port D Reset bit 10
    static constexpr uint32_t BRR_BR11 = 0x800;         // Port D Reset bit 11
    static constexpr uint32_t BRR_BR12 = 0x1000;        // Port D Reset bit 12
    static constexpr uint32_t BRR_BR13 = 0x2000;        // Port D Reset bit 13
    static constexpr uint32_t BRR_BR14 = 0x4000;        // Port D Reset bit 14
    static constexpr uint32_t BRR_BR15 = 0x8000;        // Port D Reset bit 15
    static const uint32_t BRR_RESET_VALUE = 0x0;
};

static gpioc_t& GPIOC = *reinterpret_cast<gpioc_t*>(0x40020800);

#define HAVE_PERIPHERAL_GPIOC


////
//
//    General-purpose I/Os
//
////

struct gpiok_t
{
    volatile uint32_t    MODER;                // [Read-write] GPIO port mode register
    volatile uint32_t    OTYPER;               // [Read-write] GPIO port output type register
    volatile uint32_t    GPIOB_OSPEEDR;        // [Read-write] GPIO port output speed register
    volatile uint32_t    PUPDR;                // [Read-write] GPIO port pull-up/pull-down register
    volatile uint32_t    IDR;                  // [Read-only] GPIO port input data register
    volatile uint32_t    ODR;                  // [Read-write] GPIO port output data register
    volatile uint32_t    BSRR;                 // [Write-only] GPIO port bit set/reset register
    volatile uint32_t    LCKR;                 // [Read-write] GPIO port configuration lock register
    volatile uint32_t    AFRL;                 // [Read-write] GPIO alternate function lowregister
    volatile uint32_t    AFRH;                 // [Read-write] GPIO alternate function high register
    volatile uint32_t    BRR;                  // [Read-write] GPIO port bit reset register

    template<uint32_t X>
    static constexpr uint32_t MODER_MODER15 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER14 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER13 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER12 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER11 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER10 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER9 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER8 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER7 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER6 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER5 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER4 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER3 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER2 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER1 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER0 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t MODER_RESET_VALUE = 0x0;

    static constexpr uint32_t OTYPER_OT15 = 0x8000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT14 = 0x4000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT13 = 0x2000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT12 = 0x1000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT11 = 0x800;         // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT10 = 0x400;         // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT9 = 0x200;          // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT8 = 0x100;          // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT7 = 0x80;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT6 = 0x40;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT5 = 0x20;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT4 = 0x10;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT3 = 0x8;            // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT2 = 0x4;            // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT1 = 0x2;            // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT0 = 0x1;            // Port x configuration bits (y = 0..15)
    static const uint32_t OTYPER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR15 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR14 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR13 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR12 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR11 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR10 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR9 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR8 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR7 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR6 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR5 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR4 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR3 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR2 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR1 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR0 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t GPIOB_OSPEEDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR15 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR14 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR13 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR12 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR11 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR10 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR9 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR8 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR7 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR6 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR5 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR4 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR3 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR2 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR1 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR0 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t PUPDR_RESET_VALUE = 0x0;

    static constexpr uint32_t IDR_IDR15 = 0x8000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR14 = 0x4000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR13 = 0x2000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR12 = 0x1000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR11 = 0x800;        // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR10 = 0x400;        // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR9 = 0x200;         // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR8 = 0x100;         // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR7 = 0x80;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR6 = 0x40;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR5 = 0x20;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR4 = 0x10;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR3 = 0x8;           // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR2 = 0x4;           // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR1 = 0x2;           // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR0 = 0x1;           // Port input data (y = 0..15)
    static const uint32_t IDR_RESET_VALUE = 0x0;

    static constexpr uint32_t ODR_ODR15 = 0x8000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR14 = 0x4000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR13 = 0x2000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR12 = 0x1000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR11 = 0x800;        // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR10 = 0x400;        // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR9 = 0x200;         // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR8 = 0x100;         // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR7 = 0x80;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR6 = 0x40;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR5 = 0x20;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR4 = 0x10;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR3 = 0x8;           // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR2 = 0x4;           // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR1 = 0x2;           // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR0 = 0x1;           // Port output data (y = 0..15)
    static const uint32_t ODR_RESET_VALUE = 0x0;

    static constexpr uint32_t BSRR_BR15 = 0x80000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR14 = 0x40000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR13 = 0x20000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR12 = 0x10000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR11 = 0x8000000;     // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR10 = 0x4000000;     // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR9 = 0x2000000;      // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR8 = 0x1000000;      // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR7 = 0x800000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR6 = 0x400000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR5 = 0x200000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR4 = 0x100000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR3 = 0x80000;        // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR2 = 0x40000;        // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR1 = 0x20000;        // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR0 = 0x10000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS15 = 0x8000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS14 = 0x4000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS13 = 0x2000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS12 = 0x1000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS11 = 0x800;         // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS10 = 0x400;         // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS9 = 0x200;          // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS8 = 0x100;          // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS7 = 0x80;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS6 = 0x40;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS5 = 0x20;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS4 = 0x10;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS3 = 0x8;            // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS2 = 0x4;            // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS1 = 0x2;            // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS0 = 0x1;            // Port x set bit y (y= 0..15)
    static const uint32_t BSRR_RESET_VALUE = 0x0;

    static constexpr uint32_t LCKR_LCKK = 0x10000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK15 = 0x8000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK14 = 0x4000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK13 = 0x2000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK12 = 0x1000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK11 = 0x800;        // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK10 = 0x400;        // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK9 = 0x200;         // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK8 = 0x100;         // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK7 = 0x80;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK6 = 0x40;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK5 = 0x20;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK4 = 0x10;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK3 = 0x8;           // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK2 = 0x4;           // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK1 = 0x2;           // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK0 = 0x1;           // Port x lock bit y (y= 0..15)
    static const uint32_t LCKR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL7 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL6 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL5 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL4 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL3 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL2 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL1 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL0 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t AFRL_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH15 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH14 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH13 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH12 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH11 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH10 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH9 =               // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH8 =               // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t AFRH_RESET_VALUE = 0x0;

    static constexpr uint32_t BRR_BR0 = 0x1;            // Port D Reset bit 0
    static constexpr uint32_t BRR_BR1 = 0x2;            // Port D Reset bit 1
    static constexpr uint32_t BRR_BR2 = 0x4;            // Port D Reset bit 2
    static constexpr uint32_t BRR_BR3 = 0x8;            // Port D Reset bit 3
    static constexpr uint32_t BRR_BR4 = 0x10;           // Port D Reset bit 4
    static constexpr uint32_t BRR_BR5 = 0x20;           // Port D Reset bit 5
    static constexpr uint32_t BRR_BR6 = 0x40;           // Port D Reset bit 6
    static constexpr uint32_t BRR_BR7 = 0x80;           // Port D Reset bit 7
    static constexpr uint32_t BRR_BR8 = 0x100;          // Port D Reset bit 8
    static constexpr uint32_t BRR_BR9 = 0x200;          // Port D Reset bit 9
    static constexpr uint32_t BRR_BR10 = 0x400;         // Port D Reset bit 10
    static constexpr uint32_t BRR_BR11 = 0x800;         // Port D Reset bit 11
    static constexpr uint32_t BRR_BR12 = 0x1000;        // Port D Reset bit 12
    static constexpr uint32_t BRR_BR13 = 0x2000;        // Port D Reset bit 13
    static constexpr uint32_t BRR_BR14 = 0x4000;        // Port D Reset bit 14
    static constexpr uint32_t BRR_BR15 = 0x8000;        // Port D Reset bit 15
    static const uint32_t BRR_RESET_VALUE = 0x0;
};

static gpiok_t& GPIOK = *reinterpret_cast<gpiok_t*>(0x40022800);

#define HAVE_PERIPHERAL_GPIOK


////
//
//    General-purpose I/Os
//
////

struct gpioj_t
{
    volatile uint32_t    MODER;                // [Read-write] GPIO port mode register
    volatile uint32_t    OTYPER;               // [Read-write] GPIO port output type register
    volatile uint32_t    GPIOB_OSPEEDR;        // [Read-write] GPIO port output speed register
    volatile uint32_t    PUPDR;                // [Read-write] GPIO port pull-up/pull-down register
    volatile uint32_t    IDR;                  // [Read-only] GPIO port input data register
    volatile uint32_t    ODR;                  // [Read-write] GPIO port output data register
    volatile uint32_t    BSRR;                 // [Write-only] GPIO port bit set/reset register
    volatile uint32_t    LCKR;                 // [Read-write] GPIO port configuration lock register
    volatile uint32_t    AFRL;                 // [Read-write] GPIO alternate function lowregister
    volatile uint32_t    AFRH;                 // [Read-write] GPIO alternate function high register
    volatile uint32_t    BRR;                  // [Read-write] GPIO port bit reset register

    template<uint32_t X>
    static constexpr uint32_t MODER_MODER15 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER14 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER13 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER12 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER11 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER10 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER9 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER8 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER7 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER6 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER5 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER4 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER3 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER2 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER1 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER0 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t MODER_RESET_VALUE = 0x0;

    static constexpr uint32_t OTYPER_OT15 = 0x8000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT14 = 0x4000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT13 = 0x2000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT12 = 0x1000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT11 = 0x800;         // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT10 = 0x400;         // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT9 = 0x200;          // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT8 = 0x100;          // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT7 = 0x80;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT6 = 0x40;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT5 = 0x20;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT4 = 0x10;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT3 = 0x8;            // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT2 = 0x4;            // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT1 = 0x2;            // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT0 = 0x1;            // Port x configuration bits (y = 0..15)
    static const uint32_t OTYPER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR15 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR14 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR13 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR12 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR11 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR10 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR9 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR8 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR7 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR6 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR5 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR4 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR3 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR2 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR1 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR0 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t GPIOB_OSPEEDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR15 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR14 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR13 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR12 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR11 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR10 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR9 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR8 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR7 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR6 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR5 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR4 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR3 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR2 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR1 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR0 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t PUPDR_RESET_VALUE = 0x0;

    static constexpr uint32_t IDR_IDR15 = 0x8000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR14 = 0x4000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR13 = 0x2000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR12 = 0x1000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR11 = 0x800;        // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR10 = 0x400;        // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR9 = 0x200;         // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR8 = 0x100;         // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR7 = 0x80;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR6 = 0x40;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR5 = 0x20;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR4 = 0x10;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR3 = 0x8;           // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR2 = 0x4;           // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR1 = 0x2;           // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR0 = 0x1;           // Port input data (y = 0..15)
    static const uint32_t IDR_RESET_VALUE = 0x0;

    static constexpr uint32_t ODR_ODR15 = 0x8000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR14 = 0x4000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR13 = 0x2000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR12 = 0x1000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR11 = 0x800;        // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR10 = 0x400;        // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR9 = 0x200;         // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR8 = 0x100;         // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR7 = 0x80;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR6 = 0x40;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR5 = 0x20;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR4 = 0x10;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR3 = 0x8;           // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR2 = 0x4;           // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR1 = 0x2;           // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR0 = 0x1;           // Port output data (y = 0..15)
    static const uint32_t ODR_RESET_VALUE = 0x0;

    static constexpr uint32_t BSRR_BR15 = 0x80000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR14 = 0x40000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR13 = 0x20000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR12 = 0x10000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR11 = 0x8000000;     // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR10 = 0x4000000;     // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR9 = 0x2000000;      // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR8 = 0x1000000;      // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR7 = 0x800000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR6 = 0x400000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR5 = 0x200000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR4 = 0x100000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR3 = 0x80000;        // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR2 = 0x40000;        // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR1 = 0x20000;        // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR0 = 0x10000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS15 = 0x8000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS14 = 0x4000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS13 = 0x2000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS12 = 0x1000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS11 = 0x800;         // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS10 = 0x400;         // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS9 = 0x200;          // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS8 = 0x100;          // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS7 = 0x80;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS6 = 0x40;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS5 = 0x20;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS4 = 0x10;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS3 = 0x8;            // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS2 = 0x4;            // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS1 = 0x2;            // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS0 = 0x1;            // Port x set bit y (y= 0..15)
    static const uint32_t BSRR_RESET_VALUE = 0x0;

    static constexpr uint32_t LCKR_LCKK = 0x10000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK15 = 0x8000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK14 = 0x4000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK13 = 0x2000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK12 = 0x1000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK11 = 0x800;        // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK10 = 0x400;        // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK9 = 0x200;         // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK8 = 0x100;         // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK7 = 0x80;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK6 = 0x40;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK5 = 0x20;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK4 = 0x10;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK3 = 0x8;           // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK2 = 0x4;           // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK1 = 0x2;           // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK0 = 0x1;           // Port x lock bit y (y= 0..15)
    static const uint32_t LCKR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL7 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL6 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL5 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL4 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL3 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL2 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL1 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL0 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t AFRL_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH15 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH14 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH13 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH12 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH11 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH10 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH9 =               // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH8 =               // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t AFRH_RESET_VALUE = 0x0;

    static constexpr uint32_t BRR_BR0 = 0x1;            // Port D Reset bit 0
    static constexpr uint32_t BRR_BR1 = 0x2;            // Port D Reset bit 1
    static constexpr uint32_t BRR_BR2 = 0x4;            // Port D Reset bit 2
    static constexpr uint32_t BRR_BR3 = 0x8;            // Port D Reset bit 3
    static constexpr uint32_t BRR_BR4 = 0x10;           // Port D Reset bit 4
    static constexpr uint32_t BRR_BR5 = 0x20;           // Port D Reset bit 5
    static constexpr uint32_t BRR_BR6 = 0x40;           // Port D Reset bit 6
    static constexpr uint32_t BRR_BR7 = 0x80;           // Port D Reset bit 7
    static constexpr uint32_t BRR_BR8 = 0x100;          // Port D Reset bit 8
    static constexpr uint32_t BRR_BR9 = 0x200;          // Port D Reset bit 9
    static constexpr uint32_t BRR_BR10 = 0x400;         // Port D Reset bit 10
    static constexpr uint32_t BRR_BR11 = 0x800;         // Port D Reset bit 11
    static constexpr uint32_t BRR_BR12 = 0x1000;        // Port D Reset bit 12
    static constexpr uint32_t BRR_BR13 = 0x2000;        // Port D Reset bit 13
    static constexpr uint32_t BRR_BR14 = 0x4000;        // Port D Reset bit 14
    static constexpr uint32_t BRR_BR15 = 0x8000;        // Port D Reset bit 15
    static const uint32_t BRR_RESET_VALUE = 0x0;
};

static gpioj_t& GPIOJ = *reinterpret_cast<gpioj_t*>(0x40022400);

#define HAVE_PERIPHERAL_GPIOJ


////
//
//    General-purpose I/Os
//
////

struct gpioi_t
{
    volatile uint32_t    MODER;                // [Read-write] GPIO port mode register
    volatile uint32_t    OTYPER;               // [Read-write] GPIO port output type register
    volatile uint32_t    GPIOB_OSPEEDR;        // [Read-write] GPIO port output speed register
    volatile uint32_t    PUPDR;                // [Read-write] GPIO port pull-up/pull-down register
    volatile uint32_t    IDR;                  // [Read-only] GPIO port input data register
    volatile uint32_t    ODR;                  // [Read-write] GPIO port output data register
    volatile uint32_t    BSRR;                 // [Write-only] GPIO port bit set/reset register
    volatile uint32_t    LCKR;                 // [Read-write] GPIO port configuration lock register
    volatile uint32_t    AFRL;                 // [Read-write] GPIO alternate function lowregister
    volatile uint32_t    AFRH;                 // [Read-write] GPIO alternate function high register
    volatile uint32_t    BRR;                  // [Read-write] GPIO port bit reset register

    template<uint32_t X>
    static constexpr uint32_t MODER_MODER15 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER14 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER13 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER12 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER11 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER10 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER9 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER8 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER7 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER6 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER5 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER4 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER3 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER2 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER1 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER0 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t MODER_RESET_VALUE = 0x0;

    static constexpr uint32_t OTYPER_OT15 = 0x8000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT14 = 0x4000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT13 = 0x2000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT12 = 0x1000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT11 = 0x800;         // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT10 = 0x400;         // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT9 = 0x200;          // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT8 = 0x100;          // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT7 = 0x80;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT6 = 0x40;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT5 = 0x20;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT4 = 0x10;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT3 = 0x8;            // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT2 = 0x4;            // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT1 = 0x2;            // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT0 = 0x1;            // Port x configuration bits (y = 0..15)
    static const uint32_t OTYPER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR15 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR14 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR13 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR12 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR11 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR10 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR9 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR8 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR7 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR6 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR5 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR4 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR3 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR2 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR1 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR0 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t GPIOB_OSPEEDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR15 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR14 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR13 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR12 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR11 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR10 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR9 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR8 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR7 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR6 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR5 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR4 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR3 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR2 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR1 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR0 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t PUPDR_RESET_VALUE = 0x0;

    static constexpr uint32_t IDR_IDR15 = 0x8000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR14 = 0x4000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR13 = 0x2000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR12 = 0x1000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR11 = 0x800;        // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR10 = 0x400;        // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR9 = 0x200;         // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR8 = 0x100;         // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR7 = 0x80;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR6 = 0x40;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR5 = 0x20;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR4 = 0x10;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR3 = 0x8;           // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR2 = 0x4;           // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR1 = 0x2;           // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR0 = 0x1;           // Port input data (y = 0..15)
    static const uint32_t IDR_RESET_VALUE = 0x0;

    static constexpr uint32_t ODR_ODR15 = 0x8000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR14 = 0x4000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR13 = 0x2000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR12 = 0x1000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR11 = 0x800;        // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR10 = 0x400;        // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR9 = 0x200;         // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR8 = 0x100;         // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR7 = 0x80;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR6 = 0x40;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR5 = 0x20;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR4 = 0x10;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR3 = 0x8;           // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR2 = 0x4;           // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR1 = 0x2;           // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR0 = 0x1;           // Port output data (y = 0..15)
    static const uint32_t ODR_RESET_VALUE = 0x0;

    static constexpr uint32_t BSRR_BR15 = 0x80000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR14 = 0x40000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR13 = 0x20000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR12 = 0x10000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR11 = 0x8000000;     // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR10 = 0x4000000;     // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR9 = 0x2000000;      // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR8 = 0x1000000;      // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR7 = 0x800000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR6 = 0x400000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR5 = 0x200000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR4 = 0x100000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR3 = 0x80000;        // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR2 = 0x40000;        // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR1 = 0x20000;        // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR0 = 0x10000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS15 = 0x8000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS14 = 0x4000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS13 = 0x2000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS12 = 0x1000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS11 = 0x800;         // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS10 = 0x400;         // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS9 = 0x200;          // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS8 = 0x100;          // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS7 = 0x80;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS6 = 0x40;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS5 = 0x20;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS4 = 0x10;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS3 = 0x8;            // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS2 = 0x4;            // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS1 = 0x2;            // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS0 = 0x1;            // Port x set bit y (y= 0..15)
    static const uint32_t BSRR_RESET_VALUE = 0x0;

    static constexpr uint32_t LCKR_LCKK = 0x10000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK15 = 0x8000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK14 = 0x4000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK13 = 0x2000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK12 = 0x1000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK11 = 0x800;        // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK10 = 0x400;        // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK9 = 0x200;         // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK8 = 0x100;         // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK7 = 0x80;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK6 = 0x40;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK5 = 0x20;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK4 = 0x10;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK3 = 0x8;           // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK2 = 0x4;           // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK1 = 0x2;           // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK0 = 0x1;           // Port x lock bit y (y= 0..15)
    static const uint32_t LCKR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL7 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL6 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL5 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL4 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL3 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL2 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL1 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL0 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t AFRL_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH15 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH14 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH13 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH12 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH11 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH10 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH9 =               // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH8 =               // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t AFRH_RESET_VALUE = 0x0;

    static constexpr uint32_t BRR_BR0 = 0x1;            // Port D Reset bit 0
    static constexpr uint32_t BRR_BR1 = 0x2;            // Port D Reset bit 1
    static constexpr uint32_t BRR_BR2 = 0x4;            // Port D Reset bit 2
    static constexpr uint32_t BRR_BR3 = 0x8;            // Port D Reset bit 3
    static constexpr uint32_t BRR_BR4 = 0x10;           // Port D Reset bit 4
    static constexpr uint32_t BRR_BR5 = 0x20;           // Port D Reset bit 5
    static constexpr uint32_t BRR_BR6 = 0x40;           // Port D Reset bit 6
    static constexpr uint32_t BRR_BR7 = 0x80;           // Port D Reset bit 7
    static constexpr uint32_t BRR_BR8 = 0x100;          // Port D Reset bit 8
    static constexpr uint32_t BRR_BR9 = 0x200;          // Port D Reset bit 9
    static constexpr uint32_t BRR_BR10 = 0x400;         // Port D Reset bit 10
    static constexpr uint32_t BRR_BR11 = 0x800;         // Port D Reset bit 11
    static constexpr uint32_t BRR_BR12 = 0x1000;        // Port D Reset bit 12
    static constexpr uint32_t BRR_BR13 = 0x2000;        // Port D Reset bit 13
    static constexpr uint32_t BRR_BR14 = 0x4000;        // Port D Reset bit 14
    static constexpr uint32_t BRR_BR15 = 0x8000;        // Port D Reset bit 15
    static const uint32_t BRR_RESET_VALUE = 0x0;
};

static gpioi_t& GPIOI = *reinterpret_cast<gpioi_t*>(0x40022000);

#define HAVE_PERIPHERAL_GPIOI


////
//
//    General-purpose I/Os
//
////

struct gpioh_t
{
    volatile uint32_t    MODER;                // [Read-write] GPIO port mode register
    volatile uint32_t    OTYPER;               // [Read-write] GPIO port output type register
    volatile uint32_t    GPIOB_OSPEEDR;        // [Read-write] GPIO port output speed register
    volatile uint32_t    PUPDR;                // [Read-write] GPIO port pull-up/pull-down register
    volatile uint32_t    IDR;                  // [Read-only] GPIO port input data register
    volatile uint32_t    ODR;                  // [Read-write] GPIO port output data register
    volatile uint32_t    BSRR;                 // [Write-only] GPIO port bit set/reset register
    volatile uint32_t    LCKR;                 // [Read-write] GPIO port configuration lock register
    volatile uint32_t    AFRL;                 // [Read-write] GPIO alternate function lowregister
    volatile uint32_t    AFRH;                 // [Read-write] GPIO alternate function high register
    volatile uint32_t    BRR;                  // [Read-write] GPIO port bit reset register

    template<uint32_t X>
    static constexpr uint32_t MODER_MODER15 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER14 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER13 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER12 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER11 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER10 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER9 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER8 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER7 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER6 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER5 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER4 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER3 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER2 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER1 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER0 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t MODER_RESET_VALUE = 0x0;

    static constexpr uint32_t OTYPER_OT15 = 0x8000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT14 = 0x4000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT13 = 0x2000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT12 = 0x1000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT11 = 0x800;         // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT10 = 0x400;         // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT9 = 0x200;          // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT8 = 0x100;          // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT7 = 0x80;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT6 = 0x40;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT5 = 0x20;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT4 = 0x10;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT3 = 0x8;            // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT2 = 0x4;            // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT1 = 0x2;            // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT0 = 0x1;            // Port x configuration bits (y = 0..15)
    static const uint32_t OTYPER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR15 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR14 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR13 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR12 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR11 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR10 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR9 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR8 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR7 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR6 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR5 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR4 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR3 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR2 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR1 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR0 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t GPIOB_OSPEEDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR15 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR14 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR13 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR12 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR11 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR10 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR9 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR8 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR7 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR6 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR5 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR4 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR3 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR2 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR1 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR0 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t PUPDR_RESET_VALUE = 0x0;

    static constexpr uint32_t IDR_IDR15 = 0x8000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR14 = 0x4000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR13 = 0x2000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR12 = 0x1000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR11 = 0x800;        // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR10 = 0x400;        // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR9 = 0x200;         // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR8 = 0x100;         // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR7 = 0x80;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR6 = 0x40;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR5 = 0x20;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR4 = 0x10;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR3 = 0x8;           // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR2 = 0x4;           // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR1 = 0x2;           // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR0 = 0x1;           // Port input data (y = 0..15)
    static const uint32_t IDR_RESET_VALUE = 0x0;

    static constexpr uint32_t ODR_ODR15 = 0x8000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR14 = 0x4000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR13 = 0x2000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR12 = 0x1000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR11 = 0x800;        // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR10 = 0x400;        // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR9 = 0x200;         // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR8 = 0x100;         // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR7 = 0x80;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR6 = 0x40;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR5 = 0x20;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR4 = 0x10;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR3 = 0x8;           // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR2 = 0x4;           // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR1 = 0x2;           // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR0 = 0x1;           // Port output data (y = 0..15)
    static const uint32_t ODR_RESET_VALUE = 0x0;

    static constexpr uint32_t BSRR_BR15 = 0x80000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR14 = 0x40000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR13 = 0x20000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR12 = 0x10000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR11 = 0x8000000;     // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR10 = 0x4000000;     // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR9 = 0x2000000;      // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR8 = 0x1000000;      // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR7 = 0x800000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR6 = 0x400000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR5 = 0x200000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR4 = 0x100000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR3 = 0x80000;        // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR2 = 0x40000;        // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR1 = 0x20000;        // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR0 = 0x10000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS15 = 0x8000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS14 = 0x4000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS13 = 0x2000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS12 = 0x1000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS11 = 0x800;         // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS10 = 0x400;         // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS9 = 0x200;          // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS8 = 0x100;          // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS7 = 0x80;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS6 = 0x40;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS5 = 0x20;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS4 = 0x10;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS3 = 0x8;            // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS2 = 0x4;            // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS1 = 0x2;            // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS0 = 0x1;            // Port x set bit y (y= 0..15)
    static const uint32_t BSRR_RESET_VALUE = 0x0;

    static constexpr uint32_t LCKR_LCKK = 0x10000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK15 = 0x8000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK14 = 0x4000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK13 = 0x2000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK12 = 0x1000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK11 = 0x800;        // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK10 = 0x400;        // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK9 = 0x200;         // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK8 = 0x100;         // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK7 = 0x80;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK6 = 0x40;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK5 = 0x20;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK4 = 0x10;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK3 = 0x8;           // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK2 = 0x4;           // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK1 = 0x2;           // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK0 = 0x1;           // Port x lock bit y (y= 0..15)
    static const uint32_t LCKR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL7 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL6 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL5 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL4 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL3 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL2 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL1 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL0 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t AFRL_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH15 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH14 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH13 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH12 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH11 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH10 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH9 =               // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH8 =               // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t AFRH_RESET_VALUE = 0x0;

    static constexpr uint32_t BRR_BR0 = 0x1;            // Port D Reset bit 0
    static constexpr uint32_t BRR_BR1 = 0x2;            // Port D Reset bit 1
    static constexpr uint32_t BRR_BR2 = 0x4;            // Port D Reset bit 2
    static constexpr uint32_t BRR_BR3 = 0x8;            // Port D Reset bit 3
    static constexpr uint32_t BRR_BR4 = 0x10;           // Port D Reset bit 4
    static constexpr uint32_t BRR_BR5 = 0x20;           // Port D Reset bit 5
    static constexpr uint32_t BRR_BR6 = 0x40;           // Port D Reset bit 6
    static constexpr uint32_t BRR_BR7 = 0x80;           // Port D Reset bit 7
    static constexpr uint32_t BRR_BR8 = 0x100;          // Port D Reset bit 8
    static constexpr uint32_t BRR_BR9 = 0x200;          // Port D Reset bit 9
    static constexpr uint32_t BRR_BR10 = 0x400;         // Port D Reset bit 10
    static constexpr uint32_t BRR_BR11 = 0x800;         // Port D Reset bit 11
    static constexpr uint32_t BRR_BR12 = 0x1000;        // Port D Reset bit 12
    static constexpr uint32_t BRR_BR13 = 0x2000;        // Port D Reset bit 13
    static constexpr uint32_t BRR_BR14 = 0x4000;        // Port D Reset bit 14
    static constexpr uint32_t BRR_BR15 = 0x8000;        // Port D Reset bit 15
    static const uint32_t BRR_RESET_VALUE = 0x0;
};

static gpioh_t& GPIOH = *reinterpret_cast<gpioh_t*>(0x40021c00);

#define HAVE_PERIPHERAL_GPIOH


////
//
//    General-purpose I/Os
//
////

struct gpiog_t
{
    volatile uint32_t    MODER;                // [Read-write] GPIO port mode register
    volatile uint32_t    OTYPER;               // [Read-write] GPIO port output type register
    volatile uint32_t    GPIOB_OSPEEDR;        // [Read-write] GPIO port output speed register
    volatile uint32_t    PUPDR;                // [Read-write] GPIO port pull-up/pull-down register
    volatile uint32_t    IDR;                  // [Read-only] GPIO port input data register
    volatile uint32_t    ODR;                  // [Read-write] GPIO port output data register
    volatile uint32_t    BSRR;                 // [Write-only] GPIO port bit set/reset register
    volatile uint32_t    LCKR;                 // [Read-write] GPIO port configuration lock register
    volatile uint32_t    AFRL;                 // [Read-write] GPIO alternate function lowregister
    volatile uint32_t    AFRH;                 // [Read-write] GPIO alternate function high register
    volatile uint32_t    BRR;                  // [Read-write] GPIO port bit reset register

    template<uint32_t X>
    static constexpr uint32_t MODER_MODER15 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER14 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER13 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER12 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER11 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER10 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER9 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER8 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER7 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER6 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER5 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER4 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER3 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER2 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER1 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER0 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t MODER_RESET_VALUE = 0x0;

    static constexpr uint32_t OTYPER_OT15 = 0x8000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT14 = 0x4000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT13 = 0x2000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT12 = 0x1000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT11 = 0x800;         // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT10 = 0x400;         // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT9 = 0x200;          // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT8 = 0x100;          // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT7 = 0x80;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT6 = 0x40;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT5 = 0x20;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT4 = 0x10;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT3 = 0x8;            // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT2 = 0x4;            // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT1 = 0x2;            // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT0 = 0x1;            // Port x configuration bits (y = 0..15)
    static const uint32_t OTYPER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR15 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR14 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR13 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR12 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR11 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR10 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR9 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR8 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR7 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR6 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR5 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR4 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR3 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR2 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR1 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR0 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t GPIOB_OSPEEDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR15 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR14 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR13 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR12 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR11 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR10 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR9 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR8 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR7 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR6 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR5 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR4 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR3 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR2 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR1 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR0 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t PUPDR_RESET_VALUE = 0x0;

    static constexpr uint32_t IDR_IDR15 = 0x8000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR14 = 0x4000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR13 = 0x2000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR12 = 0x1000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR11 = 0x800;        // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR10 = 0x400;        // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR9 = 0x200;         // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR8 = 0x100;         // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR7 = 0x80;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR6 = 0x40;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR5 = 0x20;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR4 = 0x10;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR3 = 0x8;           // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR2 = 0x4;           // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR1 = 0x2;           // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR0 = 0x1;           // Port input data (y = 0..15)
    static const uint32_t IDR_RESET_VALUE = 0x0;

    static constexpr uint32_t ODR_ODR15 = 0x8000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR14 = 0x4000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR13 = 0x2000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR12 = 0x1000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR11 = 0x800;        // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR10 = 0x400;        // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR9 = 0x200;         // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR8 = 0x100;         // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR7 = 0x80;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR6 = 0x40;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR5 = 0x20;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR4 = 0x10;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR3 = 0x8;           // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR2 = 0x4;           // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR1 = 0x2;           // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR0 = 0x1;           // Port output data (y = 0..15)
    static const uint32_t ODR_RESET_VALUE = 0x0;

    static constexpr uint32_t BSRR_BR15 = 0x80000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR14 = 0x40000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR13 = 0x20000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR12 = 0x10000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR11 = 0x8000000;     // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR10 = 0x4000000;     // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR9 = 0x2000000;      // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR8 = 0x1000000;      // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR7 = 0x800000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR6 = 0x400000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR5 = 0x200000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR4 = 0x100000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR3 = 0x80000;        // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR2 = 0x40000;        // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR1 = 0x20000;        // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR0 = 0x10000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS15 = 0x8000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS14 = 0x4000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS13 = 0x2000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS12 = 0x1000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS11 = 0x800;         // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS10 = 0x400;         // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS9 = 0x200;          // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS8 = 0x100;          // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS7 = 0x80;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS6 = 0x40;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS5 = 0x20;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS4 = 0x10;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS3 = 0x8;            // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS2 = 0x4;            // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS1 = 0x2;            // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS0 = 0x1;            // Port x set bit y (y= 0..15)
    static const uint32_t BSRR_RESET_VALUE = 0x0;

    static constexpr uint32_t LCKR_LCKK = 0x10000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK15 = 0x8000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK14 = 0x4000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK13 = 0x2000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK12 = 0x1000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK11 = 0x800;        // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK10 = 0x400;        // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK9 = 0x200;         // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK8 = 0x100;         // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK7 = 0x80;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK6 = 0x40;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK5 = 0x20;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK4 = 0x10;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK3 = 0x8;           // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK2 = 0x4;           // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK1 = 0x2;           // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK0 = 0x1;           // Port x lock bit y (y= 0..15)
    static const uint32_t LCKR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL7 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL6 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL5 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL4 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL3 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL2 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL1 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL0 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t AFRL_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH15 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH14 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH13 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH12 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH11 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH10 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH9 =               // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH8 =               // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t AFRH_RESET_VALUE = 0x0;

    static constexpr uint32_t BRR_BR0 = 0x1;            // Port D Reset bit 0
    static constexpr uint32_t BRR_BR1 = 0x2;            // Port D Reset bit 1
    static constexpr uint32_t BRR_BR2 = 0x4;            // Port D Reset bit 2
    static constexpr uint32_t BRR_BR3 = 0x8;            // Port D Reset bit 3
    static constexpr uint32_t BRR_BR4 = 0x10;           // Port D Reset bit 4
    static constexpr uint32_t BRR_BR5 = 0x20;           // Port D Reset bit 5
    static constexpr uint32_t BRR_BR6 = 0x40;           // Port D Reset bit 6
    static constexpr uint32_t BRR_BR7 = 0x80;           // Port D Reset bit 7
    static constexpr uint32_t BRR_BR8 = 0x100;          // Port D Reset bit 8
    static constexpr uint32_t BRR_BR9 = 0x200;          // Port D Reset bit 9
    static constexpr uint32_t BRR_BR10 = 0x400;         // Port D Reset bit 10
    static constexpr uint32_t BRR_BR11 = 0x800;         // Port D Reset bit 11
    static constexpr uint32_t BRR_BR12 = 0x1000;        // Port D Reset bit 12
    static constexpr uint32_t BRR_BR13 = 0x2000;        // Port D Reset bit 13
    static constexpr uint32_t BRR_BR14 = 0x4000;        // Port D Reset bit 14
    static constexpr uint32_t BRR_BR15 = 0x8000;        // Port D Reset bit 15
    static const uint32_t BRR_RESET_VALUE = 0x0;
};

static gpiog_t& GPIOG = *reinterpret_cast<gpiog_t*>(0x40021800);

#define HAVE_PERIPHERAL_GPIOG


////
//
//    General-purpose I/Os
//
////

struct gpiof_t
{
    volatile uint32_t    MODER;                // [Read-write] GPIO port mode register
    volatile uint32_t    OTYPER;               // [Read-write] GPIO port output type register
    volatile uint32_t    GPIOB_OSPEEDR;        // [Read-write] GPIO port output speed register
    volatile uint32_t    PUPDR;                // [Read-write] GPIO port pull-up/pull-down register
    volatile uint32_t    IDR;                  // [Read-only] GPIO port input data register
    volatile uint32_t    ODR;                  // [Read-write] GPIO port output data register
    volatile uint32_t    BSRR;                 // [Write-only] GPIO port bit set/reset register
    volatile uint32_t    LCKR;                 // [Read-write] GPIO port configuration lock register
    volatile uint32_t    AFRL;                 // [Read-write] GPIO alternate function lowregister
    volatile uint32_t    AFRH;                 // [Read-write] GPIO alternate function high register
    volatile uint32_t    BRR;                  // [Read-write] GPIO port bit reset register

    template<uint32_t X>
    static constexpr uint32_t MODER_MODER15 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER14 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER13 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER12 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER11 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER10 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER9 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER8 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER7 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER6 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER5 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER4 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER3 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER2 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER1 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER0 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t MODER_RESET_VALUE = 0x0;

    static constexpr uint32_t OTYPER_OT15 = 0x8000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT14 = 0x4000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT13 = 0x2000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT12 = 0x1000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT11 = 0x800;         // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT10 = 0x400;         // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT9 = 0x200;          // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT8 = 0x100;          // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT7 = 0x80;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT6 = 0x40;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT5 = 0x20;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT4 = 0x10;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT3 = 0x8;            // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT2 = 0x4;            // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT1 = 0x2;            // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT0 = 0x1;            // Port x configuration bits (y = 0..15)
    static const uint32_t OTYPER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR15 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR14 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR13 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR12 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR11 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR10 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR9 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR8 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR7 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR6 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR5 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR4 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR3 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR2 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR1 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR0 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t GPIOB_OSPEEDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR15 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR14 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR13 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR12 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR11 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR10 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR9 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR8 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR7 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR6 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR5 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR4 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR3 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR2 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR1 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR0 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t PUPDR_RESET_VALUE = 0x0;

    static constexpr uint32_t IDR_IDR15 = 0x8000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR14 = 0x4000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR13 = 0x2000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR12 = 0x1000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR11 = 0x800;        // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR10 = 0x400;        // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR9 = 0x200;         // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR8 = 0x100;         // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR7 = 0x80;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR6 = 0x40;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR5 = 0x20;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR4 = 0x10;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR3 = 0x8;           // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR2 = 0x4;           // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR1 = 0x2;           // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR0 = 0x1;           // Port input data (y = 0..15)
    static const uint32_t IDR_RESET_VALUE = 0x0;

    static constexpr uint32_t ODR_ODR15 = 0x8000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR14 = 0x4000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR13 = 0x2000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR12 = 0x1000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR11 = 0x800;        // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR10 = 0x400;        // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR9 = 0x200;         // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR8 = 0x100;         // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR7 = 0x80;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR6 = 0x40;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR5 = 0x20;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR4 = 0x10;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR3 = 0x8;           // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR2 = 0x4;           // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR1 = 0x2;           // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR0 = 0x1;           // Port output data (y = 0..15)
    static const uint32_t ODR_RESET_VALUE = 0x0;

    static constexpr uint32_t BSRR_BR15 = 0x80000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR14 = 0x40000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR13 = 0x20000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR12 = 0x10000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR11 = 0x8000000;     // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR10 = 0x4000000;     // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR9 = 0x2000000;      // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR8 = 0x1000000;      // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR7 = 0x800000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR6 = 0x400000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR5 = 0x200000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR4 = 0x100000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR3 = 0x80000;        // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR2 = 0x40000;        // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR1 = 0x20000;        // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR0 = 0x10000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS15 = 0x8000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS14 = 0x4000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS13 = 0x2000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS12 = 0x1000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS11 = 0x800;         // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS10 = 0x400;         // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS9 = 0x200;          // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS8 = 0x100;          // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS7 = 0x80;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS6 = 0x40;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS5 = 0x20;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS4 = 0x10;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS3 = 0x8;            // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS2 = 0x4;            // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS1 = 0x2;            // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS0 = 0x1;            // Port x set bit y (y= 0..15)
    static const uint32_t BSRR_RESET_VALUE = 0x0;

    static constexpr uint32_t LCKR_LCKK = 0x10000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK15 = 0x8000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK14 = 0x4000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK13 = 0x2000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK12 = 0x1000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK11 = 0x800;        // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK10 = 0x400;        // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK9 = 0x200;         // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK8 = 0x100;         // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK7 = 0x80;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK6 = 0x40;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK5 = 0x20;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK4 = 0x10;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK3 = 0x8;           // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK2 = 0x4;           // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK1 = 0x2;           // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK0 = 0x1;           // Port x lock bit y (y= 0..15)
    static const uint32_t LCKR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL7 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL6 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL5 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL4 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL3 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL2 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL1 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL0 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t AFRL_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH15 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH14 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH13 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH12 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH11 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH10 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH9 =               // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH8 =               // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t AFRH_RESET_VALUE = 0x0;

    static constexpr uint32_t BRR_BR0 = 0x1;            // Port D Reset bit 0
    static constexpr uint32_t BRR_BR1 = 0x2;            // Port D Reset bit 1
    static constexpr uint32_t BRR_BR2 = 0x4;            // Port D Reset bit 2
    static constexpr uint32_t BRR_BR3 = 0x8;            // Port D Reset bit 3
    static constexpr uint32_t BRR_BR4 = 0x10;           // Port D Reset bit 4
    static constexpr uint32_t BRR_BR5 = 0x20;           // Port D Reset bit 5
    static constexpr uint32_t BRR_BR6 = 0x40;           // Port D Reset bit 6
    static constexpr uint32_t BRR_BR7 = 0x80;           // Port D Reset bit 7
    static constexpr uint32_t BRR_BR8 = 0x100;          // Port D Reset bit 8
    static constexpr uint32_t BRR_BR9 = 0x200;          // Port D Reset bit 9
    static constexpr uint32_t BRR_BR10 = 0x400;         // Port D Reset bit 10
    static constexpr uint32_t BRR_BR11 = 0x800;         // Port D Reset bit 11
    static constexpr uint32_t BRR_BR12 = 0x1000;        // Port D Reset bit 12
    static constexpr uint32_t BRR_BR13 = 0x2000;        // Port D Reset bit 13
    static constexpr uint32_t BRR_BR14 = 0x4000;        // Port D Reset bit 14
    static constexpr uint32_t BRR_BR15 = 0x8000;        // Port D Reset bit 15
    static const uint32_t BRR_RESET_VALUE = 0x0;
};

static gpiof_t& GPIOF = *reinterpret_cast<gpiof_t*>(0x40021400);

#define HAVE_PERIPHERAL_GPIOF


////
//
//    General-purpose I/Os
//
////

struct gpioe_t
{
    volatile uint32_t    MODER;                // [Read-write] GPIO port mode register
    volatile uint32_t    OTYPER;               // [Read-write] GPIO port output type register
    volatile uint32_t    GPIOB_OSPEEDR;        // [Read-write] GPIO port output speed register
    volatile uint32_t    PUPDR;                // [Read-write] GPIO port pull-up/pull-down register
    volatile uint32_t    IDR;                  // [Read-only] GPIO port input data register
    volatile uint32_t    ODR;                  // [Read-write] GPIO port output data register
    volatile uint32_t    BSRR;                 // [Write-only] GPIO port bit set/reset register
    volatile uint32_t    LCKR;                 // [Read-write] GPIO port configuration lock register
    volatile uint32_t    AFRL;                 // [Read-write] GPIO alternate function lowregister
    volatile uint32_t    AFRH;                 // [Read-write] GPIO alternate function high register
    volatile uint32_t    BRR;                  // [Read-write] GPIO port bit reset register

    template<uint32_t X>
    static constexpr uint32_t MODER_MODER15 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER14 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER13 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER12 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER11 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER10 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER9 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER8 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER7 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER6 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER5 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER4 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER3 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER2 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER1 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER0 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t MODER_RESET_VALUE = 0x0;

    static constexpr uint32_t OTYPER_OT15 = 0x8000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT14 = 0x4000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT13 = 0x2000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT12 = 0x1000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT11 = 0x800;         // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT10 = 0x400;         // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT9 = 0x200;          // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT8 = 0x100;          // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT7 = 0x80;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT6 = 0x40;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT5 = 0x20;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT4 = 0x10;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT3 = 0x8;            // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT2 = 0x4;            // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT1 = 0x2;            // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT0 = 0x1;            // Port x configuration bits (y = 0..15)
    static const uint32_t OTYPER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR15 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR14 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR13 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR12 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR11 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR10 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR9 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR8 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR7 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR6 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR5 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR4 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR3 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR2 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR1 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR0 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t GPIOB_OSPEEDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR15 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR14 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR13 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR12 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR11 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR10 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR9 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR8 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR7 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR6 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR5 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR4 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR3 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR2 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR1 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR0 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t PUPDR_RESET_VALUE = 0x0;

    static constexpr uint32_t IDR_IDR15 = 0x8000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR14 = 0x4000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR13 = 0x2000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR12 = 0x1000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR11 = 0x800;        // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR10 = 0x400;        // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR9 = 0x200;         // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR8 = 0x100;         // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR7 = 0x80;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR6 = 0x40;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR5 = 0x20;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR4 = 0x10;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR3 = 0x8;           // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR2 = 0x4;           // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR1 = 0x2;           // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR0 = 0x1;           // Port input data (y = 0..15)
    static const uint32_t IDR_RESET_VALUE = 0x0;

    static constexpr uint32_t ODR_ODR15 = 0x8000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR14 = 0x4000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR13 = 0x2000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR12 = 0x1000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR11 = 0x800;        // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR10 = 0x400;        // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR9 = 0x200;         // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR8 = 0x100;         // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR7 = 0x80;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR6 = 0x40;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR5 = 0x20;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR4 = 0x10;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR3 = 0x8;           // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR2 = 0x4;           // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR1 = 0x2;           // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR0 = 0x1;           // Port output data (y = 0..15)
    static const uint32_t ODR_RESET_VALUE = 0x0;

    static constexpr uint32_t BSRR_BR15 = 0x80000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR14 = 0x40000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR13 = 0x20000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR12 = 0x10000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR11 = 0x8000000;     // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR10 = 0x4000000;     // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR9 = 0x2000000;      // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR8 = 0x1000000;      // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR7 = 0x800000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR6 = 0x400000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR5 = 0x200000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR4 = 0x100000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR3 = 0x80000;        // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR2 = 0x40000;        // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR1 = 0x20000;        // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR0 = 0x10000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS15 = 0x8000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS14 = 0x4000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS13 = 0x2000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS12 = 0x1000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS11 = 0x800;         // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS10 = 0x400;         // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS9 = 0x200;          // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS8 = 0x100;          // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS7 = 0x80;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS6 = 0x40;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS5 = 0x20;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS4 = 0x10;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS3 = 0x8;            // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS2 = 0x4;            // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS1 = 0x2;            // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS0 = 0x1;            // Port x set bit y (y= 0..15)
    static const uint32_t BSRR_RESET_VALUE = 0x0;

    static constexpr uint32_t LCKR_LCKK = 0x10000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK15 = 0x8000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK14 = 0x4000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK13 = 0x2000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK12 = 0x1000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK11 = 0x800;        // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK10 = 0x400;        // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK9 = 0x200;         // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK8 = 0x100;         // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK7 = 0x80;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK6 = 0x40;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK5 = 0x20;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK4 = 0x10;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK3 = 0x8;           // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK2 = 0x4;           // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK1 = 0x2;           // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK0 = 0x1;           // Port x lock bit y (y= 0..15)
    static const uint32_t LCKR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL7 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL6 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL5 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL4 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL3 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL2 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL1 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL0 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t AFRL_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH15 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH14 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH13 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH12 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH11 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH10 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH9 =               // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH8 =               // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t AFRH_RESET_VALUE = 0x0;

    static constexpr uint32_t BRR_BR0 = 0x1;            // Port D Reset bit 0
    static constexpr uint32_t BRR_BR1 = 0x2;            // Port D Reset bit 1
    static constexpr uint32_t BRR_BR2 = 0x4;            // Port D Reset bit 2
    static constexpr uint32_t BRR_BR3 = 0x8;            // Port D Reset bit 3
    static constexpr uint32_t BRR_BR4 = 0x10;           // Port D Reset bit 4
    static constexpr uint32_t BRR_BR5 = 0x20;           // Port D Reset bit 5
    static constexpr uint32_t BRR_BR6 = 0x40;           // Port D Reset bit 6
    static constexpr uint32_t BRR_BR7 = 0x80;           // Port D Reset bit 7
    static constexpr uint32_t BRR_BR8 = 0x100;          // Port D Reset bit 8
    static constexpr uint32_t BRR_BR9 = 0x200;          // Port D Reset bit 9
    static constexpr uint32_t BRR_BR10 = 0x400;         // Port D Reset bit 10
    static constexpr uint32_t BRR_BR11 = 0x800;         // Port D Reset bit 11
    static constexpr uint32_t BRR_BR12 = 0x1000;        // Port D Reset bit 12
    static constexpr uint32_t BRR_BR13 = 0x2000;        // Port D Reset bit 13
    static constexpr uint32_t BRR_BR14 = 0x4000;        // Port D Reset bit 14
    static constexpr uint32_t BRR_BR15 = 0x8000;        // Port D Reset bit 15
    static const uint32_t BRR_RESET_VALUE = 0x0;
};

static gpioe_t& GPIOE = *reinterpret_cast<gpioe_t*>(0x40021000);

#define HAVE_PERIPHERAL_GPIOE


////
//
//    General-purpose I/Os
//
////

struct gpiob_t
{
    volatile uint32_t    MODER;                // [Read-write] GPIO port mode register
    volatile uint32_t    OTYPER;               // [Read-write] GPIO port output type register
    volatile uint32_t    OSPEEDR;              // [Read-write] GPIO port output speed register
    volatile uint32_t    PUPDR;                // [Read-write] GPIO port pull-up/pull-down register
    volatile uint32_t    IDR;                  // [Read-only] GPIO port input data register
    volatile uint32_t    ODR;                  // [Read-write] GPIO port output data register
    volatile uint32_t    BSRR;                 // [Write-only] GPIO port bit set/reset register
    volatile uint32_t    LCKR;                 // [Read-write] GPIO port configuration lock register
    volatile uint32_t    AFRL;                 // [Read-write] GPIO alternate function low register
    volatile uint32_t    AFRH;                 // [Read-write] GPIO alternate function high register
    volatile uint32_t    BRR;                  // [Read-write] GPIO port bit reset register

    template<uint32_t X>
    static constexpr uint32_t MODER_MODER15 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER14 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER13 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER12 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER11 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER10 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER9 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER8 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER7 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER6 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER5 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER4 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER3 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER2 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER1 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER0 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t MODER_RESET_VALUE = 0x280;

    static constexpr uint32_t OTYPER_OT15 = 0x8000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT14 = 0x4000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT13 = 0x2000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT12 = 0x1000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT11 = 0x800;         // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT10 = 0x400;         // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT9 = 0x200;          // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT8 = 0x100;          // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT7 = 0x80;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT6 = 0x40;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT5 = 0x20;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT4 = 0x10;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT3 = 0x8;            // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT2 = 0x4;            // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT1 = 0x2;            // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT0 = 0x1;            // Port x configuration bits (y = 0..15)
    static const uint32_t OTYPER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEEDR15 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEEDR14 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEEDR13 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEEDR12 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEEDR11 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEEDR10 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEEDR9 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEEDR8 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEEDR7 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEEDR6 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEEDR5 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEEDR4 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEEDR3 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEEDR2 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEEDR1 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OSPEEDR_OSPEEDR0 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t OSPEEDR_RESET_VALUE = 0xc0;

    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR15 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR14 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR13 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR12 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR11 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR10 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR9 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR8 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR7 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR6 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR5 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR4 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR3 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR2 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR1 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR0 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t PUPDR_RESET_VALUE = 0x100;

    static constexpr uint32_t IDR_IDR15 = 0x8000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR14 = 0x4000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR13 = 0x2000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR12 = 0x1000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR11 = 0x800;        // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR10 = 0x400;        // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR9 = 0x200;         // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR8 = 0x100;         // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR7 = 0x80;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR6 = 0x40;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR5 = 0x20;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR4 = 0x10;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR3 = 0x8;           // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR2 = 0x4;           // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR1 = 0x2;           // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR0 = 0x1;           // Port input data (y = 0..15)
    static const uint32_t IDR_RESET_VALUE = 0x0;

    static constexpr uint32_t ODR_ODR15 = 0x8000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR14 = 0x4000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR13 = 0x2000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR12 = 0x1000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR11 = 0x800;        // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR10 = 0x400;        // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR9 = 0x200;         // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR8 = 0x100;         // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR7 = 0x80;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR6 = 0x40;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR5 = 0x20;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR4 = 0x10;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR3 = 0x8;           // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR2 = 0x4;           // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR1 = 0x2;           // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR0 = 0x1;           // Port output data (y = 0..15)
    static const uint32_t ODR_RESET_VALUE = 0x0;

    static constexpr uint32_t BSRR_BR15 = 0x80000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR14 = 0x40000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR13 = 0x20000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR12 = 0x10000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR11 = 0x8000000;     // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR10 = 0x4000000;     // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR9 = 0x2000000;      // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR8 = 0x1000000;      // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR7 = 0x800000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR6 = 0x400000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR5 = 0x200000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR4 = 0x100000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR3 = 0x80000;        // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR2 = 0x40000;        // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR1 = 0x20000;        // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR0 = 0x10000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS15 = 0x8000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS14 = 0x4000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS13 = 0x2000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS12 = 0x1000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS11 = 0x800;         // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS10 = 0x400;         // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS9 = 0x200;          // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS8 = 0x100;          // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS7 = 0x80;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS6 = 0x40;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS5 = 0x20;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS4 = 0x10;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS3 = 0x8;            // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS2 = 0x4;            // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS1 = 0x2;            // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS0 = 0x1;            // Port x set bit y (y= 0..15)
    static const uint32_t BSRR_RESET_VALUE = 0x0;

    static constexpr uint32_t LCKR_LCKK = 0x10000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK15 = 0x8000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK14 = 0x4000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK13 = 0x2000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK12 = 0x1000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK11 = 0x800;        // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK10 = 0x400;        // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK9 = 0x200;         // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK8 = 0x100;         // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK7 = 0x80;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK6 = 0x40;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK5 = 0x20;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK4 = 0x10;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK3 = 0x8;           // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK2 = 0x4;           // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK1 = 0x2;           // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK0 = 0x1;           // Port x lock bit y (y= 0..15)
    static const uint32_t LCKR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL7 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL6 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL5 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL4 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL3 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL2 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL1 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL0 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t AFRL_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH15 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH14 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH13 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH12 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH11 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH10 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH9 =               // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH8 =               // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t AFRH_RESET_VALUE = 0x0;

    static constexpr uint32_t BRR_BR0 = 0x1;            // Port B Reset bit 0
    static constexpr uint32_t BRR_BR1 = 0x2;            // Port B Reset bit 1
    static constexpr uint32_t BRR_BR2 = 0x4;            // Port B Reset bit 2
    static constexpr uint32_t BRR_BR3 = 0x8;            // Port B Reset bit 3
    static constexpr uint32_t BRR_BR4 = 0x10;           // Port B Reset bit 4
    static constexpr uint32_t BRR_BR5 = 0x20;           // Port B Reset bit 5
    static constexpr uint32_t BRR_BR6 = 0x40;           // Port B Reset bit 6
    static constexpr uint32_t BRR_BR7 = 0x80;           // Port B Reset bit 7
    static constexpr uint32_t BRR_BR8 = 0x100;          // Port B Reset bit 8
    static constexpr uint32_t BRR_BR9 = 0x200;          // Port B Reset bit 9
    static constexpr uint32_t BRR_BR10 = 0x400;         // Port B Reset bit 10
    static constexpr uint32_t BRR_BR11 = 0x800;         // Port B Reset bit 11
    static constexpr uint32_t BRR_BR12 = 0x1000;        // Port B Reset bit 12
    static constexpr uint32_t BRR_BR13 = 0x2000;        // Port B Reset bit 13
    static constexpr uint32_t BRR_BR14 = 0x4000;        // Port B Reset bit 14
    static constexpr uint32_t BRR_BR15 = 0x8000;        // Port B Reset bit 15
    static const uint32_t BRR_RESET_VALUE = 0x0;
};

static gpiob_t& GPIOB = *reinterpret_cast<gpiob_t*>(0x40020400);

#define HAVE_PERIPHERAL_GPIOB


////
//
//    General-purpose I/Os
//
////

struct gpioa_t
{
    volatile uint32_t    MODER;                // [Read-write] GPIO port mode register
    volatile uint32_t    OTYPER;               // [Read-write] GPIO port output type register
    volatile uint32_t    GPIOB_OSPEEDR;        // [Read-write] GPIO port output speed register
    volatile uint32_t    PUPDR;                // [Read-write] GPIO port pull-up/pull-down register
    volatile uint32_t    IDR;                  // [Read-only] GPIO port input data register
    volatile uint32_t    ODR;                  // [Read-write] GPIO port output data register
    volatile uint32_t    BSRR;                 // [Write-only] GPIO port bit set/reset register
    volatile uint32_t    LCKR;                 // [Read-write] GPIO port configuration lock register
    volatile uint32_t    AFRL;                 // [Read-write] GPIO alternate function low register
    volatile uint32_t    AFRH;                 // [Read-write] GPIO alternate function high register
    volatile uint32_t    BRR;                  // [Read-write] GPIO port bit reset register

    template<uint32_t X>
    static constexpr uint32_t MODER_MODER15 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER14 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER13 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER12 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER11 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER10 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER9 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER8 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER7 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER6 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER5 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER4 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER3 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER2 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER1 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MODER_MODER0 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t MODER_RESET_VALUE = 0xa8000000;

    static constexpr uint32_t OTYPER_OT15 = 0x8000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT14 = 0x4000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT13 = 0x2000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT12 = 0x1000;        // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT11 = 0x800;         // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT10 = 0x400;         // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT9 = 0x200;          // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT8 = 0x100;          // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT7 = 0x80;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT6 = 0x40;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT5 = 0x20;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT4 = 0x10;           // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT3 = 0x8;            // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT2 = 0x4;            // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT1 = 0x2;            // Port x configuration bits (y = 0..15)
    static constexpr uint32_t OTYPER_OT0 = 0x1;            // Port x configuration bits (y = 0..15)
    static const uint32_t OTYPER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR15 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR14 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR13 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR12 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR11 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR10 =           // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR9 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR8 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR7 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR6 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR5 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR4 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR3 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR2 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR1 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPIOB_OSPEEDR_OSPEEDR0 =            // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t GPIOB_OSPEEDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR15 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<30, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR14 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR13 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR12 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR11 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR10 =             // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR9 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR8 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR7 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR6 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR5 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR4 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR3 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR2 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR1 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PUPDR_PUPDR0 =              // Port x configuration bits (y = 0..15) (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t PUPDR_RESET_VALUE = 0x64000000;

    static constexpr uint32_t IDR_IDR15 = 0x8000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR14 = 0x4000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR13 = 0x2000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR12 = 0x1000;       // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR11 = 0x800;        // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR10 = 0x400;        // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR9 = 0x200;         // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR8 = 0x100;         // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR7 = 0x80;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR6 = 0x40;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR5 = 0x20;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR4 = 0x10;          // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR3 = 0x8;           // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR2 = 0x4;           // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR1 = 0x2;           // Port input data (y = 0..15)
    static constexpr uint32_t IDR_IDR0 = 0x1;           // Port input data (y = 0..15)
    static const uint32_t IDR_RESET_VALUE = 0x0;

    static constexpr uint32_t ODR_ODR15 = 0x8000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR14 = 0x4000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR13 = 0x2000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR12 = 0x1000;       // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR11 = 0x800;        // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR10 = 0x400;        // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR9 = 0x200;         // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR8 = 0x100;         // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR7 = 0x80;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR6 = 0x40;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR5 = 0x20;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR4 = 0x10;          // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR3 = 0x8;           // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR2 = 0x4;           // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR1 = 0x2;           // Port output data (y = 0..15)
    static constexpr uint32_t ODR_ODR0 = 0x1;           // Port output data (y = 0..15)
    static const uint32_t ODR_RESET_VALUE = 0x0;

    static constexpr uint32_t BSRR_BR15 = 0x80000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR14 = 0x40000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR13 = 0x20000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR12 = 0x10000000;    // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR11 = 0x8000000;     // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR10 = 0x4000000;     // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR9 = 0x2000000;      // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR8 = 0x1000000;      // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR7 = 0x800000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR6 = 0x400000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR5 = 0x200000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR4 = 0x100000;       // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR3 = 0x80000;        // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR2 = 0x40000;        // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR1 = 0x20000;        // Port x reset bit y (y = 0..15)
    static constexpr uint32_t BSRR_BR0 = 0x10000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS15 = 0x8000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS14 = 0x4000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS13 = 0x2000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS12 = 0x1000;        // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS11 = 0x800;         // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS10 = 0x400;         // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS9 = 0x200;          // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS8 = 0x100;          // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS7 = 0x80;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS6 = 0x40;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS5 = 0x20;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS4 = 0x10;           // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS3 = 0x8;            // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS2 = 0x4;            // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS1 = 0x2;            // Port x set bit y (y= 0..15)
    static constexpr uint32_t BSRR_BS0 = 0x1;            // Port x set bit y (y= 0..15)
    static const uint32_t BSRR_RESET_VALUE = 0x0;

    static constexpr uint32_t LCKR_LCKK = 0x10000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK15 = 0x8000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK14 = 0x4000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK13 = 0x2000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK12 = 0x1000;       // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK11 = 0x800;        // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK10 = 0x400;        // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK9 = 0x200;         // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK8 = 0x100;         // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK7 = 0x80;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK6 = 0x40;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK5 = 0x20;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK4 = 0x10;          // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK3 = 0x8;           // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK2 = 0x4;           // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK1 = 0x2;           // Port x lock bit y (y= 0..15)
    static constexpr uint32_t LCKR_LCK0 = 0x1;           // Port x lock bit y (y= 0..15)
    static const uint32_t LCKR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL7 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL6 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL5 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL4 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL3 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL2 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL1 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRL_AFRL0 =               // Alternate function selection for port x bit y (y = 0..7) (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t AFRL_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH15 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH14 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH13 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH12 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH11 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH10 =              // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH9 =               // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRH_AFRH8 =               // Alternate function selection for port x bit y (y = 8..15) (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t AFRH_RESET_VALUE = 0x0;

    static constexpr uint32_t BRR_BR0 = 0x1;            // Port A Reset bit 0
    static constexpr uint32_t BRR_BR1 = 0x2;            // Port A Reset bit 1
    static constexpr uint32_t BRR_BR2 = 0x4;            // Port A Reset bit 2
    static constexpr uint32_t BRR_BR3 = 0x8;            // Port A Reset bit 3
    static constexpr uint32_t BRR_BR4 = 0x10;           // Port A Reset bit 4
    static constexpr uint32_t BRR_BR5 = 0x20;           // Port A Reset bit 5
    static constexpr uint32_t BRR_BR6 = 0x40;           // Port A Reset bit 6
    static constexpr uint32_t BRR_BR7 = 0x80;           // Port A Reset bit 7
    static constexpr uint32_t BRR_BR8 = 0x100;          // Port A Reset bit 8
    static constexpr uint32_t BRR_BR9 = 0x200;          // Port A Reset bit 9
    static constexpr uint32_t BRR_BR10 = 0x400;         // Port A Reset bit 10
    static constexpr uint32_t BRR_BR11 = 0x800;         // Port A Reset bit 11
    static constexpr uint32_t BRR_BR12 = 0x1000;        // Port A Reset bit 12
    static constexpr uint32_t BRR_BR13 = 0x2000;        // Port A Reset bit 13
    static constexpr uint32_t BRR_BR14 = 0x4000;        // Port A Reset bit 14
    static constexpr uint32_t BRR_BR15 = 0x8000;        // Port A Reset bit 15
    static const uint32_t BRR_RESET_VALUE = 0x0;
};

static gpioa_t& GPIOA = *reinterpret_cast<gpioa_t*>(0x40020000);

#define HAVE_PERIPHERAL_GPIOA


////
//
//    System configuration controller
//
////

struct syscfg_t
{
    volatile uint32_t    MEMRM;                // [Read-write] memory remap register
    volatile uint32_t    PMC;                  // [Read-write] peripheral mode configuration register
    volatile uint32_t    EXTICR1;              // [Read-write] external interrupt configuration register 1
    volatile uint32_t    EXTICR2;              // [Read-write] external interrupt configuration register 2
    volatile uint32_t    EXTICR3;              // [Read-write] external interrupt configuration register 3
    volatile uint32_t    EXTICR4;              // [Read-write] external interrupt configuration register 4
    reserved_t<2>        _0;
    volatile uint32_t    CMPCR;                // [Read-only] Compensation cell control register

    template<uint32_t X>
    static constexpr uint32_t MEMRM_MEM_MODE =            // Memory mapping selection (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static constexpr uint32_t MEMRM_FB_MODE = 0x100;      // Flash bank mode selection
    template<uint32_t X>
    static constexpr uint32_t MEMRM_SWP_FMC =             // FMC memory mapping swap (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    static const uint32_t MEMRM_RESET_VALUE = 0x0;

    static constexpr uint32_t PMC_MII_RMII_SEL = 0x800000;// Ethernet PHY interface selection
    static constexpr uint32_t PMC_ADC1DC2 = 0x10000;    // ADC1DC2
    static constexpr uint32_t PMC_ADC2DC2 = 0x20000;    // ADC2DC2
    static constexpr uint32_t PMC_ADC3DC2 = 0x40000;    // ADC3DC2
    static const uint32_t PMC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t EXTICR1_EXTI3 =               // EXTI x configuration (x = 0 to 3) (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t EXTICR1_EXTI2 =               // EXTI x configuration (x = 0 to 3) (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t EXTICR1_EXTI1 =               // EXTI x configuration (x = 0 to 3) (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t EXTICR1_EXTI0 =               // EXTI x configuration (x = 0 to 3) (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t EXTICR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t EXTICR2_EXTI7 =               // EXTI x configuration (x = 4 to 7) (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t EXTICR2_EXTI6 =               // EXTI x configuration (x = 4 to 7) (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t EXTICR2_EXTI5 =               // EXTI x configuration (x = 4 to 7) (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t EXTICR2_EXTI4 =               // EXTI x configuration (x = 4 to 7) (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t EXTICR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t EXTICR3_EXTI11 =              // EXTI x configuration (x = 8 to 11) (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t EXTICR3_EXTI10 =              // EXTI10 (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t EXTICR3_EXTI9 =               // EXTI x configuration (x = 8 to 11) (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t EXTICR3_EXTI8 =               // EXTI x configuration (x = 8 to 11) (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t EXTICR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t EXTICR4_EXTI15 =              // EXTI x configuration (x = 12 to 15) (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t EXTICR4_EXTI14 =              // EXTI x configuration (x = 12 to 15) (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t EXTICR4_EXTI13 =              // EXTI x configuration (x = 12 to 15) (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t EXTICR4_EXTI12 =              // EXTI x configuration (x = 12 to 15) (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t EXTICR4_RESET_VALUE = 0x0;

    static constexpr uint32_t CMPCR_READY = 0x100;        // READY
    static constexpr uint32_t CMPCR_CMP_PD = 0x1;         // Compensation cell power-down
    static const uint32_t CMPCR_RESET_VALUE = 0x0;
};

static syscfg_t& SYSCFG = *reinterpret_cast<syscfg_t*>(0x40013800);

#define HAVE_PERIPHERAL_SYSCFG


////
//
//    Serial peripheral interface
//
////

struct spi1_t
{
    volatile uint32_t    CR1;                  // [Read-write] control register 1
    volatile uint32_t    CR2;                  // [Read-write] control register 2
    volatile uint32_t    SR;                   // status register
    volatile uint32_t    DR;                   // [Read-write] data register
    volatile uint32_t    CRCPR;                // [Read-write] CRC polynomial register
    volatile uint32_t    RXCRCR;               // [Read-only] RX CRC register
    volatile uint32_t    TXCRCR;               // [Read-only] TX CRC register
    volatile uint32_t    I2SCFGR;              // [Read-write] I2S configuration register
    volatile uint32_t    I2SPR;                // [Read-write] I2S prescaler register

    static constexpr uint32_t CR1_BIDIMODE = 0x8000;    // Bidirectional data mode enable
    static constexpr uint32_t CR1_BIDIOE = 0x4000;      // Output enable in bidirectional mode
    static constexpr uint32_t CR1_CRCEN = 0x2000;       // Hardware CRC calculation enable
    static constexpr uint32_t CR1_CRCNEXT = 0x1000;     // CRC transfer next
    static constexpr uint32_t CR1_CRCL = 0x800;         // CRC length
    static constexpr uint32_t CR1_RXONLY = 0x400;       // Receive only
    static constexpr uint32_t CR1_SSM = 0x200;          // Software slave management
    static constexpr uint32_t CR1_SSI = 0x100;          // Internal slave select
    static constexpr uint32_t CR1_LSBFIRST = 0x80;      // Frame format
    static constexpr uint32_t CR1_SPE = 0x40;           // SPI enable
    template<uint32_t X>
    static constexpr uint32_t CR1_BR =                  // Baud rate control (3 bits)
        bit_field_t<3, 0x7>::value<X>();
    static constexpr uint32_t CR1_MSTR = 0x4;           // Master selection
    static constexpr uint32_t CR1_CPOL = 0x2;           // Clock polarity
    static constexpr uint32_t CR1_CPHA = 0x1;           // Clock phase
    static const uint32_t CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CR2_RXDMAEN = 0x1;        // Rx buffer DMA enable
    static constexpr uint32_t CR2_TXDMAEN = 0x2;        // Tx buffer DMA enable
    static constexpr uint32_t CR2_SSOE = 0x4;           // SS output enable
    static constexpr uint32_t CR2_NSSP = 0x8;           // NSS pulse management
    static constexpr uint32_t CR2_FRF = 0x10;           // Frame format
    static constexpr uint32_t CR2_ERRIE = 0x20;         // Error interrupt enable
    static constexpr uint32_t CR2_RXNEIE = 0x40;        // RX buffer not empty interrupt enable
    static constexpr uint32_t CR2_TXEIE = 0x80;         // Tx buffer empty interrupt enable
    template<uint32_t X>
    static constexpr uint32_t CR2_DS =                  // Data size (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    static constexpr uint32_t CR2_FRXTH = 0x1000;       // FIFO reception threshold
    static constexpr uint32_t CR2_LDMA_RX = 0x2000;     // Last DMA transfer for reception
    static constexpr uint32_t CR2_LDMA_TX = 0x4000;     // Last DMA transfer for transmission
    static const uint32_t CR2_RESET_VALUE = 0x700;

    static constexpr uint32_t SR_FRE = 0x100;          // Frame format error, Read-only
    static constexpr uint32_t SR_BSY = 0x80;           // Busy flag, Read-only
    static constexpr uint32_t SR_OVR = 0x40;           // Overrun flag, Read-only
    static constexpr uint32_t SR_MODF = 0x20;          // Mode fault, Read-only
    static constexpr uint32_t SR_CRCERR = 0x10;        // CRC error flag, Read-write
    static constexpr uint32_t SR_UDR = 0x8;            // Underrun flag, Read-only
    static constexpr uint32_t SR_CHSIDE = 0x4;         // Channel side, Read-only
    static constexpr uint32_t SR_TXE = 0x2;            // Transmit buffer empty, Read-only
    static constexpr uint32_t SR_RXNE = 0x1;           // Receive buffer not empty, Read-only
    template<uint32_t X>
    static constexpr uint32_t SR_FRLVL =               // FIFO reception level (2 bits), Read-only
        bit_field_t<9, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SR_FTLVL =               // FIFO Transmission Level (2 bits), Read-only
        bit_field_t<11, 0x3>::value<X>();
    static const uint32_t SR_RESET_VALUE = 0x2;

    template<uint32_t X>
    static constexpr uint32_t DR_DR =                  // Data register (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CRCPR_CRCPOLY =             // CRC polynomial register (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CRCPR_RESET_VALUE = 0x7;

    template<uint32_t X>
    static constexpr uint32_t RXCRCR_RxCRC =               // Rx CRC register (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t RXCRCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TXCRCR_TxCRC =               // Tx CRC register (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t TXCRCR_RESET_VALUE = 0x0;

    static constexpr uint32_t I2SCFGR_I2SMOD = 0x800;       // I2S mode selection
    static constexpr uint32_t I2SCFGR_I2SE = 0x400;         // I2S Enable
    template<uint32_t X>
    static constexpr uint32_t I2SCFGR_I2SCFG =              // I2S configuration mode (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t I2SCFGR_PCMSYNC = 0x80;       // PCM frame synchronization
    template<uint32_t X>
    static constexpr uint32_t I2SCFGR_I2SSTD =              // I2S standard selection (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static constexpr uint32_t I2SCFGR_CKPOL = 0x8;          // Steady state clock polarity
    template<uint32_t X>
    static constexpr uint32_t I2SCFGR_DATLEN =              // Data length to be transferred (2 bits)
        bit_field_t<1, 0x3>::value<X>();
    static constexpr uint32_t I2SCFGR_CHLEN = 0x1;          // Channel length (number of bits per audio channel)
    static constexpr uint32_t I2SCFGR_ASTRTEN = 0x1000;     // Asynchronous start enable
    static const uint32_t I2SCFGR_RESET_VALUE = 0x0;

    static constexpr uint32_t I2SPR_MCKOE = 0x200;        // Master clock output enable
    static constexpr uint32_t I2SPR_ODD = 0x100;          // Odd factor for the prescaler
    template<uint32_t X>
    static constexpr uint32_t I2SPR_I2SDIV =              // I2S Linear prescaler (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t I2SPR_RESET_VALUE = 0xa;

    static constexpr uint8_t SPI1 = 35; // SPI1 global interrupt
};

static spi1_t& SPI1 = *reinterpret_cast<spi1_t*>(0x40013000);

#define HAVE_PERIPHERAL_SPI1


////
//
//    Serial peripheral interface
//
////

struct spi2_t
{
    volatile uint32_t    CR1;                  // [Read-write] control register 1
    volatile uint32_t    CR2;                  // [Read-write] control register 2
    volatile uint32_t    SR;                   // status register
    volatile uint32_t    DR;                   // [Read-write] data register
    volatile uint32_t    CRCPR;                // [Read-write] CRC polynomial register
    volatile uint32_t    RXCRCR;               // [Read-only] RX CRC register
    volatile uint32_t    TXCRCR;               // [Read-only] TX CRC register
    volatile uint32_t    I2SCFGR;              // [Read-write] I2S configuration register
    volatile uint32_t    I2SPR;                // [Read-write] I2S prescaler register

    static constexpr uint32_t CR1_BIDIMODE = 0x8000;    // Bidirectional data mode enable
    static constexpr uint32_t CR1_BIDIOE = 0x4000;      // Output enable in bidirectional mode
    static constexpr uint32_t CR1_CRCEN = 0x2000;       // Hardware CRC calculation enable
    static constexpr uint32_t CR1_CRCNEXT = 0x1000;     // CRC transfer next
    static constexpr uint32_t CR1_CRCL = 0x800;         // CRC length
    static constexpr uint32_t CR1_RXONLY = 0x400;       // Receive only
    static constexpr uint32_t CR1_SSM = 0x200;          // Software slave management
    static constexpr uint32_t CR1_SSI = 0x100;          // Internal slave select
    static constexpr uint32_t CR1_LSBFIRST = 0x80;      // Frame format
    static constexpr uint32_t CR1_SPE = 0x40;           // SPI enable
    template<uint32_t X>
    static constexpr uint32_t CR1_BR =                  // Baud rate control (3 bits)
        bit_field_t<3, 0x7>::value<X>();
    static constexpr uint32_t CR1_MSTR = 0x4;           // Master selection
    static constexpr uint32_t CR1_CPOL = 0x2;           // Clock polarity
    static constexpr uint32_t CR1_CPHA = 0x1;           // Clock phase
    static const uint32_t CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CR2_RXDMAEN = 0x1;        // Rx buffer DMA enable
    static constexpr uint32_t CR2_TXDMAEN = 0x2;        // Tx buffer DMA enable
    static constexpr uint32_t CR2_SSOE = 0x4;           // SS output enable
    static constexpr uint32_t CR2_NSSP = 0x8;           // NSS pulse management
    static constexpr uint32_t CR2_FRF = 0x10;           // Frame format
    static constexpr uint32_t CR2_ERRIE = 0x20;         // Error interrupt enable
    static constexpr uint32_t CR2_RXNEIE = 0x40;        // RX buffer not empty interrupt enable
    static constexpr uint32_t CR2_TXEIE = 0x80;         // Tx buffer empty interrupt enable
    template<uint32_t X>
    static constexpr uint32_t CR2_DS =                  // Data size (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    static constexpr uint32_t CR2_FRXTH = 0x1000;       // FIFO reception threshold
    static constexpr uint32_t CR2_LDMA_RX = 0x2000;     // Last DMA transfer for reception
    static constexpr uint32_t CR2_LDMA_TX = 0x4000;     // Last DMA transfer for transmission
    static const uint32_t CR2_RESET_VALUE = 0x700;

    static constexpr uint32_t SR_FRE = 0x100;          // Frame format error, Read-only
    static constexpr uint32_t SR_BSY = 0x80;           // Busy flag, Read-only
    static constexpr uint32_t SR_OVR = 0x40;           // Overrun flag, Read-only
    static constexpr uint32_t SR_MODF = 0x20;          // Mode fault, Read-only
    static constexpr uint32_t SR_CRCERR = 0x10;        // CRC error flag, Read-write
    static constexpr uint32_t SR_UDR = 0x8;            // Underrun flag, Read-only
    static constexpr uint32_t SR_CHSIDE = 0x4;         // Channel side, Read-only
    static constexpr uint32_t SR_TXE = 0x2;            // Transmit buffer empty, Read-only
    static constexpr uint32_t SR_RXNE = 0x1;           // Receive buffer not empty, Read-only
    template<uint32_t X>
    static constexpr uint32_t SR_FRLVL =               // FIFO reception level (2 bits), Read-only
        bit_field_t<9, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SR_FTLVL =               // FIFO Transmission Level (2 bits), Read-only
        bit_field_t<11, 0x3>::value<X>();
    static const uint32_t SR_RESET_VALUE = 0x2;

    template<uint32_t X>
    static constexpr uint32_t DR_DR =                  // Data register (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CRCPR_CRCPOLY =             // CRC polynomial register (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CRCPR_RESET_VALUE = 0x7;

    template<uint32_t X>
    static constexpr uint32_t RXCRCR_RxCRC =               // Rx CRC register (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t RXCRCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TXCRCR_TxCRC =               // Tx CRC register (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t TXCRCR_RESET_VALUE = 0x0;

    static constexpr uint32_t I2SCFGR_I2SMOD = 0x800;       // I2S mode selection
    static constexpr uint32_t I2SCFGR_I2SE = 0x400;         // I2S Enable
    template<uint32_t X>
    static constexpr uint32_t I2SCFGR_I2SCFG =              // I2S configuration mode (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t I2SCFGR_PCMSYNC = 0x80;       // PCM frame synchronization
    template<uint32_t X>
    static constexpr uint32_t I2SCFGR_I2SSTD =              // I2S standard selection (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static constexpr uint32_t I2SCFGR_CKPOL = 0x8;          // Steady state clock polarity
    template<uint32_t X>
    static constexpr uint32_t I2SCFGR_DATLEN =              // Data length to be transferred (2 bits)
        bit_field_t<1, 0x3>::value<X>();
    static constexpr uint32_t I2SCFGR_CHLEN = 0x1;          // Channel length (number of bits per audio channel)
    static constexpr uint32_t I2SCFGR_ASTRTEN = 0x1000;     // Asynchronous start enable
    static const uint32_t I2SCFGR_RESET_VALUE = 0x0;

    static constexpr uint32_t I2SPR_MCKOE = 0x200;        // Master clock output enable
    static constexpr uint32_t I2SPR_ODD = 0x100;          // Odd factor for the prescaler
    template<uint32_t X>
    static constexpr uint32_t I2SPR_I2SDIV =              // I2S Linear prescaler (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t I2SPR_RESET_VALUE = 0xa;

    static constexpr uint8_t SPI2 = 36; // SPI2 global interrupt
};

static spi2_t& SPI2 = *reinterpret_cast<spi2_t*>(0x40003800);

#define HAVE_PERIPHERAL_SPI2


////
//
//    Serial peripheral interface
//
////

struct spi4_t
{
    volatile uint32_t    CR1;                  // [Read-write] control register 1
    volatile uint32_t    CR2;                  // [Read-write] control register 2
    volatile uint32_t    SR;                   // status register
    volatile uint32_t    DR;                   // [Read-write] data register
    volatile uint32_t    CRCPR;                // [Read-write] CRC polynomial register
    volatile uint32_t    RXCRCR;               // [Read-only] RX CRC register
    volatile uint32_t    TXCRCR;               // [Read-only] TX CRC register
    volatile uint32_t    I2SCFGR;              // [Read-write] I2S configuration register
    volatile uint32_t    I2SPR;                // [Read-write] I2S prescaler register

    static constexpr uint32_t CR1_BIDIMODE = 0x8000;    // Bidirectional data mode enable
    static constexpr uint32_t CR1_BIDIOE = 0x4000;      // Output enable in bidirectional mode
    static constexpr uint32_t CR1_CRCEN = 0x2000;       // Hardware CRC calculation enable
    static constexpr uint32_t CR1_CRCNEXT = 0x1000;     // CRC transfer next
    static constexpr uint32_t CR1_CRCL = 0x800;         // CRC length
    static constexpr uint32_t CR1_RXONLY = 0x400;       // Receive only
    static constexpr uint32_t CR1_SSM = 0x200;          // Software slave management
    static constexpr uint32_t CR1_SSI = 0x100;          // Internal slave select
    static constexpr uint32_t CR1_LSBFIRST = 0x80;      // Frame format
    static constexpr uint32_t CR1_SPE = 0x40;           // SPI enable
    template<uint32_t X>
    static constexpr uint32_t CR1_BR =                  // Baud rate control (3 bits)
        bit_field_t<3, 0x7>::value<X>();
    static constexpr uint32_t CR1_MSTR = 0x4;           // Master selection
    static constexpr uint32_t CR1_CPOL = 0x2;           // Clock polarity
    static constexpr uint32_t CR1_CPHA = 0x1;           // Clock phase
    static const uint32_t CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CR2_RXDMAEN = 0x1;        // Rx buffer DMA enable
    static constexpr uint32_t CR2_TXDMAEN = 0x2;        // Tx buffer DMA enable
    static constexpr uint32_t CR2_SSOE = 0x4;           // SS output enable
    static constexpr uint32_t CR2_NSSP = 0x8;           // NSS pulse management
    static constexpr uint32_t CR2_FRF = 0x10;           // Frame format
    static constexpr uint32_t CR2_ERRIE = 0x20;         // Error interrupt enable
    static constexpr uint32_t CR2_RXNEIE = 0x40;        // RX buffer not empty interrupt enable
    static constexpr uint32_t CR2_TXEIE = 0x80;         // Tx buffer empty interrupt enable
    template<uint32_t X>
    static constexpr uint32_t CR2_DS =                  // Data size (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    static constexpr uint32_t CR2_FRXTH = 0x1000;       // FIFO reception threshold
    static constexpr uint32_t CR2_LDMA_RX = 0x2000;     // Last DMA transfer for reception
    static constexpr uint32_t CR2_LDMA_TX = 0x4000;     // Last DMA transfer for transmission
    static const uint32_t CR2_RESET_VALUE = 0x700;

    static constexpr uint32_t SR_FRE = 0x100;          // Frame format error, Read-only
    static constexpr uint32_t SR_BSY = 0x80;           // Busy flag, Read-only
    static constexpr uint32_t SR_OVR = 0x40;           // Overrun flag, Read-only
    static constexpr uint32_t SR_MODF = 0x20;          // Mode fault, Read-only
    static constexpr uint32_t SR_CRCERR = 0x10;        // CRC error flag, Read-write
    static constexpr uint32_t SR_UDR = 0x8;            // Underrun flag, Read-only
    static constexpr uint32_t SR_CHSIDE = 0x4;         // Channel side, Read-only
    static constexpr uint32_t SR_TXE = 0x2;            // Transmit buffer empty, Read-only
    static constexpr uint32_t SR_RXNE = 0x1;           // Receive buffer not empty, Read-only
    template<uint32_t X>
    static constexpr uint32_t SR_FRLVL =               // FIFO reception level (2 bits), Read-only
        bit_field_t<9, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SR_FTLVL =               // FIFO Transmission Level (2 bits), Read-only
        bit_field_t<11, 0x3>::value<X>();
    static const uint32_t SR_RESET_VALUE = 0x2;

    template<uint32_t X>
    static constexpr uint32_t DR_DR =                  // Data register (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CRCPR_CRCPOLY =             // CRC polynomial register (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CRCPR_RESET_VALUE = 0x7;

    template<uint32_t X>
    static constexpr uint32_t RXCRCR_RxCRC =               // Rx CRC register (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t RXCRCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TXCRCR_TxCRC =               // Tx CRC register (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t TXCRCR_RESET_VALUE = 0x0;

    static constexpr uint32_t I2SCFGR_I2SMOD = 0x800;       // I2S mode selection
    static constexpr uint32_t I2SCFGR_I2SE = 0x400;         // I2S Enable
    template<uint32_t X>
    static constexpr uint32_t I2SCFGR_I2SCFG =              // I2S configuration mode (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t I2SCFGR_PCMSYNC = 0x80;       // PCM frame synchronization
    template<uint32_t X>
    static constexpr uint32_t I2SCFGR_I2SSTD =              // I2S standard selection (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static constexpr uint32_t I2SCFGR_CKPOL = 0x8;          // Steady state clock polarity
    template<uint32_t X>
    static constexpr uint32_t I2SCFGR_DATLEN =              // Data length to be transferred (2 bits)
        bit_field_t<1, 0x3>::value<X>();
    static constexpr uint32_t I2SCFGR_CHLEN = 0x1;          // Channel length (number of bits per audio channel)
    static constexpr uint32_t I2SCFGR_ASTRTEN = 0x1000;     // Asynchronous start enable
    static const uint32_t I2SCFGR_RESET_VALUE = 0x0;

    static constexpr uint32_t I2SPR_MCKOE = 0x200;        // Master clock output enable
    static constexpr uint32_t I2SPR_ODD = 0x100;          // Odd factor for the prescaler
    template<uint32_t X>
    static constexpr uint32_t I2SPR_I2SDIV =              // I2S Linear prescaler (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t I2SPR_RESET_VALUE = 0xa;

    static constexpr uint8_t SPI4 = 84; // SPI 4 global interrupt
};

static spi4_t& SPI4 = *reinterpret_cast<spi4_t*>(0x40013400);

#define HAVE_PERIPHERAL_SPI4


////
//
//    Serial peripheral interface
//
////

struct spi5_t
{
    volatile uint32_t    CR1;                  // [Read-write] control register 1
    volatile uint32_t    CR2;                  // [Read-write] control register 2
    volatile uint32_t    SR;                   // status register
    volatile uint32_t    DR;                   // [Read-write] data register
    volatile uint32_t    CRCPR;                // [Read-write] CRC polynomial register
    volatile uint32_t    RXCRCR;               // [Read-only] RX CRC register
    volatile uint32_t    TXCRCR;               // [Read-only] TX CRC register
    volatile uint32_t    I2SCFGR;              // [Read-write] I2S configuration register
    volatile uint32_t    I2SPR;                // [Read-write] I2S prescaler register

    static constexpr uint32_t CR1_BIDIMODE = 0x8000;    // Bidirectional data mode enable
    static constexpr uint32_t CR1_BIDIOE = 0x4000;      // Output enable in bidirectional mode
    static constexpr uint32_t CR1_CRCEN = 0x2000;       // Hardware CRC calculation enable
    static constexpr uint32_t CR1_CRCNEXT = 0x1000;     // CRC transfer next
    static constexpr uint32_t CR1_CRCL = 0x800;         // CRC length
    static constexpr uint32_t CR1_RXONLY = 0x400;       // Receive only
    static constexpr uint32_t CR1_SSM = 0x200;          // Software slave management
    static constexpr uint32_t CR1_SSI = 0x100;          // Internal slave select
    static constexpr uint32_t CR1_LSBFIRST = 0x80;      // Frame format
    static constexpr uint32_t CR1_SPE = 0x40;           // SPI enable
    template<uint32_t X>
    static constexpr uint32_t CR1_BR =                  // Baud rate control (3 bits)
        bit_field_t<3, 0x7>::value<X>();
    static constexpr uint32_t CR1_MSTR = 0x4;           // Master selection
    static constexpr uint32_t CR1_CPOL = 0x2;           // Clock polarity
    static constexpr uint32_t CR1_CPHA = 0x1;           // Clock phase
    static const uint32_t CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CR2_RXDMAEN = 0x1;        // Rx buffer DMA enable
    static constexpr uint32_t CR2_TXDMAEN = 0x2;        // Tx buffer DMA enable
    static constexpr uint32_t CR2_SSOE = 0x4;           // SS output enable
    static constexpr uint32_t CR2_NSSP = 0x8;           // NSS pulse management
    static constexpr uint32_t CR2_FRF = 0x10;           // Frame format
    static constexpr uint32_t CR2_ERRIE = 0x20;         // Error interrupt enable
    static constexpr uint32_t CR2_RXNEIE = 0x40;        // RX buffer not empty interrupt enable
    static constexpr uint32_t CR2_TXEIE = 0x80;         // Tx buffer empty interrupt enable
    template<uint32_t X>
    static constexpr uint32_t CR2_DS =                  // Data size (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    static constexpr uint32_t CR2_FRXTH = 0x1000;       // FIFO reception threshold
    static constexpr uint32_t CR2_LDMA_RX = 0x2000;     // Last DMA transfer for reception
    static constexpr uint32_t CR2_LDMA_TX = 0x4000;     // Last DMA transfer for transmission
    static const uint32_t CR2_RESET_VALUE = 0x700;

    static constexpr uint32_t SR_FRE = 0x100;          // Frame format error, Read-only
    static constexpr uint32_t SR_BSY = 0x80;           // Busy flag, Read-only
    static constexpr uint32_t SR_OVR = 0x40;           // Overrun flag, Read-only
    static constexpr uint32_t SR_MODF = 0x20;          // Mode fault, Read-only
    static constexpr uint32_t SR_CRCERR = 0x10;        // CRC error flag, Read-write
    static constexpr uint32_t SR_UDR = 0x8;            // Underrun flag, Read-only
    static constexpr uint32_t SR_CHSIDE = 0x4;         // Channel side, Read-only
    static constexpr uint32_t SR_TXE = 0x2;            // Transmit buffer empty, Read-only
    static constexpr uint32_t SR_RXNE = 0x1;           // Receive buffer not empty, Read-only
    template<uint32_t X>
    static constexpr uint32_t SR_FRLVL =               // FIFO reception level (2 bits), Read-only
        bit_field_t<9, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SR_FTLVL =               // FIFO Transmission Level (2 bits), Read-only
        bit_field_t<11, 0x3>::value<X>();
    static const uint32_t SR_RESET_VALUE = 0x2;

    template<uint32_t X>
    static constexpr uint32_t DR_DR =                  // Data register (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CRCPR_CRCPOLY =             // CRC polynomial register (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CRCPR_RESET_VALUE = 0x7;

    template<uint32_t X>
    static constexpr uint32_t RXCRCR_RxCRC =               // Rx CRC register (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t RXCRCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TXCRCR_TxCRC =               // Tx CRC register (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t TXCRCR_RESET_VALUE = 0x0;

    static constexpr uint32_t I2SCFGR_I2SMOD = 0x800;       // I2S mode selection
    static constexpr uint32_t I2SCFGR_I2SE = 0x400;         // I2S Enable
    template<uint32_t X>
    static constexpr uint32_t I2SCFGR_I2SCFG =              // I2S configuration mode (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t I2SCFGR_PCMSYNC = 0x80;       // PCM frame synchronization
    template<uint32_t X>
    static constexpr uint32_t I2SCFGR_I2SSTD =              // I2S standard selection (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static constexpr uint32_t I2SCFGR_CKPOL = 0x8;          // Steady state clock polarity
    template<uint32_t X>
    static constexpr uint32_t I2SCFGR_DATLEN =              // Data length to be transferred (2 bits)
        bit_field_t<1, 0x3>::value<X>();
    static constexpr uint32_t I2SCFGR_CHLEN = 0x1;          // Channel length (number of bits per audio channel)
    static constexpr uint32_t I2SCFGR_ASTRTEN = 0x1000;     // Asynchronous start enable
    static const uint32_t I2SCFGR_RESET_VALUE = 0x0;

    static constexpr uint32_t I2SPR_MCKOE = 0x200;        // Master clock output enable
    static constexpr uint32_t I2SPR_ODD = 0x100;          // Odd factor for the prescaler
    template<uint32_t X>
    static constexpr uint32_t I2SPR_I2SDIV =              // I2S Linear prescaler (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t I2SPR_RESET_VALUE = 0xa;

    static constexpr uint8_t SPI5 = 85; // SPI 5 global interrupt
};

static spi5_t& SPI5 = *reinterpret_cast<spi5_t*>(0x40015000);

#define HAVE_PERIPHERAL_SPI5


////
//
//    Serial peripheral interface
//
////

struct spi3_t
{
    volatile uint32_t    CR1;                  // [Read-write] control register 1
    volatile uint32_t    CR2;                  // [Read-write] control register 2
    volatile uint32_t    SR;                   // status register
    volatile uint32_t    DR;                   // [Read-write] data register
    volatile uint32_t    CRCPR;                // [Read-write] CRC polynomial register
    volatile uint32_t    RXCRCR;               // [Read-only] RX CRC register
    volatile uint32_t    TXCRCR;               // [Read-only] TX CRC register
    volatile uint32_t    I2SCFGR;              // [Read-write] I2S configuration register
    volatile uint32_t    I2SPR;                // [Read-write] I2S prescaler register

    static constexpr uint32_t CR1_BIDIMODE = 0x8000;    // Bidirectional data mode enable
    static constexpr uint32_t CR1_BIDIOE = 0x4000;      // Output enable in bidirectional mode
    static constexpr uint32_t CR1_CRCEN = 0x2000;       // Hardware CRC calculation enable
    static constexpr uint32_t CR1_CRCNEXT = 0x1000;     // CRC transfer next
    static constexpr uint32_t CR1_CRCL = 0x800;         // CRC length
    static constexpr uint32_t CR1_RXONLY = 0x400;       // Receive only
    static constexpr uint32_t CR1_SSM = 0x200;          // Software slave management
    static constexpr uint32_t CR1_SSI = 0x100;          // Internal slave select
    static constexpr uint32_t CR1_LSBFIRST = 0x80;      // Frame format
    static constexpr uint32_t CR1_SPE = 0x40;           // SPI enable
    template<uint32_t X>
    static constexpr uint32_t CR1_BR =                  // Baud rate control (3 bits)
        bit_field_t<3, 0x7>::value<X>();
    static constexpr uint32_t CR1_MSTR = 0x4;           // Master selection
    static constexpr uint32_t CR1_CPOL = 0x2;           // Clock polarity
    static constexpr uint32_t CR1_CPHA = 0x1;           // Clock phase
    static const uint32_t CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CR2_RXDMAEN = 0x1;        // Rx buffer DMA enable
    static constexpr uint32_t CR2_TXDMAEN = 0x2;        // Tx buffer DMA enable
    static constexpr uint32_t CR2_SSOE = 0x4;           // SS output enable
    static constexpr uint32_t CR2_NSSP = 0x8;           // NSS pulse management
    static constexpr uint32_t CR2_FRF = 0x10;           // Frame format
    static constexpr uint32_t CR2_ERRIE = 0x20;         // Error interrupt enable
    static constexpr uint32_t CR2_RXNEIE = 0x40;        // RX buffer not empty interrupt enable
    static constexpr uint32_t CR2_TXEIE = 0x80;         // Tx buffer empty interrupt enable
    template<uint32_t X>
    static constexpr uint32_t CR2_DS =                  // Data size (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    static constexpr uint32_t CR2_FRXTH = 0x1000;       // FIFO reception threshold
    static constexpr uint32_t CR2_LDMA_RX = 0x2000;     // Last DMA transfer for reception
    static constexpr uint32_t CR2_LDMA_TX = 0x4000;     // Last DMA transfer for transmission
    static const uint32_t CR2_RESET_VALUE = 0x700;

    static constexpr uint32_t SR_FRE = 0x100;          // Frame format error, Read-only
    static constexpr uint32_t SR_BSY = 0x80;           // Busy flag, Read-only
    static constexpr uint32_t SR_OVR = 0x40;           // Overrun flag, Read-only
    static constexpr uint32_t SR_MODF = 0x20;          // Mode fault, Read-only
    static constexpr uint32_t SR_CRCERR = 0x10;        // CRC error flag, Read-write
    static constexpr uint32_t SR_UDR = 0x8;            // Underrun flag, Read-only
    static constexpr uint32_t SR_CHSIDE = 0x4;         // Channel side, Read-only
    static constexpr uint32_t SR_TXE = 0x2;            // Transmit buffer empty, Read-only
    static constexpr uint32_t SR_RXNE = 0x1;           // Receive buffer not empty, Read-only
    template<uint32_t X>
    static constexpr uint32_t SR_FRLVL =               // FIFO reception level (2 bits), Read-only
        bit_field_t<9, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SR_FTLVL =               // FIFO Transmission Level (2 bits), Read-only
        bit_field_t<11, 0x3>::value<X>();
    static const uint32_t SR_RESET_VALUE = 0x2;

    template<uint32_t X>
    static constexpr uint32_t DR_DR =                  // Data register (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CRCPR_CRCPOLY =             // CRC polynomial register (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CRCPR_RESET_VALUE = 0x7;

    template<uint32_t X>
    static constexpr uint32_t RXCRCR_RxCRC =               // Rx CRC register (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t RXCRCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TXCRCR_TxCRC =               // Tx CRC register (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t TXCRCR_RESET_VALUE = 0x0;

    static constexpr uint32_t I2SCFGR_I2SMOD = 0x800;       // I2S mode selection
    static constexpr uint32_t I2SCFGR_I2SE = 0x400;         // I2S Enable
    template<uint32_t X>
    static constexpr uint32_t I2SCFGR_I2SCFG =              // I2S configuration mode (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t I2SCFGR_PCMSYNC = 0x80;       // PCM frame synchronization
    template<uint32_t X>
    static constexpr uint32_t I2SCFGR_I2SSTD =              // I2S standard selection (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static constexpr uint32_t I2SCFGR_CKPOL = 0x8;          // Steady state clock polarity
    template<uint32_t X>
    static constexpr uint32_t I2SCFGR_DATLEN =              // Data length to be transferred (2 bits)
        bit_field_t<1, 0x3>::value<X>();
    static constexpr uint32_t I2SCFGR_CHLEN = 0x1;          // Channel length (number of bits per audio channel)
    static constexpr uint32_t I2SCFGR_ASTRTEN = 0x1000;     // Asynchronous start enable
    static const uint32_t I2SCFGR_RESET_VALUE = 0x0;

    static constexpr uint32_t I2SPR_MCKOE = 0x200;        // Master clock output enable
    static constexpr uint32_t I2SPR_ODD = 0x100;          // Odd factor for the prescaler
    template<uint32_t X>
    static constexpr uint32_t I2SPR_I2SDIV =              // I2S Linear prescaler (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t I2SPR_RESET_VALUE = 0xa;

    static constexpr uint8_t SPI3 = 51; // SPI3 global interrupt
};

static spi3_t& SPI3 = *reinterpret_cast<spi3_t*>(0x40003c00);

#define HAVE_PERIPHERAL_SPI3


////
//
//    Serial peripheral interface
//
////

struct spi6_t
{
    volatile uint32_t    CR1;                  // [Read-write] control register 1
    volatile uint32_t    CR2;                  // [Read-write] control register 2
    volatile uint32_t    SR;                   // status register
    volatile uint32_t    DR;                   // [Read-write] data register
    volatile uint32_t    CRCPR;                // [Read-write] CRC polynomial register
    volatile uint32_t    RXCRCR;               // [Read-only] RX CRC register
    volatile uint32_t    TXCRCR;               // [Read-only] TX CRC register
    volatile uint32_t    I2SCFGR;              // [Read-write] I2S configuration register
    volatile uint32_t    I2SPR;                // [Read-write] I2S prescaler register

    static constexpr uint32_t CR1_BIDIMODE = 0x8000;    // Bidirectional data mode enable
    static constexpr uint32_t CR1_BIDIOE = 0x4000;      // Output enable in bidirectional mode
    static constexpr uint32_t CR1_CRCEN = 0x2000;       // Hardware CRC calculation enable
    static constexpr uint32_t CR1_CRCNEXT = 0x1000;     // CRC transfer next
    static constexpr uint32_t CR1_CRCL = 0x800;         // CRC length
    static constexpr uint32_t CR1_RXONLY = 0x400;       // Receive only
    static constexpr uint32_t CR1_SSM = 0x200;          // Software slave management
    static constexpr uint32_t CR1_SSI = 0x100;          // Internal slave select
    static constexpr uint32_t CR1_LSBFIRST = 0x80;      // Frame format
    static constexpr uint32_t CR1_SPE = 0x40;           // SPI enable
    template<uint32_t X>
    static constexpr uint32_t CR1_BR =                  // Baud rate control (3 bits)
        bit_field_t<3, 0x7>::value<X>();
    static constexpr uint32_t CR1_MSTR = 0x4;           // Master selection
    static constexpr uint32_t CR1_CPOL = 0x2;           // Clock polarity
    static constexpr uint32_t CR1_CPHA = 0x1;           // Clock phase
    static const uint32_t CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CR2_RXDMAEN = 0x1;        // Rx buffer DMA enable
    static constexpr uint32_t CR2_TXDMAEN = 0x2;        // Tx buffer DMA enable
    static constexpr uint32_t CR2_SSOE = 0x4;           // SS output enable
    static constexpr uint32_t CR2_NSSP = 0x8;           // NSS pulse management
    static constexpr uint32_t CR2_FRF = 0x10;           // Frame format
    static constexpr uint32_t CR2_ERRIE = 0x20;         // Error interrupt enable
    static constexpr uint32_t CR2_RXNEIE = 0x40;        // RX buffer not empty interrupt enable
    static constexpr uint32_t CR2_TXEIE = 0x80;         // Tx buffer empty interrupt enable
    template<uint32_t X>
    static constexpr uint32_t CR2_DS =                  // Data size (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    static constexpr uint32_t CR2_FRXTH = 0x1000;       // FIFO reception threshold
    static constexpr uint32_t CR2_LDMA_RX = 0x2000;     // Last DMA transfer for reception
    static constexpr uint32_t CR2_LDMA_TX = 0x4000;     // Last DMA transfer for transmission
    static const uint32_t CR2_RESET_VALUE = 0x700;

    static constexpr uint32_t SR_FRE = 0x100;          // Frame format error, Read-only
    static constexpr uint32_t SR_BSY = 0x80;           // Busy flag, Read-only
    static constexpr uint32_t SR_OVR = 0x40;           // Overrun flag, Read-only
    static constexpr uint32_t SR_MODF = 0x20;          // Mode fault, Read-only
    static constexpr uint32_t SR_CRCERR = 0x10;        // CRC error flag, Read-write
    static constexpr uint32_t SR_UDR = 0x8;            // Underrun flag, Read-only
    static constexpr uint32_t SR_CHSIDE = 0x4;         // Channel side, Read-only
    static constexpr uint32_t SR_TXE = 0x2;            // Transmit buffer empty, Read-only
    static constexpr uint32_t SR_RXNE = 0x1;           // Receive buffer not empty, Read-only
    template<uint32_t X>
    static constexpr uint32_t SR_FRLVL =               // FIFO reception level (2 bits), Read-only
        bit_field_t<9, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SR_FTLVL =               // FIFO Transmission Level (2 bits), Read-only
        bit_field_t<11, 0x3>::value<X>();
    static const uint32_t SR_RESET_VALUE = 0x2;

    template<uint32_t X>
    static constexpr uint32_t DR_DR =                  // Data register (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CRCPR_CRCPOLY =             // CRC polynomial register (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CRCPR_RESET_VALUE = 0x7;

    template<uint32_t X>
    static constexpr uint32_t RXCRCR_RxCRC =               // Rx CRC register (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t RXCRCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TXCRCR_TxCRC =               // Tx CRC register (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t TXCRCR_RESET_VALUE = 0x0;

    static constexpr uint32_t I2SCFGR_I2SMOD = 0x800;       // I2S mode selection
    static constexpr uint32_t I2SCFGR_I2SE = 0x400;         // I2S Enable
    template<uint32_t X>
    static constexpr uint32_t I2SCFGR_I2SCFG =              // I2S configuration mode (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t I2SCFGR_PCMSYNC = 0x80;       // PCM frame synchronization
    template<uint32_t X>
    static constexpr uint32_t I2SCFGR_I2SSTD =              // I2S standard selection (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static constexpr uint32_t I2SCFGR_CKPOL = 0x8;          // Steady state clock polarity
    template<uint32_t X>
    static constexpr uint32_t I2SCFGR_DATLEN =              // Data length to be transferred (2 bits)
        bit_field_t<1, 0x3>::value<X>();
    static constexpr uint32_t I2SCFGR_CHLEN = 0x1;          // Channel length (number of bits per audio channel)
    static constexpr uint32_t I2SCFGR_ASTRTEN = 0x1000;     // Asynchronous start enable
    static const uint32_t I2SCFGR_RESET_VALUE = 0x0;

    static constexpr uint32_t I2SPR_MCKOE = 0x200;        // Master clock output enable
    static constexpr uint32_t I2SPR_ODD = 0x100;          // Odd factor for the prescaler
    template<uint32_t X>
    static constexpr uint32_t I2SPR_I2SDIV =              // I2S Linear prescaler (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t I2SPR_RESET_VALUE = 0xa;

    static constexpr uint8_t SPI6 = 86; // SPI 6 global interrupt
};

static spi6_t& SPI6 = *reinterpret_cast<spi6_t*>(0x40015400);

#define HAVE_PERIPHERAL_SPI6


////
//
//    Analog-to-digital converter
//
////

struct adc1_t
{
    volatile uint32_t    SR;                   // [Read-write] status register
    volatile uint32_t    CR1;                  // [Read-write] control register 1
    volatile uint32_t    CR2;                  // [Read-write] control register 2
    volatile uint32_t    SMPR1;                // [Read-write] sample time register 1
    volatile uint32_t    SMPR2;                // [Read-write] sample time register 2
    volatile uint32_t    JOFR1;                // [Read-write] injected channel data offset register x
    volatile uint32_t    JOFR2;                // [Read-write] injected channel data offset register x
    volatile uint32_t    JOFR3;                // [Read-write] injected channel data offset register x
    volatile uint32_t    JOFR4;                // [Read-write] injected channel data offset register x
    volatile uint32_t    HTR;                  // [Read-write] watchdog higher threshold register
    volatile uint32_t    LTR;                  // [Read-write] watchdog lower threshold register
    volatile uint32_t    SQR1;                 // [Read-write] regular sequence register 1
    volatile uint32_t    SQR2;                 // [Read-write] regular sequence register 2
    volatile uint32_t    SQR3;                 // [Read-write] regular sequence register 3
    volatile uint32_t    JSQR;                 // [Read-write] injected sequence register
    volatile uint32_t    JDR1;                 // [Read-only] injected data register x
    volatile uint32_t    JDR2;                 // [Read-only] injected data register x
    volatile uint32_t    JDR3;                 // [Read-only] injected data register x
    volatile uint32_t    JDR4;                 // [Read-only] injected data register x
    volatile uint32_t    DR;                   // [Read-only] regular data register

    static constexpr uint32_t SR_OVR = 0x20;           // Overrun
    static constexpr uint32_t SR_STRT = 0x10;          // Regular channel start flag
    static constexpr uint32_t SR_JSTRT = 0x8;          // Injected channel start flag
    static constexpr uint32_t SR_JEOC = 0x4;           // Injected channel end of conversion
    static constexpr uint32_t SR_EOC = 0x2;            // Regular channel end of conversion
    static constexpr uint32_t SR_AWD = 0x1;            // Analog watchdog flag
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint32_t CR1_OVRIE = 0x4000000;    // Overrun interrupt enable
    template<uint32_t X>
    static constexpr uint32_t CR1_RES =                 // Resolution (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    static constexpr uint32_t CR1_AWDEN = 0x800000;     // Analog watchdog enable on regular channels
    static constexpr uint32_t CR1_JAWDEN = 0x400000;    // Analog watchdog enable on injected channels
    template<uint32_t X>
    static constexpr uint32_t CR1_DISCNUM =             // Discontinuous mode channel count (3 bits)
        bit_field_t<13, 0x7>::value<X>();
    static constexpr uint32_t CR1_JDISCEN = 0x1000;     // Discontinuous mode on injected channels
    static constexpr uint32_t CR1_DISCEN = 0x800;       // Discontinuous mode on regular channels
    static constexpr uint32_t CR1_JAUTO = 0x400;        // Automatic injected group conversion
    static constexpr uint32_t CR1_AWDSGL = 0x200;       // Enable the watchdog on a single channel in scan mode
    static constexpr uint32_t CR1_SCAN = 0x100;         // Scan mode
    static constexpr uint32_t CR1_JEOCIE = 0x80;        // Interrupt enable for injected channels
    static constexpr uint32_t CR1_AWDIE = 0x40;         // Analog watchdog interrupt enable
    static constexpr uint32_t CR1_EOCIE = 0x20;         // Interrupt enable for EOC
    template<uint32_t X>
    static constexpr uint32_t CR1_AWDCH =               // Analog watchdog channel select bits (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CR2_SWSTART = 0x40000000; // Start conversion of regular channels
    template<uint32_t X>
    static constexpr uint32_t CR2_EXTEN =               // External trigger enable for regular channels (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR2_EXTSEL =              // External event select for regular group (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    static constexpr uint32_t CR2_JSWSTART = 0x400000;  // Start conversion of injected channels
    template<uint32_t X>
    static constexpr uint32_t CR2_JEXTEN =              // External trigger enable for injected channels (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR2_JEXTSEL =             // External event select for injected group (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    static constexpr uint32_t CR2_ALIGN = 0x800;        // Data alignment
    static constexpr uint32_t CR2_EOCS = 0x400;         // End of conversion selection
    static constexpr uint32_t CR2_DDS = 0x200;          // DMA disable selection (for single ADC mode)
    static constexpr uint32_t CR2_DMA = 0x100;          // Direct memory access mode (for single ADC mode)
    static constexpr uint32_t CR2_CONT = 0x2;           // Continuous conversion
    static constexpr uint32_t CR2_ADON = 0x1;           // A/D Converter ON / OFF
    static const uint32_t CR2_RESET_VALUE = 0x0;


    static const uint32_t SMPR1_RESET_VALUE = 0x0;


    static const uint32_t SMPR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t JOFR1_JOFFSET1 =            // Data offset for injected channel x (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t JOFR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t JOFR2_JOFFSET2 =            // Data offset for injected channel x (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t JOFR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t JOFR3_JOFFSET3 =            // Data offset for injected channel x (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t JOFR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t JOFR4_JOFFSET4 =            // Data offset for injected channel x (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t JOFR4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HTR_HT =                  // Analog watchdog higher threshold (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t HTR_RESET_VALUE = 0xfff;

    template<uint32_t X>
    static constexpr uint32_t LTR_LT =                  // Analog watchdog lower threshold (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t LTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SQR1_L =                   // Regular channel sequence length (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR1_SQ16 =                // 16th conversion in regular sequence (5 bits)
        bit_field_t<15, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR1_SQ15 =                // 15th conversion in regular sequence (5 bits)
        bit_field_t<10, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR1_SQ14 =                // 14th conversion in regular sequence (5 bits)
        bit_field_t<5, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR1_SQ13 =                // 13th conversion in regular sequence (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t SQR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SQR2_SQ12 =                // 12th conversion in regular sequence (5 bits)
        bit_field_t<25, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR2_SQ11 =                // 11th conversion in regular sequence (5 bits)
        bit_field_t<20, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR2_SQ10 =                // 10th conversion in regular sequence (5 bits)
        bit_field_t<15, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR2_SQ9 =                 // 9th conversion in regular sequence (5 bits)
        bit_field_t<10, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR2_SQ8 =                 // 8th conversion in regular sequence (5 bits)
        bit_field_t<5, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR2_SQ7 =                 // 7th conversion in regular sequence (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t SQR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SQR3_SQ6 =                 // 6th conversion in regular sequence (5 bits)
        bit_field_t<25, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR3_SQ5 =                 // 5th conversion in regular sequence (5 bits)
        bit_field_t<20, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR3_SQ4 =                 // 4th conversion in regular sequence (5 bits)
        bit_field_t<15, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR3_SQ3 =                 // 3rd conversion in regular sequence (5 bits)
        bit_field_t<10, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR3_SQ2 =                 // 2nd conversion in regular sequence (5 bits)
        bit_field_t<5, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR3_SQ1 =                 // 1st conversion in regular sequence (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t SQR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t JSQR_JL =                  // Injected sequence length (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t JSQR_JSQ4 =                // 4th conversion in injected sequence (5 bits)
        bit_field_t<15, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t JSQR_JSQ3 =                // 3rd conversion in injected sequence (5 bits)
        bit_field_t<10, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t JSQR_JSQ2 =                // 2nd conversion in injected sequence (5 bits)
        bit_field_t<5, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t JSQR_JSQ1 =                // 1st conversion in injected sequence (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t JSQR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t JDR1_JDATA =               // Injected data (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t JDR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t JDR2_JDATA =               // Injected data (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t JDR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t JDR3_JDATA =               // Injected data (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t JDR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t JDR4_JDATA =               // Injected data (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t JDR4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DR_DATA =                // Regular data (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DR_RESET_VALUE = 0x0;

    static constexpr uint8_t ADC = 18; // ADC1 global interrupt
};

static adc1_t& ADC1 = *reinterpret_cast<adc1_t*>(0x40012000);

#define HAVE_PERIPHERAL_ADC1


////
//
//    Analog-to-digital converter
//
////

struct adc2_t
{
    volatile uint32_t    SR;                   // [Read-write] status register
    volatile uint32_t    CR1;                  // [Read-write] control register 1
    volatile uint32_t    CR2;                  // [Read-write] control register 2
    volatile uint32_t    SMPR1;                // [Read-write] sample time register 1
    volatile uint32_t    SMPR2;                // [Read-write] sample time register 2
    volatile uint32_t    JOFR1;                // [Read-write] injected channel data offset register x
    volatile uint32_t    JOFR2;                // [Read-write] injected channel data offset register x
    volatile uint32_t    JOFR3;                // [Read-write] injected channel data offset register x
    volatile uint32_t    JOFR4;                // [Read-write] injected channel data offset register x
    volatile uint32_t    HTR;                  // [Read-write] watchdog higher threshold register
    volatile uint32_t    LTR;                  // [Read-write] watchdog lower threshold register
    volatile uint32_t    SQR1;                 // [Read-write] regular sequence register 1
    volatile uint32_t    SQR2;                 // [Read-write] regular sequence register 2
    volatile uint32_t    SQR3;                 // [Read-write] regular sequence register 3
    volatile uint32_t    JSQR;                 // [Read-write] injected sequence register
    volatile uint32_t    JDR1;                 // [Read-only] injected data register x
    volatile uint32_t    JDR2;                 // [Read-only] injected data register x
    volatile uint32_t    JDR3;                 // [Read-only] injected data register x
    volatile uint32_t    JDR4;                 // [Read-only] injected data register x
    volatile uint32_t    DR;                   // [Read-only] regular data register

    static constexpr uint32_t SR_OVR = 0x20;           // Overrun
    static constexpr uint32_t SR_STRT = 0x10;          // Regular channel start flag
    static constexpr uint32_t SR_JSTRT = 0x8;          // Injected channel start flag
    static constexpr uint32_t SR_JEOC = 0x4;           // Injected channel end of conversion
    static constexpr uint32_t SR_EOC = 0x2;            // Regular channel end of conversion
    static constexpr uint32_t SR_AWD = 0x1;            // Analog watchdog flag
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint32_t CR1_OVRIE = 0x4000000;    // Overrun interrupt enable
    template<uint32_t X>
    static constexpr uint32_t CR1_RES =                 // Resolution (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    static constexpr uint32_t CR1_AWDEN = 0x800000;     // Analog watchdog enable on regular channels
    static constexpr uint32_t CR1_JAWDEN = 0x400000;    // Analog watchdog enable on injected channels
    template<uint32_t X>
    static constexpr uint32_t CR1_DISCNUM =             // Discontinuous mode channel count (3 bits)
        bit_field_t<13, 0x7>::value<X>();
    static constexpr uint32_t CR1_JDISCEN = 0x1000;     // Discontinuous mode on injected channels
    static constexpr uint32_t CR1_DISCEN = 0x800;       // Discontinuous mode on regular channels
    static constexpr uint32_t CR1_JAUTO = 0x400;        // Automatic injected group conversion
    static constexpr uint32_t CR1_AWDSGL = 0x200;       // Enable the watchdog on a single channel in scan mode
    static constexpr uint32_t CR1_SCAN = 0x100;         // Scan mode
    static constexpr uint32_t CR1_JEOCIE = 0x80;        // Interrupt enable for injected channels
    static constexpr uint32_t CR1_AWDIE = 0x40;         // Analog watchdog interrupt enable
    static constexpr uint32_t CR1_EOCIE = 0x20;         // Interrupt enable for EOC
    template<uint32_t X>
    static constexpr uint32_t CR1_AWDCH =               // Analog watchdog channel select bits (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CR2_SWSTART = 0x40000000; // Start conversion of regular channels
    template<uint32_t X>
    static constexpr uint32_t CR2_EXTEN =               // External trigger enable for regular channels (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR2_EXTSEL =              // External event select for regular group (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    static constexpr uint32_t CR2_JSWSTART = 0x400000;  // Start conversion of injected channels
    template<uint32_t X>
    static constexpr uint32_t CR2_JEXTEN =              // External trigger enable for injected channels (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR2_JEXTSEL =             // External event select for injected group (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    static constexpr uint32_t CR2_ALIGN = 0x800;        // Data alignment
    static constexpr uint32_t CR2_EOCS = 0x400;         // End of conversion selection
    static constexpr uint32_t CR2_DDS = 0x200;          // DMA disable selection (for single ADC mode)
    static constexpr uint32_t CR2_DMA = 0x100;          // Direct memory access mode (for single ADC mode)
    static constexpr uint32_t CR2_CONT = 0x2;           // Continuous conversion
    static constexpr uint32_t CR2_ADON = 0x1;           // A/D Converter ON / OFF
    static const uint32_t CR2_RESET_VALUE = 0x0;


    static const uint32_t SMPR1_RESET_VALUE = 0x0;


    static const uint32_t SMPR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t JOFR1_JOFFSET1 =            // Data offset for injected channel x (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t JOFR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t JOFR2_JOFFSET2 =            // Data offset for injected channel x (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t JOFR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t JOFR3_JOFFSET3 =            // Data offset for injected channel x (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t JOFR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t JOFR4_JOFFSET4 =            // Data offset for injected channel x (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t JOFR4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HTR_HT =                  // Analog watchdog higher threshold (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t HTR_RESET_VALUE = 0xfff;

    template<uint32_t X>
    static constexpr uint32_t LTR_LT =                  // Analog watchdog lower threshold (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t LTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SQR1_L =                   // Regular channel sequence length (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR1_SQ16 =                // 16th conversion in regular sequence (5 bits)
        bit_field_t<15, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR1_SQ15 =                // 15th conversion in regular sequence (5 bits)
        bit_field_t<10, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR1_SQ14 =                // 14th conversion in regular sequence (5 bits)
        bit_field_t<5, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR1_SQ13 =                // 13th conversion in regular sequence (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t SQR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SQR2_SQ12 =                // 12th conversion in regular sequence (5 bits)
        bit_field_t<25, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR2_SQ11 =                // 11th conversion in regular sequence (5 bits)
        bit_field_t<20, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR2_SQ10 =                // 10th conversion in regular sequence (5 bits)
        bit_field_t<15, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR2_SQ9 =                 // 9th conversion in regular sequence (5 bits)
        bit_field_t<10, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR2_SQ8 =                 // 8th conversion in regular sequence (5 bits)
        bit_field_t<5, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR2_SQ7 =                 // 7th conversion in regular sequence (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t SQR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SQR3_SQ6 =                 // 6th conversion in regular sequence (5 bits)
        bit_field_t<25, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR3_SQ5 =                 // 5th conversion in regular sequence (5 bits)
        bit_field_t<20, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR3_SQ4 =                 // 4th conversion in regular sequence (5 bits)
        bit_field_t<15, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR3_SQ3 =                 // 3rd conversion in regular sequence (5 bits)
        bit_field_t<10, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR3_SQ2 =                 // 2nd conversion in regular sequence (5 bits)
        bit_field_t<5, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR3_SQ1 =                 // 1st conversion in regular sequence (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t SQR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t JSQR_JL =                  // Injected sequence length (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t JSQR_JSQ4 =                // 4th conversion in injected sequence (5 bits)
        bit_field_t<15, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t JSQR_JSQ3 =                // 3rd conversion in injected sequence (5 bits)
        bit_field_t<10, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t JSQR_JSQ2 =                // 2nd conversion in injected sequence (5 bits)
        bit_field_t<5, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t JSQR_JSQ1 =                // 1st conversion in injected sequence (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t JSQR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t JDR1_JDATA =               // Injected data (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t JDR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t JDR2_JDATA =               // Injected data (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t JDR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t JDR3_JDATA =               // Injected data (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t JDR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t JDR4_JDATA =               // Injected data (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t JDR4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DR_DATA =                // Regular data (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DR_RESET_VALUE = 0x0;
};

static adc2_t& ADC2 = *reinterpret_cast<adc2_t*>(0x40012100);

#define HAVE_PERIPHERAL_ADC2


////
//
//    Analog-to-digital converter
//
////

struct adc3_t
{
    volatile uint32_t    SR;                   // [Read-write] status register
    volatile uint32_t    CR1;                  // [Read-write] control register 1
    volatile uint32_t    CR2;                  // [Read-write] control register 2
    volatile uint32_t    SMPR1;                // [Read-write] sample time register 1
    volatile uint32_t    SMPR2;                // [Read-write] sample time register 2
    volatile uint32_t    JOFR1;                // [Read-write] injected channel data offset register x
    volatile uint32_t    JOFR2;                // [Read-write] injected channel data offset register x
    volatile uint32_t    JOFR3;                // [Read-write] injected channel data offset register x
    volatile uint32_t    JOFR4;                // [Read-write] injected channel data offset register x
    volatile uint32_t    HTR;                  // [Read-write] watchdog higher threshold register
    volatile uint32_t    LTR;                  // [Read-write] watchdog lower threshold register
    volatile uint32_t    SQR1;                 // [Read-write] regular sequence register 1
    volatile uint32_t    SQR2;                 // [Read-write] regular sequence register 2
    volatile uint32_t    SQR3;                 // [Read-write] regular sequence register 3
    volatile uint32_t    JSQR;                 // [Read-write] injected sequence register
    volatile uint32_t    JDR1;                 // [Read-only] injected data register x
    volatile uint32_t    JDR2;                 // [Read-only] injected data register x
    volatile uint32_t    JDR3;                 // [Read-only] injected data register x
    volatile uint32_t    JDR4;                 // [Read-only] injected data register x
    volatile uint32_t    DR;                   // [Read-only] regular data register

    static constexpr uint32_t SR_OVR = 0x20;           // Overrun
    static constexpr uint32_t SR_STRT = 0x10;          // Regular channel start flag
    static constexpr uint32_t SR_JSTRT = 0x8;          // Injected channel start flag
    static constexpr uint32_t SR_JEOC = 0x4;           // Injected channel end of conversion
    static constexpr uint32_t SR_EOC = 0x2;            // Regular channel end of conversion
    static constexpr uint32_t SR_AWD = 0x1;            // Analog watchdog flag
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint32_t CR1_OVRIE = 0x4000000;    // Overrun interrupt enable
    template<uint32_t X>
    static constexpr uint32_t CR1_RES =                 // Resolution (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    static constexpr uint32_t CR1_AWDEN = 0x800000;     // Analog watchdog enable on regular channels
    static constexpr uint32_t CR1_JAWDEN = 0x400000;    // Analog watchdog enable on injected channels
    template<uint32_t X>
    static constexpr uint32_t CR1_DISCNUM =             // Discontinuous mode channel count (3 bits)
        bit_field_t<13, 0x7>::value<X>();
    static constexpr uint32_t CR1_JDISCEN = 0x1000;     // Discontinuous mode on injected channels
    static constexpr uint32_t CR1_DISCEN = 0x800;       // Discontinuous mode on regular channels
    static constexpr uint32_t CR1_JAUTO = 0x400;        // Automatic injected group conversion
    static constexpr uint32_t CR1_AWDSGL = 0x200;       // Enable the watchdog on a single channel in scan mode
    static constexpr uint32_t CR1_SCAN = 0x100;         // Scan mode
    static constexpr uint32_t CR1_JEOCIE = 0x80;        // Interrupt enable for injected channels
    static constexpr uint32_t CR1_AWDIE = 0x40;         // Analog watchdog interrupt enable
    static constexpr uint32_t CR1_EOCIE = 0x20;         // Interrupt enable for EOC
    template<uint32_t X>
    static constexpr uint32_t CR1_AWDCH =               // Analog watchdog channel select bits (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CR2_SWSTART = 0x40000000; // Start conversion of regular channels
    template<uint32_t X>
    static constexpr uint32_t CR2_EXTEN =               // External trigger enable for regular channels (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR2_EXTSEL =              // External event select for regular group (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    static constexpr uint32_t CR2_JSWSTART = 0x400000;  // Start conversion of injected channels
    template<uint32_t X>
    static constexpr uint32_t CR2_JEXTEN =              // External trigger enable for injected channels (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR2_JEXTSEL =             // External event select for injected group (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    static constexpr uint32_t CR2_ALIGN = 0x800;        // Data alignment
    static constexpr uint32_t CR2_EOCS = 0x400;         // End of conversion selection
    static constexpr uint32_t CR2_DDS = 0x200;          // DMA disable selection (for single ADC mode)
    static constexpr uint32_t CR2_DMA = 0x100;          // Direct memory access mode (for single ADC mode)
    static constexpr uint32_t CR2_CONT = 0x2;           // Continuous conversion
    static constexpr uint32_t CR2_ADON = 0x1;           // A/D Converter ON / OFF
    static const uint32_t CR2_RESET_VALUE = 0x0;


    static const uint32_t SMPR1_RESET_VALUE = 0x0;


    static const uint32_t SMPR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t JOFR1_JOFFSET1 =            // Data offset for injected channel x (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t JOFR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t JOFR2_JOFFSET2 =            // Data offset for injected channel x (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t JOFR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t JOFR3_JOFFSET3 =            // Data offset for injected channel x (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t JOFR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t JOFR4_JOFFSET4 =            // Data offset for injected channel x (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t JOFR4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HTR_HT =                  // Analog watchdog higher threshold (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t HTR_RESET_VALUE = 0xfff;

    template<uint32_t X>
    static constexpr uint32_t LTR_LT =                  // Analog watchdog lower threshold (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t LTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SQR1_L =                   // Regular channel sequence length (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR1_SQ16 =                // 16th conversion in regular sequence (5 bits)
        bit_field_t<15, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR1_SQ15 =                // 15th conversion in regular sequence (5 bits)
        bit_field_t<10, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR1_SQ14 =                // 14th conversion in regular sequence (5 bits)
        bit_field_t<5, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR1_SQ13 =                // 13th conversion in regular sequence (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t SQR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SQR2_SQ12 =                // 12th conversion in regular sequence (5 bits)
        bit_field_t<25, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR2_SQ11 =                // 11th conversion in regular sequence (5 bits)
        bit_field_t<20, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR2_SQ10 =                // 10th conversion in regular sequence (5 bits)
        bit_field_t<15, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR2_SQ9 =                 // 9th conversion in regular sequence (5 bits)
        bit_field_t<10, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR2_SQ8 =                 // 8th conversion in regular sequence (5 bits)
        bit_field_t<5, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR2_SQ7 =                 // 7th conversion in regular sequence (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t SQR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SQR3_SQ6 =                 // 6th conversion in regular sequence (5 bits)
        bit_field_t<25, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR3_SQ5 =                 // 5th conversion in regular sequence (5 bits)
        bit_field_t<20, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR3_SQ4 =                 // 4th conversion in regular sequence (5 bits)
        bit_field_t<15, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR3_SQ3 =                 // 3rd conversion in regular sequence (5 bits)
        bit_field_t<10, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR3_SQ2 =                 // 2nd conversion in regular sequence (5 bits)
        bit_field_t<5, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SQR3_SQ1 =                 // 1st conversion in regular sequence (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t SQR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t JSQR_JL =                  // Injected sequence length (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t JSQR_JSQ4 =                // 4th conversion in injected sequence (5 bits)
        bit_field_t<15, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t JSQR_JSQ3 =                // 3rd conversion in injected sequence (5 bits)
        bit_field_t<10, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t JSQR_JSQ2 =                // 2nd conversion in injected sequence (5 bits)
        bit_field_t<5, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t JSQR_JSQ1 =                // 1st conversion in injected sequence (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t JSQR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t JDR1_JDATA =               // Injected data (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t JDR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t JDR2_JDATA =               // Injected data (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t JDR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t JDR3_JDATA =               // Injected data (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t JDR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t JDR4_JDATA =               // Injected data (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t JDR4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DR_DATA =                // Regular data (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DR_RESET_VALUE = 0x0;
};

static adc3_t& ADC3 = *reinterpret_cast<adc3_t*>(0x40012200);

#define HAVE_PERIPHERAL_ADC3


////
//
//    Digital-to-analog converter
//
////

struct dac_t
{
    volatile uint32_t    CR;                   // [Read-write] control register
    volatile uint32_t    SWTRIGR;              // [Write-only] software trigger register
    volatile uint32_t    DHR12R1;              // [Read-write] channel1 12-bit right-aligned data holding register
    volatile uint32_t    DHR12L1;              // [Read-write] channel1 12-bit left aligned data holding register
    volatile uint32_t    DHR8R1;               // [Read-write] channel1 8-bit right aligned data holding register
    volatile uint32_t    DHR12R2;              // [Read-write] channel2 12-bit right aligned data holding register
    volatile uint32_t    DHR12L2;              // [Read-write] channel2 12-bit left aligned data holding register
    volatile uint32_t    DHR8R2;               // [Read-write] channel2 8-bit right-aligned data holding register
    volatile uint32_t    DHR12RD;              // [Read-write] Dual DAC 12-bit right-aligned data holding register
    volatile uint32_t    DHR12LD;              // [Read-write] DUAL DAC 12-bit left aligned data holding register
    volatile uint32_t    DHR8RD;               // [Read-write] DUAL DAC 8-bit right aligned data holding register
    volatile uint32_t    DOR1;                 // [Read-only] channel1 data output register
    volatile uint32_t    DOR2;                 // [Read-only] channel2 data output register
    volatile uint32_t    SR;                   // [Read-write] status register

    static constexpr uint32_t CR_DMAUDRIE2 = 0x20000000;// DAC channel2 DMA underrun interrupt enable
    static constexpr uint32_t CR_DMAEN2 = 0x10000000;  // DAC channel2 DMA enable
    template<uint32_t X>
    static constexpr uint32_t CR_MAMP2 =               // DAC channel2 mask/amplitude selector (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR_WAVE2 =               // DAC channel2 noise/triangle wave generation enable (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR_TSEL2 =               // DAC channel2 trigger selection (3 bits)
        bit_field_t<19, 0x7>::value<X>();
    static constexpr uint32_t CR_TEN2 = 0x40000;       // DAC channel2 trigger enable
    static constexpr uint32_t CR_BOFF2 = 0x20000;      // DAC channel2 output buffer disable
    static constexpr uint32_t CR_EN2 = 0x10000;        // DAC channel2 enable
    static constexpr uint32_t CR_DMAUDRIE1 = 0x2000;   // DAC channel1 DMA Underrun Interrupt enable
    static constexpr uint32_t CR_DMAEN1 = 0x1000;      // DAC channel1 DMA enable
    template<uint32_t X>
    static constexpr uint32_t CR_MAMP1 =               // DAC channel1 mask/amplitude selector (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR_WAVE1 =               // DAC channel1 noise/triangle wave generation enable (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR_TSEL1 =               // DAC channel1 trigger selection (3 bits)
        bit_field_t<3, 0x7>::value<X>();
    static constexpr uint32_t CR_TEN1 = 0x4;           // DAC channel1 trigger enable
    static constexpr uint32_t CR_BOFF1 = 0x2;          // DAC channel1 output buffer disable
    static constexpr uint32_t CR_EN1 = 0x1;            // DAC channel1 enable
    static const uint32_t CR_RESET_VALUE = 0x0;

    static constexpr uint32_t SWTRIGR_SWTRIG2 = 0x2;        // DAC channel2 software trigger
    static constexpr uint32_t SWTRIGR_SWTRIG1 = 0x1;        // DAC channel1 software trigger
    static const uint32_t SWTRIGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DHR12R1_DACC1DHR =            // DAC channel1 12-bit right-aligned data (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t DHR12R1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DHR12L1_DACC1DHR =            // DAC channel1 12-bit left-aligned data (12 bits)
        bit_field_t<4, 0xfff>::value<X>();
    static const uint32_t DHR12L1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DHR8R1_DACC1DHR =            // DAC channel1 8-bit right-aligned data (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t DHR8R1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DHR12R2_DACC2DHR =            // DAC channel2 12-bit right-aligned data (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t DHR12R2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DHR12L2_DACC2DHR =            // DAC channel2 12-bit left-aligned data (12 bits)
        bit_field_t<4, 0xfff>::value<X>();
    static const uint32_t DHR12L2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DHR8R2_DACC2DHR =            // DAC channel2 8-bit right-aligned data (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t DHR8R2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DHR12RD_DACC2DHR =            // DAC channel2 12-bit right-aligned data (12 bits)
        bit_field_t<16, 0xfff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DHR12RD_DACC1DHR =            // DAC channel1 12-bit right-aligned data (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t DHR12RD_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DHR12LD_DACC2DHR =            // DAC channel2 12-bit left-aligned data (12 bits)
        bit_field_t<20, 0xfff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DHR12LD_DACC1DHR =            // DAC channel1 12-bit left-aligned data (12 bits)
        bit_field_t<4, 0xfff>::value<X>();
    static const uint32_t DHR12LD_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DHR8RD_DACC2DHR =            // DAC channel2 8-bit right-aligned data (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DHR8RD_DACC1DHR =            // DAC channel1 8-bit right-aligned data (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t DHR8RD_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOR1_DACC1DOR =            // DAC channel1 data output (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t DOR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOR2_DACC2DOR =            // DAC channel2 data output (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t DOR2_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_DMAUDR2 = 0x20000000; // DAC channel2 DMA underrun flag
    static constexpr uint32_t SR_DMAUDR1 = 0x2000;     // DAC channel1 DMA underrun flag
    static const uint32_t SR_RESET_VALUE = 0x0;
};

static dac_t& DAC = *reinterpret_cast<dac_t*>(0x40007400);

#define HAVE_PERIPHERAL_DAC


////
//
//    Power control
//
////

struct pwr_t
{
    volatile uint32_t    CR1;                  // [Read-write] power control register
    volatile uint32_t    CSR1;                 // power control/status register
    volatile uint32_t    CR2;                  // power control register
    volatile uint32_t    CSR2;                 // power control/status register

    static constexpr uint32_t CR1_LPDS = 0x1;           // Low-power deep sleep
    static constexpr uint32_t CR1_PDDS = 0x2;           // Power down deepsleep
    static constexpr uint32_t CR1_CSBF = 0x8;           // Clear standby flag
    static constexpr uint32_t CR1_PVDE = 0x10;          // Power voltage detector enable
    template<uint32_t X>
    static constexpr uint32_t CR1_PLS =                 // PVD level selection (3 bits)
        bit_field_t<5, 0x7>::value<X>();
    static constexpr uint32_t CR1_DBP = 0x100;          // Disable backup domain write protection
    static constexpr uint32_t CR1_FPDS = 0x200;         // Flash power down in Stop mode
    static constexpr uint32_t CR1_LPUDS = 0x400;        // Low-power regulator in deepsleep under-drive mode
    static constexpr uint32_t CR1_MRUDS = 0x800;        // Main regulator in deepsleep under-drive mode
    static constexpr uint32_t CR1_ADCDC1 = 0x2000;      // ADCDC1
    template<uint32_t X>
    static constexpr uint32_t CR1_VOS =                 // Regulator voltage scaling output selection (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t CR1_ODEN = 0x10000;       // Over-drive enable
    static constexpr uint32_t CR1_ODSWEN = 0x20000;     // Over-drive switching enabled
    template<uint32_t X>
    static constexpr uint32_t CR1_UDEN =                // Under-drive enable in stop mode (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    static const uint32_t CR1_RESET_VALUE = 0xc000;

    static constexpr uint32_t CSR1_WUIF = 0x1;           // Wakeup internal flag, Read-only
    static constexpr uint32_t CSR1_SBF = 0x2;            // Standby flag, Read-only
    static constexpr uint32_t CSR1_PVDO = 0x4;           // PVD output, Read-only
    static constexpr uint32_t CSR1_BRR = 0x8;            // Backup regulator ready, Read-only
    static constexpr uint32_t CSR1_BRE = 0x200;          // Backup regulator enable, Read-write
    static constexpr uint32_t CSR1_VOSRDY = 0x4000;      // Regulator voltage scaling output selection ready bit, Read-write
    static constexpr uint32_t CSR1_ODRDY = 0x10000;      // Over-drive mode ready, Read-write
    static constexpr uint32_t CSR1_ODSWRDY = 0x20000;    // Over-drive mode switching ready, Read-write
    template<uint32_t X>
    static constexpr uint32_t CSR1_UDRDY =               // Under-drive ready flag (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static const uint32_t CSR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CR2_CWUPF1 = 0x1;         // Clear Wakeup Pin flag for PA0, Read-only
    static constexpr uint32_t CR2_CWUPF2 = 0x2;         // Clear Wakeup Pin flag for PA2, Read-only
    static constexpr uint32_t CR2_CWUPF3 = 0x4;         // Clear Wakeup Pin flag for PC1, Read-only
    static constexpr uint32_t CR2_CWUPF4 = 0x8;         // Clear Wakeup Pin flag for PC13, Read-only
    static constexpr uint32_t CR2_CWUPF5 = 0x10;        // Clear Wakeup Pin flag for PI8, Read-only
    static constexpr uint32_t CR2_CWUPF6 = 0x20;        // Clear Wakeup Pin flag for PI11, Read-only
    static constexpr uint32_t CR2_WUPP1 = 0x100;        // Wakeup pin polarity bit for PA0, Read-write
    static constexpr uint32_t CR2_WUPP2 = 0x200;        // Wakeup pin polarity bit for PA2, Read-write
    static constexpr uint32_t CR2_WUPP3 = 0x400;        // Wakeup pin polarity bit for PC1, Read-write
    static constexpr uint32_t CR2_WUPP4 = 0x800;        // Wakeup pin polarity bit for PC13, Read-write
    static constexpr uint32_t CR2_WUPP5 = 0x1000;       // Wakeup pin polarity bit for PI8, Read-write
    static constexpr uint32_t CR2_WUPP6 = 0x2000;       // Wakeup pin polarity bit for PI11, Read-write
    static const uint32_t CR2_RESET_VALUE = 0x0;

    static constexpr uint32_t CSR2_WUPF1 = 0x1;          // Wakeup Pin flag for PA0, Read-only
    static constexpr uint32_t CSR2_WUPF2 = 0x2;          // Wakeup Pin flag for PA2, Read-only
    static constexpr uint32_t CSR2_WUPF3 = 0x4;          // Wakeup Pin flag for PC1, Read-only
    static constexpr uint32_t CSR2_WUPF4 = 0x8;          // Wakeup Pin flag for PC13, Read-only
    static constexpr uint32_t CSR2_WUPF5 = 0x10;         // Wakeup Pin flag for PI8, Read-only
    static constexpr uint32_t CSR2_WUPF6 = 0x20;         // Wakeup Pin flag for PI11, Read-only
    static constexpr uint32_t CSR2_EWUP1 = 0x100;        // Enable Wakeup pin for PA0, Read-write
    static constexpr uint32_t CSR2_EWUP2 = 0x200;        // Enable Wakeup pin for PA2, Read-write
    static constexpr uint32_t CSR2_EWUP3 = 0x400;        // Enable Wakeup pin for PC1, Read-write
    static constexpr uint32_t CSR2_EWUP4 = 0x800;        // Enable Wakeup pin for PC13, Read-write
    static constexpr uint32_t CSR2_EWUP5 = 0x1000;       // Enable Wakeup pin for PI8, Read-write
    static constexpr uint32_t CSR2_EWUP6 = 0x2000;       // Enable Wakeup pin for PI11, Read-write
    static const uint32_t CSR2_RESET_VALUE = 0x0;
};

static pwr_t& PWR = *reinterpret_cast<pwr_t*>(0x40007000);

#define HAVE_PERIPHERAL_PWR


////
//
//    Independent watchdog
//
////

struct iwdg_t
{
    volatile uint32_t    KR;                   // [Write-only] Key register
    volatile uint32_t    PR;                   // [Read-write] Prescaler register
    volatile uint32_t    RLR;                  // [Read-write] Reload register
    volatile uint32_t    SR;                   // [Read-only] Status register
    volatile uint32_t    WINR;                 // [Read-write] Window register

    template<uint32_t X>
    static constexpr uint32_t KR_KEY =                 // Key value (write only, read 0000h) (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t KR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PR_PR =                  // Prescaler divider (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t PR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RLR_RL =                  // Watchdog counter reload value (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t RLR_RESET_VALUE = 0xfff;

    static constexpr uint32_t SR_RVU = 0x2;            // Watchdog counter reload value update
    static constexpr uint32_t SR_PVU = 0x1;            // Watchdog prescaler value update
    static const uint32_t SR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t WINR_WIN =                 // Watchdog counter window value (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t WINR_RESET_VALUE = 0x0;
};

static iwdg_t& IWDG = *reinterpret_cast<iwdg_t*>(0x40003000);

#define HAVE_PERIPHERAL_IWDG


////
//
//    Window watchdog
//
////

struct wwdg_t
{
    volatile uint32_t    CR;                   // [Read-write] Control register
    volatile uint32_t    CFR;                  // [Read-write] Configuration register
    volatile uint32_t    SR;                   // [Read-write] Status register

    static constexpr uint32_t CR_WDGA = 0x80;          // Activation bit
    template<uint32_t X>
    static constexpr uint32_t CR_T =                   // 7-bit counter (MSB to LSB) (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    static const uint32_t CR_RESET_VALUE = 0x7f;

    static constexpr uint32_t CFR_EWI = 0x200;          // Early wakeup interrupt
    static constexpr uint32_t CFR_WDGTB1 = 0x100;       // Timer base
    static constexpr uint32_t CFR_WDGTB0 = 0x80;        // Timer base
    template<uint32_t X>
    static constexpr uint32_t CFR_W =                   // 7-bit window value (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    static const uint32_t CFR_RESET_VALUE = 0x7f;

    static constexpr uint32_t SR_EWIF = 0x1;           // Early wakeup interrupt flag
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint8_t WWDG = 0; // Window Watchdog interrupt
};

static wwdg_t& WWDG = *reinterpret_cast<wwdg_t*>(0x40002c00);

#define HAVE_PERIPHERAL_WWDG


////
//
//    Advanced-timers
//
////

struct tim1_t
{
    volatile uint32_t    CR1;                  // [Read-write] control register 1
    volatile uint32_t    CR2;                  // [Read-write] control register 2
    volatile uint32_t    SMCR;                 // [Read-write] slave mode control register
    volatile uint32_t    DIER;                 // [Read-write] DMA/Interrupt enable register
    volatile uint32_t    SR;                   // [Read-write] status register
    volatile uint32_t    EGR;                  // [Write-only] event generation register
    volatile uint32_t    CCMR1;                // [Read-write] capture/compare mode register 1 (output mode)
    volatile uint32_t    CCMR2;                // [Read-write] capture/compare mode register 2 (output mode)
    volatile uint32_t    CCER;                 // [Read-write] capture/compare enable register
    volatile uint32_t    CNT;                  // [Read-write] counter
    volatile uint32_t    PSC;                  // [Read-write] prescaler
    volatile uint32_t    ARR;                  // [Read-write] auto-reload register
    volatile uint32_t    RCR;                  // [Read-write] repetition counter register
    volatile uint32_t    CCR1;                 // [Read-write] capture/compare register 1
    volatile uint32_t    CCR2;                 // [Read-write] capture/compare register 2
    volatile uint32_t    CCR3;                 // [Read-write] capture/compare register 3
    volatile uint32_t    CCR4;                 // [Read-write] capture/compare register 4
    volatile uint32_t    BDTR;                 // [Read-write] break and dead-time register
    volatile uint32_t    DCR;                  // [Read-write] DMA control register
    volatile uint32_t    DMAR;                 // [Read-write] DMA address for full transfer
    reserved_t<1>        _0;
    volatile uint32_t    CCMR3_Output;         // [Read-write] capture/compare mode register 3 (output mode)
    volatile uint32_t    CCR5;                 // [Read-write] capture/compare register 5
    volatile uint32_t    CRR6;                 // [Read-write] capture/compare register 6
    volatile uint32_t    AF1;                  // [Read-write] alternate function option register 1
    volatile uint32_t    AF2;                  // [Read-write] alternate function option register 2

    template<uint32_t X>
    static constexpr uint32_t CR1_CKD =                 // Clock division (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t CR1_ARPE = 0x80;          // Auto-reload preload enable
    template<uint32_t X>
    static constexpr uint32_t CR1_CMS =                 // Center-aligned mode selection (2 bits)
        bit_field_t<5, 0x3>::value<X>();
    static constexpr uint32_t CR1_DIR = 0x10;           // Direction
    static constexpr uint32_t CR1_OPM = 0x8;            // One-pulse mode
    static constexpr uint32_t CR1_URS = 0x4;            // Update request source
    static constexpr uint32_t CR1_UDIS = 0x2;           // Update disable
    static constexpr uint32_t CR1_CEN = 0x1;            // Counter enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CR2_OIS4 = 0x4000;        // Output Idle state 4
    static constexpr uint32_t CR2_OIS3N = 0x2000;       // Output Idle state 3
    static constexpr uint32_t CR2_OIS3 = 0x1000;        // Output Idle state 3
    static constexpr uint32_t CR2_OIS2N = 0x800;        // Output Idle state 2
    static constexpr uint32_t CR2_OIS2 = 0x400;         // Output Idle state 2
    static constexpr uint32_t CR2_OIS1N = 0x200;        // Output Idle state 1
    static constexpr uint32_t CR2_OIS1 = 0x100;         // Output Idle state 1
    static constexpr uint32_t CR2_TI1S = 0x80;          // TI1 selection
    template<uint32_t X>
    static constexpr uint32_t CR2_MMS =                 // Master mode selection (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CR2_CCDS = 0x8;           // Capture/compare DMA selection
    static constexpr uint32_t CR2_CCUS = 0x4;           // Capture/compare control update selection
    static constexpr uint32_t CR2_CCPC = 0x1;           // Capture/compare preloaded control
    static const uint32_t CR2_RESET_VALUE = 0x0;

    static constexpr uint32_t SMCR_ETP = 0x8000;         // External trigger polarity
    static constexpr uint32_t SMCR_ECE = 0x4000;         // External clock enable
    template<uint32_t X>
    static constexpr uint32_t SMCR_ETPS =                // External trigger prescaler (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMCR_ETF =                 // External trigger filter (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    static constexpr uint32_t SMCR_MSM = 0x80;           // Master/Slave mode
    template<uint32_t X>
    static constexpr uint32_t SMCR_TS =                  // Trigger selection (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMCR_SMS =                 // Slave mode selection (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t SMCR_RESET_VALUE = 0x0;

    static constexpr uint32_t DIER_TDE = 0x4000;         // Trigger DMA request enable
    static constexpr uint32_t DIER_COMDE = 0x2000;       // COM DMA request enable
    static constexpr uint32_t DIER_CC4DE = 0x1000;       // Capture/Compare 4 DMA request enable
    static constexpr uint32_t DIER_CC3DE = 0x800;        // Capture/Compare 3 DMA request enable
    static constexpr uint32_t DIER_CC2DE = 0x400;        // Capture/Compare 2 DMA request enable
    static constexpr uint32_t DIER_CC1DE = 0x200;        // Capture/Compare 1 DMA request enable
    static constexpr uint32_t DIER_UDE = 0x100;          // Update DMA request enable
    static constexpr uint32_t DIER_TIE = 0x40;           // Trigger interrupt enable
    static constexpr uint32_t DIER_CC4IE = 0x10;         // Capture/Compare 4 interrupt enable
    static constexpr uint32_t DIER_CC3IE = 0x8;          // Capture/Compare 3 interrupt enable
    static constexpr uint32_t DIER_CC2IE = 0x4;          // Capture/Compare 2 interrupt enable
    static constexpr uint32_t DIER_CC1IE = 0x2;          // Capture/Compare 1 interrupt enable
    static constexpr uint32_t DIER_UIE = 0x1;            // Update interrupt enable
    static constexpr uint32_t DIER_BIE = 0x80;           // Break interrupt enable
    static constexpr uint32_t DIER_COMIE = 0x20;         // COM interrupt enable
    static const uint32_t DIER_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_CC4OF = 0x1000;       // Capture/Compare 4 overcapture flag
    static constexpr uint32_t SR_CC3OF = 0x800;        // Capture/Compare 3 overcapture flag
    static constexpr uint32_t SR_CC2OF = 0x400;        // Capture/compare 2 overcapture flag
    static constexpr uint32_t SR_CC1OF = 0x200;        // Capture/Compare 1 overcapture flag
    static constexpr uint32_t SR_BIF = 0x80;           // Break interrupt flag
    static constexpr uint32_t SR_TIF = 0x40;           // Trigger interrupt flag
    static constexpr uint32_t SR_COMIF = 0x20;         // COM interrupt flag
    static constexpr uint32_t SR_CC4IF = 0x10;         // Capture/Compare 4 interrupt flag
    static constexpr uint32_t SR_CC3IF = 0x8;          // Capture/Compare 3 interrupt flag
    static constexpr uint32_t SR_CC2IF = 0x4;          // Capture/Compare 2 interrupt flag
    static constexpr uint32_t SR_CC1IF = 0x2;          // Capture/compare 1 interrupt flag
    static constexpr uint32_t SR_UIF = 0x1;            // Update interrupt flag
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint32_t EGR_BG = 0x80;            // Break generation
    static constexpr uint32_t EGR_TG = 0x40;            // Trigger generation
    static constexpr uint32_t EGR_COMG = 0x20;          // Capture/Compare control update generation
    static constexpr uint32_t EGR_CC4G = 0x10;          // Capture/compare 4 generation
    static constexpr uint32_t EGR_CC3G = 0x8;           // Capture/compare 3 generation
    static constexpr uint32_t EGR_CC2G = 0x4;           // Capture/compare 2 generation
    static constexpr uint32_t EGR_CC1G = 0x2;           // Capture/compare 1 generation
    static constexpr uint32_t EGR_UG = 0x1;             // Update generation
    static const uint32_t EGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCMR1_CC1S =                // Capture/Compare 1 selection (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_CC2S =                // Capture/Compare 2 selection (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC1F =                // Input capture 1 filter (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC2F =                // Input capture 2 filter (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC2PCS =              // Input capture 2 prescaler (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_ICPCS =               // Input capture 1 prescaler (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t CCMR1_OC1CE = 0x80;         // Output Compare 1 clear enable
    static constexpr uint32_t CCMR1_OC1FE = 0x4;          // Output Compare 1 fast enable
    template<uint32_t X>
    static constexpr uint32_t CCMR1_OC1M =                // Output Compare 1 mode (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR1_OC1PE = 0x8;          // Output Compare 1 preload enable
    static constexpr uint32_t CCMR1_OC2CE = 0x8000;       // Output Compare 2 clear enable
    static constexpr uint32_t CCMR1_OC2FE = 0x400;        // Output Compare 2 fast enable
    template<uint32_t X>
    static constexpr uint32_t CCMR1_OC2M =                // Output Compare 2 mode (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    static constexpr uint32_t CCMR1_OC2PE = 0x800;        // Output Compare 2 preload enable
    static const uint32_t CCMR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCMR2_CC3S =                // Capture/Compare 3 selection (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_CC4S =                // Capture/Compare 4 selection (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC3F =                // Input capture 3 filter (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC3PSC =              // Input capture 3 prescaler (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC4F =                // Input capture 4 filter (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC4PSC =              // Input capture 4 prescaler (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    static constexpr uint32_t CCMR2_OC3CE = 0x80;         // Output compare 3 clear enable
    static constexpr uint32_t CCMR2_OC3FE = 0x4;          // Output compare 3 fast enable
    template<uint32_t X>
    static constexpr uint32_t CCMR2_OC3M =                // Output compare 3 mode (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR2_OC3PE = 0x8;          // Output compare 3 preload enable
    static constexpr uint32_t CCMR2_OC4CE = 0x8000;       // Output compare 4 clear enable
    static constexpr uint32_t CCMR2_OC4FE = 0x400;        // Output compare 4 fast enable
    template<uint32_t X>
    static constexpr uint32_t CCMR2_OC4M =                // Output compare 4 mode (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    static constexpr uint32_t CCMR2_OC4PE = 0x800;        // Output compare 4 preload enable
    static const uint32_t CCMR2_RESET_VALUE = 0x0;

    static constexpr uint32_t CCER_CC4P = 0x2000;        // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC4E = 0x1000;        // Capture/Compare 4 output enable
    static constexpr uint32_t CCER_CC3NP = 0x800;        // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC3NE = 0x400;        // Capture/Compare 3 complementary output enable
    static constexpr uint32_t CCER_CC3P = 0x200;         // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC3E = 0x100;         // Capture/Compare 3 output enable
    static constexpr uint32_t CCER_CC2NP = 0x80;         // Capture/Compare 2 output Polarity
    static constexpr uint32_t CCER_CC2NE = 0x40;         // Capture/Compare 2 complementary output enable
    static constexpr uint32_t CCER_CC2P = 0x20;          // Capture/Compare 2 output Polarity
    static constexpr uint32_t CCER_CC2E = 0x10;          // Capture/Compare 2 output enable
    static constexpr uint32_t CCER_CC1NP = 0x8;          // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1NE = 0x4;          // Capture/Compare 1 complementary output enable
    static constexpr uint32_t CCER_CC1P = 0x2;           // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1E = 0x1;           // Capture/Compare 1 output enable
    static const uint32_t CCER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CNT_CNT =                 // counter value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CNT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PSC_PSC =                 // Prescaler value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t PSC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ARR_ARR =                 // Auto-reload value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t ARR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RCR_REP =                 // Repetition counter value (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t RCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR1_CCR1 =                // Capture/Compare 1 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR2_CCR2 =                // Capture/Compare 2 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR3_CCR3 =                // Capture/Compare value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR4_CCR4 =                // Capture/Compare value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BDTR_DTG =                 // Dead-time generator setup (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BDTR_LOCK =                // Lock configuration (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t BDTR_OSSI = 0x400;         // Off-state selection for Idle mode
    static constexpr uint32_t BDTR_OSSR = 0x800;         // Off-state selection for Run mode
    static constexpr uint32_t BDTR_BKE = 0x1000;         // Break enable
    static constexpr uint32_t BDTR_BKP = 0x2000;         // Break polarity
    static constexpr uint32_t BDTR_AOE = 0x4000;         // Automatic output enable
    static constexpr uint32_t BDTR_MOE = 0x8000;         // Main output enable
    template<uint32_t X>
    static constexpr uint32_t BDTR_BKF =                 // Break filter (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BDTR_BK2F =                // Break 2 filter (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    static constexpr uint32_t BDTR_BK2E = 0x1000000;     // Break 2 enable
    static constexpr uint32_t BDTR_BK2P = 0x2000000;     // Break 2 polarity
    static const uint32_t BDTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DCR_DBL =                 // DMA burst length (5 bits)
        bit_field_t<8, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DCR_DBA =                 // DMA base address (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t DCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DMAR_DMAB =                // DMA register for burst accesses (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DMAR_RESET_VALUE = 0x0;

    static constexpr uint32_t CCMR3_Output_OC5FE = 0x4;          // Output compare 5 fast enable
    static constexpr uint32_t CCMR3_Output_OC5PE = 0x8;          // Output compare 5 preload enable
    template<uint32_t X>
    static constexpr uint32_t CCMR3_Output_OC5M =                // Output compare 5 mode (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR3_Output_OC5CE = 0x80;         // Output compare 5 clear enable
    static constexpr uint32_t CCMR3_Output_OC6FE = 0x400;        // Output compare 6 fast enable
    static constexpr uint32_t CCMR3_Output_OC6PE = 0x800;        // Output compare 6 preload enable
    template<uint32_t X>
    static constexpr uint32_t CCMR3_Output_OC6M =                // Output compare 6 mode (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    static constexpr uint32_t CCMR3_Output_OC6CE = 0x8000;       // Output compare 6 clear enable
    static constexpr uint32_t CCMR3_Output_OC5M3 = 0x10000;      // Output Compare 5 mode
    static constexpr uint32_t CCMR3_Output_OC6M3 = 0x1000000;    // Output Compare 6 mode
    static const uint32_t CCMR3_Output_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR5_CCR5 =                // Capture/Compare 5 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static constexpr uint32_t CCR5_GC5C1 = 0x20000000;   // Group Channel 5 and Channel 1
    static constexpr uint32_t CCR5_GC5C2 = 0x40000000;   // Group Channel 5 and Channel 2
    static constexpr uint32_t CCR5_GC5C3 = 0x80000000;   // Group Channel 5 and Channel 3
    static const uint32_t CCR5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CRR6_CCR6 =                // Capture/Compare 6 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CRR6_RESET_VALUE = 0x0;

    static constexpr uint32_t AF1_BKINE = 0x1;          // BRK BKIN input enable
    static constexpr uint32_t AF1_BKDFBKE = 0x100;      // BRK DFSDM_BREAK[0] enable
    static constexpr uint32_t AF1_BKINP = 0x200;        // BRK BKIN input polarity
    static const uint32_t AF1_RESET_VALUE = 0x0;

    static constexpr uint32_t AF2_BK2INE = 0x1;         // BRK2 BKIN input enable
    static constexpr uint32_t AF2_BK2DFBKE = 0x100;     // BRK2 DFSDM_BREAK enable
    static constexpr uint32_t AF2_BK2INP = 0x200;       // BRK2 BKIN2 input polarity
    static const uint32_t AF2_RESET_VALUE = 0x0;

    static constexpr uint8_t TIM1_BRK_TIM9 = 24; // TIM1 Break interrupt and TIM9 global interrupt
    static constexpr uint8_t TIM1_CC = 27; // TIM1 Capture Compare interrupt
    static constexpr uint8_t TIM1_TRG_COM_TIM11 = 26; // TIM1 Trigger and Commutation interrupts and TIM11 global interrupt
    static constexpr uint8_t TIM1_UP_TIM10 = 25; // TIM1 Update interrupt and TIM10
};

static tim1_t& TIM1 = *reinterpret_cast<tim1_t*>(0x40010000);

#define HAVE_PERIPHERAL_TIM1


////
//
//    Advanced-timers
//
////

struct tim8_t
{
    volatile uint32_t    CR1;                  // [Read-write] control register 1
    volatile uint32_t    CR2;                  // [Read-write] control register 2
    volatile uint32_t    SMCR;                 // [Read-write] slave mode control register
    volatile uint32_t    DIER;                 // [Read-write] DMA/Interrupt enable register
    volatile uint32_t    SR;                   // [Read-write] status register
    volatile uint32_t    EGR;                  // [Write-only] event generation register
    volatile uint32_t    CCMR1;                // [Read-write] capture/compare mode register 1 (output mode)
    volatile uint32_t    CCMR2;                // [Read-write] capture/compare mode register 2 (output mode)
    volatile uint32_t    CCER;                 // [Read-write] capture/compare enable register
    volatile uint32_t    CNT;                  // [Read-write] counter
    volatile uint32_t    PSC;                  // [Read-write] prescaler
    volatile uint32_t    ARR;                  // [Read-write] auto-reload register
    volatile uint32_t    RCR;                  // [Read-write] repetition counter register
    volatile uint32_t    CCR1;                 // [Read-write] capture/compare register 1
    volatile uint32_t    CCR2;                 // [Read-write] capture/compare register 2
    volatile uint32_t    CCR3;                 // [Read-write] capture/compare register 3
    volatile uint32_t    CCR4;                 // [Read-write] capture/compare register 4
    volatile uint32_t    BDTR;                 // [Read-write] break and dead-time register
    volatile uint32_t    DCR;                  // [Read-write] DMA control register
    volatile uint32_t    DMAR;                 // [Read-write] DMA address for full transfer
    reserved_t<1>        _0;
    volatile uint32_t    CCMR3_Output;         // [Read-write] capture/compare mode register 3 (output mode)
    volatile uint32_t    CCR5;                 // [Read-write] capture/compare register 5
    volatile uint32_t    CRR6;                 // [Read-write] capture/compare register 6
    volatile uint32_t    AF1;                  // [Read-write] alternate function option register 1
    volatile uint32_t    AF2;                  // [Read-write] alternate function option register 2

    template<uint32_t X>
    static constexpr uint32_t CR1_CKD =                 // Clock division (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t CR1_ARPE = 0x80;          // Auto-reload preload enable
    template<uint32_t X>
    static constexpr uint32_t CR1_CMS =                 // Center-aligned mode selection (2 bits)
        bit_field_t<5, 0x3>::value<X>();
    static constexpr uint32_t CR1_DIR = 0x10;           // Direction
    static constexpr uint32_t CR1_OPM = 0x8;            // One-pulse mode
    static constexpr uint32_t CR1_URS = 0x4;            // Update request source
    static constexpr uint32_t CR1_UDIS = 0x2;           // Update disable
    static constexpr uint32_t CR1_CEN = 0x1;            // Counter enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CR2_OIS4 = 0x4000;        // Output Idle state 4
    static constexpr uint32_t CR2_OIS3N = 0x2000;       // Output Idle state 3
    static constexpr uint32_t CR2_OIS3 = 0x1000;        // Output Idle state 3
    static constexpr uint32_t CR2_OIS2N = 0x800;        // Output Idle state 2
    static constexpr uint32_t CR2_OIS2 = 0x400;         // Output Idle state 2
    static constexpr uint32_t CR2_OIS1N = 0x200;        // Output Idle state 1
    static constexpr uint32_t CR2_OIS1 = 0x100;         // Output Idle state 1
    static constexpr uint32_t CR2_TI1S = 0x80;          // TI1 selection
    template<uint32_t X>
    static constexpr uint32_t CR2_MMS =                 // Master mode selection (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CR2_CCDS = 0x8;           // Capture/compare DMA selection
    static constexpr uint32_t CR2_CCUS = 0x4;           // Capture/compare control update selection
    static constexpr uint32_t CR2_CCPC = 0x1;           // Capture/compare preloaded control
    static const uint32_t CR2_RESET_VALUE = 0x0;

    static constexpr uint32_t SMCR_ETP = 0x8000;         // External trigger polarity
    static constexpr uint32_t SMCR_ECE = 0x4000;         // External clock enable
    template<uint32_t X>
    static constexpr uint32_t SMCR_ETPS =                // External trigger prescaler (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMCR_ETF =                 // External trigger filter (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    static constexpr uint32_t SMCR_MSM = 0x80;           // Master/Slave mode
    template<uint32_t X>
    static constexpr uint32_t SMCR_TS =                  // Trigger selection (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMCR_SMS =                 // Slave mode selection (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t SMCR_RESET_VALUE = 0x0;

    static constexpr uint32_t DIER_TDE = 0x4000;         // Trigger DMA request enable
    static constexpr uint32_t DIER_COMDE = 0x2000;       // COM DMA request enable
    static constexpr uint32_t DIER_CC4DE = 0x1000;       // Capture/Compare 4 DMA request enable
    static constexpr uint32_t DIER_CC3DE = 0x800;        // Capture/Compare 3 DMA request enable
    static constexpr uint32_t DIER_CC2DE = 0x400;        // Capture/Compare 2 DMA request enable
    static constexpr uint32_t DIER_CC1DE = 0x200;        // Capture/Compare 1 DMA request enable
    static constexpr uint32_t DIER_UDE = 0x100;          // Update DMA request enable
    static constexpr uint32_t DIER_TIE = 0x40;           // Trigger interrupt enable
    static constexpr uint32_t DIER_CC4IE = 0x10;         // Capture/Compare 4 interrupt enable
    static constexpr uint32_t DIER_CC3IE = 0x8;          // Capture/Compare 3 interrupt enable
    static constexpr uint32_t DIER_CC2IE = 0x4;          // Capture/Compare 2 interrupt enable
    static constexpr uint32_t DIER_CC1IE = 0x2;          // Capture/Compare 1 interrupt enable
    static constexpr uint32_t DIER_UIE = 0x1;            // Update interrupt enable
    static constexpr uint32_t DIER_BIE = 0x80;           // Break interrupt enable
    static constexpr uint32_t DIER_COMIE = 0x20;         // COM interrupt enable
    static const uint32_t DIER_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_CC4OF = 0x1000;       // Capture/Compare 4 overcapture flag
    static constexpr uint32_t SR_CC3OF = 0x800;        // Capture/Compare 3 overcapture flag
    static constexpr uint32_t SR_CC2OF = 0x400;        // Capture/compare 2 overcapture flag
    static constexpr uint32_t SR_CC1OF = 0x200;        // Capture/Compare 1 overcapture flag
    static constexpr uint32_t SR_BIF = 0x80;           // Break interrupt flag
    static constexpr uint32_t SR_TIF = 0x40;           // Trigger interrupt flag
    static constexpr uint32_t SR_COMIF = 0x20;         // COM interrupt flag
    static constexpr uint32_t SR_CC4IF = 0x10;         // Capture/Compare 4 interrupt flag
    static constexpr uint32_t SR_CC3IF = 0x8;          // Capture/Compare 3 interrupt flag
    static constexpr uint32_t SR_CC2IF = 0x4;          // Capture/Compare 2 interrupt flag
    static constexpr uint32_t SR_CC1IF = 0x2;          // Capture/compare 1 interrupt flag
    static constexpr uint32_t SR_UIF = 0x1;            // Update interrupt flag
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint32_t EGR_BG = 0x80;            // Break generation
    static constexpr uint32_t EGR_TG = 0x40;            // Trigger generation
    static constexpr uint32_t EGR_COMG = 0x20;          // Capture/Compare control update generation
    static constexpr uint32_t EGR_CC4G = 0x10;          // Capture/compare 4 generation
    static constexpr uint32_t EGR_CC3G = 0x8;           // Capture/compare 3 generation
    static constexpr uint32_t EGR_CC2G = 0x4;           // Capture/compare 2 generation
    static constexpr uint32_t EGR_CC1G = 0x2;           // Capture/compare 1 generation
    static constexpr uint32_t EGR_UG = 0x1;             // Update generation
    static const uint32_t EGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCMR1_CC1S =                // Capture/Compare 1 selection (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_CC2S =                // Capture/Compare 2 selection (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC1F =                // Input capture 1 filter (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC2F =                // Input capture 2 filter (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC2PCS =              // Input capture 2 prescaler (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_ICPCS =               // Input capture 1 prescaler (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t CCMR1_OC1CE = 0x80;         // Output Compare 1 clear enable
    static constexpr uint32_t CCMR1_OC1FE = 0x4;          // Output Compare 1 fast enable
    template<uint32_t X>
    static constexpr uint32_t CCMR1_OC1M =                // Output Compare 1 mode (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR1_OC1PE = 0x8;          // Output Compare 1 preload enable
    static constexpr uint32_t CCMR1_OC2CE = 0x8000;       // Output Compare 2 clear enable
    static constexpr uint32_t CCMR1_OC2FE = 0x400;        // Output Compare 2 fast enable
    template<uint32_t X>
    static constexpr uint32_t CCMR1_OC2M =                // Output Compare 2 mode (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    static constexpr uint32_t CCMR1_OC2PE = 0x800;        // Output Compare 2 preload enable
    static const uint32_t CCMR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCMR2_CC3S =                // Capture/Compare 3 selection (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_CC4S =                // Capture/Compare 4 selection (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC3F =                // Input capture 3 filter (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC3PSC =              // Input capture 3 prescaler (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC4F =                // Input capture 4 filter (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC4PSC =              // Input capture 4 prescaler (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    static constexpr uint32_t CCMR2_OC3CE = 0x80;         // Output compare 3 clear enable
    static constexpr uint32_t CCMR2_OC3FE = 0x4;          // Output compare 3 fast enable
    template<uint32_t X>
    static constexpr uint32_t CCMR2_OC3M =                // Output compare 3 mode (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR2_OC3PE = 0x8;          // Output compare 3 preload enable
    static constexpr uint32_t CCMR2_OC4CE = 0x8000;       // Output compare 4 clear enable
    static constexpr uint32_t CCMR2_OC4FE = 0x400;        // Output compare 4 fast enable
    template<uint32_t X>
    static constexpr uint32_t CCMR2_OC4M =                // Output compare 4 mode (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    static constexpr uint32_t CCMR2_OC4PE = 0x800;        // Output compare 4 preload enable
    static const uint32_t CCMR2_RESET_VALUE = 0x0;

    static constexpr uint32_t CCER_CC4P = 0x2000;        // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC4E = 0x1000;        // Capture/Compare 4 output enable
    static constexpr uint32_t CCER_CC3NP = 0x800;        // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC3NE = 0x400;        // Capture/Compare 3 complementary output enable
    static constexpr uint32_t CCER_CC3P = 0x200;         // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC3E = 0x100;         // Capture/Compare 3 output enable
    static constexpr uint32_t CCER_CC2NP = 0x80;         // Capture/Compare 2 output Polarity
    static constexpr uint32_t CCER_CC2NE = 0x40;         // Capture/Compare 2 complementary output enable
    static constexpr uint32_t CCER_CC2P = 0x20;          // Capture/Compare 2 output Polarity
    static constexpr uint32_t CCER_CC2E = 0x10;          // Capture/Compare 2 output enable
    static constexpr uint32_t CCER_CC1NP = 0x8;          // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1NE = 0x4;          // Capture/Compare 1 complementary output enable
    static constexpr uint32_t CCER_CC1P = 0x2;           // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1E = 0x1;           // Capture/Compare 1 output enable
    static const uint32_t CCER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CNT_CNT =                 // counter value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CNT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PSC_PSC =                 // Prescaler value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t PSC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ARR_ARR =                 // Auto-reload value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t ARR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RCR_REP =                 // Repetition counter value (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t RCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR1_CCR1 =                // Capture/Compare 1 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR2_CCR2 =                // Capture/Compare 2 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR3_CCR3 =                // Capture/Compare value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR4_CCR4 =                // Capture/Compare value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BDTR_DTG =                 // Dead-time generator setup (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BDTR_LOCK =                // Lock configuration (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t BDTR_OSSI = 0x400;         // Off-state selection for Idle mode
    static constexpr uint32_t BDTR_OSSR = 0x800;         // Off-state selection for Run mode
    static constexpr uint32_t BDTR_BKE = 0x1000;         // Break enable
    static constexpr uint32_t BDTR_BKP = 0x2000;         // Break polarity
    static constexpr uint32_t BDTR_AOE = 0x4000;         // Automatic output enable
    static constexpr uint32_t BDTR_MOE = 0x8000;         // Main output enable
    template<uint32_t X>
    static constexpr uint32_t BDTR_BKF =                 // Break filter (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BDTR_BK2F =                // Break 2 filter (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    static constexpr uint32_t BDTR_BK2E = 0x1000000;     // Break 2 enable
    static constexpr uint32_t BDTR_BK2P = 0x2000000;     // Break 2 polarity
    static const uint32_t BDTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DCR_DBL =                 // DMA burst length (5 bits)
        bit_field_t<8, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DCR_DBA =                 // DMA base address (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t DCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DMAR_DMAB =                // DMA register for burst accesses (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DMAR_RESET_VALUE = 0x0;

    static constexpr uint32_t CCMR3_Output_OC5FE = 0x4;          // Output compare 5 fast enable
    static constexpr uint32_t CCMR3_Output_OC5PE = 0x8;          // Output compare 5 preload enable
    template<uint32_t X>
    static constexpr uint32_t CCMR3_Output_OC5M =                // Output compare 5 mode (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR3_Output_OC5CE = 0x80;         // Output compare 5 clear enable
    static constexpr uint32_t CCMR3_Output_OC6FE = 0x400;        // Output compare 6 fast enable
    static constexpr uint32_t CCMR3_Output_OC6PE = 0x800;        // Output compare 6 preload enable
    template<uint32_t X>
    static constexpr uint32_t CCMR3_Output_OC6M =                // Output compare 6 mode (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    static constexpr uint32_t CCMR3_Output_OC6CE = 0x8000;       // Output compare 6 clear enable
    static constexpr uint32_t CCMR3_Output_OC5M3 = 0x10000;      // Output Compare 5 mode
    static constexpr uint32_t CCMR3_Output_OC6M3 = 0x1000000;    // Output Compare 6 mode
    static const uint32_t CCMR3_Output_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR5_CCR5 =                // Capture/Compare 5 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static constexpr uint32_t CCR5_GC5C1 = 0x20000000;   // Group Channel 5 and Channel 1
    static constexpr uint32_t CCR5_GC5C2 = 0x40000000;   // Group Channel 5 and Channel 2
    static constexpr uint32_t CCR5_GC5C3 = 0x80000000;   // Group Channel 5 and Channel 3
    static const uint32_t CCR5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CRR6_CCR6 =                // Capture/Compare 6 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CRR6_RESET_VALUE = 0x0;

    static constexpr uint32_t AF1_BKINE = 0x1;          // BRK BKIN input enable
    static constexpr uint32_t AF1_BKDFBKE = 0x100;      // BRK DFSDM_BREAK[0] enable
    static constexpr uint32_t AF1_BKINP = 0x200;        // BRK BKIN input polarity
    static const uint32_t AF1_RESET_VALUE = 0x0;

    static constexpr uint32_t AF2_BK2INE = 0x1;         // BRK2 BKIN input enable
    static constexpr uint32_t AF2_BK2DFBKE = 0x100;     // BRK2 DFSDM_BREAK enable
    static constexpr uint32_t AF2_BK2INP = 0x200;       // BRK2 BKIN2 input polarity
    static const uint32_t AF2_RESET_VALUE = 0x0;

    static constexpr uint8_t TIM8_BRK_TIM12 = 43; // TIM8 Break interrupt and TIM12 global interrupt
    static constexpr uint8_t TIM8_CC = 46; // TIM8 Capture Compare interrupt
    static constexpr uint8_t TIM8_TRG_COM_TIM14 = 45; // TIM8 Trigger and Commutation interrupts and TIM14 global interrupt
    static constexpr uint8_t TIM8_UP_TIM13 = 44; // TIM8 Update interrupt and TIM13 global interrupt
};

static tim8_t& TIM8 = *reinterpret_cast<tim8_t*>(0x40010400);

#define HAVE_PERIPHERAL_TIM8


////
//
//    General purpose timers
//
////

struct tim2_t
{
    volatile uint32_t    CR1;                  // [Read-write] control register 1
    volatile uint32_t    CR2;                  // [Read-write] control register 2
    volatile uint32_t    SMCR;                 // [Read-write] slave mode control register
    volatile uint32_t    DIER;                 // [Read-write] DMA/Interrupt enable register
    volatile uint32_t    SR;                   // [Read-write] status register
    volatile uint32_t    EGR;                  // [Write-only] event generation register
    volatile uint32_t    CCMR1;                // [Read-write] capture/compare mode register 1 (output mode)
    volatile uint32_t    CCMR2;                // [Read-write] capture/compare mode register 2 (output mode)
    volatile uint32_t    CCER;                 // [Read-write] capture/compare enable register
    volatile uint32_t    CNT;                  // [Read-write] counter
    volatile uint32_t    PSC;                  // [Read-write] prescaler
    volatile uint32_t    ARR;                  // [Read-write] auto-reload register
    reserved_t<1>        _0;
    volatile uint32_t    CCR1;                 // [Read-write] capture/compare register 1
    volatile uint32_t    CCR2;                 // [Read-write] capture/compare register 2
    volatile uint32_t    CCR3;                 // [Read-write] capture/compare register 3
    volatile uint32_t    CCR4;                 // [Read-write] capture/compare register 4
    reserved_t<1>        _1;
    volatile uint32_t    DCR;                  // [Read-write] DMA control register
    volatile uint32_t    DMAR;                 // [Read-write] DMA address for full transfer
    volatile uint32_t    OR1;                  // [Read-write] TIM2 option register 1
    reserved_t<3>        _2;
    volatile uint32_t    OR2;                  // [Read-write] TIM2 option register 2

    template<uint32_t X>
    static constexpr uint32_t CR1_CKD =                 // Clock division (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t CR1_ARPE = 0x80;          // Auto-reload preload enable
    template<uint32_t X>
    static constexpr uint32_t CR1_CMS =                 // Center-aligned mode selection (2 bits)
        bit_field_t<5, 0x3>::value<X>();
    static constexpr uint32_t CR1_DIR = 0x10;           // Direction
    static constexpr uint32_t CR1_OPM = 0x8;            // One-pulse mode
    static constexpr uint32_t CR1_URS = 0x4;            // Update request source
    static constexpr uint32_t CR1_UDIS = 0x2;           // Update disable
    static constexpr uint32_t CR1_CEN = 0x1;            // Counter enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CR2_TI1S = 0x80;          // TI1 selection
    template<uint32_t X>
    static constexpr uint32_t CR2_MMS =                 // Master mode selection (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CR2_CCDS = 0x8;           // Capture/compare DMA selection
    static const uint32_t CR2_RESET_VALUE = 0x0;

    static constexpr uint32_t SMCR_ETP = 0x8000;         // External trigger polarity
    static constexpr uint32_t SMCR_ECE = 0x4000;         // External clock enable
    template<uint32_t X>
    static constexpr uint32_t SMCR_ETPS =                // External trigger prescaler (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMCR_ETF =                 // External trigger filter (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    static constexpr uint32_t SMCR_MSM = 0x80;           // Master/Slave mode
    template<uint32_t X>
    static constexpr uint32_t SMCR_TS =                  // Trigger selection (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMCR_SMS =                 // Slave mode selection (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t SMCR_RESET_VALUE = 0x0;

    static constexpr uint32_t DIER_TDE = 0x4000;         // Trigger DMA request enable
    static constexpr uint32_t DIER_CC4DE = 0x1000;       // Capture/Compare 4 DMA request enable
    static constexpr uint32_t DIER_CC3DE = 0x800;        // Capture/Compare 3 DMA request enable
    static constexpr uint32_t DIER_CC2DE = 0x400;        // Capture/Compare 2 DMA request enable
    static constexpr uint32_t DIER_CC1DE = 0x200;        // Capture/Compare 1 DMA request enable
    static constexpr uint32_t DIER_UDE = 0x100;          // Update DMA request enable
    static constexpr uint32_t DIER_TIE = 0x40;           // Trigger interrupt enable
    static constexpr uint32_t DIER_CC4IE = 0x10;         // Capture/Compare 4 interrupt enable
    static constexpr uint32_t DIER_CC3IE = 0x8;          // Capture/Compare 3 interrupt enable
    static constexpr uint32_t DIER_CC2IE = 0x4;          // Capture/Compare 2 interrupt enable
    static constexpr uint32_t DIER_CC1IE = 0x2;          // Capture/Compare 1 interrupt enable
    static constexpr uint32_t DIER_UIE = 0x1;            // Update interrupt enable
    static const uint32_t DIER_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_CC4OF = 0x1000;       // Capture/Compare 4 overcapture flag
    static constexpr uint32_t SR_CC3OF = 0x800;        // Capture/Compare 3 overcapture flag
    static constexpr uint32_t SR_CC2OF = 0x400;        // Capture/compare 2 overcapture flag
    static constexpr uint32_t SR_CC1OF = 0x200;        // Capture/Compare 1 overcapture flag
    static constexpr uint32_t SR_TIF = 0x40;           // Trigger interrupt flag
    static constexpr uint32_t SR_CC4IF = 0x10;         // Capture/Compare 4 interrupt flag
    static constexpr uint32_t SR_CC3IF = 0x8;          // Capture/Compare 3 interrupt flag
    static constexpr uint32_t SR_CC2IF = 0x4;          // Capture/Compare 2 interrupt flag
    static constexpr uint32_t SR_CC1IF = 0x2;          // Capture/compare 1 interrupt flag
    static constexpr uint32_t SR_UIF = 0x1;            // Update interrupt flag
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint32_t EGR_TG = 0x40;            // Trigger generation
    static constexpr uint32_t EGR_CC4G = 0x10;          // Capture/compare 4 generation
    static constexpr uint32_t EGR_CC3G = 0x8;           // Capture/compare 3 generation
    static constexpr uint32_t EGR_CC2G = 0x4;           // Capture/compare 2 generation
    static constexpr uint32_t EGR_CC1G = 0x2;           // Capture/compare 1 generation
    static constexpr uint32_t EGR_UG = 0x1;             // Update generation
    static const uint32_t EGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCMR1_CC1S =                // CC1S (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_CC2S =                // CC2S (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC1F =                // Input capture 1 filter (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC2F =                // Input capture 2 filter (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC2PCS =              // Input capture 2 prescaler (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_ICPCS =               // Input capture 1 prescaler (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t CCMR1_OC1CE = 0x80;         // OC1CE
    static constexpr uint32_t CCMR1_OC1FE = 0x4;          // OC1FE
    template<uint32_t X>
    static constexpr uint32_t CCMR1_OC1M =                // OC1M (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR1_OC1PE = 0x8;          // OC1PE
    static constexpr uint32_t CCMR1_OC2CE = 0x8000;       // OC2CE
    static constexpr uint32_t CCMR1_OC2FE = 0x400;        // OC2FE
    template<uint32_t X>
    static constexpr uint32_t CCMR1_OC2M =                // OC2M (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    static constexpr uint32_t CCMR1_OC2PE = 0x800;        // OC2PE
    static const uint32_t CCMR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCMR2_CC3S =                // CC3S (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_CC4S =                // CC4S (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC3F =                // Input capture 3 filter (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC3PSC =              // Input capture 3 prescaler (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC4F =                // Input capture 4 filter (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC4PSC =              // Input capture 4 prescaler (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    static constexpr uint32_t CCMR2_O24CE = 0x8000;       // O24CE
    static constexpr uint32_t CCMR2_OC3CE = 0x80;         // OC3CE
    static constexpr uint32_t CCMR2_OC3FE = 0x4;          // OC3FE
    template<uint32_t X>
    static constexpr uint32_t CCMR2_OC3M =                // OC3M (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR2_OC3PE = 0x8;          // OC3PE
    static constexpr uint32_t CCMR2_OC4FE = 0x400;        // OC4FE
    template<uint32_t X>
    static constexpr uint32_t CCMR2_OC4M =                // OC4M (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    static constexpr uint32_t CCMR2_OC4PE = 0x800;        // OC4PE
    static const uint32_t CCMR2_RESET_VALUE = 0x0;

    static constexpr uint32_t CCER_CC4NP = 0x8000;       // Capture/Compare 4 output Polarity
    static constexpr uint32_t CCER_CC4P = 0x2000;        // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC4E = 0x1000;        // Capture/Compare 4 output enable
    static constexpr uint32_t CCER_CC3NP = 0x800;        // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC3P = 0x200;         // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC3E = 0x100;         // Capture/Compare 3 output enable
    static constexpr uint32_t CCER_CC2NP = 0x80;         // Capture/Compare 2 output Polarity
    static constexpr uint32_t CCER_CC2P = 0x20;          // Capture/Compare 2 output Polarity
    static constexpr uint32_t CCER_CC2E = 0x10;          // Capture/Compare 2 output enable
    static constexpr uint32_t CCER_CC1NP = 0x8;          // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1P = 0x2;           // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1E = 0x1;           // Capture/Compare 1 output enable
    static const uint32_t CCER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CNT_CNT_H =               // High counter value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CNT_CNT_L =               // Low counter value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CNT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PSC_PSC =                 // Prescaler value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t PSC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ARR_ARR_H =               // High Auto-reload value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ARR_ARR_L =               // Low Auto-reload value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t ARR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR1_CCR1_H =              // High Capture/Compare 1 value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR1_CCR1_L =              // Low Capture/Compare 1 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR2_CCR2_H =              // High Capture/Compare 2 value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR2_CCR2_L =              // Low Capture/Compare 2 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR3_CCR3_H =              // High Capture/Compare value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR3_CCR3_L =              // Low Capture/Compare value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR4_CCR4_H =              // High Capture/Compare value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR4_CCR4_L =              // Low Capture/Compare value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DCR_DBL =                 // DMA burst length (5 bits)
        bit_field_t<8, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DCR_DBA =                 // DMA base address (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t DCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DMAR_DMAB =                // DMA register for burst accesses (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DMAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OR1_TI4_RMP =             // Input Capture 4 remap (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t OR1_ETR1_RMP = 0x2;       // External trigger remap
    static constexpr uint32_t OR1_ITR1_RMP = 0x1;       // Internal trigger 1 remap
    static const uint32_t OR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OR2_ETRSEL =              // ETR source selection (3 bits)
        bit_field_t<14, 0x7>::value<X>();
    static const uint32_t OR2_RESET_VALUE = 0x0;

    static constexpr uint8_t TIM2 = 28; // TIM2 global interrupt
};

static tim2_t& TIM2 = *reinterpret_cast<tim2_t*>(0x40000000);

#define HAVE_PERIPHERAL_TIM2


////
//
//    General purpose timers
//
////

struct tim3_t
{
    volatile uint32_t    CR1;                  // [Read-write] control register 1
    volatile uint32_t    CR2;                  // [Read-write] control register 2
    volatile uint32_t    SMCR;                 // [Read-write] slave mode control register
    volatile uint32_t    DIER;                 // [Read-write] DMA/Interrupt enable register
    volatile uint32_t    SR;                   // [Read-write] status register
    volatile uint32_t    EGR;                  // [Write-only] event generation register
    volatile uint32_t    CCMR1;                // [Read-write] capture/compare mode register 1 (output mode)
    volatile uint32_t    CCMR2;                // [Read-write] capture/compare mode register 2 (output mode)
    volatile uint32_t    CCER;                 // [Read-write] capture/compare enable register
    volatile uint32_t    CNT;                  // [Read-write] counter
    volatile uint32_t    PSC;                  // [Read-write] prescaler
    volatile uint32_t    ARR;                  // [Read-write] auto-reload register
    reserved_t<1>        _0;
    volatile uint32_t    CCR1;                 // [Read-write] capture/compare register 1
    volatile uint32_t    CCR2;                 // [Read-write] capture/compare register 2
    volatile uint32_t    CCR3;                 // [Read-write] capture/compare register 3
    volatile uint32_t    CCR4;                 // [Read-write] capture/compare register 4
    reserved_t<1>        _1;
    volatile uint32_t    DCR;                  // [Read-write] DMA control register
    volatile uint32_t    DMAR;                 // [Read-write] DMA address for full transfer
    volatile uint32_t    OR1;                  // [Read-write] TIM3 option register 1
    reserved_t<3>        _2;
    volatile uint32_t    OR2;                  // [Read-write] TIM3 option register 2

    template<uint32_t X>
    static constexpr uint32_t CR1_CKD =                 // Clock division (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t CR1_ARPE = 0x80;          // Auto-reload preload enable
    template<uint32_t X>
    static constexpr uint32_t CR1_CMS =                 // Center-aligned mode selection (2 bits)
        bit_field_t<5, 0x3>::value<X>();
    static constexpr uint32_t CR1_DIR = 0x10;           // Direction
    static constexpr uint32_t CR1_OPM = 0x8;            // One-pulse mode
    static constexpr uint32_t CR1_URS = 0x4;            // Update request source
    static constexpr uint32_t CR1_UDIS = 0x2;           // Update disable
    static constexpr uint32_t CR1_CEN = 0x1;            // Counter enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CR2_TI1S = 0x80;          // TI1 selection
    template<uint32_t X>
    static constexpr uint32_t CR2_MMS =                 // Master mode selection (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CR2_CCDS = 0x8;           // Capture/compare DMA selection
    static const uint32_t CR2_RESET_VALUE = 0x0;

    static constexpr uint32_t SMCR_ETP = 0x8000;         // External trigger polarity
    static constexpr uint32_t SMCR_ECE = 0x4000;         // External clock enable
    template<uint32_t X>
    static constexpr uint32_t SMCR_ETPS =                // External trigger prescaler (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMCR_ETF =                 // External trigger filter (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    static constexpr uint32_t SMCR_MSM = 0x80;           // Master/Slave mode
    template<uint32_t X>
    static constexpr uint32_t SMCR_TS =                  // Trigger selection (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMCR_SMS =                 // Slave mode selection (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t SMCR_RESET_VALUE = 0x0;

    static constexpr uint32_t DIER_TDE = 0x4000;         // Trigger DMA request enable
    static constexpr uint32_t DIER_CC4DE = 0x1000;       // Capture/Compare 4 DMA request enable
    static constexpr uint32_t DIER_CC3DE = 0x800;        // Capture/Compare 3 DMA request enable
    static constexpr uint32_t DIER_CC2DE = 0x400;        // Capture/Compare 2 DMA request enable
    static constexpr uint32_t DIER_CC1DE = 0x200;        // Capture/Compare 1 DMA request enable
    static constexpr uint32_t DIER_UDE = 0x100;          // Update DMA request enable
    static constexpr uint32_t DIER_TIE = 0x40;           // Trigger interrupt enable
    static constexpr uint32_t DIER_CC4IE = 0x10;         // Capture/Compare 4 interrupt enable
    static constexpr uint32_t DIER_CC3IE = 0x8;          // Capture/Compare 3 interrupt enable
    static constexpr uint32_t DIER_CC2IE = 0x4;          // Capture/Compare 2 interrupt enable
    static constexpr uint32_t DIER_CC1IE = 0x2;          // Capture/Compare 1 interrupt enable
    static constexpr uint32_t DIER_UIE = 0x1;            // Update interrupt enable
    static const uint32_t DIER_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_CC4OF = 0x1000;       // Capture/Compare 4 overcapture flag
    static constexpr uint32_t SR_CC3OF = 0x800;        // Capture/Compare 3 overcapture flag
    static constexpr uint32_t SR_CC2OF = 0x400;        // Capture/compare 2 overcapture flag
    static constexpr uint32_t SR_CC1OF = 0x200;        // Capture/Compare 1 overcapture flag
    static constexpr uint32_t SR_TIF = 0x40;           // Trigger interrupt flag
    static constexpr uint32_t SR_CC4IF = 0x10;         // Capture/Compare 4 interrupt flag
    static constexpr uint32_t SR_CC3IF = 0x8;          // Capture/Compare 3 interrupt flag
    static constexpr uint32_t SR_CC2IF = 0x4;          // Capture/Compare 2 interrupt flag
    static constexpr uint32_t SR_CC1IF = 0x2;          // Capture/compare 1 interrupt flag
    static constexpr uint32_t SR_UIF = 0x1;            // Update interrupt flag
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint32_t EGR_TG = 0x40;            // Trigger generation
    static constexpr uint32_t EGR_CC4G = 0x10;          // Capture/compare 4 generation
    static constexpr uint32_t EGR_CC3G = 0x8;           // Capture/compare 3 generation
    static constexpr uint32_t EGR_CC2G = 0x4;           // Capture/compare 2 generation
    static constexpr uint32_t EGR_CC1G = 0x2;           // Capture/compare 1 generation
    static constexpr uint32_t EGR_UG = 0x1;             // Update generation
    static const uint32_t EGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCMR1_CC1S =                // CC1S (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_CC2S =                // CC2S (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC1F =                // Input capture 1 filter (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC2F =                // Input capture 2 filter (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC2PCS =              // Input capture 2 prescaler (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_ICPCS =               // Input capture 1 prescaler (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t CCMR1_OC1CE = 0x80;         // OC1CE
    static constexpr uint32_t CCMR1_OC1FE = 0x4;          // OC1FE
    template<uint32_t X>
    static constexpr uint32_t CCMR1_OC1M =                // OC1M (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR1_OC1PE = 0x8;          // OC1PE
    static constexpr uint32_t CCMR1_OC2CE = 0x8000;       // OC2CE
    static constexpr uint32_t CCMR1_OC2FE = 0x400;        // OC2FE
    template<uint32_t X>
    static constexpr uint32_t CCMR1_OC2M =                // OC2M (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    static constexpr uint32_t CCMR1_OC2PE = 0x800;        // OC2PE
    static const uint32_t CCMR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCMR2_CC3S =                // CC3S (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_CC4S =                // CC4S (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC3F =                // Input capture 3 filter (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC3PSC =              // Input capture 3 prescaler (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC4F =                // Input capture 4 filter (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC4PSC =              // Input capture 4 prescaler (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    static constexpr uint32_t CCMR2_O24CE = 0x8000;       // O24CE
    static constexpr uint32_t CCMR2_OC3CE = 0x80;         // OC3CE
    static constexpr uint32_t CCMR2_OC3FE = 0x4;          // OC3FE
    template<uint32_t X>
    static constexpr uint32_t CCMR2_OC3M =                // OC3M (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR2_OC3PE = 0x8;          // OC3PE
    static constexpr uint32_t CCMR2_OC4FE = 0x400;        // OC4FE
    template<uint32_t X>
    static constexpr uint32_t CCMR2_OC4M =                // OC4M (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    static constexpr uint32_t CCMR2_OC4PE = 0x800;        // OC4PE
    static const uint32_t CCMR2_RESET_VALUE = 0x0;

    static constexpr uint32_t CCER_CC4NP = 0x8000;       // Capture/Compare 4 output Polarity
    static constexpr uint32_t CCER_CC4P = 0x2000;        // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC4E = 0x1000;        // Capture/Compare 4 output enable
    static constexpr uint32_t CCER_CC3NP = 0x800;        // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC3P = 0x200;         // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC3E = 0x100;         // Capture/Compare 3 output enable
    static constexpr uint32_t CCER_CC2NP = 0x80;         // Capture/Compare 2 output Polarity
    static constexpr uint32_t CCER_CC2P = 0x20;          // Capture/Compare 2 output Polarity
    static constexpr uint32_t CCER_CC2E = 0x10;          // Capture/Compare 2 output enable
    static constexpr uint32_t CCER_CC1NP = 0x8;          // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1P = 0x2;           // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1E = 0x1;           // Capture/Compare 1 output enable
    static const uint32_t CCER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CNT_CNT_H =               // High counter value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CNT_CNT_L =               // Low counter value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CNT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PSC_PSC =                 // Prescaler value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t PSC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ARR_ARR_H =               // High Auto-reload value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ARR_ARR_L =               // Low Auto-reload value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t ARR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR1_CCR1_H =              // High Capture/Compare 1 value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR1_CCR1_L =              // Low Capture/Compare 1 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR2_CCR2_H =              // High Capture/Compare 2 value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR2_CCR2_L =              // Low Capture/Compare 2 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR3_CCR3_H =              // High Capture/Compare value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR3_CCR3_L =              // Low Capture/Compare value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR4_CCR4_H =              // High Capture/Compare value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR4_CCR4_L =              // Low Capture/Compare value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DCR_DBL =                 // DMA burst length (5 bits)
        bit_field_t<8, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DCR_DBA =                 // DMA base address (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t DCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DMAR_DMAB =                // DMA register for burst accesses (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DMAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OR1_TI1_RMP =             // Input Capture 1 remap (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t OR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OR2_ETRSEL =              // ETR source selection (3 bits)
        bit_field_t<14, 0x7>::value<X>();
    static const uint32_t OR2_RESET_VALUE = 0x0;

    static constexpr uint8_t TIM3 = 29; // TIM3 global interrupt
};

static tim3_t& TIM3 = *reinterpret_cast<tim3_t*>(0x40000400);

#define HAVE_PERIPHERAL_TIM3


////
//
//    General purpose timers
//
////

struct tim4_t
{
    volatile uint32_t    CR1;                  // [Read-write] control register 1
    volatile uint32_t    CR2;                  // [Read-write] control register 2
    volatile uint32_t    SMCR;                 // [Read-write] slave mode control register
    volatile uint32_t    DIER;                 // [Read-write] DMA/Interrupt enable register
    volatile uint32_t    SR;                   // [Read-write] status register
    volatile uint32_t    EGR;                  // [Write-only] event generation register
    volatile uint32_t    CCMR1;                // [Read-write] capture/compare mode register 1 (output mode)
    volatile uint32_t    CCMR2;                // [Read-write] capture/compare mode register 2 (output mode)
    volatile uint32_t    CCER;                 // [Read-write] capture/compare enable register
    volatile uint32_t    CNT;                  // [Read-write] counter
    volatile uint32_t    PSC;                  // [Read-write] prescaler
    volatile uint32_t    ARR;                  // [Read-write] auto-reload register
    reserved_t<1>        _0;
    volatile uint32_t    CCR1;                 // [Read-write] capture/compare register 1
    volatile uint32_t    CCR2;                 // [Read-write] capture/compare register 2
    volatile uint32_t    CCR3;                 // [Read-write] capture/compare register 3
    volatile uint32_t    CCR4;                 // [Read-write] capture/compare register 4
    reserved_t<1>        _1;
    volatile uint32_t    DCR;                  // [Read-write] DMA control register
    volatile uint32_t    DMAR;                 // [Read-write] DMA address for full transfer

    template<uint32_t X>
    static constexpr uint32_t CR1_CKD =                 // Clock division (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t CR1_ARPE = 0x80;          // Auto-reload preload enable
    template<uint32_t X>
    static constexpr uint32_t CR1_CMS =                 // Center-aligned mode selection (2 bits)
        bit_field_t<5, 0x3>::value<X>();
    static constexpr uint32_t CR1_DIR = 0x10;           // Direction
    static constexpr uint32_t CR1_OPM = 0x8;            // One-pulse mode
    static constexpr uint32_t CR1_URS = 0x4;            // Update request source
    static constexpr uint32_t CR1_UDIS = 0x2;           // Update disable
    static constexpr uint32_t CR1_CEN = 0x1;            // Counter enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CR2_TI1S = 0x80;          // TI1 selection
    template<uint32_t X>
    static constexpr uint32_t CR2_MMS =                 // Master mode selection (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CR2_CCDS = 0x8;           // Capture/compare DMA selection
    static const uint32_t CR2_RESET_VALUE = 0x0;

    static constexpr uint32_t SMCR_ETP = 0x8000;         // External trigger polarity
    static constexpr uint32_t SMCR_ECE = 0x4000;         // External clock enable
    template<uint32_t X>
    static constexpr uint32_t SMCR_ETPS =                // External trigger prescaler (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMCR_ETF =                 // External trigger filter (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    static constexpr uint32_t SMCR_MSM = 0x80;           // Master/Slave mode
    template<uint32_t X>
    static constexpr uint32_t SMCR_TS =                  // Trigger selection (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMCR_SMS =                 // Slave mode selection (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t SMCR_RESET_VALUE = 0x0;

    static constexpr uint32_t DIER_TDE = 0x4000;         // Trigger DMA request enable
    static constexpr uint32_t DIER_CC4DE = 0x1000;       // Capture/Compare 4 DMA request enable
    static constexpr uint32_t DIER_CC3DE = 0x800;        // Capture/Compare 3 DMA request enable
    static constexpr uint32_t DIER_CC2DE = 0x400;        // Capture/Compare 2 DMA request enable
    static constexpr uint32_t DIER_CC1DE = 0x200;        // Capture/Compare 1 DMA request enable
    static constexpr uint32_t DIER_UDE = 0x100;          // Update DMA request enable
    static constexpr uint32_t DIER_TIE = 0x40;           // Trigger interrupt enable
    static constexpr uint32_t DIER_CC4IE = 0x10;         // Capture/Compare 4 interrupt enable
    static constexpr uint32_t DIER_CC3IE = 0x8;          // Capture/Compare 3 interrupt enable
    static constexpr uint32_t DIER_CC2IE = 0x4;          // Capture/Compare 2 interrupt enable
    static constexpr uint32_t DIER_CC1IE = 0x2;          // Capture/Compare 1 interrupt enable
    static constexpr uint32_t DIER_UIE = 0x1;            // Update interrupt enable
    static const uint32_t DIER_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_CC4OF = 0x1000;       // Capture/Compare 4 overcapture flag
    static constexpr uint32_t SR_CC3OF = 0x800;        // Capture/Compare 3 overcapture flag
    static constexpr uint32_t SR_CC2OF = 0x400;        // Capture/compare 2 overcapture flag
    static constexpr uint32_t SR_CC1OF = 0x200;        // Capture/Compare 1 overcapture flag
    static constexpr uint32_t SR_TIF = 0x40;           // Trigger interrupt flag
    static constexpr uint32_t SR_CC4IF = 0x10;         // Capture/Compare 4 interrupt flag
    static constexpr uint32_t SR_CC3IF = 0x8;          // Capture/Compare 3 interrupt flag
    static constexpr uint32_t SR_CC2IF = 0x4;          // Capture/Compare 2 interrupt flag
    static constexpr uint32_t SR_CC1IF = 0x2;          // Capture/compare 1 interrupt flag
    static constexpr uint32_t SR_UIF = 0x1;            // Update interrupt flag
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint32_t EGR_TG = 0x40;            // Trigger generation
    static constexpr uint32_t EGR_CC4G = 0x10;          // Capture/compare 4 generation
    static constexpr uint32_t EGR_CC3G = 0x8;           // Capture/compare 3 generation
    static constexpr uint32_t EGR_CC2G = 0x4;           // Capture/compare 2 generation
    static constexpr uint32_t EGR_CC1G = 0x2;           // Capture/compare 1 generation
    static constexpr uint32_t EGR_UG = 0x1;             // Update generation
    static const uint32_t EGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCMR1_CC1S =                // CC1S (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_CC2S =                // CC2S (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC1F =                // Input capture 1 filter (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC2F =                // Input capture 2 filter (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC2PCS =              // Input capture 2 prescaler (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_ICPCS =               // Input capture 1 prescaler (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t CCMR1_OC1CE = 0x80;         // OC1CE
    static constexpr uint32_t CCMR1_OC1FE = 0x4;          // OC1FE
    template<uint32_t X>
    static constexpr uint32_t CCMR1_OC1M =                // OC1M (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR1_OC1PE = 0x8;          // OC1PE
    static constexpr uint32_t CCMR1_OC2CE = 0x8000;       // OC2CE
    static constexpr uint32_t CCMR1_OC2FE = 0x400;        // OC2FE
    template<uint32_t X>
    static constexpr uint32_t CCMR1_OC2M =                // OC2M (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    static constexpr uint32_t CCMR1_OC2PE = 0x800;        // OC2PE
    static const uint32_t CCMR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCMR2_CC3S =                // CC3S (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_CC4S =                // CC4S (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC3F =                // Input capture 3 filter (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC3PSC =              // Input capture 3 prescaler (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC4F =                // Input capture 4 filter (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC4PSC =              // Input capture 4 prescaler (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    static constexpr uint32_t CCMR2_O24CE = 0x8000;       // O24CE
    static constexpr uint32_t CCMR2_OC3CE = 0x80;         // OC3CE
    static constexpr uint32_t CCMR2_OC3FE = 0x4;          // OC3FE
    template<uint32_t X>
    static constexpr uint32_t CCMR2_OC3M =                // OC3M (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR2_OC3PE = 0x8;          // OC3PE
    static constexpr uint32_t CCMR2_OC4FE = 0x400;        // OC4FE
    template<uint32_t X>
    static constexpr uint32_t CCMR2_OC4M =                // OC4M (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    static constexpr uint32_t CCMR2_OC4PE = 0x800;        // OC4PE
    static const uint32_t CCMR2_RESET_VALUE = 0x0;

    static constexpr uint32_t CCER_CC4NP = 0x8000;       // Capture/Compare 4 output Polarity
    static constexpr uint32_t CCER_CC4P = 0x2000;        // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC4E = 0x1000;        // Capture/Compare 4 output enable
    static constexpr uint32_t CCER_CC3NP = 0x800;        // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC3P = 0x200;         // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC3E = 0x100;         // Capture/Compare 3 output enable
    static constexpr uint32_t CCER_CC2NP = 0x80;         // Capture/Compare 2 output Polarity
    static constexpr uint32_t CCER_CC2P = 0x20;          // Capture/Compare 2 output Polarity
    static constexpr uint32_t CCER_CC2E = 0x10;          // Capture/Compare 2 output enable
    static constexpr uint32_t CCER_CC1NP = 0x8;          // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1P = 0x2;           // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1E = 0x1;           // Capture/Compare 1 output enable
    static const uint32_t CCER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CNT_CNT_H =               // High counter value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CNT_CNT_L =               // Low counter value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CNT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PSC_PSC =                 // Prescaler value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t PSC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ARR_ARR_H =               // High Auto-reload value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ARR_ARR_L =               // Low Auto-reload value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t ARR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR1_CCR1_H =              // High Capture/Compare 1 value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR1_CCR1_L =              // Low Capture/Compare 1 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR2_CCR2_H =              // High Capture/Compare 2 value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR2_CCR2_L =              // Low Capture/Compare 2 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR3_CCR3_H =              // High Capture/Compare value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR3_CCR3_L =              // Low Capture/Compare value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR4_CCR4_H =              // High Capture/Compare value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR4_CCR4_L =              // Low Capture/Compare value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DCR_DBL =                 // DMA burst length (5 bits)
        bit_field_t<8, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DCR_DBA =                 // DMA base address (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t DCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DMAR_DMAB =                // DMA register for burst accesses (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DMAR_RESET_VALUE = 0x0;

    static constexpr uint8_t TIM4 = 30; // TIM4 global interrupt
};

static tim4_t& TIM4 = *reinterpret_cast<tim4_t*>(0x40000800);

#define HAVE_PERIPHERAL_TIM4


////
//
//    General purpose timers
//
////

struct tim5_t
{
    volatile uint32_t    CR1;                  // [Read-write] control register 1
    volatile uint32_t    CR2;                  // [Read-write] control register 2
    volatile uint32_t    SMCR;                 // [Read-write] slave mode control register
    volatile uint32_t    DIER;                 // [Read-write] DMA/Interrupt enable register
    volatile uint32_t    SR;                   // [Read-write] status register
    volatile uint32_t    EGR;                  // [Write-only] event generation register
    volatile uint32_t    CCMR1;                // [Read-write] capture/compare mode register 1 (output mode)
    volatile uint32_t    CCMR2;                // [Read-write] capture/compare mode register 2 (output mode)
    volatile uint32_t    CCER;                 // [Read-write] capture/compare enable register
    volatile uint32_t    CNT;                  // [Read-write] counter
    volatile uint32_t    PSC;                  // [Read-write] prescaler
    volatile uint32_t    ARR;                  // [Read-write] auto-reload register
    reserved_t<1>        _0;
    volatile uint32_t    CCR1;                 // [Read-write] capture/compare register 1
    volatile uint32_t    CCR2;                 // [Read-write] capture/compare register 2
    volatile uint32_t    CCR3;                 // [Read-write] capture/compare register 3
    volatile uint32_t    CCR4;                 // [Read-write] capture/compare register 4
    reserved_t<1>        _1;
    volatile uint32_t    DCR;                  // [Read-write] DMA control register
    volatile uint32_t    DMAR;                 // [Read-write] DMA address for full transfer

    template<uint32_t X>
    static constexpr uint32_t CR1_CKD =                 // Clock division (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t CR1_ARPE = 0x80;          // Auto-reload preload enable
    template<uint32_t X>
    static constexpr uint32_t CR1_CMS =                 // Center-aligned mode selection (2 bits)
        bit_field_t<5, 0x3>::value<X>();
    static constexpr uint32_t CR1_DIR = 0x10;           // Direction
    static constexpr uint32_t CR1_OPM = 0x8;            // One-pulse mode
    static constexpr uint32_t CR1_URS = 0x4;            // Update request source
    static constexpr uint32_t CR1_UDIS = 0x2;           // Update disable
    static constexpr uint32_t CR1_CEN = 0x1;            // Counter enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CR2_TI1S = 0x80;          // TI1 selection
    template<uint32_t X>
    static constexpr uint32_t CR2_MMS =                 // Master mode selection (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CR2_CCDS = 0x8;           // Capture/compare DMA selection
    static const uint32_t CR2_RESET_VALUE = 0x0;

    static constexpr uint32_t SMCR_ETP = 0x8000;         // External trigger polarity
    static constexpr uint32_t SMCR_ECE = 0x4000;         // External clock enable
    template<uint32_t X>
    static constexpr uint32_t SMCR_ETPS =                // External trigger prescaler (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMCR_ETF =                 // External trigger filter (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    static constexpr uint32_t SMCR_MSM = 0x80;           // Master/Slave mode
    template<uint32_t X>
    static constexpr uint32_t SMCR_TS =                  // Trigger selection (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMCR_SMS =                 // Slave mode selection (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t SMCR_RESET_VALUE = 0x0;

    static constexpr uint32_t DIER_TDE = 0x4000;         // Trigger DMA request enable
    static constexpr uint32_t DIER_CC4DE = 0x1000;       // Capture/Compare 4 DMA request enable
    static constexpr uint32_t DIER_CC3DE = 0x800;        // Capture/Compare 3 DMA request enable
    static constexpr uint32_t DIER_CC2DE = 0x400;        // Capture/Compare 2 DMA request enable
    static constexpr uint32_t DIER_CC1DE = 0x200;        // Capture/Compare 1 DMA request enable
    static constexpr uint32_t DIER_UDE = 0x100;          // Update DMA request enable
    static constexpr uint32_t DIER_TIE = 0x40;           // Trigger interrupt enable
    static constexpr uint32_t DIER_CC4IE = 0x10;         // Capture/Compare 4 interrupt enable
    static constexpr uint32_t DIER_CC3IE = 0x8;          // Capture/Compare 3 interrupt enable
    static constexpr uint32_t DIER_CC2IE = 0x4;          // Capture/Compare 2 interrupt enable
    static constexpr uint32_t DIER_CC1IE = 0x2;          // Capture/Compare 1 interrupt enable
    static constexpr uint32_t DIER_UIE = 0x1;            // Update interrupt enable
    static const uint32_t DIER_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_CC4OF = 0x1000;       // Capture/Compare 4 overcapture flag
    static constexpr uint32_t SR_CC3OF = 0x800;        // Capture/Compare 3 overcapture flag
    static constexpr uint32_t SR_CC2OF = 0x400;        // Capture/compare 2 overcapture flag
    static constexpr uint32_t SR_CC1OF = 0x200;        // Capture/Compare 1 overcapture flag
    static constexpr uint32_t SR_TIF = 0x40;           // Trigger interrupt flag
    static constexpr uint32_t SR_CC4IF = 0x10;         // Capture/Compare 4 interrupt flag
    static constexpr uint32_t SR_CC3IF = 0x8;          // Capture/Compare 3 interrupt flag
    static constexpr uint32_t SR_CC2IF = 0x4;          // Capture/Compare 2 interrupt flag
    static constexpr uint32_t SR_CC1IF = 0x2;          // Capture/compare 1 interrupt flag
    static constexpr uint32_t SR_UIF = 0x1;            // Update interrupt flag
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint32_t EGR_TG = 0x40;            // Trigger generation
    static constexpr uint32_t EGR_CC4G = 0x10;          // Capture/compare 4 generation
    static constexpr uint32_t EGR_CC3G = 0x8;           // Capture/compare 3 generation
    static constexpr uint32_t EGR_CC2G = 0x4;           // Capture/compare 2 generation
    static constexpr uint32_t EGR_CC1G = 0x2;           // Capture/compare 1 generation
    static constexpr uint32_t EGR_UG = 0x1;             // Update generation
    static const uint32_t EGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCMR1_CC1S =                // CC1S (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_CC2S =                // CC2S (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC1F =                // Input capture 1 filter (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC2F =                // Input capture 2 filter (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC2PCS =              // Input capture 2 prescaler (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_ICPCS =               // Input capture 1 prescaler (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t CCMR1_OC1CE = 0x80;         // OC1CE
    static constexpr uint32_t CCMR1_OC1FE = 0x4;          // OC1FE
    template<uint32_t X>
    static constexpr uint32_t CCMR1_OC1M =                // OC1M (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR1_OC1PE = 0x8;          // OC1PE
    static constexpr uint32_t CCMR1_OC2CE = 0x8000;       // OC2CE
    static constexpr uint32_t CCMR1_OC2FE = 0x400;        // OC2FE
    template<uint32_t X>
    static constexpr uint32_t CCMR1_OC2M =                // OC2M (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    static constexpr uint32_t CCMR1_OC2PE = 0x800;        // OC2PE
    static const uint32_t CCMR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCMR2_CC3S =                // CC3S (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_CC4S =                // CC4S (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC3F =                // Input capture 3 filter (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC3PSC =              // Input capture 3 prescaler (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC4F =                // Input capture 4 filter (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR2_IC4PSC =              // Input capture 4 prescaler (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    static constexpr uint32_t CCMR2_O24CE = 0x8000;       // O24CE
    static constexpr uint32_t CCMR2_OC3CE = 0x80;         // OC3CE
    static constexpr uint32_t CCMR2_OC3FE = 0x4;          // OC3FE
    template<uint32_t X>
    static constexpr uint32_t CCMR2_OC3M =                // OC3M (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR2_OC3PE = 0x8;          // OC3PE
    static constexpr uint32_t CCMR2_OC4FE = 0x400;        // OC4FE
    template<uint32_t X>
    static constexpr uint32_t CCMR2_OC4M =                // OC4M (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    static constexpr uint32_t CCMR2_OC4PE = 0x800;        // OC4PE
    static const uint32_t CCMR2_RESET_VALUE = 0x0;

    static constexpr uint32_t CCER_CC4NP = 0x8000;       // Capture/Compare 4 output Polarity
    static constexpr uint32_t CCER_CC4P = 0x2000;        // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC4E = 0x1000;        // Capture/Compare 4 output enable
    static constexpr uint32_t CCER_CC3NP = 0x800;        // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC3P = 0x200;         // Capture/Compare 3 output Polarity
    static constexpr uint32_t CCER_CC3E = 0x100;         // Capture/Compare 3 output enable
    static constexpr uint32_t CCER_CC2NP = 0x80;         // Capture/Compare 2 output Polarity
    static constexpr uint32_t CCER_CC2P = 0x20;          // Capture/Compare 2 output Polarity
    static constexpr uint32_t CCER_CC2E = 0x10;          // Capture/Compare 2 output enable
    static constexpr uint32_t CCER_CC1NP = 0x8;          // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1P = 0x2;           // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1E = 0x1;           // Capture/Compare 1 output enable
    static const uint32_t CCER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CNT_CNT_H =               // High counter value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CNT_CNT_L =               // Low counter value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CNT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PSC_PSC =                 // Prescaler value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t PSC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ARR_ARR_H =               // High Auto-reload value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ARR_ARR_L =               // Low Auto-reload value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t ARR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR1_CCR1_H =              // High Capture/Compare 1 value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR1_CCR1_L =              // Low Capture/Compare 1 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR2_CCR2_H =              // High Capture/Compare 2 value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR2_CCR2_L =              // Low Capture/Compare 2 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR3_CCR3_H =              // High Capture/Compare value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR3_CCR3_L =              // Low Capture/Compare value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR4_CCR4_H =              // High Capture/Compare value (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR4_CCR4_L =              // Low Capture/Compare value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DCR_DBL =                 // DMA burst length (5 bits)
        bit_field_t<8, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DCR_DBA =                 // DMA base address (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t DCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DMAR_DMAB =                // DMA register for burst accesses (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DMAR_RESET_VALUE = 0x0;
};

static tim5_t& TIM5 = *reinterpret_cast<tim5_t*>(0x40000c00);

#define HAVE_PERIPHERAL_TIM5


////
//
//    General purpose timers
//
////

struct tim9_t
{
    volatile uint32_t    CR1;                  // [Read-write] control register 1
    reserved_t<1>        _0;
    volatile uint32_t    SMCR;                 // [Read-write] slave mode control register
    volatile uint32_t    DIER;                 // [Read-write] DMA/Interrupt enable register
    volatile uint32_t    SR;                   // [Read-write] status register
    volatile uint32_t    EGR;                  // [Write-only] event generation register
    volatile uint32_t    CCMR1;                // [Read-write] capture/compare mode register 1 (output mode)
    reserved_t<1>        _1;
    volatile uint32_t    CCER;                 // [Read-write] capture/compare enable register
    volatile uint32_t    CNT;                  // [Read-write] counter
    volatile uint32_t    PSC;                  // [Read-write] prescaler
    volatile uint32_t    ARR;                  // [Read-write] auto-reload register
    reserved_t<1>        _2;
    volatile uint32_t    CCR1;                 // [Read-write] capture/compare register 1
    volatile uint32_t    CCR2;                 // [Read-write] capture/compare register 2

    template<uint32_t X>
    static constexpr uint32_t CR1_CKD =                 // Clock division (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t CR1_ARPE = 0x80;          // Auto-reload preload enable
    static constexpr uint32_t CR1_OPM = 0x8;            // One-pulse mode
    static constexpr uint32_t CR1_URS = 0x4;            // Update request source
    static constexpr uint32_t CR1_UDIS = 0x2;           // Update disable
    static constexpr uint32_t CR1_CEN = 0x1;            // Counter enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t SMCR_MSM = 0x80;           // Master/Slave mode
    template<uint32_t X>
    static constexpr uint32_t SMCR_TS =                  // Trigger selection (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMCR_SMS =                 // Slave mode selection (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t SMCR_RESET_VALUE = 0x0;

    static constexpr uint32_t DIER_TIE = 0x40;           // Trigger interrupt enable
    static constexpr uint32_t DIER_CC2IE = 0x4;          // Capture/Compare 2 interrupt enable
    static constexpr uint32_t DIER_CC1IE = 0x2;          // Capture/Compare 1 interrupt enable
    static constexpr uint32_t DIER_UIE = 0x1;            // Update interrupt enable
    static const uint32_t DIER_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_CC2OF = 0x400;        // Capture/compare 2 overcapture flag
    static constexpr uint32_t SR_CC1OF = 0x200;        // Capture/Compare 1 overcapture flag
    static constexpr uint32_t SR_TIF = 0x40;           // Trigger interrupt flag
    static constexpr uint32_t SR_CC2IF = 0x4;          // Capture/Compare 2 interrupt flag
    static constexpr uint32_t SR_CC1IF = 0x2;          // Capture/compare 1 interrupt flag
    static constexpr uint32_t SR_UIF = 0x1;            // Update interrupt flag
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint32_t EGR_TG = 0x40;            // Trigger generation
    static constexpr uint32_t EGR_CC2G = 0x4;           // Capture/compare 2 generation
    static constexpr uint32_t EGR_CC1G = 0x2;           // Capture/compare 1 generation
    static constexpr uint32_t EGR_UG = 0x1;             // Update generation
    static const uint32_t EGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCMR1_CC1S =                // Capture/Compare 1 selection (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_CC2S =                // Capture/Compare 2 selection (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC1F =                // Input capture 1 filter (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC2F =                // Input capture 2 filter (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC2PCS =              // Input capture 2 prescaler (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_ICPCS =               // Input capture 1 prescaler (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t CCMR1_OC1FE = 0x4;          // Output Compare 1 fast enable
    template<uint32_t X>
    static constexpr uint32_t CCMR1_OC1M =                // Output Compare 1 mode (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR1_OC1PE = 0x8;          // Output Compare 1 preload enable
    static constexpr uint32_t CCMR1_OC2FE = 0x400;        // Output Compare 2 fast enable
    template<uint32_t X>
    static constexpr uint32_t CCMR1_OC2M =                // Output Compare 2 mode (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    static constexpr uint32_t CCMR1_OC2PE = 0x800;        // Output Compare 2 preload enable
    static const uint32_t CCMR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CCER_CC2NP = 0x80;         // Capture/Compare 2 output Polarity
    static constexpr uint32_t CCER_CC2P = 0x20;          // Capture/Compare 2 output Polarity
    static constexpr uint32_t CCER_CC2E = 0x10;          // Capture/Compare 2 output enable
    static constexpr uint32_t CCER_CC1NP = 0x8;          // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1P = 0x2;           // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1E = 0x1;           // Capture/Compare 1 output enable
    static const uint32_t CCER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CNT_CNT =                 // counter value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CNT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PSC_PSC =                 // Prescaler value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t PSC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ARR_ARR =                 // Auto-reload value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t ARR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR1_CCR1 =                // Capture/Compare 1 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR2_CCR2 =                // Capture/Compare 2 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR2_RESET_VALUE = 0x0;
};

static tim9_t& TIM9 = *reinterpret_cast<tim9_t*>(0x40014000);

#define HAVE_PERIPHERAL_TIM9


////
//
//    General purpose timers
//
////

struct tim12_t
{
    volatile uint32_t    CR1;                  // [Read-write] control register 1
    reserved_t<1>        _0;
    volatile uint32_t    SMCR;                 // [Read-write] slave mode control register
    volatile uint32_t    DIER;                 // [Read-write] DMA/Interrupt enable register
    volatile uint32_t    SR;                   // [Read-write] status register
    volatile uint32_t    EGR;                  // [Write-only] event generation register
    volatile uint32_t    CCMR1;                // [Read-write] capture/compare mode register 1 (output mode)
    reserved_t<1>        _1;
    volatile uint32_t    CCER;                 // [Read-write] capture/compare enable register
    volatile uint32_t    CNT;                  // [Read-write] counter
    volatile uint32_t    PSC;                  // [Read-write] prescaler
    volatile uint32_t    ARR;                  // [Read-write] auto-reload register
    reserved_t<1>        _2;
    volatile uint32_t    CCR1;                 // [Read-write] capture/compare register 1
    volatile uint32_t    CCR2;                 // [Read-write] capture/compare register 2

    template<uint32_t X>
    static constexpr uint32_t CR1_CKD =                 // Clock division (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t CR1_ARPE = 0x80;          // Auto-reload preload enable
    static constexpr uint32_t CR1_OPM = 0x8;            // One-pulse mode
    static constexpr uint32_t CR1_URS = 0x4;            // Update request source
    static constexpr uint32_t CR1_UDIS = 0x2;           // Update disable
    static constexpr uint32_t CR1_CEN = 0x1;            // Counter enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t SMCR_MSM = 0x80;           // Master/Slave mode
    template<uint32_t X>
    static constexpr uint32_t SMCR_TS =                  // Trigger selection (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMCR_SMS =                 // Slave mode selection (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t SMCR_RESET_VALUE = 0x0;

    static constexpr uint32_t DIER_TIE = 0x40;           // Trigger interrupt enable
    static constexpr uint32_t DIER_CC2IE = 0x4;          // Capture/Compare 2 interrupt enable
    static constexpr uint32_t DIER_CC1IE = 0x2;          // Capture/Compare 1 interrupt enable
    static constexpr uint32_t DIER_UIE = 0x1;            // Update interrupt enable
    static const uint32_t DIER_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_CC2OF = 0x400;        // Capture/compare 2 overcapture flag
    static constexpr uint32_t SR_CC1OF = 0x200;        // Capture/Compare 1 overcapture flag
    static constexpr uint32_t SR_TIF = 0x40;           // Trigger interrupt flag
    static constexpr uint32_t SR_CC2IF = 0x4;          // Capture/Compare 2 interrupt flag
    static constexpr uint32_t SR_CC1IF = 0x2;          // Capture/compare 1 interrupt flag
    static constexpr uint32_t SR_UIF = 0x1;            // Update interrupt flag
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint32_t EGR_TG = 0x40;            // Trigger generation
    static constexpr uint32_t EGR_CC2G = 0x4;           // Capture/compare 2 generation
    static constexpr uint32_t EGR_CC1G = 0x2;           // Capture/compare 1 generation
    static constexpr uint32_t EGR_UG = 0x1;             // Update generation
    static const uint32_t EGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCMR1_CC1S =                // Capture/Compare 1 selection (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_CC2S =                // Capture/Compare 2 selection (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC1F =                // Input capture 1 filter (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC2F =                // Input capture 2 filter (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC2PCS =              // Input capture 2 prescaler (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_ICPCS =               // Input capture 1 prescaler (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t CCMR1_OC1FE = 0x4;          // Output Compare 1 fast enable
    template<uint32_t X>
    static constexpr uint32_t CCMR1_OC1M =                // Output Compare 1 mode (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR1_OC1PE = 0x8;          // Output Compare 1 preload enable
    static constexpr uint32_t CCMR1_OC2FE = 0x400;        // Output Compare 2 fast enable
    template<uint32_t X>
    static constexpr uint32_t CCMR1_OC2M =                // Output Compare 2 mode (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    static constexpr uint32_t CCMR1_OC2PE = 0x800;        // Output Compare 2 preload enable
    static const uint32_t CCMR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CCER_CC2NP = 0x80;         // Capture/Compare 2 output Polarity
    static constexpr uint32_t CCER_CC2P = 0x20;          // Capture/Compare 2 output Polarity
    static constexpr uint32_t CCER_CC2E = 0x10;          // Capture/Compare 2 output enable
    static constexpr uint32_t CCER_CC1NP = 0x8;          // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1P = 0x2;           // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1E = 0x1;           // Capture/Compare 1 output enable
    static const uint32_t CCER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CNT_CNT =                 // counter value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CNT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PSC_PSC =                 // Prescaler value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t PSC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ARR_ARR =                 // Auto-reload value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t ARR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR1_CCR1 =                // Capture/Compare 1 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR2_CCR2 =                // Capture/Compare 2 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR2_RESET_VALUE = 0x0;
};

static tim12_t& TIM12 = *reinterpret_cast<tim12_t*>(0x40001800);

#define HAVE_PERIPHERAL_TIM12


////
//
//    General-purpose-timers
//
////

struct tim10_t
{
    volatile uint32_t    CR1;                  // [Read-write] control register 1
    reserved_t<1>        _0;
    volatile uint32_t    SMCR;                 // [Read-write] slave mode control register
    volatile uint32_t    DIER;                 // [Read-write] DMA/Interrupt enable register
    volatile uint32_t    SR;                   // [Read-write] status register
    volatile uint32_t    EGR;                  // [Write-only] event generation register
    volatile uint32_t    CCMR1;                // [Read-write] capture/compare mode register 1 (output mode)
    reserved_t<1>        _1;
    volatile uint32_t    CCER;                 // [Read-write] capture/compare enable register
    volatile uint32_t    CNT;                  // [Read-write] counter
    volatile uint32_t    PSC;                  // [Read-write] prescaler
    volatile uint32_t    ARR;                  // [Read-write] auto-reload register
    reserved_t<1>        _2;
    volatile uint32_t    CCR1;                 // [Read-write] capture/compare register 1
    reserved_t<6>        _3;
    volatile uint32_t    OR;                   // [Read-write] option register

    template<uint32_t X>
    static constexpr uint32_t CR1_CKD =                 // Clock division (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t CR1_ARPE = 0x80;          // Auto-reload preload enable
    static constexpr uint32_t CR1_URS = 0x4;            // Update request source
    static constexpr uint32_t CR1_UDIS = 0x2;           // Update disable
    static constexpr uint32_t CR1_CEN = 0x1;            // Counter enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t SMCR_SMS3 = 0x10000;       // Slave mode selection
    static constexpr uint32_t SMCR_ETP = 0x8000;         // External trigger polarity
    static constexpr uint32_t SMCR_ECE = 0x4000;         // External clock enable
    template<uint32_t X>
    static constexpr uint32_t SMCR_ETPS =                // External trigger prescaler (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMCR_ETF =                 // External trigger filter (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    static constexpr uint32_t SMCR_MSM = 0x80;           // Master/slave mode
    template<uint32_t X>
    static constexpr uint32_t SMCR_TS =                  // Trigger selection (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMCR_SMS =                 // Slave mode selection (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t SMCR_RESET_VALUE = 0x0;

    static constexpr uint32_t DIER_CC1IE = 0x2;          // Capture/Compare 1 interrupt enable
    static constexpr uint32_t DIER_UIE = 0x1;            // Update interrupt enable
    static const uint32_t DIER_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_CC1OF = 0x200;        // Capture/Compare 1 overcapture flag
    static constexpr uint32_t SR_CC1IF = 0x2;          // Capture/compare 1 interrupt flag
    static constexpr uint32_t SR_UIF = 0x1;            // Update interrupt flag
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint32_t EGR_CC1G = 0x2;           // Capture/compare 1 generation
    static constexpr uint32_t EGR_UG = 0x1;             // Update generation
    static const uint32_t EGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCMR1_CC1S =                // Capture/Compare 1 selection (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC1F =                // Input capture 1 filter (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_ICPCS =               // Input capture 1 prescaler (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t CCMR1_OC1FE = 0x4;          // Output Compare 1 fast enable
    template<uint32_t X>
    static constexpr uint32_t CCMR1_OC1M =                // Output Compare 1 mode (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR1_OC1PE = 0x8;          // Output Compare 1 preload enable
    static const uint32_t CCMR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CCER_CC1NP = 0x8;          // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1P = 0x2;           // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1E = 0x1;           // Capture/Compare 1 output enable
    static const uint32_t CCER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CNT_CNT =                 // counter value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CNT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PSC_PSC =                 // Prescaler value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t PSC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ARR_ARR =                 // Auto-reload value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t ARR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR1_CCR1 =                // Capture/Compare 1 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OR_TI1_RMP =             // TIM11 Input 1 remapping capability (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t OR_RESET_VALUE = 0x0;

    static constexpr uint8_t TIM5 = 50; // TIM5 global interrupt
};

static tim10_t& TIM10 = *reinterpret_cast<tim10_t*>(0x40014400);

#define HAVE_PERIPHERAL_TIM10


////
//
//    General-purpose-timers
//
////

struct tim11_t
{
    volatile uint32_t    CR1;                  // [Read-write] control register 1
    reserved_t<1>        _0;
    volatile uint32_t    SMCR;                 // [Read-write] slave mode control register
    volatile uint32_t    DIER;                 // [Read-write] DMA/Interrupt enable register
    volatile uint32_t    SR;                   // [Read-write] status register
    volatile uint32_t    EGR;                  // [Write-only] event generation register
    volatile uint32_t    CCMR1;                // [Read-write] capture/compare mode register 1 (output mode)
    reserved_t<1>        _1;
    volatile uint32_t    CCER;                 // [Read-write] capture/compare enable register
    volatile uint32_t    CNT;                  // [Read-write] counter
    volatile uint32_t    PSC;                  // [Read-write] prescaler
    volatile uint32_t    ARR;                  // [Read-write] auto-reload register
    reserved_t<1>        _2;
    volatile uint32_t    CCR1;                 // [Read-write] capture/compare register 1
    reserved_t<6>        _3;
    volatile uint32_t    OR;                   // [Read-write] option register

    template<uint32_t X>
    static constexpr uint32_t CR1_CKD =                 // Clock division (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t CR1_ARPE = 0x80;          // Auto-reload preload enable
    static constexpr uint32_t CR1_URS = 0x4;            // Update request source
    static constexpr uint32_t CR1_UDIS = 0x2;           // Update disable
    static constexpr uint32_t CR1_CEN = 0x1;            // Counter enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t SMCR_SMS3 = 0x10000;       // Slave mode selection
    static constexpr uint32_t SMCR_ETP = 0x8000;         // External trigger polarity
    static constexpr uint32_t SMCR_ECE = 0x4000;         // External clock enable
    template<uint32_t X>
    static constexpr uint32_t SMCR_ETPS =                // External trigger prescaler (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMCR_ETF =                 // External trigger filter (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    static constexpr uint32_t SMCR_MSM = 0x80;           // Master/slave mode
    template<uint32_t X>
    static constexpr uint32_t SMCR_TS =                  // Trigger selection (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMCR_SMS =                 // Slave mode selection (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t SMCR_RESET_VALUE = 0x0;

    static constexpr uint32_t DIER_CC1IE = 0x2;          // Capture/Compare 1 interrupt enable
    static constexpr uint32_t DIER_UIE = 0x1;            // Update interrupt enable
    static const uint32_t DIER_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_CC1OF = 0x200;        // Capture/Compare 1 overcapture flag
    static constexpr uint32_t SR_CC1IF = 0x2;          // Capture/compare 1 interrupt flag
    static constexpr uint32_t SR_UIF = 0x1;            // Update interrupt flag
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint32_t EGR_CC1G = 0x2;           // Capture/compare 1 generation
    static constexpr uint32_t EGR_UG = 0x1;             // Update generation
    static const uint32_t EGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCMR1_CC1S =                // Capture/Compare 1 selection (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC1F =                // Input capture 1 filter (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_ICPCS =               // Input capture 1 prescaler (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t CCMR1_OC1FE = 0x4;          // Output Compare 1 fast enable
    template<uint32_t X>
    static constexpr uint32_t CCMR1_OC1M =                // Output Compare 1 mode (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR1_OC1PE = 0x8;          // Output Compare 1 preload enable
    static const uint32_t CCMR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CCER_CC1NP = 0x8;          // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1P = 0x2;           // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1E = 0x1;           // Capture/Compare 1 output enable
    static const uint32_t CCER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CNT_CNT =                 // counter value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CNT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PSC_PSC =                 // Prescaler value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t PSC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ARR_ARR =                 // Auto-reload value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t ARR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR1_CCR1 =                // Capture/Compare 1 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OR_TI1_RMP =             // TIM11 Input 1 remapping capability (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t OR_RESET_VALUE = 0x0;
};

static tim11_t& TIM11 = *reinterpret_cast<tim11_t*>(0x40014800);

#define HAVE_PERIPHERAL_TIM11


////
//
//    General-purpose-timers
//
////

struct tim13_t
{
    volatile uint32_t    CR1;                  // [Read-write] control register 1
    reserved_t<1>        _0;
    volatile uint32_t    SMCR;                 // [Read-write] slave mode control register
    volatile uint32_t    DIER;                 // [Read-write] DMA/Interrupt enable register
    volatile uint32_t    SR;                   // [Read-write] status register
    volatile uint32_t    EGR;                  // [Write-only] event generation register
    volatile uint32_t    CCMR1;                // [Read-write] capture/compare mode register 1 (output mode)
    reserved_t<1>        _1;
    volatile uint32_t    CCER;                 // [Read-write] capture/compare enable register
    volatile uint32_t    CNT;                  // [Read-write] counter
    volatile uint32_t    PSC;                  // [Read-write] prescaler
    volatile uint32_t    ARR;                  // [Read-write] auto-reload register
    reserved_t<1>        _2;
    volatile uint32_t    CCR1;                 // [Read-write] capture/compare register 1
    reserved_t<6>        _3;
    volatile uint32_t    OR;                   // [Read-write] option register

    template<uint32_t X>
    static constexpr uint32_t CR1_CKD =                 // Clock division (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t CR1_ARPE = 0x80;          // Auto-reload preload enable
    static constexpr uint32_t CR1_URS = 0x4;            // Update request source
    static constexpr uint32_t CR1_UDIS = 0x2;           // Update disable
    static constexpr uint32_t CR1_CEN = 0x1;            // Counter enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t SMCR_SMS3 = 0x10000;       // Slave mode selection
    static constexpr uint32_t SMCR_ETP = 0x8000;         // External trigger polarity
    static constexpr uint32_t SMCR_ECE = 0x4000;         // External clock enable
    template<uint32_t X>
    static constexpr uint32_t SMCR_ETPS =                // External trigger prescaler (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMCR_ETF =                 // External trigger filter (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    static constexpr uint32_t SMCR_MSM = 0x80;           // Master/slave mode
    template<uint32_t X>
    static constexpr uint32_t SMCR_TS =                  // Trigger selection (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMCR_SMS =                 // Slave mode selection (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t SMCR_RESET_VALUE = 0x0;

    static constexpr uint32_t DIER_CC1IE = 0x2;          // Capture/Compare 1 interrupt enable
    static constexpr uint32_t DIER_UIE = 0x1;            // Update interrupt enable
    static const uint32_t DIER_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_CC1OF = 0x200;        // Capture/Compare 1 overcapture flag
    static constexpr uint32_t SR_CC1IF = 0x2;          // Capture/compare 1 interrupt flag
    static constexpr uint32_t SR_UIF = 0x1;            // Update interrupt flag
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint32_t EGR_CC1G = 0x2;           // Capture/compare 1 generation
    static constexpr uint32_t EGR_UG = 0x1;             // Update generation
    static const uint32_t EGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCMR1_CC1S =                // Capture/Compare 1 selection (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC1F =                // Input capture 1 filter (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_ICPCS =               // Input capture 1 prescaler (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t CCMR1_OC1FE = 0x4;          // Output Compare 1 fast enable
    template<uint32_t X>
    static constexpr uint32_t CCMR1_OC1M =                // Output Compare 1 mode (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR1_OC1PE = 0x8;          // Output Compare 1 preload enable
    static const uint32_t CCMR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CCER_CC1NP = 0x8;          // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1P = 0x2;           // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1E = 0x1;           // Capture/Compare 1 output enable
    static const uint32_t CCER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CNT_CNT =                 // counter value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CNT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PSC_PSC =                 // Prescaler value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t PSC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ARR_ARR =                 // Auto-reload value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t ARR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR1_CCR1 =                // Capture/Compare 1 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OR_TI1_RMP =             // TIM11 Input 1 remapping capability (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t OR_RESET_VALUE = 0x0;
};

static tim13_t& TIM13 = *reinterpret_cast<tim13_t*>(0x40001c00);

#define HAVE_PERIPHERAL_TIM13


////
//
//    General-purpose-timers
//
////

struct tim14_t
{
    volatile uint32_t    CR1;                  // [Read-write] control register 1
    reserved_t<1>        _0;
    volatile uint32_t    SMCR;                 // [Read-write] slave mode control register
    volatile uint32_t    DIER;                 // [Read-write] DMA/Interrupt enable register
    volatile uint32_t    SR;                   // [Read-write] status register
    volatile uint32_t    EGR;                  // [Write-only] event generation register
    volatile uint32_t    CCMR1;                // [Read-write] capture/compare mode register 1 (output mode)
    reserved_t<1>        _1;
    volatile uint32_t    CCER;                 // [Read-write] capture/compare enable register
    volatile uint32_t    CNT;                  // [Read-write] counter
    volatile uint32_t    PSC;                  // [Read-write] prescaler
    volatile uint32_t    ARR;                  // [Read-write] auto-reload register
    reserved_t<1>        _2;
    volatile uint32_t    CCR1;                 // [Read-write] capture/compare register 1
    reserved_t<6>        _3;
    volatile uint32_t    OR;                   // [Read-write] option register

    template<uint32_t X>
    static constexpr uint32_t CR1_CKD =                 // Clock division (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t CR1_ARPE = 0x80;          // Auto-reload preload enable
    static constexpr uint32_t CR1_URS = 0x4;            // Update request source
    static constexpr uint32_t CR1_UDIS = 0x2;           // Update disable
    static constexpr uint32_t CR1_CEN = 0x1;            // Counter enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t SMCR_SMS3 = 0x10000;       // Slave mode selection
    static constexpr uint32_t SMCR_ETP = 0x8000;         // External trigger polarity
    static constexpr uint32_t SMCR_ECE = 0x4000;         // External clock enable
    template<uint32_t X>
    static constexpr uint32_t SMCR_ETPS =                // External trigger prescaler (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMCR_ETF =                 // External trigger filter (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    static constexpr uint32_t SMCR_MSM = 0x80;           // Master/slave mode
    template<uint32_t X>
    static constexpr uint32_t SMCR_TS =                  // Trigger selection (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SMCR_SMS =                 // Slave mode selection (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t SMCR_RESET_VALUE = 0x0;

    static constexpr uint32_t DIER_CC1IE = 0x2;          // Capture/Compare 1 interrupt enable
    static constexpr uint32_t DIER_UIE = 0x1;            // Update interrupt enable
    static const uint32_t DIER_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_CC1OF = 0x200;        // Capture/Compare 1 overcapture flag
    static constexpr uint32_t SR_CC1IF = 0x2;          // Capture/compare 1 interrupt flag
    static constexpr uint32_t SR_UIF = 0x1;            // Update interrupt flag
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint32_t EGR_CC1G = 0x2;           // Capture/compare 1 generation
    static constexpr uint32_t EGR_UG = 0x1;             // Update generation
    static const uint32_t EGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCMR1_CC1S =                // Capture/Compare 1 selection (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_IC1F =                // Input capture 1 filter (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCMR1_ICPCS =               // Input capture 1 prescaler (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t CCMR1_OC1FE = 0x4;          // Output Compare 1 fast enable
    template<uint32_t X>
    static constexpr uint32_t CCMR1_OC1M =                // Output Compare 1 mode (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t CCMR1_OC1PE = 0x8;          // Output Compare 1 preload enable
    static const uint32_t CCMR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CCER_CC1NP = 0x8;          // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1P = 0x2;           // Capture/Compare 1 output Polarity
    static constexpr uint32_t CCER_CC1E = 0x1;           // Capture/Compare 1 output enable
    static const uint32_t CCER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CNT_CNT =                 // counter value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CNT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PSC_PSC =                 // Prescaler value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t PSC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ARR_ARR =                 // Auto-reload value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t ARR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR1_CCR1 =                // Capture/Compare 1 value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CCR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OR_TI1_RMP =             // TIM11 Input 1 remapping capability (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t OR_RESET_VALUE = 0x0;
};

static tim14_t& TIM14 = *reinterpret_cast<tim14_t*>(0x40002000);

#define HAVE_PERIPHERAL_TIM14


////
//
//    Basic timers
//
////

struct tim6_t
{
    volatile uint32_t    CR1;                  // [Read-write] control register 1
    volatile uint32_t    CR2;                  // [Read-write] control register 2
    reserved_t<1>        _0;
    volatile uint32_t    DIER;                 // [Read-write] DMA/Interrupt enable register
    volatile uint32_t    SR;                   // [Read-write] status register
    volatile uint32_t    EGR;                  // [Write-only] event generation register
    reserved_t<3>        _1;
    volatile uint32_t    CNT;                  // [Read-write] counter
    volatile uint32_t    PSC;                  // [Read-write] prescaler
    volatile uint32_t    ARR;                  // [Read-write] auto-reload register

    static constexpr uint32_t CR1_ARPE = 0x80;          // Auto-reload preload enable
    static constexpr uint32_t CR1_OPM = 0x8;            // One-pulse mode
    static constexpr uint32_t CR1_URS = 0x4;            // Update request source
    static constexpr uint32_t CR1_UDIS = 0x2;           // Update disable
    static constexpr uint32_t CR1_CEN = 0x1;            // Counter enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CR2_MMS =                 // Master mode selection (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static const uint32_t CR2_RESET_VALUE = 0x0;

    static constexpr uint32_t DIER_UDE = 0x100;          // Update DMA request enable
    static constexpr uint32_t DIER_UIE = 0x1;            // Update interrupt enable
    static const uint32_t DIER_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_UIF = 0x1;            // Update interrupt flag
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint32_t EGR_UG = 0x1;             // Update generation
    static const uint32_t EGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CNT_CNT =                 // Low counter value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CNT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PSC_PSC =                 // Prescaler value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t PSC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ARR_ARR =                 // Low Auto-reload value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t ARR_RESET_VALUE = 0x0;

    static constexpr uint8_t TIM6_DAC = 54; // TIM6 global interrupt, DAC1 and DAC2 underrun error interrupt
};

static tim6_t& TIM6 = *reinterpret_cast<tim6_t*>(0x40001000);

#define HAVE_PERIPHERAL_TIM6


////
//
//    Basic timers
//
////

struct tim7_t
{
    volatile uint32_t    CR1;                  // [Read-write] control register 1
    volatile uint32_t    CR2;                  // [Read-write] control register 2
    reserved_t<1>        _0;
    volatile uint32_t    DIER;                 // [Read-write] DMA/Interrupt enable register
    volatile uint32_t    SR;                   // [Read-write] status register
    volatile uint32_t    EGR;                  // [Write-only] event generation register
    reserved_t<3>        _1;
    volatile uint32_t    CNT;                  // [Read-write] counter
    volatile uint32_t    PSC;                  // [Read-write] prescaler
    volatile uint32_t    ARR;                  // [Read-write] auto-reload register

    static constexpr uint32_t CR1_ARPE = 0x80;          // Auto-reload preload enable
    static constexpr uint32_t CR1_OPM = 0x8;            // One-pulse mode
    static constexpr uint32_t CR1_URS = 0x4;            // Update request source
    static constexpr uint32_t CR1_UDIS = 0x2;           // Update disable
    static constexpr uint32_t CR1_CEN = 0x1;            // Counter enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CR2_MMS =                 // Master mode selection (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    static const uint32_t CR2_RESET_VALUE = 0x0;

    static constexpr uint32_t DIER_UDE = 0x100;          // Update DMA request enable
    static constexpr uint32_t DIER_UIE = 0x1;            // Update interrupt enable
    static const uint32_t DIER_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_UIF = 0x1;            // Update interrupt flag
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint32_t EGR_UG = 0x1;             // Update generation
    static const uint32_t EGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CNT_CNT =                 // Low counter value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CNT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PSC_PSC =                 // Prescaler value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t PSC_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ARR_ARR =                 // Low Auto-reload value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t ARR_RESET_VALUE = 0x0;

    static constexpr uint8_t TIM7 = 55; // TIM7 global interrupt
};

static tim7_t& TIM7 = *reinterpret_cast<tim7_t*>(0x40001400);

#define HAVE_PERIPHERAL_TIM7


////
//
//    Ethernet: media access control (MAC)
//
////

struct ethernet_mac_t
{
    volatile uint32_t    MACCR;                // [Read-write] Ethernet MAC configuration register
    volatile uint32_t    MACFFR;               // [Read-write] Ethernet MAC frame filter register
    volatile uint32_t    MACHTHR;              // [Read-write] Ethernet MAC hash table high register
    volatile uint32_t    MACHTLR;              // [Read-write] Ethernet MAC hash table low register
    volatile uint32_t    MACMIIAR;             // [Read-write] Ethernet MAC MII address register
    volatile uint32_t    MACMIIDR;             // [Read-write] Ethernet MAC MII data register
    volatile uint32_t    MACFCR;               // [Read-write] Ethernet MAC flow control register
    volatile uint32_t    MACVLANTR;            // [Read-write] Ethernet MAC VLAN tag register
    reserved_t<3>        _0;
    volatile uint32_t    MACPMTCSR;            // [Read-write] Ethernet MAC PMT control and status register
    reserved_t<1>        _1;
    volatile uint32_t    MACDBGR;              // [Read-only] Ethernet MAC debug register
    volatile uint32_t    MACSR;                // Ethernet MAC interrupt status register
    volatile uint32_t    MACIMR;               // [Read-write] Ethernet MAC interrupt mask register
    volatile uint32_t    MACA0HR;              // Ethernet MAC address 0 high register
    volatile uint32_t    MACA0LR;              // [Read-write] Ethernet MAC address 0 low register
    volatile uint32_t    MACA1HR;              // [Read-write] Ethernet MAC address 1 high register
    volatile uint32_t    MACA1LR;              // [Read-write] Ethernet MAC address1 low register
    volatile uint32_t    MACA2HR;              // [Read-write] Ethernet MAC address 2 high register
    volatile uint32_t    MACA2LR;              // [Read-write] Ethernet MAC address 2 low register
    volatile uint32_t    MACA3HR;              // [Read-write] Ethernet MAC address 3 high register
    volatile uint32_t    MACA3LR;              // [Read-write] Ethernet MAC address 3 low register
    volatile uint32_t    MACRWUFFER;           // [Read-write] Ethernet MAC remote wakeup frame filter register

    static constexpr uint32_t MACCR_RE = 0x4;             // RE
    static constexpr uint32_t MACCR_TE = 0x8;             // TE
    static constexpr uint32_t MACCR_DC = 0x10;            // DC
    template<uint32_t X>
    static constexpr uint32_t MACCR_BL =                  // BL (2 bits)
        bit_field_t<5, 0x3>::value<X>();
    static constexpr uint32_t MACCR_APCS = 0x80;          // APCS
    static constexpr uint32_t MACCR_RD = 0x200;           // RD
    static constexpr uint32_t MACCR_IPCO = 0x400;         // IPCO
    static constexpr uint32_t MACCR_DM = 0x800;           // DM
    static constexpr uint32_t MACCR_LM = 0x1000;          // LM
    static constexpr uint32_t MACCR_ROD = 0x2000;         // ROD
    static constexpr uint32_t MACCR_FES = 0x4000;         // FES
    static constexpr uint32_t MACCR_CSD = 0x10000;        // CSD
    template<uint32_t X>
    static constexpr uint32_t MACCR_IFG =                 // IFG (3 bits)
        bit_field_t<17, 0x7>::value<X>();
    static constexpr uint32_t MACCR_JD = 0x400000;        // JD
    static constexpr uint32_t MACCR_WD = 0x800000;        // WD
    static constexpr uint32_t MACCR_CSTF = 0x2000000;     // CSTF
    static const uint32_t MACCR_RESET_VALUE = 0x8000;

    static constexpr uint32_t MACFFR_PM = 0x1;             // PM
    static constexpr uint32_t MACFFR_HU = 0x2;             // HU
    static constexpr uint32_t MACFFR_HM = 0x4;             // HM
    static constexpr uint32_t MACFFR_DAIF = 0x8;           // DAIF
    static constexpr uint32_t MACFFR_RAM = 0x10;           // RAM
    static constexpr uint32_t MACFFR_BFD = 0x20;           // BFD
    static constexpr uint32_t MACFFR_PCF = 0x40;           // PCF
    static constexpr uint32_t MACFFR_SAIF = 0x80;          // SAIF
    static constexpr uint32_t MACFFR_SAF = 0x100;          // SAF
    static constexpr uint32_t MACFFR_HPF = 0x200;          // HPF
    static constexpr uint32_t MACFFR_RA = 0x80000000;      // RA
    static const uint32_t MACFFR_RESET_VALUE = 0x0;


    static const uint32_t MACHTHR_RESET_VALUE = 0x0;


    static const uint32_t MACHTLR_RESET_VALUE = 0x0;

    static constexpr uint32_t MACMIIAR_MB = 0x1;             // MB
    static constexpr uint32_t MACMIIAR_MW = 0x2;             // MW
    template<uint32_t X>
    static constexpr uint32_t MACMIIAR_CR =                  // CR (3 bits)
        bit_field_t<2, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MACMIIAR_MR =                  // MR (5 bits)
        bit_field_t<6, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MACMIIAR_PA =                  // PA (5 bits)
        bit_field_t<11, 0x1f>::value<X>();
    static const uint32_t MACMIIAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t MACMIIDR_TD =                  // TD (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t MACMIIDR_RESET_VALUE = 0x0;

    static constexpr uint32_t MACFCR_FCB = 0x1;            // FCB
    static constexpr uint32_t MACFCR_TFCE = 0x2;           // TFCE
    static constexpr uint32_t MACFCR_RFCE = 0x4;           // RFCE
    static constexpr uint32_t MACFCR_UPFD = 0x8;           // UPFD
    template<uint32_t X>
    static constexpr uint32_t MACFCR_PLT =                 // PLT (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static constexpr uint32_t MACFCR_ZQPD = 0x80;          // ZQPD
    template<uint32_t X>
    static constexpr uint32_t MACFCR_PT =                  // PT (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t MACFCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t MACVLANTR_VLANTI =              // VLANTI (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static constexpr uint32_t MACVLANTR_VLANTC = 0x10000;     // VLANTC
    static const uint32_t MACVLANTR_RESET_VALUE = 0x0;

    static constexpr uint32_t MACPMTCSR_PD = 0x1;             // PD
    static constexpr uint32_t MACPMTCSR_MPE = 0x2;            // MPE
    static constexpr uint32_t MACPMTCSR_WFE = 0x4;            // WFE
    static constexpr uint32_t MACPMTCSR_MPR = 0x20;           // MPR
    static constexpr uint32_t MACPMTCSR_WFR = 0x40;           // WFR
    static constexpr uint32_t MACPMTCSR_GU = 0x200;           // GU
    static constexpr uint32_t MACPMTCSR_WFFRPR = 0x80000000;  // WFFRPR
    static const uint32_t MACPMTCSR_RESET_VALUE = 0x0;

    static constexpr uint32_t MACDBGR_CR = 0x1;             // CR
    static constexpr uint32_t MACDBGR_CSR = 0x2;            // CSR
    static constexpr uint32_t MACDBGR_ROR = 0x4;            // ROR
    static constexpr uint32_t MACDBGR_MCF = 0x8;            // MCF
    static constexpr uint32_t MACDBGR_MCP = 0x10;           // MCP
    static constexpr uint32_t MACDBGR_MCFHP = 0x20;         // MCFHP
    static const uint32_t MACDBGR_RESET_VALUE = 0x0;

    static constexpr uint32_t MACSR_PMTS = 0x8;           // PMTS, Read-only
    static constexpr uint32_t MACSR_MMCS = 0x10;          // MMCS, Read-only
    static constexpr uint32_t MACSR_MMCRS = 0x20;         // MMCRS, Read-only
    static constexpr uint32_t MACSR_MMCTS = 0x40;         // MMCTS, Read-only
    static constexpr uint32_t MACSR_TSTS = 0x200;         // TSTS, Read-write
    static const uint32_t MACSR_RESET_VALUE = 0x0;

    static constexpr uint32_t MACIMR_PMTIM = 0x8;          // PMTIM
    static constexpr uint32_t MACIMR_TSTIM = 0x200;        // TSTIM
    static const uint32_t MACIMR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t MACA0HR_MACA0H =              // MAC address0 high (16 bits), Read-write
        bit_field_t<0, 0xffff>::value<X>();
    static constexpr uint32_t MACA0HR_MO = 0x80000000;      // Always 1, Read-only
    static const uint32_t MACA0HR_RESET_VALUE = 0x10ffff;


    static const uint32_t MACA0LR_RESET_VALUE = 0xffffffff;

    template<uint32_t X>
    static constexpr uint32_t MACA1HR_MACA1H =              // MACA1H (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MACA1HR_MBC =                 // MBC (6 bits)
        bit_field_t<24, 0x3f>::value<X>();
    static constexpr uint32_t MACA1HR_SA = 0x40000000;      // SA
    static constexpr uint32_t MACA1HR_AE = 0x80000000;      // AE
    static const uint32_t MACA1HR_RESET_VALUE = 0xffff;


    static const uint32_t MACA1LR_RESET_VALUE = 0xffffffff;

    template<uint32_t X>
    static constexpr uint32_t MACA2HR_MAC2AH =              // MAC2AH (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MACA2HR_MBC =                 // MBC (6 bits)
        bit_field_t<24, 0x3f>::value<X>();
    static constexpr uint32_t MACA2HR_SA = 0x40000000;      // SA
    static constexpr uint32_t MACA2HR_AE = 0x80000000;      // AE
    static const uint32_t MACA2HR_RESET_VALUE = 0xffff;

    template<uint32_t X>
    static constexpr uint32_t MACA2LR_MACA2L =              // MACA2L (31 bits)
        bit_field_t<0, 0x7fffffff>::value<X>();
    static const uint32_t MACA2LR_RESET_VALUE = 0xffffffff;

    template<uint32_t X>
    static constexpr uint32_t MACA3HR_MACA3H =              // MACA3H (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t MACA3HR_MBC =                 // MBC (6 bits)
        bit_field_t<24, 0x3f>::value<X>();
    static constexpr uint32_t MACA3HR_SA = 0x40000000;      // SA
    static constexpr uint32_t MACA3HR_AE = 0x80000000;      // AE
    static const uint32_t MACA3HR_RESET_VALUE = 0xffff;


    static const uint32_t MACA3LR_RESET_VALUE = 0xffffffff;

    static const uint32_t MACRWUFFER_RESET_VALUE = 0xffffffff;

    static constexpr uint8_t ETH = 61; // Ethernet global interrupt
    static constexpr uint8_t ETH_WKUP = 62; // Ethernet Wakeup through EXTI line
};

static ethernet_mac_t& ETHERNET_MAC = *reinterpret_cast<ethernet_mac_t*>(0x40028000);

#define HAVE_PERIPHERAL_ETHERNET_MAC


////
//
//    Cryptographic processor
//
////

struct crc_t
{
    volatile uint32_t    DR;                   // [Read-write] Data register
    volatile uint32_t    IDR;                  // [Read-write] Independent Data register
    volatile uint32_t    CR;                   // [Write-only] Control register
    volatile uint32_t    INIT;                 // [Read-write] Initial CRC value
    volatile uint32_t    POL;                  // [Read-write] CRC polynomial


    static const uint32_t DR_RESET_VALUE = 0xffffffff;

    template<uint32_t X>
    static constexpr uint32_t IDR_IDR =                 // Independent Data register (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t IDR_RESET_VALUE = 0x0;

    static constexpr uint32_t CR_CR = 0x1;             // Control regidter
    static const uint32_t CR_RESET_VALUE = 0x0;


    static const uint32_t INIT_RESET_VALUE = 0x0;


    static const uint32_t POL_RESET_VALUE = 0x0;
};

static crc_t& CRC = *reinterpret_cast<crc_t*>(0x40023000);

#define HAVE_PERIPHERAL_CRC


////
//
//    Controller area network
//
////

struct can1_t
{
    volatile uint32_t    MCR;                  // [Read-write] master control register
    volatile uint32_t    MSR;                  // master status register
    volatile uint32_t    TSR;                  // transmit status register
    volatile uint32_t    RF0R;                 // receive FIFO 0 register
    volatile uint32_t    RF1R;                 // receive FIFO 1 register
    volatile uint32_t    IER;                  // [Read-write] interrupt enable register
    volatile uint32_t    ESR;                  // interrupt enable register
    volatile uint32_t    BTR;                  // [Read-write] bit timing register
    reserved_t<88>       _0;
    volatile uint32_t    TI0R;                 // [Read-write] TX mailbox identifier register
    volatile uint32_t    TDT0R;                // [Read-write] mailbox data length control and time stamp register
    volatile uint32_t    TDL0R;                // [Read-write] mailbox data low register
    volatile uint32_t    TDH0R;                // [Read-write] mailbox data high register
    volatile uint32_t    TI1R;                 // [Read-write] mailbox identifier register
    volatile uint32_t    TDT1R;                // [Read-write] mailbox data length control and time stamp register
    volatile uint32_t    TDL1R;                // [Read-write] mailbox data low register
    volatile uint32_t    TDH1R;                // [Read-write] mailbox data high register
    volatile uint32_t    TI2R;                 // [Read-write] mailbox identifier register
    volatile uint32_t    TDT2R;                // [Read-write] mailbox data length control and time stamp register
    volatile uint32_t    TDL2R;                // [Read-write] mailbox data low register
    volatile uint32_t    TDH2R;                // [Read-write] mailbox data high register
    volatile uint32_t    RI0R;                 // [Read-only] receive FIFO mailbox identifier register
    volatile uint32_t    RDT0R;                // [Read-only] mailbox data high register
    volatile uint32_t    RDL0R;                // [Read-only] mailbox data high register
    volatile uint32_t    RDH0R;                // [Read-only] receive FIFO mailbox data high register
    volatile uint32_t    RI1R;                 // [Read-only] mailbox data high register
    volatile uint32_t    RDT1R;                // [Read-only] mailbox data high register
    volatile uint32_t    RDL1R;                // [Read-only] mailbox data high register
    volatile uint32_t    RDH1R;                // [Read-only] mailbox data high register
    reserved_t<12>       _1;
    volatile uint32_t    FMR;                  // [Read-write] filter master register
    volatile uint32_t    FM1R;                 // [Read-write] filter mode register
    reserved_t<1>        _2;
    volatile uint32_t    FS1R;                 // [Read-write] filter scale register
    reserved_t<1>        _3;
    volatile uint32_t    FFA1R;                // [Read-write] filter FIFO assignment register
    reserved_t<1>        _4;
    volatile uint32_t    FA1R;                 // [Read-write] filter activation register
    reserved_t<8>        _5;
    volatile uint32_t    F0R1;                 // [Read-write] Filter bank 0 register 1
    volatile uint32_t    F0R2;                 // [Read-write] Filter bank 0 register 2
    volatile uint32_t    F1R1;                 // [Read-write] Filter bank 1 register 1
    volatile uint32_t    F1R2;                 // [Read-write] Filter bank 1 register 2
    volatile uint32_t    F2R1;                 // [Read-write] Filter bank 2 register 1
    volatile uint32_t    F2R2;                 // [Read-write] Filter bank 2 register 2
    volatile uint32_t    F3R1;                 // [Read-write] Filter bank 3 register 1
    volatile uint32_t    F3R2;                 // [Read-write] Filter bank 3 register 2
    volatile uint32_t    F4R1;                 // [Read-write] Filter bank 4 register 1
    volatile uint32_t    F4R2;                 // [Read-write] Filter bank 4 register 2
    volatile uint32_t    F5R1;                 // [Read-write] Filter bank 5 register 1
    volatile uint32_t    F5R2;                 // [Read-write] Filter bank 5 register 2
    volatile uint32_t    F6R1;                 // [Read-write] Filter bank 6 register 1
    volatile uint32_t    F6R2;                 // [Read-write] Filter bank 6 register 2
    volatile uint32_t    F7R1;                 // [Read-write] Filter bank 7 register 1
    volatile uint32_t    F7R2;                 // [Read-write] Filter bank 7 register 2
    volatile uint32_t    F8R1;                 // [Read-write] Filter bank 8 register 1
    volatile uint32_t    F8R2;                 // [Read-write] Filter bank 8 register 2
    volatile uint32_t    F9R1;                 // [Read-write] Filter bank 9 register 1
    volatile uint32_t    F9R2;                 // [Read-write] Filter bank 9 register 2
    volatile uint32_t    F10R1;                // [Read-write] Filter bank 10 register 1
    volatile uint32_t    F10R2;                // [Read-write] Filter bank 10 register 2
    volatile uint32_t    F11R1;                // [Read-write] Filter bank 11 register 1
    volatile uint32_t    F11R2;                // [Read-write] Filter bank 11 register 2
    volatile uint32_t    F12R1;                // [Read-write] Filter bank 4 register 1
    volatile uint32_t    F12R2;                // [Read-write] Filter bank 12 register 2
    volatile uint32_t    F13R1;                // [Read-write] Filter bank 13 register 1
    volatile uint32_t    F13R2;                // [Read-write] Filter bank 13 register 2
    volatile uint32_t    F14R1;                // [Read-write] Filter bank 14 register 1
    volatile uint32_t    F14R2;                // [Read-write] Filter bank 14 register 2
    volatile uint32_t    F15R1;                // [Read-write] Filter bank 15 register 1
    volatile uint32_t    F15R2;                // [Read-write] Filter bank 15 register 2
    volatile uint32_t    F16R1;                // [Read-write] Filter bank 16 register 1
    volatile uint32_t    F16R2;                // [Read-write] Filter bank 16 register 2
    volatile uint32_t    F17R1;                // [Read-write] Filter bank 17 register 1
    volatile uint32_t    F17R2;                // [Read-write] Filter bank 17 register 2
    volatile uint32_t    F18R1;                // [Read-write] Filter bank 18 register 1
    volatile uint32_t    F18R2;                // [Read-write] Filter bank 18 register 2
    volatile uint32_t    F19R1;                // [Read-write] Filter bank 19 register 1
    volatile uint32_t    F19R2;                // [Read-write] Filter bank 19 register 2
    volatile uint32_t    F20R1;                // [Read-write] Filter bank 20 register 1
    volatile uint32_t    F20R2;                // [Read-write] Filter bank 20 register 2
    volatile uint32_t    F21R1;                // [Read-write] Filter bank 21 register 1
    volatile uint32_t    F21R2;                // [Read-write] Filter bank 21 register 2
    volatile uint32_t    F22R1;                // [Read-write] Filter bank 22 register 1
    volatile uint32_t    F22R2;                // [Read-write] Filter bank 22 register 2
    volatile uint32_t    F23R1;                // [Read-write] Filter bank 23 register 1
    volatile uint32_t    F23R2;                // [Read-write] Filter bank 23 register 2
    volatile uint32_t    F24R1;                // [Read-write] Filter bank 24 register 1
    volatile uint32_t    F24R2;                // [Read-write] Filter bank 24 register 2
    volatile uint32_t    F25R1;                // [Read-write] Filter bank 25 register 1
    volatile uint32_t    F25R2;                // [Read-write] Filter bank 25 register 2
    volatile uint32_t    F26R1;                // [Read-write] Filter bank 26 register 1
    volatile uint32_t    F26R2;                // [Read-write] Filter bank 26 register 2
    volatile uint32_t    F27R1;                // [Read-write] Filter bank 27 register 1
    volatile uint32_t    F27R2;                // [Read-write] Filter bank 27 register 2

    static constexpr uint32_t MCR_DBF = 0x10000;        // DBF
    static constexpr uint32_t MCR_RESET = 0x8000;       // RESET
    static constexpr uint32_t MCR_TTCM = 0x80;          // TTCM
    static constexpr uint32_t MCR_ABOM = 0x40;          // ABOM
    static constexpr uint32_t MCR_AWUM = 0x20;          // AWUM
    static constexpr uint32_t MCR_NART = 0x10;          // NART
    static constexpr uint32_t MCR_RFLM = 0x8;           // RFLM
    static constexpr uint32_t MCR_TXFP = 0x4;           // TXFP
    static constexpr uint32_t MCR_SLEEP = 0x2;          // SLEEP
    static constexpr uint32_t MCR_INRQ = 0x1;           // INRQ
    static const uint32_t MCR_RESET_VALUE = 0x10002;

    static constexpr uint32_t MSR_RX = 0x800;           // RX, Read-only
    static constexpr uint32_t MSR_SAMP = 0x400;         // SAMP, Read-only
    static constexpr uint32_t MSR_RXM = 0x200;          // RXM, Read-only
    static constexpr uint32_t MSR_TXM = 0x100;          // TXM, Read-only
    static constexpr uint32_t MSR_SLAKI = 0x10;         // SLAKI, Read-write
    static constexpr uint32_t MSR_WKUI = 0x8;           // WKUI, Read-write
    static constexpr uint32_t MSR_ERRI = 0x4;           // ERRI, Read-write
    static constexpr uint32_t MSR_SLAK = 0x2;           // SLAK, Read-only
    static constexpr uint32_t MSR_INAK = 0x1;           // INAK, Read-only
    static const uint32_t MSR_RESET_VALUE = 0xc02;

    static constexpr uint32_t TSR_LOW2 = 0x80000000;    // Lowest priority flag for mailbox 2, Read-only
    static constexpr uint32_t TSR_LOW1 = 0x40000000;    // Lowest priority flag for mailbox 1, Read-only
    static constexpr uint32_t TSR_LOW0 = 0x20000000;    // Lowest priority flag for mailbox 0, Read-only
    static constexpr uint32_t TSR_TME2 = 0x10000000;    // Lowest priority flag for mailbox 2, Read-only
    static constexpr uint32_t TSR_TME1 = 0x8000000;     // Lowest priority flag for mailbox 1, Read-only
    static constexpr uint32_t TSR_TME0 = 0x4000000;     // Lowest priority flag for mailbox 0, Read-only
    template<uint32_t X>
    static constexpr uint32_t TSR_CODE =                // CODE (2 bits), Read-only
        bit_field_t<24, 0x3>::value<X>();
    static constexpr uint32_t TSR_ABRQ2 = 0x800000;     // ABRQ2, Read-write
    static constexpr uint32_t TSR_TERR2 = 0x80000;      // TERR2, Read-write
    static constexpr uint32_t TSR_ALST2 = 0x40000;      // ALST2, Read-write
    static constexpr uint32_t TSR_TXOK2 = 0x20000;      // TXOK2, Read-write
    static constexpr uint32_t TSR_RQCP2 = 0x10000;      // RQCP2, Read-write
    static constexpr uint32_t TSR_ABRQ1 = 0x8000;       // ABRQ1, Read-write
    static constexpr uint32_t TSR_TERR1 = 0x800;        // TERR1, Read-write
    static constexpr uint32_t TSR_ALST1 = 0x400;        // ALST1, Read-write
    static constexpr uint32_t TSR_TXOK1 = 0x200;        // TXOK1, Read-write
    static constexpr uint32_t TSR_RQCP1 = 0x100;        // RQCP1, Read-write
    static constexpr uint32_t TSR_ABRQ0 = 0x80;         // ABRQ0, Read-write
    static constexpr uint32_t TSR_TERR0 = 0x8;          // TERR0, Read-write
    static constexpr uint32_t TSR_ALST0 = 0x4;          // ALST0, Read-write
    static constexpr uint32_t TSR_TXOK0 = 0x2;          // TXOK0, Read-write
    static constexpr uint32_t TSR_RQCP0 = 0x1;          // RQCP0, Read-write
    static const uint32_t TSR_RESET_VALUE = 0x1c000000;

    static constexpr uint32_t RF0R_RFOM0 = 0x20;         // RFOM0, Read-write
    static constexpr uint32_t RF0R_FOVR0 = 0x10;         // FOVR0, Read-write
    static constexpr uint32_t RF0R_FULL0 = 0x8;          // FULL0, Read-write
    template<uint32_t X>
    static constexpr uint32_t RF0R_FMP0 =                // FMP0 (2 bits), Read-only
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t RF0R_RESET_VALUE = 0x0;

    static constexpr uint32_t RF1R_RFOM1 = 0x20;         // RFOM1, Read-write
    static constexpr uint32_t RF1R_FOVR1 = 0x10;         // FOVR1, Read-write
    static constexpr uint32_t RF1R_FULL1 = 0x8;          // FULL1, Read-write
    template<uint32_t X>
    static constexpr uint32_t RF1R_FMP1 =                // FMP1 (2 bits), Read-only
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t RF1R_RESET_VALUE = 0x0;

    static constexpr uint32_t IER_SLKIE = 0x20000;      // SLKIE
    static constexpr uint32_t IER_WKUIE = 0x10000;      // WKUIE
    static constexpr uint32_t IER_ERRIE = 0x8000;       // ERRIE
    static constexpr uint32_t IER_LECIE = 0x800;        // LECIE
    static constexpr uint32_t IER_BOFIE = 0x400;        // BOFIE
    static constexpr uint32_t IER_EPVIE = 0x200;        // EPVIE
    static constexpr uint32_t IER_EWGIE = 0x100;        // EWGIE
    static constexpr uint32_t IER_FOVIE1 = 0x40;        // FOVIE1
    static constexpr uint32_t IER_FFIE1 = 0x20;         // FFIE1
    static constexpr uint32_t IER_FMPIE1 = 0x10;        // FMPIE1
    static constexpr uint32_t IER_FOVIE0 = 0x8;         // FOVIE0
    static constexpr uint32_t IER_FFIE0 = 0x4;          // FFIE0
    static constexpr uint32_t IER_FMPIE0 = 0x2;         // FMPIE0
    static constexpr uint32_t IER_TMEIE = 0x1;          // TMEIE
    static const uint32_t IER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ESR_REC =                 // REC (8 bits), Read-only
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ESR_TEC =                 // TEC (8 bits), Read-only
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ESR_LEC =                 // LEC (3 bits), Read-write
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t ESR_BOFF = 0x4;           // BOFF, Read-only
    static constexpr uint32_t ESR_EPVF = 0x2;           // EPVF, Read-only
    static constexpr uint32_t ESR_EWGF = 0x1;           // EWGF, Read-only
    static const uint32_t ESR_RESET_VALUE = 0x0;

    static constexpr uint32_t BTR_SILM = 0x80000000;    // SILM
    static constexpr uint32_t BTR_LBKM = 0x40000000;    // LBKM
    template<uint32_t X>
    static constexpr uint32_t BTR_SJW =                 // SJW (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR_TS2 =                 // TS2 (3 bits)
        bit_field_t<20, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR_TS1 =                 // TS1 (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR_BRP =                 // BRP (10 bits)
        bit_field_t<0, 0x3ff>::value<X>();
    static const uint32_t BTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TI0R_STID =                // STID (11 bits)
        bit_field_t<21, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TI0R_EXID =                // EXID (18 bits)
        bit_field_t<3, 0x3ffff>::value<X>();
    static constexpr uint32_t TI0R_IDE = 0x4;            // IDE
    static constexpr uint32_t TI0R_RTR = 0x2;            // RTR
    static constexpr uint32_t TI0R_TXRQ = 0x1;           // TXRQ
    static const uint32_t TI0R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDT0R_TIME =                // TIME (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static constexpr uint32_t TDT0R_TGT = 0x100;          // TGT
    template<uint32_t X>
    static constexpr uint32_t TDT0R_DLC =                 // DLC (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t TDT0R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDL0R_DATA3 =               // DATA3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDL0R_DATA2 =               // DATA2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDL0R_DATA1 =               // DATA1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDL0R_DATA0 =               // DATA0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t TDL0R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDH0R_DATA7 =               // DATA7 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDH0R_DATA6 =               // DATA6 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDH0R_DATA5 =               // DATA5 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDH0R_DATA4 =               // DATA4 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t TDH0R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TI1R_STID =                // STID (11 bits)
        bit_field_t<21, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TI1R_EXID =                // EXID (18 bits)
        bit_field_t<3, 0x3ffff>::value<X>();
    static constexpr uint32_t TI1R_IDE = 0x4;            // IDE
    static constexpr uint32_t TI1R_RTR = 0x2;            // RTR
    static constexpr uint32_t TI1R_TXRQ = 0x1;           // TXRQ
    static const uint32_t TI1R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDT1R_TIME =                // TIME (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static constexpr uint32_t TDT1R_TGT = 0x100;          // TGT
    template<uint32_t X>
    static constexpr uint32_t TDT1R_DLC =                 // DLC (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t TDT1R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDL1R_DATA3 =               // DATA3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDL1R_DATA2 =               // DATA2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDL1R_DATA1 =               // DATA1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDL1R_DATA0 =               // DATA0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t TDL1R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDH1R_DATA7 =               // DATA7 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDH1R_DATA6 =               // DATA6 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDH1R_DATA5 =               // DATA5 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDH1R_DATA4 =               // DATA4 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t TDH1R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TI2R_STID =                // STID (11 bits)
        bit_field_t<21, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TI2R_EXID =                // EXID (18 bits)
        bit_field_t<3, 0x3ffff>::value<X>();
    static constexpr uint32_t TI2R_IDE = 0x4;            // IDE
    static constexpr uint32_t TI2R_RTR = 0x2;            // RTR
    static constexpr uint32_t TI2R_TXRQ = 0x1;           // TXRQ
    static const uint32_t TI2R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDT2R_TIME =                // TIME (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static constexpr uint32_t TDT2R_TGT = 0x100;          // TGT
    template<uint32_t X>
    static constexpr uint32_t TDT2R_DLC =                 // DLC (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t TDT2R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDL2R_DATA3 =               // DATA3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDL2R_DATA2 =               // DATA2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDL2R_DATA1 =               // DATA1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDL2R_DATA0 =               // DATA0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t TDL2R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDH2R_DATA7 =               // DATA7 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDH2R_DATA6 =               // DATA6 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDH2R_DATA5 =               // DATA5 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDH2R_DATA4 =               // DATA4 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t TDH2R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RI0R_STID =                // STID (11 bits)
        bit_field_t<21, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RI0R_EXID =                // EXID (18 bits)
        bit_field_t<3, 0x3ffff>::value<X>();
    static constexpr uint32_t RI0R_IDE = 0x4;            // IDE
    static constexpr uint32_t RI0R_RTR = 0x2;            // RTR
    static const uint32_t RI0R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RDT0R_TIME =                // TIME (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDT0R_FMI =                 // FMI (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDT0R_DLC =                 // DLC (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t RDT0R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RDL0R_DATA3 =               // DATA3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDL0R_DATA2 =               // DATA2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDL0R_DATA1 =               // DATA1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDL0R_DATA0 =               // DATA0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t RDL0R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RDH0R_DATA7 =               // DATA7 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDH0R_DATA6 =               // DATA6 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDH0R_DATA5 =               // DATA5 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDH0R_DATA4 =               // DATA4 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t RDH0R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RI1R_STID =                // STID (11 bits)
        bit_field_t<21, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RI1R_EXID =                // EXID (18 bits)
        bit_field_t<3, 0x3ffff>::value<X>();
    static constexpr uint32_t RI1R_IDE = 0x4;            // IDE
    static constexpr uint32_t RI1R_RTR = 0x2;            // RTR
    static const uint32_t RI1R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RDT1R_TIME =                // TIME (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDT1R_FMI =                 // FMI (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDT1R_DLC =                 // DLC (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t RDT1R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RDL1R_DATA3 =               // DATA3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDL1R_DATA2 =               // DATA2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDL1R_DATA1 =               // DATA1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDL1R_DATA0 =               // DATA0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t RDL1R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RDH1R_DATA7 =               // DATA7 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDH1R_DATA6 =               // DATA6 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDH1R_DATA5 =               // DATA5 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDH1R_DATA4 =               // DATA4 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t RDH1R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t FMR_CAN2SB =              // CAN2SB (6 bits)
        bit_field_t<8, 0x3f>::value<X>();
    static constexpr uint32_t FMR_FINIT = 0x1;          // FINIT
    static const uint32_t FMR_RESET_VALUE = 0x2a1c0e01;

    static constexpr uint32_t FM1R_FBM0 = 0x1;           // Filter mode
    static constexpr uint32_t FM1R_FBM1 = 0x2;           // Filter mode
    static constexpr uint32_t FM1R_FBM2 = 0x4;           // Filter mode
    static constexpr uint32_t FM1R_FBM3 = 0x8;           // Filter mode
    static constexpr uint32_t FM1R_FBM4 = 0x10;          // Filter mode
    static constexpr uint32_t FM1R_FBM5 = 0x20;          // Filter mode
    static constexpr uint32_t FM1R_FBM6 = 0x40;          // Filter mode
    static constexpr uint32_t FM1R_FBM7 = 0x80;          // Filter mode
    static constexpr uint32_t FM1R_FBM8 = 0x100;         // Filter mode
    static constexpr uint32_t FM1R_FBM9 = 0x200;         // Filter mode
    static constexpr uint32_t FM1R_FBM10 = 0x400;        // Filter mode
    static constexpr uint32_t FM1R_FBM11 = 0x800;        // Filter mode
    static constexpr uint32_t FM1R_FBM12 = 0x1000;       // Filter mode
    static constexpr uint32_t FM1R_FBM13 = 0x2000;       // Filter mode
    static constexpr uint32_t FM1R_FBM14 = 0x4000;       // Filter mode
    static constexpr uint32_t FM1R_FBM15 = 0x8000;       // Filter mode
    static constexpr uint32_t FM1R_FBM16 = 0x10000;      // Filter mode
    static constexpr uint32_t FM1R_FBM17 = 0x20000;      // Filter mode
    static constexpr uint32_t FM1R_FBM18 = 0x40000;      // Filter mode
    static constexpr uint32_t FM1R_FBM19 = 0x80000;      // Filter mode
    static constexpr uint32_t FM1R_FBM20 = 0x100000;     // Filter mode
    static constexpr uint32_t FM1R_FBM21 = 0x200000;     // Filter mode
    static constexpr uint32_t FM1R_FBM22 = 0x400000;     // Filter mode
    static constexpr uint32_t FM1R_FBM23 = 0x800000;     // Filter mode
    static constexpr uint32_t FM1R_FBM24 = 0x1000000;    // Filter mode
    static constexpr uint32_t FM1R_FBM25 = 0x2000000;    // Filter mode
    static constexpr uint32_t FM1R_FBM26 = 0x4000000;    // Filter mode
    static constexpr uint32_t FM1R_FBM27 = 0x8000000;    // Filter mode
    static const uint32_t FM1R_RESET_VALUE = 0x0;

    static constexpr uint32_t FS1R_FSC0 = 0x1;           // Filter scale configuration
    static constexpr uint32_t FS1R_FSC1 = 0x2;           // Filter scale configuration
    static constexpr uint32_t FS1R_FSC2 = 0x4;           // Filter scale configuration
    static constexpr uint32_t FS1R_FSC3 = 0x8;           // Filter scale configuration
    static constexpr uint32_t FS1R_FSC4 = 0x10;          // Filter scale configuration
    static constexpr uint32_t FS1R_FSC5 = 0x20;          // Filter scale configuration
    static constexpr uint32_t FS1R_FSC6 = 0x40;          // Filter scale configuration
    static constexpr uint32_t FS1R_FSC7 = 0x80;          // Filter scale configuration
    static constexpr uint32_t FS1R_FSC8 = 0x100;         // Filter scale configuration
    static constexpr uint32_t FS1R_FSC9 = 0x200;         // Filter scale configuration
    static constexpr uint32_t FS1R_FSC10 = 0x400;        // Filter scale configuration
    static constexpr uint32_t FS1R_FSC11 = 0x800;        // Filter scale configuration
    static constexpr uint32_t FS1R_FSC12 = 0x1000;       // Filter scale configuration
    static constexpr uint32_t FS1R_FSC13 = 0x2000;       // Filter scale configuration
    static constexpr uint32_t FS1R_FSC14 = 0x4000;       // Filter scale configuration
    static constexpr uint32_t FS1R_FSC15 = 0x8000;       // Filter scale configuration
    static constexpr uint32_t FS1R_FSC16 = 0x10000;      // Filter scale configuration
    static constexpr uint32_t FS1R_FSC17 = 0x20000;      // Filter scale configuration
    static constexpr uint32_t FS1R_FSC18 = 0x40000;      // Filter scale configuration
    static constexpr uint32_t FS1R_FSC19 = 0x80000;      // Filter scale configuration
    static constexpr uint32_t FS1R_FSC20 = 0x100000;     // Filter scale configuration
    static constexpr uint32_t FS1R_FSC21 = 0x200000;     // Filter scale configuration
    static constexpr uint32_t FS1R_FSC22 = 0x400000;     // Filter scale configuration
    static constexpr uint32_t FS1R_FSC23 = 0x800000;     // Filter scale configuration
    static constexpr uint32_t FS1R_FSC24 = 0x1000000;    // Filter scale configuration
    static constexpr uint32_t FS1R_FSC25 = 0x2000000;    // Filter scale configuration
    static constexpr uint32_t FS1R_FSC26 = 0x4000000;    // Filter scale configuration
    static constexpr uint32_t FS1R_FSC27 = 0x8000000;    // Filter scale configuration
    static const uint32_t FS1R_RESET_VALUE = 0x0;

    static constexpr uint32_t FFA1R_FFA0 = 0x1;           // Filter FIFO assignment for filter 0
    static constexpr uint32_t FFA1R_FFA1 = 0x2;           // Filter FIFO assignment for filter 1
    static constexpr uint32_t FFA1R_FFA2 = 0x4;           // Filter FIFO assignment for filter 2
    static constexpr uint32_t FFA1R_FFA3 = 0x8;           // Filter FIFO assignment for filter 3
    static constexpr uint32_t FFA1R_FFA4 = 0x10;          // Filter FIFO assignment for filter 4
    static constexpr uint32_t FFA1R_FFA5 = 0x20;          // Filter FIFO assignment for filter 5
    static constexpr uint32_t FFA1R_FFA6 = 0x40;          // Filter FIFO assignment for filter 6
    static constexpr uint32_t FFA1R_FFA7 = 0x80;          // Filter FIFO assignment for filter 7
    static constexpr uint32_t FFA1R_FFA8 = 0x100;         // Filter FIFO assignment for filter 8
    static constexpr uint32_t FFA1R_FFA9 = 0x200;         // Filter FIFO assignment for filter 9
    static constexpr uint32_t FFA1R_FFA10 = 0x400;        // Filter FIFO assignment for filter 10
    static constexpr uint32_t FFA1R_FFA11 = 0x800;        // Filter FIFO assignment for filter 11
    static constexpr uint32_t FFA1R_FFA12 = 0x1000;       // Filter FIFO assignment for filter 12
    static constexpr uint32_t FFA1R_FFA13 = 0x2000;       // Filter FIFO assignment for filter 13
    static constexpr uint32_t FFA1R_FFA14 = 0x4000;       // Filter FIFO assignment for filter 14
    static constexpr uint32_t FFA1R_FFA15 = 0x8000;       // Filter FIFO assignment for filter 15
    static constexpr uint32_t FFA1R_FFA16 = 0x10000;      // Filter FIFO assignment for filter 16
    static constexpr uint32_t FFA1R_FFA17 = 0x20000;      // Filter FIFO assignment for filter 17
    static constexpr uint32_t FFA1R_FFA18 = 0x40000;      // Filter FIFO assignment for filter 18
    static constexpr uint32_t FFA1R_FFA19 = 0x80000;      // Filter FIFO assignment for filter 19
    static constexpr uint32_t FFA1R_FFA20 = 0x100000;     // Filter FIFO assignment for filter 20
    static constexpr uint32_t FFA1R_FFA21 = 0x200000;     // Filter FIFO assignment for filter 21
    static constexpr uint32_t FFA1R_FFA22 = 0x400000;     // Filter FIFO assignment for filter 22
    static constexpr uint32_t FFA1R_FFA23 = 0x800000;     // Filter FIFO assignment for filter 23
    static constexpr uint32_t FFA1R_FFA24 = 0x1000000;    // Filter FIFO assignment for filter 24
    static constexpr uint32_t FFA1R_FFA25 = 0x2000000;    // Filter FIFO assignment for filter 25
    static constexpr uint32_t FFA1R_FFA26 = 0x4000000;    // Filter FIFO assignment for filter 26
    static constexpr uint32_t FFA1R_FFA27 = 0x8000000;    // Filter FIFO assignment for filter 27
    static const uint32_t FFA1R_RESET_VALUE = 0x0;

    static constexpr uint32_t FA1R_FACT0 = 0x1;          // Filter active
    static constexpr uint32_t FA1R_FACT1 = 0x2;          // Filter active
    static constexpr uint32_t FA1R_FACT2 = 0x4;          // Filter active
    static constexpr uint32_t FA1R_FACT3 = 0x8;          // Filter active
    static constexpr uint32_t FA1R_FACT4 = 0x10;         // Filter active
    static constexpr uint32_t FA1R_FACT5 = 0x20;         // Filter active
    static constexpr uint32_t FA1R_FACT6 = 0x40;         // Filter active
    static constexpr uint32_t FA1R_FACT7 = 0x80;         // Filter active
    static constexpr uint32_t FA1R_FACT8 = 0x100;        // Filter active
    static constexpr uint32_t FA1R_FACT9 = 0x200;        // Filter active
    static constexpr uint32_t FA1R_FACT10 = 0x400;       // Filter active
    static constexpr uint32_t FA1R_FACT11 = 0x800;       // Filter active
    static constexpr uint32_t FA1R_FACT12 = 0x1000;      // Filter active
    static constexpr uint32_t FA1R_FACT13 = 0x2000;      // Filter active
    static constexpr uint32_t FA1R_FACT14 = 0x4000;      // Filter active
    static constexpr uint32_t FA1R_FACT15 = 0x8000;      // Filter active
    static constexpr uint32_t FA1R_FACT16 = 0x10000;     // Filter active
    static constexpr uint32_t FA1R_FACT17 = 0x20000;     // Filter active
    static constexpr uint32_t FA1R_FACT18 = 0x40000;     // Filter active
    static constexpr uint32_t FA1R_FACT19 = 0x80000;     // Filter active
    static constexpr uint32_t FA1R_FACT20 = 0x100000;    // Filter active
    static constexpr uint32_t FA1R_FACT21 = 0x200000;    // Filter active
    static constexpr uint32_t FA1R_FACT22 = 0x400000;    // Filter active
    static constexpr uint32_t FA1R_FACT23 = 0x800000;    // Filter active
    static constexpr uint32_t FA1R_FACT24 = 0x1000000;   // Filter active
    static constexpr uint32_t FA1R_FACT25 = 0x2000000;   // Filter active
    static constexpr uint32_t FA1R_FACT26 = 0x4000000;   // Filter active
    static constexpr uint32_t FA1R_FACT27 = 0x8000000;   // Filter active
    static const uint32_t FA1R_RESET_VALUE = 0x0;

    static constexpr uint32_t F0R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F0R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F0R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F0R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F0R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F0R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F0R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F0R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F0R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F0R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F0R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F0R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F0R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F0R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F0R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F0R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F0R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F0R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F0R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F0R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F0R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F0R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F0R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F0R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F0R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F0R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F0R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F0R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F0R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F0R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F0R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F0R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F0R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F0R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F0R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F0R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F0R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F0R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F0R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F0R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F0R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F0R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F0R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F0R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F0R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F0R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F0R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F0R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F0R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F0R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F0R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F0R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F0R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F0R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F0R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F0R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F0R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F0R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F0R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F0R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F0R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F0R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F0R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F0R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F0R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F0R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F1R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F1R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F1R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F1R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F1R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F1R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F1R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F1R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F1R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F1R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F1R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F1R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F1R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F1R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F1R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F1R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F1R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F1R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F1R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F1R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F1R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F1R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F1R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F1R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F1R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F1R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F1R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F1R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F1R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F1R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F1R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F1R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F1R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F1R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F1R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F1R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F1R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F1R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F1R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F1R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F1R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F1R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F1R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F1R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F1R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F1R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F1R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F1R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F1R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F1R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F1R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F1R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F1R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F1R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F1R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F1R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F1R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F1R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F1R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F1R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F1R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F1R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F1R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F1R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F1R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F1R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F2R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F2R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F2R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F2R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F2R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F2R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F2R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F2R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F2R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F2R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F2R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F2R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F2R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F2R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F2R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F2R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F2R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F2R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F2R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F2R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F2R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F2R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F2R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F2R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F2R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F2R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F2R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F2R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F2R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F2R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F2R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F2R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F2R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F2R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F2R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F2R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F2R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F2R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F2R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F2R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F2R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F2R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F2R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F2R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F2R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F2R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F2R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F2R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F2R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F2R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F2R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F2R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F2R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F2R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F2R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F2R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F2R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F2R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F2R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F2R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F2R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F2R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F2R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F2R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F2R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F2R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F3R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F3R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F3R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F3R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F3R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F3R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F3R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F3R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F3R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F3R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F3R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F3R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F3R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F3R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F3R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F3R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F3R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F3R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F3R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F3R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F3R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F3R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F3R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F3R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F3R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F3R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F3R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F3R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F3R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F3R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F3R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F3R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F3R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F3R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F3R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F3R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F3R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F3R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F3R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F3R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F3R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F3R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F3R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F3R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F3R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F3R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F3R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F3R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F3R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F3R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F3R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F3R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F3R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F3R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F3R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F3R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F3R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F3R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F3R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F3R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F3R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F3R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F3R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F3R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F3R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F3R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F4R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F4R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F4R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F4R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F4R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F4R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F4R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F4R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F4R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F4R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F4R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F4R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F4R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F4R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F4R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F4R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F4R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F4R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F4R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F4R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F4R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F4R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F4R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F4R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F4R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F4R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F4R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F4R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F4R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F4R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F4R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F4R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F4R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F4R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F4R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F4R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F4R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F4R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F4R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F4R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F4R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F4R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F4R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F4R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F4R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F4R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F4R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F4R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F4R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F4R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F4R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F4R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F4R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F4R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F4R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F4R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F4R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F4R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F4R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F4R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F4R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F4R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F4R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F4R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F4R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F4R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F5R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F5R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F5R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F5R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F5R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F5R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F5R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F5R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F5R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F5R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F5R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F5R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F5R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F5R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F5R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F5R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F5R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F5R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F5R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F5R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F5R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F5R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F5R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F5R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F5R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F5R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F5R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F5R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F5R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F5R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F5R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F5R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F5R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F5R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F5R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F5R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F5R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F5R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F5R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F5R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F5R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F5R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F5R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F5R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F5R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F5R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F5R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F5R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F5R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F5R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F5R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F5R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F5R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F5R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F5R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F5R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F5R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F5R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F5R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F5R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F5R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F5R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F5R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F5R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F5R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F5R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F6R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F6R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F6R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F6R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F6R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F6R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F6R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F6R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F6R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F6R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F6R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F6R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F6R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F6R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F6R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F6R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F6R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F6R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F6R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F6R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F6R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F6R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F6R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F6R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F6R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F6R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F6R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F6R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F6R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F6R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F6R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F6R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F6R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F6R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F6R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F6R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F6R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F6R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F6R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F6R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F6R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F6R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F6R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F6R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F6R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F6R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F6R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F6R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F6R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F6R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F6R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F6R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F6R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F6R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F6R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F6R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F6R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F6R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F6R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F6R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F6R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F6R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F6R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F6R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F6R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F6R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F7R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F7R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F7R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F7R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F7R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F7R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F7R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F7R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F7R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F7R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F7R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F7R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F7R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F7R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F7R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F7R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F7R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F7R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F7R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F7R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F7R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F7R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F7R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F7R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F7R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F7R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F7R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F7R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F7R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F7R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F7R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F7R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F7R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F7R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F7R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F7R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F7R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F7R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F7R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F7R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F7R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F7R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F7R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F7R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F7R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F7R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F7R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F7R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F7R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F7R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F7R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F7R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F7R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F7R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F7R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F7R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F7R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F7R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F7R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F7R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F7R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F7R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F7R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F7R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F7R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F7R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F8R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F8R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F8R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F8R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F8R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F8R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F8R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F8R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F8R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F8R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F8R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F8R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F8R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F8R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F8R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F8R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F8R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F8R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F8R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F8R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F8R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F8R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F8R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F8R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F8R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F8R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F8R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F8R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F8R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F8R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F8R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F8R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F8R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F8R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F8R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F8R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F8R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F8R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F8R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F8R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F8R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F8R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F8R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F8R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F8R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F8R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F8R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F8R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F8R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F8R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F8R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F8R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F8R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F8R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F8R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F8R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F8R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F8R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F8R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F8R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F8R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F8R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F8R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F8R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F8R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F8R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F9R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F9R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F9R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F9R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F9R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F9R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F9R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F9R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F9R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F9R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F9R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F9R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F9R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F9R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F9R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F9R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F9R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F9R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F9R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F9R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F9R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F9R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F9R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F9R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F9R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F9R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F9R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F9R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F9R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F9R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F9R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F9R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F9R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F9R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F9R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F9R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F9R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F9R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F9R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F9R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F9R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F9R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F9R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F9R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F9R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F9R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F9R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F9R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F9R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F9R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F9R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F9R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F9R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F9R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F9R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F9R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F9R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F9R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F9R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F9R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F9R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F9R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F9R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F9R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F9R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F9R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F10R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F10R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F10R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F10R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F10R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F10R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F10R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F10R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F10R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F10R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F10R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F10R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F10R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F10R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F10R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F10R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F10R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F10R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F10R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F10R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F10R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F10R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F10R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F10R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F10R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F10R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F10R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F10R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F10R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F10R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F10R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F10R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F10R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F10R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F10R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F10R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F10R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F10R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F10R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F10R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F10R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F10R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F10R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F10R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F10R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F10R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F10R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F10R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F10R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F10R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F10R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F10R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F10R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F10R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F10R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F10R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F10R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F10R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F10R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F10R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F10R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F10R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F10R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F10R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F10R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F10R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F11R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F11R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F11R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F11R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F11R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F11R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F11R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F11R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F11R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F11R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F11R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F11R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F11R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F11R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F11R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F11R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F11R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F11R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F11R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F11R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F11R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F11R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F11R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F11R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F11R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F11R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F11R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F11R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F11R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F11R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F11R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F11R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F11R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F11R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F11R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F11R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F11R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F11R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F11R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F11R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F11R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F11R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F11R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F11R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F11R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F11R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F11R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F11R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F11R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F11R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F11R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F11R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F11R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F11R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F11R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F11R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F11R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F11R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F11R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F11R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F11R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F11R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F11R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F11R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F11R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F11R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F12R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F12R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F12R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F12R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F12R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F12R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F12R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F12R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F12R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F12R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F12R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F12R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F12R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F12R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F12R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F12R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F12R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F12R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F12R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F12R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F12R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F12R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F12R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F12R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F12R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F12R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F12R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F12R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F12R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F12R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F12R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F12R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F12R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F12R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F12R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F12R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F12R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F12R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F12R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F12R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F12R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F12R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F12R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F12R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F12R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F12R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F12R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F12R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F12R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F12R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F12R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F12R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F12R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F12R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F12R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F12R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F12R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F12R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F12R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F12R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F12R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F12R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F12R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F12R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F12R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F12R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F13R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F13R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F13R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F13R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F13R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F13R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F13R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F13R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F13R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F13R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F13R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F13R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F13R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F13R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F13R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F13R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F13R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F13R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F13R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F13R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F13R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F13R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F13R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F13R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F13R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F13R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F13R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F13R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F13R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F13R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F13R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F13R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F13R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F13R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F13R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F13R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F13R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F13R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F13R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F13R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F13R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F13R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F13R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F13R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F13R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F13R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F13R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F13R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F13R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F13R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F13R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F13R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F13R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F13R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F13R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F13R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F13R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F13R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F13R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F13R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F13R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F13R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F13R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F13R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F13R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F13R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F14R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F14R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F14R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F14R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F14R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F14R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F14R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F14R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F14R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F14R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F14R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F14R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F14R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F14R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F14R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F14R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F14R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F14R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F14R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F14R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F14R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F14R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F14R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F14R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F14R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F14R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F14R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F14R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F14R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F14R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F14R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F14R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F14R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F14R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F14R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F14R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F14R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F14R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F14R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F14R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F14R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F14R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F14R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F14R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F14R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F14R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F14R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F14R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F14R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F14R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F14R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F14R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F14R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F14R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F14R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F14R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F14R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F14R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F14R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F14R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F14R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F14R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F14R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F14R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F14R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F14R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F15R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F15R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F15R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F15R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F15R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F15R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F15R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F15R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F15R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F15R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F15R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F15R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F15R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F15R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F15R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F15R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F15R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F15R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F15R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F15R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F15R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F15R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F15R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F15R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F15R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F15R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F15R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F15R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F15R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F15R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F15R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F15R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F15R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F15R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F15R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F15R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F15R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F15R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F15R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F15R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F15R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F15R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F15R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F15R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F15R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F15R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F15R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F15R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F15R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F15R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F15R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F15R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F15R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F15R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F15R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F15R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F15R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F15R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F15R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F15R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F15R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F15R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F15R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F15R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F15R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F15R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F16R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F16R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F16R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F16R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F16R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F16R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F16R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F16R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F16R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F16R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F16R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F16R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F16R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F16R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F16R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F16R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F16R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F16R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F16R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F16R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F16R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F16R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F16R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F16R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F16R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F16R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F16R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F16R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F16R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F16R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F16R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F16R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F16R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F16R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F16R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F16R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F16R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F16R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F16R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F16R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F16R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F16R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F16R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F16R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F16R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F16R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F16R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F16R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F16R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F16R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F16R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F16R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F16R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F16R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F16R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F16R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F16R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F16R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F16R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F16R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F16R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F16R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F16R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F16R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F16R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F16R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F17R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F17R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F17R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F17R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F17R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F17R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F17R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F17R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F17R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F17R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F17R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F17R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F17R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F17R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F17R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F17R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F17R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F17R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F17R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F17R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F17R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F17R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F17R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F17R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F17R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F17R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F17R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F17R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F17R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F17R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F17R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F17R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F17R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F17R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F17R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F17R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F17R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F17R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F17R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F17R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F17R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F17R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F17R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F17R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F17R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F17R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F17R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F17R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F17R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F17R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F17R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F17R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F17R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F17R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F17R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F17R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F17R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F17R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F17R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F17R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F17R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F17R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F17R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F17R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F17R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F17R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F18R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F18R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F18R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F18R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F18R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F18R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F18R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F18R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F18R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F18R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F18R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F18R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F18R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F18R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F18R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F18R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F18R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F18R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F18R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F18R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F18R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F18R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F18R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F18R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F18R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F18R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F18R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F18R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F18R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F18R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F18R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F18R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F18R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F18R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F18R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F18R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F18R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F18R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F18R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F18R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F18R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F18R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F18R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F18R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F18R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F18R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F18R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F18R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F18R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F18R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F18R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F18R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F18R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F18R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F18R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F18R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F18R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F18R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F18R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F18R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F18R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F18R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F18R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F18R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F18R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F18R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F19R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F19R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F19R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F19R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F19R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F19R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F19R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F19R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F19R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F19R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F19R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F19R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F19R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F19R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F19R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F19R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F19R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F19R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F19R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F19R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F19R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F19R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F19R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F19R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F19R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F19R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F19R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F19R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F19R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F19R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F19R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F19R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F19R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F19R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F19R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F19R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F19R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F19R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F19R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F19R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F19R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F19R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F19R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F19R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F19R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F19R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F19R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F19R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F19R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F19R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F19R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F19R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F19R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F19R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F19R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F19R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F19R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F19R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F19R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F19R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F19R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F19R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F19R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F19R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F19R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F19R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F20R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F20R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F20R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F20R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F20R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F20R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F20R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F20R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F20R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F20R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F20R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F20R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F20R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F20R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F20R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F20R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F20R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F20R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F20R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F20R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F20R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F20R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F20R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F20R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F20R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F20R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F20R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F20R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F20R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F20R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F20R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F20R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F20R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F20R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F20R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F20R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F20R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F20R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F20R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F20R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F20R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F20R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F20R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F20R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F20R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F20R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F20R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F20R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F20R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F20R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F20R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F20R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F20R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F20R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F20R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F20R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F20R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F20R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F20R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F20R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F20R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F20R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F20R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F20R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F20R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F20R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F21R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F21R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F21R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F21R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F21R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F21R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F21R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F21R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F21R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F21R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F21R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F21R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F21R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F21R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F21R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F21R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F21R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F21R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F21R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F21R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F21R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F21R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F21R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F21R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F21R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F21R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F21R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F21R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F21R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F21R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F21R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F21R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F21R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F21R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F21R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F21R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F21R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F21R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F21R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F21R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F21R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F21R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F21R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F21R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F21R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F21R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F21R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F21R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F21R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F21R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F21R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F21R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F21R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F21R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F21R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F21R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F21R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F21R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F21R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F21R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F21R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F21R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F21R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F21R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F21R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F21R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F22R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F22R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F22R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F22R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F22R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F22R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F22R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F22R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F22R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F22R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F22R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F22R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F22R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F22R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F22R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F22R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F22R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F22R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F22R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F22R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F22R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F22R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F22R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F22R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F22R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F22R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F22R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F22R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F22R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F22R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F22R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F22R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F22R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F22R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F22R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F22R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F22R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F22R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F22R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F22R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F22R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F22R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F22R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F22R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F22R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F22R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F22R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F22R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F22R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F22R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F22R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F22R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F22R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F22R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F22R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F22R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F22R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F22R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F22R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F22R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F22R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F22R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F22R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F22R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F22R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F22R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F23R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F23R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F23R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F23R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F23R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F23R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F23R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F23R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F23R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F23R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F23R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F23R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F23R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F23R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F23R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F23R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F23R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F23R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F23R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F23R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F23R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F23R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F23R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F23R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F23R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F23R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F23R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F23R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F23R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F23R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F23R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F23R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F23R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F23R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F23R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F23R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F23R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F23R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F23R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F23R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F23R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F23R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F23R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F23R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F23R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F23R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F23R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F23R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F23R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F23R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F23R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F23R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F23R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F23R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F23R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F23R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F23R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F23R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F23R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F23R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F23R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F23R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F23R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F23R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F23R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F23R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F24R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F24R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F24R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F24R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F24R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F24R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F24R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F24R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F24R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F24R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F24R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F24R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F24R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F24R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F24R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F24R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F24R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F24R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F24R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F24R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F24R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F24R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F24R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F24R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F24R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F24R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F24R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F24R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F24R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F24R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F24R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F24R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F24R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F24R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F24R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F24R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F24R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F24R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F24R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F24R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F24R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F24R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F24R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F24R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F24R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F24R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F24R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F24R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F24R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F24R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F24R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F24R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F24R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F24R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F24R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F24R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F24R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F24R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F24R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F24R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F24R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F24R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F24R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F24R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F24R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F24R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F25R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F25R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F25R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F25R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F25R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F25R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F25R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F25R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F25R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F25R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F25R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F25R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F25R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F25R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F25R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F25R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F25R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F25R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F25R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F25R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F25R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F25R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F25R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F25R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F25R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F25R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F25R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F25R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F25R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F25R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F25R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F25R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F25R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F25R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F25R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F25R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F25R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F25R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F25R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F25R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F25R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F25R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F25R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F25R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F25R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F25R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F25R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F25R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F25R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F25R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F25R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F25R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F25R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F25R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F25R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F25R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F25R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F25R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F25R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F25R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F25R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F25R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F25R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F25R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F25R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F25R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F26R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F26R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F26R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F26R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F26R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F26R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F26R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F26R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F26R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F26R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F26R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F26R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F26R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F26R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F26R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F26R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F26R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F26R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F26R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F26R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F26R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F26R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F26R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F26R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F26R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F26R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F26R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F26R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F26R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F26R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F26R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F26R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F26R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F26R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F26R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F26R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F26R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F26R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F26R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F26R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F26R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F26R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F26R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F26R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F26R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F26R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F26R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F26R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F26R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F26R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F26R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F26R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F26R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F26R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F26R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F26R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F26R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F26R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F26R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F26R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F26R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F26R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F26R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F26R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F26R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F26R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F27R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F27R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F27R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F27R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F27R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F27R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F27R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F27R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F27R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F27R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F27R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F27R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F27R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F27R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F27R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F27R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F27R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F27R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F27R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F27R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F27R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F27R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F27R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F27R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F27R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F27R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F27R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F27R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F27R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F27R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F27R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F27R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F27R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F27R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F27R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F27R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F27R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F27R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F27R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F27R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F27R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F27R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F27R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F27R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F27R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F27R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F27R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F27R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F27R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F27R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F27R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F27R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F27R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F27R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F27R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F27R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F27R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F27R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F27R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F27R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F27R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F27R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F27R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F27R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F27R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F27R2_RESET_VALUE = 0x0;

    static constexpr uint8_t CAN1_RX0 = 20; // CAN1 RX0 interrupts
    static constexpr uint8_t CAN1_RX1 = 21; // CAN1 RX1 interrupts
    static constexpr uint8_t CAN1_SCE = 22; // CAN1 SCE interrupt
    static constexpr uint8_t CAN1_TX = 19; // CAN1 TX interrupts
};

static can1_t& CAN1 = *reinterpret_cast<can1_t*>(0x40006400);

#define HAVE_PERIPHERAL_CAN1


////
//
//    Controller area network
//
////

struct can2_t
{
    volatile uint32_t    MCR;                  // [Read-write] master control register
    volatile uint32_t    MSR;                  // master status register
    volatile uint32_t    TSR;                  // transmit status register
    volatile uint32_t    RF0R;                 // receive FIFO 0 register
    volatile uint32_t    RF1R;                 // receive FIFO 1 register
    volatile uint32_t    IER;                  // [Read-write] interrupt enable register
    volatile uint32_t    ESR;                  // interrupt enable register
    volatile uint32_t    BTR;                  // [Read-write] bit timing register
    reserved_t<88>       _0;
    volatile uint32_t    TI0R;                 // [Read-write] TX mailbox identifier register
    volatile uint32_t    TDT0R;                // [Read-write] mailbox data length control and time stamp register
    volatile uint32_t    TDL0R;                // [Read-write] mailbox data low register
    volatile uint32_t    TDH0R;                // [Read-write] mailbox data high register
    volatile uint32_t    TI1R;                 // [Read-write] mailbox identifier register
    volatile uint32_t    TDT1R;                // [Read-write] mailbox data length control and time stamp register
    volatile uint32_t    TDL1R;                // [Read-write] mailbox data low register
    volatile uint32_t    TDH1R;                // [Read-write] mailbox data high register
    volatile uint32_t    TI2R;                 // [Read-write] mailbox identifier register
    volatile uint32_t    TDT2R;                // [Read-write] mailbox data length control and time stamp register
    volatile uint32_t    TDL2R;                // [Read-write] mailbox data low register
    volatile uint32_t    TDH2R;                // [Read-write] mailbox data high register
    volatile uint32_t    RI0R;                 // [Read-only] receive FIFO mailbox identifier register
    volatile uint32_t    RDT0R;                // [Read-only] mailbox data high register
    volatile uint32_t    RDL0R;                // [Read-only] mailbox data high register
    volatile uint32_t    RDH0R;                // [Read-only] receive FIFO mailbox data high register
    volatile uint32_t    RI1R;                 // [Read-only] mailbox data high register
    volatile uint32_t    RDT1R;                // [Read-only] mailbox data high register
    volatile uint32_t    RDL1R;                // [Read-only] mailbox data high register
    volatile uint32_t    RDH1R;                // [Read-only] mailbox data high register
    reserved_t<12>       _1;
    volatile uint32_t    FMR;                  // [Read-write] filter master register
    volatile uint32_t    FM1R;                 // [Read-write] filter mode register
    reserved_t<1>        _2;
    volatile uint32_t    FS1R;                 // [Read-write] filter scale register
    reserved_t<1>        _3;
    volatile uint32_t    FFA1R;                // [Read-write] filter FIFO assignment register
    reserved_t<1>        _4;
    volatile uint32_t    FA1R;                 // [Read-write] filter activation register
    reserved_t<8>        _5;
    volatile uint32_t    F0R1;                 // [Read-write] Filter bank 0 register 1
    volatile uint32_t    F0R2;                 // [Read-write] Filter bank 0 register 2
    volatile uint32_t    F1R1;                 // [Read-write] Filter bank 1 register 1
    volatile uint32_t    F1R2;                 // [Read-write] Filter bank 1 register 2
    volatile uint32_t    F2R1;                 // [Read-write] Filter bank 2 register 1
    volatile uint32_t    F2R2;                 // [Read-write] Filter bank 2 register 2
    volatile uint32_t    F3R1;                 // [Read-write] Filter bank 3 register 1
    volatile uint32_t    F3R2;                 // [Read-write] Filter bank 3 register 2
    volatile uint32_t    F4R1;                 // [Read-write] Filter bank 4 register 1
    volatile uint32_t    F4R2;                 // [Read-write] Filter bank 4 register 2
    volatile uint32_t    F5R1;                 // [Read-write] Filter bank 5 register 1
    volatile uint32_t    F5R2;                 // [Read-write] Filter bank 5 register 2
    volatile uint32_t    F6R1;                 // [Read-write] Filter bank 6 register 1
    volatile uint32_t    F6R2;                 // [Read-write] Filter bank 6 register 2
    volatile uint32_t    F7R1;                 // [Read-write] Filter bank 7 register 1
    volatile uint32_t    F7R2;                 // [Read-write] Filter bank 7 register 2
    volatile uint32_t    F8R1;                 // [Read-write] Filter bank 8 register 1
    volatile uint32_t    F8R2;                 // [Read-write] Filter bank 8 register 2
    volatile uint32_t    F9R1;                 // [Read-write] Filter bank 9 register 1
    volatile uint32_t    F9R2;                 // [Read-write] Filter bank 9 register 2
    volatile uint32_t    F10R1;                // [Read-write] Filter bank 10 register 1
    volatile uint32_t    F10R2;                // [Read-write] Filter bank 10 register 2
    volatile uint32_t    F11R1;                // [Read-write] Filter bank 11 register 1
    volatile uint32_t    F11R2;                // [Read-write] Filter bank 11 register 2
    volatile uint32_t    F12R1;                // [Read-write] Filter bank 4 register 1
    volatile uint32_t    F12R2;                // [Read-write] Filter bank 12 register 2
    volatile uint32_t    F13R1;                // [Read-write] Filter bank 13 register 1
    volatile uint32_t    F13R2;                // [Read-write] Filter bank 13 register 2
    volatile uint32_t    F14R1;                // [Read-write] Filter bank 14 register 1
    volatile uint32_t    F14R2;                // [Read-write] Filter bank 14 register 2
    volatile uint32_t    F15R1;                // [Read-write] Filter bank 15 register 1
    volatile uint32_t    F15R2;                // [Read-write] Filter bank 15 register 2
    volatile uint32_t    F16R1;                // [Read-write] Filter bank 16 register 1
    volatile uint32_t    F16R2;                // [Read-write] Filter bank 16 register 2
    volatile uint32_t    F17R1;                // [Read-write] Filter bank 17 register 1
    volatile uint32_t    F17R2;                // [Read-write] Filter bank 17 register 2
    volatile uint32_t    F18R1;                // [Read-write] Filter bank 18 register 1
    volatile uint32_t    F18R2;                // [Read-write] Filter bank 18 register 2
    volatile uint32_t    F19R1;                // [Read-write] Filter bank 19 register 1
    volatile uint32_t    F19R2;                // [Read-write] Filter bank 19 register 2
    volatile uint32_t    F20R1;                // [Read-write] Filter bank 20 register 1
    volatile uint32_t    F20R2;                // [Read-write] Filter bank 20 register 2
    volatile uint32_t    F21R1;                // [Read-write] Filter bank 21 register 1
    volatile uint32_t    F21R2;                // [Read-write] Filter bank 21 register 2
    volatile uint32_t    F22R1;                // [Read-write] Filter bank 22 register 1
    volatile uint32_t    F22R2;                // [Read-write] Filter bank 22 register 2
    volatile uint32_t    F23R1;                // [Read-write] Filter bank 23 register 1
    volatile uint32_t    F23R2;                // [Read-write] Filter bank 23 register 2
    volatile uint32_t    F24R1;                // [Read-write] Filter bank 24 register 1
    volatile uint32_t    F24R2;                // [Read-write] Filter bank 24 register 2
    volatile uint32_t    F25R1;                // [Read-write] Filter bank 25 register 1
    volatile uint32_t    F25R2;                // [Read-write] Filter bank 25 register 2
    volatile uint32_t    F26R1;                // [Read-write] Filter bank 26 register 1
    volatile uint32_t    F26R2;                // [Read-write] Filter bank 26 register 2
    volatile uint32_t    F27R1;                // [Read-write] Filter bank 27 register 1
    volatile uint32_t    F27R2;                // [Read-write] Filter bank 27 register 2

    static constexpr uint32_t MCR_DBF = 0x10000;        // DBF
    static constexpr uint32_t MCR_RESET = 0x8000;       // RESET
    static constexpr uint32_t MCR_TTCM = 0x80;          // TTCM
    static constexpr uint32_t MCR_ABOM = 0x40;          // ABOM
    static constexpr uint32_t MCR_AWUM = 0x20;          // AWUM
    static constexpr uint32_t MCR_NART = 0x10;          // NART
    static constexpr uint32_t MCR_RFLM = 0x8;           // RFLM
    static constexpr uint32_t MCR_TXFP = 0x4;           // TXFP
    static constexpr uint32_t MCR_SLEEP = 0x2;          // SLEEP
    static constexpr uint32_t MCR_INRQ = 0x1;           // INRQ
    static const uint32_t MCR_RESET_VALUE = 0x10002;

    static constexpr uint32_t MSR_RX = 0x800;           // RX, Read-only
    static constexpr uint32_t MSR_SAMP = 0x400;         // SAMP, Read-only
    static constexpr uint32_t MSR_RXM = 0x200;          // RXM, Read-only
    static constexpr uint32_t MSR_TXM = 0x100;          // TXM, Read-only
    static constexpr uint32_t MSR_SLAKI = 0x10;         // SLAKI, Read-write
    static constexpr uint32_t MSR_WKUI = 0x8;           // WKUI, Read-write
    static constexpr uint32_t MSR_ERRI = 0x4;           // ERRI, Read-write
    static constexpr uint32_t MSR_SLAK = 0x2;           // SLAK, Read-only
    static constexpr uint32_t MSR_INAK = 0x1;           // INAK, Read-only
    static const uint32_t MSR_RESET_VALUE = 0xc02;

    static constexpr uint32_t TSR_LOW2 = 0x80000000;    // Lowest priority flag for mailbox 2, Read-only
    static constexpr uint32_t TSR_LOW1 = 0x40000000;    // Lowest priority flag for mailbox 1, Read-only
    static constexpr uint32_t TSR_LOW0 = 0x20000000;    // Lowest priority flag for mailbox 0, Read-only
    static constexpr uint32_t TSR_TME2 = 0x10000000;    // Lowest priority flag for mailbox 2, Read-only
    static constexpr uint32_t TSR_TME1 = 0x8000000;     // Lowest priority flag for mailbox 1, Read-only
    static constexpr uint32_t TSR_TME0 = 0x4000000;     // Lowest priority flag for mailbox 0, Read-only
    template<uint32_t X>
    static constexpr uint32_t TSR_CODE =                // CODE (2 bits), Read-only
        bit_field_t<24, 0x3>::value<X>();
    static constexpr uint32_t TSR_ABRQ2 = 0x800000;     // ABRQ2, Read-write
    static constexpr uint32_t TSR_TERR2 = 0x80000;      // TERR2, Read-write
    static constexpr uint32_t TSR_ALST2 = 0x40000;      // ALST2, Read-write
    static constexpr uint32_t TSR_TXOK2 = 0x20000;      // TXOK2, Read-write
    static constexpr uint32_t TSR_RQCP2 = 0x10000;      // RQCP2, Read-write
    static constexpr uint32_t TSR_ABRQ1 = 0x8000;       // ABRQ1, Read-write
    static constexpr uint32_t TSR_TERR1 = 0x800;        // TERR1, Read-write
    static constexpr uint32_t TSR_ALST1 = 0x400;        // ALST1, Read-write
    static constexpr uint32_t TSR_TXOK1 = 0x200;        // TXOK1, Read-write
    static constexpr uint32_t TSR_RQCP1 = 0x100;        // RQCP1, Read-write
    static constexpr uint32_t TSR_ABRQ0 = 0x80;         // ABRQ0, Read-write
    static constexpr uint32_t TSR_TERR0 = 0x8;          // TERR0, Read-write
    static constexpr uint32_t TSR_ALST0 = 0x4;          // ALST0, Read-write
    static constexpr uint32_t TSR_TXOK0 = 0x2;          // TXOK0, Read-write
    static constexpr uint32_t TSR_RQCP0 = 0x1;          // RQCP0, Read-write
    static const uint32_t TSR_RESET_VALUE = 0x1c000000;

    static constexpr uint32_t RF0R_RFOM0 = 0x20;         // RFOM0, Read-write
    static constexpr uint32_t RF0R_FOVR0 = 0x10;         // FOVR0, Read-write
    static constexpr uint32_t RF0R_FULL0 = 0x8;          // FULL0, Read-write
    template<uint32_t X>
    static constexpr uint32_t RF0R_FMP0 =                // FMP0 (2 bits), Read-only
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t RF0R_RESET_VALUE = 0x0;

    static constexpr uint32_t RF1R_RFOM1 = 0x20;         // RFOM1, Read-write
    static constexpr uint32_t RF1R_FOVR1 = 0x10;         // FOVR1, Read-write
    static constexpr uint32_t RF1R_FULL1 = 0x8;          // FULL1, Read-write
    template<uint32_t X>
    static constexpr uint32_t RF1R_FMP1 =                // FMP1 (2 bits), Read-only
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t RF1R_RESET_VALUE = 0x0;

    static constexpr uint32_t IER_SLKIE = 0x20000;      // SLKIE
    static constexpr uint32_t IER_WKUIE = 0x10000;      // WKUIE
    static constexpr uint32_t IER_ERRIE = 0x8000;       // ERRIE
    static constexpr uint32_t IER_LECIE = 0x800;        // LECIE
    static constexpr uint32_t IER_BOFIE = 0x400;        // BOFIE
    static constexpr uint32_t IER_EPVIE = 0x200;        // EPVIE
    static constexpr uint32_t IER_EWGIE = 0x100;        // EWGIE
    static constexpr uint32_t IER_FOVIE1 = 0x40;        // FOVIE1
    static constexpr uint32_t IER_FFIE1 = 0x20;         // FFIE1
    static constexpr uint32_t IER_FMPIE1 = 0x10;        // FMPIE1
    static constexpr uint32_t IER_FOVIE0 = 0x8;         // FOVIE0
    static constexpr uint32_t IER_FFIE0 = 0x4;          // FFIE0
    static constexpr uint32_t IER_FMPIE0 = 0x2;         // FMPIE0
    static constexpr uint32_t IER_TMEIE = 0x1;          // TMEIE
    static const uint32_t IER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ESR_REC =                 // REC (8 bits), Read-only
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ESR_TEC =                 // TEC (8 bits), Read-only
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ESR_LEC =                 // LEC (3 bits), Read-write
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t ESR_BOFF = 0x4;           // BOFF, Read-only
    static constexpr uint32_t ESR_EPVF = 0x2;           // EPVF, Read-only
    static constexpr uint32_t ESR_EWGF = 0x1;           // EWGF, Read-only
    static const uint32_t ESR_RESET_VALUE = 0x0;

    static constexpr uint32_t BTR_SILM = 0x80000000;    // SILM
    static constexpr uint32_t BTR_LBKM = 0x40000000;    // LBKM
    template<uint32_t X>
    static constexpr uint32_t BTR_SJW =                 // SJW (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR_TS2 =                 // TS2 (3 bits)
        bit_field_t<20, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR_TS1 =                 // TS1 (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR_BRP =                 // BRP (10 bits)
        bit_field_t<0, 0x3ff>::value<X>();
    static const uint32_t BTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TI0R_STID =                // STID (11 bits)
        bit_field_t<21, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TI0R_EXID =                // EXID (18 bits)
        bit_field_t<3, 0x3ffff>::value<X>();
    static constexpr uint32_t TI0R_IDE = 0x4;            // IDE
    static constexpr uint32_t TI0R_RTR = 0x2;            // RTR
    static constexpr uint32_t TI0R_TXRQ = 0x1;           // TXRQ
    static const uint32_t TI0R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDT0R_TIME =                // TIME (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static constexpr uint32_t TDT0R_TGT = 0x100;          // TGT
    template<uint32_t X>
    static constexpr uint32_t TDT0R_DLC =                 // DLC (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t TDT0R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDL0R_DATA3 =               // DATA3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDL0R_DATA2 =               // DATA2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDL0R_DATA1 =               // DATA1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDL0R_DATA0 =               // DATA0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t TDL0R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDH0R_DATA7 =               // DATA7 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDH0R_DATA6 =               // DATA6 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDH0R_DATA5 =               // DATA5 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDH0R_DATA4 =               // DATA4 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t TDH0R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TI1R_STID =                // STID (11 bits)
        bit_field_t<21, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TI1R_EXID =                // EXID (18 bits)
        bit_field_t<3, 0x3ffff>::value<X>();
    static constexpr uint32_t TI1R_IDE = 0x4;            // IDE
    static constexpr uint32_t TI1R_RTR = 0x2;            // RTR
    static constexpr uint32_t TI1R_TXRQ = 0x1;           // TXRQ
    static const uint32_t TI1R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDT1R_TIME =                // TIME (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static constexpr uint32_t TDT1R_TGT = 0x100;          // TGT
    template<uint32_t X>
    static constexpr uint32_t TDT1R_DLC =                 // DLC (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t TDT1R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDL1R_DATA3 =               // DATA3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDL1R_DATA2 =               // DATA2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDL1R_DATA1 =               // DATA1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDL1R_DATA0 =               // DATA0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t TDL1R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDH1R_DATA7 =               // DATA7 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDH1R_DATA6 =               // DATA6 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDH1R_DATA5 =               // DATA5 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDH1R_DATA4 =               // DATA4 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t TDH1R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TI2R_STID =                // STID (11 bits)
        bit_field_t<21, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TI2R_EXID =                // EXID (18 bits)
        bit_field_t<3, 0x3ffff>::value<X>();
    static constexpr uint32_t TI2R_IDE = 0x4;            // IDE
    static constexpr uint32_t TI2R_RTR = 0x2;            // RTR
    static constexpr uint32_t TI2R_TXRQ = 0x1;           // TXRQ
    static const uint32_t TI2R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDT2R_TIME =                // TIME (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static constexpr uint32_t TDT2R_TGT = 0x100;          // TGT
    template<uint32_t X>
    static constexpr uint32_t TDT2R_DLC =                 // DLC (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t TDT2R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDL2R_DATA3 =               // DATA3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDL2R_DATA2 =               // DATA2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDL2R_DATA1 =               // DATA1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDL2R_DATA0 =               // DATA0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t TDL2R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDH2R_DATA7 =               // DATA7 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDH2R_DATA6 =               // DATA6 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDH2R_DATA5 =               // DATA5 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDH2R_DATA4 =               // DATA4 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t TDH2R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RI0R_STID =                // STID (11 bits)
        bit_field_t<21, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RI0R_EXID =                // EXID (18 bits)
        bit_field_t<3, 0x3ffff>::value<X>();
    static constexpr uint32_t RI0R_IDE = 0x4;            // IDE
    static constexpr uint32_t RI0R_RTR = 0x2;            // RTR
    static const uint32_t RI0R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RDT0R_TIME =                // TIME (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDT0R_FMI =                 // FMI (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDT0R_DLC =                 // DLC (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t RDT0R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RDL0R_DATA3 =               // DATA3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDL0R_DATA2 =               // DATA2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDL0R_DATA1 =               // DATA1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDL0R_DATA0 =               // DATA0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t RDL0R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RDH0R_DATA7 =               // DATA7 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDH0R_DATA6 =               // DATA6 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDH0R_DATA5 =               // DATA5 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDH0R_DATA4 =               // DATA4 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t RDH0R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RI1R_STID =                // STID (11 bits)
        bit_field_t<21, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RI1R_EXID =                // EXID (18 bits)
        bit_field_t<3, 0x3ffff>::value<X>();
    static constexpr uint32_t RI1R_IDE = 0x4;            // IDE
    static constexpr uint32_t RI1R_RTR = 0x2;            // RTR
    static const uint32_t RI1R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RDT1R_TIME =                // TIME (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDT1R_FMI =                 // FMI (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDT1R_DLC =                 // DLC (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t RDT1R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RDL1R_DATA3 =               // DATA3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDL1R_DATA2 =               // DATA2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDL1R_DATA1 =               // DATA1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDL1R_DATA0 =               // DATA0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t RDL1R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RDH1R_DATA7 =               // DATA7 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDH1R_DATA6 =               // DATA6 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDH1R_DATA5 =               // DATA5 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDH1R_DATA4 =               // DATA4 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t RDH1R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t FMR_CAN2SB =              // CAN2SB (6 bits)
        bit_field_t<8, 0x3f>::value<X>();
    static constexpr uint32_t FMR_FINIT = 0x1;          // FINIT
    static const uint32_t FMR_RESET_VALUE = 0x2a1c0e01;

    static constexpr uint32_t FM1R_FBM0 = 0x1;           // Filter mode
    static constexpr uint32_t FM1R_FBM1 = 0x2;           // Filter mode
    static constexpr uint32_t FM1R_FBM2 = 0x4;           // Filter mode
    static constexpr uint32_t FM1R_FBM3 = 0x8;           // Filter mode
    static constexpr uint32_t FM1R_FBM4 = 0x10;          // Filter mode
    static constexpr uint32_t FM1R_FBM5 = 0x20;          // Filter mode
    static constexpr uint32_t FM1R_FBM6 = 0x40;          // Filter mode
    static constexpr uint32_t FM1R_FBM7 = 0x80;          // Filter mode
    static constexpr uint32_t FM1R_FBM8 = 0x100;         // Filter mode
    static constexpr uint32_t FM1R_FBM9 = 0x200;         // Filter mode
    static constexpr uint32_t FM1R_FBM10 = 0x400;        // Filter mode
    static constexpr uint32_t FM1R_FBM11 = 0x800;        // Filter mode
    static constexpr uint32_t FM1R_FBM12 = 0x1000;       // Filter mode
    static constexpr uint32_t FM1R_FBM13 = 0x2000;       // Filter mode
    static constexpr uint32_t FM1R_FBM14 = 0x4000;       // Filter mode
    static constexpr uint32_t FM1R_FBM15 = 0x8000;       // Filter mode
    static constexpr uint32_t FM1R_FBM16 = 0x10000;      // Filter mode
    static constexpr uint32_t FM1R_FBM17 = 0x20000;      // Filter mode
    static constexpr uint32_t FM1R_FBM18 = 0x40000;      // Filter mode
    static constexpr uint32_t FM1R_FBM19 = 0x80000;      // Filter mode
    static constexpr uint32_t FM1R_FBM20 = 0x100000;     // Filter mode
    static constexpr uint32_t FM1R_FBM21 = 0x200000;     // Filter mode
    static constexpr uint32_t FM1R_FBM22 = 0x400000;     // Filter mode
    static constexpr uint32_t FM1R_FBM23 = 0x800000;     // Filter mode
    static constexpr uint32_t FM1R_FBM24 = 0x1000000;    // Filter mode
    static constexpr uint32_t FM1R_FBM25 = 0x2000000;    // Filter mode
    static constexpr uint32_t FM1R_FBM26 = 0x4000000;    // Filter mode
    static constexpr uint32_t FM1R_FBM27 = 0x8000000;    // Filter mode
    static const uint32_t FM1R_RESET_VALUE = 0x0;

    static constexpr uint32_t FS1R_FSC0 = 0x1;           // Filter scale configuration
    static constexpr uint32_t FS1R_FSC1 = 0x2;           // Filter scale configuration
    static constexpr uint32_t FS1R_FSC2 = 0x4;           // Filter scale configuration
    static constexpr uint32_t FS1R_FSC3 = 0x8;           // Filter scale configuration
    static constexpr uint32_t FS1R_FSC4 = 0x10;          // Filter scale configuration
    static constexpr uint32_t FS1R_FSC5 = 0x20;          // Filter scale configuration
    static constexpr uint32_t FS1R_FSC6 = 0x40;          // Filter scale configuration
    static constexpr uint32_t FS1R_FSC7 = 0x80;          // Filter scale configuration
    static constexpr uint32_t FS1R_FSC8 = 0x100;         // Filter scale configuration
    static constexpr uint32_t FS1R_FSC9 = 0x200;         // Filter scale configuration
    static constexpr uint32_t FS1R_FSC10 = 0x400;        // Filter scale configuration
    static constexpr uint32_t FS1R_FSC11 = 0x800;        // Filter scale configuration
    static constexpr uint32_t FS1R_FSC12 = 0x1000;       // Filter scale configuration
    static constexpr uint32_t FS1R_FSC13 = 0x2000;       // Filter scale configuration
    static constexpr uint32_t FS1R_FSC14 = 0x4000;       // Filter scale configuration
    static constexpr uint32_t FS1R_FSC15 = 0x8000;       // Filter scale configuration
    static constexpr uint32_t FS1R_FSC16 = 0x10000;      // Filter scale configuration
    static constexpr uint32_t FS1R_FSC17 = 0x20000;      // Filter scale configuration
    static constexpr uint32_t FS1R_FSC18 = 0x40000;      // Filter scale configuration
    static constexpr uint32_t FS1R_FSC19 = 0x80000;      // Filter scale configuration
    static constexpr uint32_t FS1R_FSC20 = 0x100000;     // Filter scale configuration
    static constexpr uint32_t FS1R_FSC21 = 0x200000;     // Filter scale configuration
    static constexpr uint32_t FS1R_FSC22 = 0x400000;     // Filter scale configuration
    static constexpr uint32_t FS1R_FSC23 = 0x800000;     // Filter scale configuration
    static constexpr uint32_t FS1R_FSC24 = 0x1000000;    // Filter scale configuration
    static constexpr uint32_t FS1R_FSC25 = 0x2000000;    // Filter scale configuration
    static constexpr uint32_t FS1R_FSC26 = 0x4000000;    // Filter scale configuration
    static constexpr uint32_t FS1R_FSC27 = 0x8000000;    // Filter scale configuration
    static const uint32_t FS1R_RESET_VALUE = 0x0;

    static constexpr uint32_t FFA1R_FFA0 = 0x1;           // Filter FIFO assignment for filter 0
    static constexpr uint32_t FFA1R_FFA1 = 0x2;           // Filter FIFO assignment for filter 1
    static constexpr uint32_t FFA1R_FFA2 = 0x4;           // Filter FIFO assignment for filter 2
    static constexpr uint32_t FFA1R_FFA3 = 0x8;           // Filter FIFO assignment for filter 3
    static constexpr uint32_t FFA1R_FFA4 = 0x10;          // Filter FIFO assignment for filter 4
    static constexpr uint32_t FFA1R_FFA5 = 0x20;          // Filter FIFO assignment for filter 5
    static constexpr uint32_t FFA1R_FFA6 = 0x40;          // Filter FIFO assignment for filter 6
    static constexpr uint32_t FFA1R_FFA7 = 0x80;          // Filter FIFO assignment for filter 7
    static constexpr uint32_t FFA1R_FFA8 = 0x100;         // Filter FIFO assignment for filter 8
    static constexpr uint32_t FFA1R_FFA9 = 0x200;         // Filter FIFO assignment for filter 9
    static constexpr uint32_t FFA1R_FFA10 = 0x400;        // Filter FIFO assignment for filter 10
    static constexpr uint32_t FFA1R_FFA11 = 0x800;        // Filter FIFO assignment for filter 11
    static constexpr uint32_t FFA1R_FFA12 = 0x1000;       // Filter FIFO assignment for filter 12
    static constexpr uint32_t FFA1R_FFA13 = 0x2000;       // Filter FIFO assignment for filter 13
    static constexpr uint32_t FFA1R_FFA14 = 0x4000;       // Filter FIFO assignment for filter 14
    static constexpr uint32_t FFA1R_FFA15 = 0x8000;       // Filter FIFO assignment for filter 15
    static constexpr uint32_t FFA1R_FFA16 = 0x10000;      // Filter FIFO assignment for filter 16
    static constexpr uint32_t FFA1R_FFA17 = 0x20000;      // Filter FIFO assignment for filter 17
    static constexpr uint32_t FFA1R_FFA18 = 0x40000;      // Filter FIFO assignment for filter 18
    static constexpr uint32_t FFA1R_FFA19 = 0x80000;      // Filter FIFO assignment for filter 19
    static constexpr uint32_t FFA1R_FFA20 = 0x100000;     // Filter FIFO assignment for filter 20
    static constexpr uint32_t FFA1R_FFA21 = 0x200000;     // Filter FIFO assignment for filter 21
    static constexpr uint32_t FFA1R_FFA22 = 0x400000;     // Filter FIFO assignment for filter 22
    static constexpr uint32_t FFA1R_FFA23 = 0x800000;     // Filter FIFO assignment for filter 23
    static constexpr uint32_t FFA1R_FFA24 = 0x1000000;    // Filter FIFO assignment for filter 24
    static constexpr uint32_t FFA1R_FFA25 = 0x2000000;    // Filter FIFO assignment for filter 25
    static constexpr uint32_t FFA1R_FFA26 = 0x4000000;    // Filter FIFO assignment for filter 26
    static constexpr uint32_t FFA1R_FFA27 = 0x8000000;    // Filter FIFO assignment for filter 27
    static const uint32_t FFA1R_RESET_VALUE = 0x0;

    static constexpr uint32_t FA1R_FACT0 = 0x1;          // Filter active
    static constexpr uint32_t FA1R_FACT1 = 0x2;          // Filter active
    static constexpr uint32_t FA1R_FACT2 = 0x4;          // Filter active
    static constexpr uint32_t FA1R_FACT3 = 0x8;          // Filter active
    static constexpr uint32_t FA1R_FACT4 = 0x10;         // Filter active
    static constexpr uint32_t FA1R_FACT5 = 0x20;         // Filter active
    static constexpr uint32_t FA1R_FACT6 = 0x40;         // Filter active
    static constexpr uint32_t FA1R_FACT7 = 0x80;         // Filter active
    static constexpr uint32_t FA1R_FACT8 = 0x100;        // Filter active
    static constexpr uint32_t FA1R_FACT9 = 0x200;        // Filter active
    static constexpr uint32_t FA1R_FACT10 = 0x400;       // Filter active
    static constexpr uint32_t FA1R_FACT11 = 0x800;       // Filter active
    static constexpr uint32_t FA1R_FACT12 = 0x1000;      // Filter active
    static constexpr uint32_t FA1R_FACT13 = 0x2000;      // Filter active
    static constexpr uint32_t FA1R_FACT14 = 0x4000;      // Filter active
    static constexpr uint32_t FA1R_FACT15 = 0x8000;      // Filter active
    static constexpr uint32_t FA1R_FACT16 = 0x10000;     // Filter active
    static constexpr uint32_t FA1R_FACT17 = 0x20000;     // Filter active
    static constexpr uint32_t FA1R_FACT18 = 0x40000;     // Filter active
    static constexpr uint32_t FA1R_FACT19 = 0x80000;     // Filter active
    static constexpr uint32_t FA1R_FACT20 = 0x100000;    // Filter active
    static constexpr uint32_t FA1R_FACT21 = 0x200000;    // Filter active
    static constexpr uint32_t FA1R_FACT22 = 0x400000;    // Filter active
    static constexpr uint32_t FA1R_FACT23 = 0x800000;    // Filter active
    static constexpr uint32_t FA1R_FACT24 = 0x1000000;   // Filter active
    static constexpr uint32_t FA1R_FACT25 = 0x2000000;   // Filter active
    static constexpr uint32_t FA1R_FACT26 = 0x4000000;   // Filter active
    static constexpr uint32_t FA1R_FACT27 = 0x8000000;   // Filter active
    static const uint32_t FA1R_RESET_VALUE = 0x0;

    static constexpr uint32_t F0R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F0R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F0R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F0R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F0R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F0R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F0R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F0R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F0R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F0R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F0R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F0R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F0R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F0R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F0R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F0R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F0R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F0R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F0R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F0R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F0R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F0R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F0R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F0R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F0R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F0R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F0R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F0R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F0R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F0R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F0R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F0R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F0R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F0R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F0R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F0R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F0R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F0R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F0R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F0R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F0R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F0R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F0R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F0R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F0R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F0R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F0R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F0R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F0R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F0R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F0R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F0R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F0R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F0R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F0R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F0R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F0R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F0R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F0R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F0R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F0R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F0R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F0R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F0R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F0R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F0R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F1R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F1R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F1R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F1R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F1R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F1R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F1R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F1R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F1R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F1R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F1R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F1R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F1R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F1R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F1R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F1R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F1R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F1R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F1R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F1R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F1R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F1R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F1R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F1R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F1R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F1R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F1R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F1R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F1R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F1R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F1R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F1R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F1R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F1R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F1R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F1R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F1R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F1R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F1R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F1R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F1R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F1R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F1R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F1R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F1R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F1R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F1R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F1R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F1R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F1R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F1R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F1R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F1R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F1R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F1R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F1R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F1R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F1R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F1R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F1R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F1R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F1R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F1R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F1R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F1R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F1R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F2R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F2R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F2R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F2R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F2R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F2R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F2R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F2R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F2R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F2R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F2R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F2R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F2R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F2R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F2R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F2R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F2R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F2R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F2R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F2R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F2R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F2R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F2R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F2R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F2R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F2R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F2R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F2R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F2R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F2R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F2R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F2R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F2R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F2R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F2R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F2R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F2R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F2R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F2R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F2R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F2R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F2R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F2R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F2R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F2R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F2R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F2R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F2R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F2R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F2R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F2R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F2R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F2R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F2R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F2R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F2R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F2R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F2R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F2R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F2R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F2R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F2R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F2R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F2R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F2R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F2R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F3R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F3R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F3R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F3R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F3R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F3R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F3R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F3R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F3R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F3R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F3R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F3R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F3R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F3R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F3R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F3R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F3R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F3R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F3R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F3R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F3R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F3R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F3R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F3R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F3R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F3R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F3R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F3R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F3R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F3R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F3R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F3R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F3R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F3R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F3R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F3R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F3R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F3R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F3R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F3R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F3R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F3R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F3R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F3R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F3R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F3R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F3R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F3R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F3R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F3R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F3R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F3R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F3R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F3R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F3R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F3R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F3R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F3R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F3R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F3R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F3R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F3R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F3R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F3R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F3R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F3R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F4R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F4R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F4R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F4R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F4R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F4R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F4R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F4R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F4R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F4R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F4R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F4R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F4R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F4R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F4R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F4R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F4R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F4R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F4R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F4R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F4R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F4R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F4R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F4R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F4R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F4R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F4R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F4R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F4R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F4R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F4R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F4R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F4R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F4R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F4R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F4R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F4R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F4R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F4R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F4R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F4R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F4R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F4R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F4R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F4R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F4R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F4R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F4R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F4R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F4R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F4R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F4R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F4R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F4R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F4R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F4R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F4R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F4R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F4R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F4R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F4R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F4R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F4R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F4R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F4R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F4R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F5R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F5R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F5R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F5R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F5R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F5R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F5R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F5R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F5R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F5R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F5R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F5R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F5R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F5R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F5R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F5R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F5R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F5R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F5R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F5R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F5R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F5R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F5R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F5R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F5R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F5R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F5R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F5R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F5R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F5R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F5R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F5R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F5R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F5R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F5R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F5R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F5R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F5R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F5R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F5R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F5R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F5R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F5R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F5R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F5R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F5R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F5R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F5R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F5R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F5R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F5R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F5R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F5R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F5R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F5R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F5R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F5R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F5R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F5R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F5R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F5R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F5R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F5R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F5R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F5R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F5R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F6R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F6R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F6R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F6R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F6R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F6R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F6R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F6R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F6R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F6R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F6R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F6R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F6R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F6R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F6R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F6R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F6R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F6R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F6R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F6R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F6R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F6R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F6R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F6R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F6R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F6R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F6R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F6R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F6R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F6R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F6R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F6R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F6R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F6R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F6R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F6R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F6R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F6R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F6R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F6R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F6R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F6R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F6R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F6R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F6R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F6R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F6R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F6R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F6R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F6R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F6R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F6R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F6R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F6R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F6R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F6R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F6R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F6R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F6R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F6R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F6R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F6R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F6R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F6R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F6R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F6R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F7R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F7R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F7R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F7R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F7R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F7R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F7R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F7R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F7R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F7R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F7R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F7R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F7R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F7R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F7R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F7R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F7R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F7R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F7R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F7R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F7R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F7R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F7R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F7R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F7R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F7R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F7R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F7R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F7R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F7R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F7R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F7R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F7R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F7R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F7R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F7R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F7R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F7R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F7R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F7R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F7R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F7R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F7R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F7R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F7R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F7R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F7R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F7R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F7R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F7R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F7R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F7R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F7R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F7R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F7R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F7R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F7R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F7R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F7R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F7R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F7R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F7R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F7R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F7R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F7R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F7R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F8R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F8R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F8R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F8R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F8R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F8R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F8R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F8R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F8R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F8R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F8R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F8R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F8R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F8R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F8R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F8R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F8R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F8R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F8R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F8R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F8R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F8R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F8R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F8R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F8R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F8R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F8R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F8R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F8R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F8R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F8R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F8R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F8R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F8R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F8R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F8R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F8R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F8R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F8R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F8R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F8R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F8R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F8R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F8R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F8R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F8R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F8R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F8R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F8R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F8R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F8R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F8R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F8R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F8R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F8R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F8R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F8R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F8R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F8R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F8R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F8R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F8R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F8R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F8R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F8R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F8R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F9R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F9R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F9R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F9R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F9R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F9R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F9R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F9R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F9R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F9R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F9R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F9R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F9R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F9R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F9R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F9R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F9R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F9R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F9R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F9R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F9R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F9R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F9R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F9R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F9R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F9R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F9R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F9R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F9R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F9R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F9R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F9R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F9R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F9R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F9R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F9R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F9R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F9R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F9R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F9R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F9R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F9R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F9R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F9R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F9R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F9R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F9R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F9R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F9R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F9R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F9R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F9R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F9R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F9R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F9R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F9R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F9R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F9R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F9R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F9R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F9R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F9R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F9R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F9R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F9R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F9R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F10R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F10R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F10R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F10R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F10R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F10R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F10R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F10R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F10R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F10R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F10R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F10R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F10R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F10R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F10R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F10R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F10R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F10R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F10R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F10R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F10R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F10R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F10R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F10R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F10R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F10R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F10R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F10R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F10R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F10R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F10R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F10R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F10R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F10R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F10R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F10R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F10R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F10R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F10R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F10R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F10R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F10R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F10R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F10R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F10R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F10R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F10R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F10R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F10R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F10R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F10R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F10R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F10R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F10R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F10R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F10R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F10R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F10R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F10R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F10R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F10R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F10R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F10R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F10R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F10R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F10R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F11R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F11R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F11R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F11R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F11R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F11R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F11R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F11R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F11R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F11R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F11R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F11R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F11R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F11R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F11R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F11R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F11R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F11R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F11R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F11R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F11R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F11R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F11R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F11R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F11R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F11R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F11R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F11R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F11R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F11R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F11R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F11R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F11R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F11R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F11R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F11R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F11R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F11R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F11R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F11R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F11R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F11R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F11R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F11R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F11R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F11R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F11R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F11R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F11R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F11R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F11R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F11R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F11R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F11R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F11R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F11R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F11R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F11R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F11R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F11R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F11R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F11R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F11R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F11R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F11R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F11R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F12R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F12R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F12R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F12R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F12R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F12R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F12R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F12R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F12R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F12R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F12R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F12R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F12R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F12R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F12R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F12R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F12R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F12R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F12R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F12R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F12R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F12R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F12R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F12R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F12R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F12R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F12R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F12R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F12R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F12R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F12R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F12R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F12R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F12R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F12R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F12R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F12R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F12R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F12R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F12R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F12R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F12R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F12R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F12R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F12R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F12R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F12R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F12R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F12R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F12R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F12R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F12R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F12R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F12R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F12R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F12R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F12R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F12R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F12R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F12R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F12R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F12R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F12R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F12R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F12R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F12R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F13R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F13R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F13R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F13R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F13R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F13R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F13R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F13R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F13R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F13R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F13R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F13R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F13R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F13R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F13R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F13R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F13R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F13R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F13R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F13R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F13R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F13R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F13R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F13R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F13R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F13R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F13R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F13R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F13R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F13R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F13R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F13R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F13R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F13R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F13R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F13R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F13R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F13R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F13R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F13R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F13R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F13R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F13R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F13R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F13R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F13R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F13R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F13R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F13R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F13R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F13R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F13R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F13R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F13R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F13R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F13R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F13R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F13R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F13R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F13R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F13R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F13R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F13R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F13R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F13R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F13R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F14R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F14R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F14R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F14R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F14R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F14R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F14R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F14R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F14R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F14R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F14R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F14R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F14R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F14R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F14R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F14R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F14R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F14R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F14R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F14R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F14R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F14R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F14R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F14R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F14R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F14R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F14R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F14R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F14R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F14R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F14R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F14R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F14R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F14R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F14R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F14R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F14R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F14R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F14R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F14R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F14R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F14R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F14R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F14R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F14R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F14R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F14R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F14R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F14R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F14R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F14R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F14R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F14R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F14R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F14R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F14R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F14R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F14R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F14R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F14R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F14R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F14R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F14R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F14R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F14R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F14R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F15R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F15R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F15R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F15R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F15R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F15R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F15R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F15R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F15R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F15R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F15R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F15R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F15R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F15R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F15R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F15R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F15R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F15R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F15R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F15R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F15R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F15R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F15R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F15R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F15R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F15R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F15R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F15R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F15R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F15R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F15R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F15R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F15R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F15R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F15R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F15R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F15R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F15R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F15R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F15R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F15R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F15R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F15R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F15R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F15R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F15R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F15R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F15R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F15R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F15R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F15R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F15R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F15R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F15R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F15R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F15R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F15R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F15R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F15R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F15R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F15R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F15R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F15R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F15R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F15R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F15R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F16R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F16R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F16R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F16R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F16R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F16R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F16R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F16R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F16R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F16R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F16R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F16R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F16R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F16R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F16R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F16R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F16R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F16R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F16R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F16R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F16R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F16R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F16R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F16R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F16R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F16R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F16R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F16R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F16R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F16R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F16R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F16R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F16R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F16R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F16R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F16R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F16R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F16R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F16R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F16R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F16R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F16R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F16R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F16R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F16R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F16R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F16R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F16R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F16R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F16R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F16R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F16R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F16R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F16R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F16R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F16R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F16R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F16R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F16R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F16R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F16R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F16R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F16R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F16R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F16R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F16R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F17R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F17R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F17R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F17R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F17R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F17R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F17R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F17R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F17R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F17R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F17R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F17R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F17R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F17R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F17R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F17R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F17R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F17R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F17R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F17R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F17R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F17R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F17R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F17R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F17R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F17R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F17R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F17R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F17R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F17R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F17R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F17R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F17R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F17R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F17R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F17R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F17R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F17R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F17R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F17R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F17R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F17R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F17R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F17R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F17R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F17R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F17R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F17R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F17R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F17R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F17R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F17R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F17R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F17R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F17R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F17R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F17R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F17R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F17R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F17R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F17R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F17R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F17R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F17R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F17R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F17R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F18R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F18R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F18R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F18R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F18R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F18R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F18R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F18R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F18R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F18R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F18R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F18R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F18R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F18R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F18R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F18R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F18R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F18R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F18R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F18R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F18R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F18R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F18R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F18R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F18R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F18R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F18R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F18R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F18R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F18R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F18R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F18R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F18R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F18R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F18R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F18R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F18R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F18R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F18R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F18R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F18R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F18R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F18R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F18R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F18R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F18R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F18R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F18R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F18R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F18R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F18R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F18R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F18R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F18R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F18R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F18R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F18R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F18R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F18R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F18R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F18R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F18R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F18R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F18R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F18R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F18R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F19R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F19R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F19R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F19R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F19R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F19R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F19R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F19R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F19R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F19R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F19R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F19R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F19R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F19R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F19R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F19R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F19R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F19R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F19R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F19R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F19R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F19R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F19R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F19R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F19R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F19R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F19R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F19R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F19R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F19R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F19R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F19R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F19R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F19R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F19R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F19R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F19R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F19R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F19R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F19R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F19R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F19R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F19R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F19R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F19R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F19R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F19R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F19R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F19R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F19R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F19R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F19R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F19R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F19R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F19R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F19R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F19R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F19R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F19R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F19R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F19R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F19R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F19R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F19R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F19R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F19R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F20R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F20R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F20R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F20R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F20R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F20R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F20R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F20R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F20R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F20R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F20R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F20R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F20R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F20R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F20R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F20R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F20R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F20R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F20R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F20R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F20R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F20R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F20R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F20R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F20R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F20R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F20R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F20R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F20R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F20R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F20R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F20R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F20R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F20R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F20R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F20R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F20R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F20R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F20R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F20R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F20R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F20R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F20R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F20R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F20R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F20R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F20R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F20R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F20R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F20R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F20R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F20R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F20R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F20R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F20R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F20R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F20R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F20R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F20R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F20R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F20R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F20R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F20R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F20R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F20R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F20R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F21R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F21R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F21R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F21R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F21R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F21R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F21R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F21R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F21R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F21R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F21R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F21R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F21R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F21R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F21R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F21R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F21R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F21R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F21R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F21R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F21R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F21R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F21R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F21R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F21R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F21R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F21R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F21R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F21R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F21R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F21R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F21R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F21R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F21R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F21R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F21R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F21R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F21R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F21R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F21R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F21R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F21R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F21R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F21R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F21R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F21R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F21R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F21R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F21R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F21R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F21R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F21R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F21R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F21R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F21R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F21R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F21R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F21R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F21R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F21R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F21R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F21R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F21R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F21R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F21R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F21R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F22R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F22R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F22R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F22R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F22R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F22R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F22R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F22R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F22R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F22R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F22R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F22R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F22R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F22R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F22R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F22R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F22R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F22R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F22R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F22R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F22R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F22R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F22R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F22R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F22R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F22R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F22R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F22R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F22R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F22R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F22R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F22R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F22R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F22R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F22R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F22R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F22R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F22R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F22R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F22R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F22R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F22R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F22R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F22R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F22R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F22R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F22R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F22R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F22R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F22R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F22R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F22R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F22R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F22R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F22R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F22R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F22R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F22R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F22R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F22R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F22R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F22R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F22R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F22R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F22R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F22R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F23R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F23R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F23R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F23R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F23R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F23R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F23R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F23R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F23R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F23R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F23R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F23R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F23R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F23R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F23R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F23R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F23R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F23R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F23R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F23R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F23R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F23R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F23R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F23R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F23R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F23R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F23R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F23R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F23R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F23R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F23R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F23R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F23R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F23R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F23R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F23R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F23R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F23R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F23R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F23R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F23R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F23R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F23R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F23R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F23R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F23R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F23R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F23R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F23R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F23R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F23R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F23R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F23R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F23R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F23R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F23R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F23R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F23R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F23R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F23R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F23R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F23R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F23R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F23R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F23R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F23R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F24R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F24R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F24R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F24R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F24R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F24R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F24R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F24R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F24R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F24R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F24R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F24R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F24R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F24R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F24R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F24R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F24R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F24R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F24R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F24R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F24R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F24R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F24R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F24R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F24R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F24R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F24R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F24R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F24R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F24R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F24R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F24R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F24R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F24R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F24R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F24R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F24R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F24R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F24R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F24R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F24R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F24R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F24R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F24R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F24R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F24R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F24R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F24R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F24R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F24R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F24R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F24R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F24R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F24R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F24R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F24R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F24R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F24R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F24R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F24R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F24R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F24R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F24R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F24R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F24R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F24R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F25R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F25R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F25R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F25R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F25R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F25R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F25R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F25R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F25R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F25R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F25R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F25R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F25R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F25R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F25R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F25R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F25R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F25R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F25R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F25R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F25R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F25R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F25R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F25R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F25R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F25R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F25R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F25R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F25R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F25R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F25R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F25R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F25R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F25R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F25R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F25R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F25R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F25R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F25R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F25R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F25R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F25R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F25R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F25R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F25R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F25R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F25R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F25R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F25R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F25R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F25R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F25R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F25R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F25R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F25R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F25R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F25R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F25R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F25R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F25R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F25R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F25R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F25R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F25R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F25R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F25R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F26R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F26R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F26R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F26R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F26R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F26R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F26R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F26R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F26R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F26R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F26R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F26R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F26R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F26R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F26R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F26R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F26R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F26R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F26R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F26R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F26R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F26R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F26R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F26R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F26R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F26R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F26R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F26R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F26R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F26R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F26R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F26R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F26R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F26R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F26R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F26R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F26R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F26R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F26R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F26R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F26R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F26R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F26R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F26R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F26R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F26R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F26R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F26R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F26R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F26R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F26R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F26R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F26R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F26R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F26R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F26R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F26R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F26R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F26R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F26R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F26R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F26R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F26R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F26R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F26R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F26R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F27R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F27R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F27R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F27R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F27R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F27R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F27R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F27R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F27R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F27R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F27R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F27R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F27R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F27R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F27R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F27R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F27R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F27R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F27R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F27R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F27R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F27R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F27R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F27R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F27R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F27R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F27R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F27R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F27R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F27R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F27R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F27R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F27R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F27R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F27R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F27R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F27R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F27R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F27R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F27R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F27R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F27R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F27R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F27R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F27R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F27R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F27R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F27R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F27R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F27R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F27R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F27R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F27R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F27R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F27R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F27R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F27R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F27R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F27R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F27R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F27R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F27R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F27R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F27R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F27R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F27R2_RESET_VALUE = 0x0;

    static constexpr uint8_t CAN2_RX0 = 64; // CAN2 RX0 interrupts
    static constexpr uint8_t CAN2_RX1 = 65; // CAN2 RX1 interrupts
    static constexpr uint8_t CAN2_SCE = 66; // CAN2 SCE interrupt
    static constexpr uint8_t CAN2_TX = 63; // CAN2 TX interrupts
};

static can2_t& CAN2 = *reinterpret_cast<can2_t*>(0x40006800);

#define HAVE_PERIPHERAL_CAN2


////
//
//    Controller area network
//
////

struct can3_t
{
    volatile uint32_t    MCR;                  // [Read-write] master control register
    volatile uint32_t    MSR;                  // master status register
    volatile uint32_t    TSR;                  // transmit status register
    volatile uint32_t    RF0R;                 // receive FIFO 0 register
    volatile uint32_t    RF1R;                 // receive FIFO 1 register
    volatile uint32_t    IER;                  // [Read-write] interrupt enable register
    volatile uint32_t    ESR;                  // interrupt enable register
    volatile uint32_t    BTR;                  // [Read-write] bit timing register
    reserved_t<88>       _0;
    volatile uint32_t    TI0R;                 // [Read-write] TX mailbox identifier register
    volatile uint32_t    TDT0R;                // [Read-write] mailbox data length control and time stamp register
    volatile uint32_t    TDL0R;                // [Read-write] mailbox data low register
    volatile uint32_t    TDH0R;                // [Read-write] mailbox data high register
    volatile uint32_t    TI1R;                 // [Read-write] mailbox identifier register
    volatile uint32_t    TDT1R;                // [Read-write] mailbox data length control and time stamp register
    volatile uint32_t    TDL1R;                // [Read-write] mailbox data low register
    volatile uint32_t    TDH1R;                // [Read-write] mailbox data high register
    volatile uint32_t    TI2R;                 // [Read-write] mailbox identifier register
    volatile uint32_t    TDT2R;                // [Read-write] mailbox data length control and time stamp register
    volatile uint32_t    TDL2R;                // [Read-write] mailbox data low register
    volatile uint32_t    TDH2R;                // [Read-write] mailbox data high register
    volatile uint32_t    RI0R;                 // [Read-only] receive FIFO mailbox identifier register
    volatile uint32_t    RDT0R;                // [Read-only] mailbox data high register
    volatile uint32_t    RDL0R;                // [Read-only] mailbox data high register
    volatile uint32_t    RDH0R;                // [Read-only] receive FIFO mailbox data high register
    volatile uint32_t    RI1R;                 // [Read-only] mailbox data high register
    volatile uint32_t    RDT1R;                // [Read-only] mailbox data high register
    volatile uint32_t    RDL1R;                // [Read-only] mailbox data high register
    volatile uint32_t    RDH1R;                // [Read-only] mailbox data high register
    reserved_t<12>       _1;
    volatile uint32_t    FMR;                  // [Read-write] filter master register
    volatile uint32_t    FM1R;                 // [Read-write] filter mode register
    reserved_t<1>        _2;
    volatile uint32_t    FS1R;                 // [Read-write] filter scale register
    reserved_t<1>        _3;
    volatile uint32_t    FFA1R;                // [Read-write] filter FIFO assignment register
    reserved_t<1>        _4;
    volatile uint32_t    FA1R;                 // [Read-write] filter activation register
    reserved_t<8>        _5;
    volatile uint32_t    F0R1;                 // [Read-write] Filter bank 0 register 1
    volatile uint32_t    F0R2;                 // [Read-write] Filter bank 0 register 2
    volatile uint32_t    F1R1;                 // [Read-write] Filter bank 1 register 1
    volatile uint32_t    F1R2;                 // [Read-write] Filter bank 1 register 2
    volatile uint32_t    F2R1;                 // [Read-write] Filter bank 2 register 1
    volatile uint32_t    F2R2;                 // [Read-write] Filter bank 2 register 2
    volatile uint32_t    F3R1;                 // [Read-write] Filter bank 3 register 1
    volatile uint32_t    F3R2;                 // [Read-write] Filter bank 3 register 2
    volatile uint32_t    F4R1;                 // [Read-write] Filter bank 4 register 1
    volatile uint32_t    F4R2;                 // [Read-write] Filter bank 4 register 2
    volatile uint32_t    F5R1;                 // [Read-write] Filter bank 5 register 1
    volatile uint32_t    F5R2;                 // [Read-write] Filter bank 5 register 2
    volatile uint32_t    F6R1;                 // [Read-write] Filter bank 6 register 1
    volatile uint32_t    F6R2;                 // [Read-write] Filter bank 6 register 2
    volatile uint32_t    F7R1;                 // [Read-write] Filter bank 7 register 1
    volatile uint32_t    F7R2;                 // [Read-write] Filter bank 7 register 2
    volatile uint32_t    F8R1;                 // [Read-write] Filter bank 8 register 1
    volatile uint32_t    F8R2;                 // [Read-write] Filter bank 8 register 2
    volatile uint32_t    F9R1;                 // [Read-write] Filter bank 9 register 1
    volatile uint32_t    F9R2;                 // [Read-write] Filter bank 9 register 2
    volatile uint32_t    F10R1;                // [Read-write] Filter bank 10 register 1
    volatile uint32_t    F10R2;                // [Read-write] Filter bank 10 register 2
    volatile uint32_t    F11R1;                // [Read-write] Filter bank 11 register 1
    volatile uint32_t    F11R2;                // [Read-write] Filter bank 11 register 2
    volatile uint32_t    F12R1;                // [Read-write] Filter bank 4 register 1
    volatile uint32_t    F12R2;                // [Read-write] Filter bank 12 register 2
    volatile uint32_t    F13R1;                // [Read-write] Filter bank 13 register 1
    volatile uint32_t    F13R2;                // [Read-write] Filter bank 13 register 2
    volatile uint32_t    F14R1;                // [Read-write] Filter bank 14 register 1
    volatile uint32_t    F14R2;                // [Read-write] Filter bank 14 register 2
    volatile uint32_t    F15R1;                // [Read-write] Filter bank 15 register 1
    volatile uint32_t    F15R2;                // [Read-write] Filter bank 15 register 2
    volatile uint32_t    F16R1;                // [Read-write] Filter bank 16 register 1
    volatile uint32_t    F16R2;                // [Read-write] Filter bank 16 register 2
    volatile uint32_t    F17R1;                // [Read-write] Filter bank 17 register 1
    volatile uint32_t    F17R2;                // [Read-write] Filter bank 17 register 2
    volatile uint32_t    F18R1;                // [Read-write] Filter bank 18 register 1
    volatile uint32_t    F18R2;                // [Read-write] Filter bank 18 register 2
    volatile uint32_t    F19R1;                // [Read-write] Filter bank 19 register 1
    volatile uint32_t    F19R2;                // [Read-write] Filter bank 19 register 2
    volatile uint32_t    F20R1;                // [Read-write] Filter bank 20 register 1
    volatile uint32_t    F20R2;                // [Read-write] Filter bank 20 register 2
    volatile uint32_t    F21R1;                // [Read-write] Filter bank 21 register 1
    volatile uint32_t    F21R2;                // [Read-write] Filter bank 21 register 2
    volatile uint32_t    F22R1;                // [Read-write] Filter bank 22 register 1
    volatile uint32_t    F22R2;                // [Read-write] Filter bank 22 register 2
    volatile uint32_t    F23R1;                // [Read-write] Filter bank 23 register 1
    volatile uint32_t    F23R2;                // [Read-write] Filter bank 23 register 2
    volatile uint32_t    F24R1;                // [Read-write] Filter bank 24 register 1
    volatile uint32_t    F24R2;                // [Read-write] Filter bank 24 register 2
    volatile uint32_t    F25R1;                // [Read-write] Filter bank 25 register 1
    volatile uint32_t    F25R2;                // [Read-write] Filter bank 25 register 2
    volatile uint32_t    F26R1;                // [Read-write] Filter bank 26 register 1
    volatile uint32_t    F26R2;                // [Read-write] Filter bank 26 register 2
    volatile uint32_t    F27R1;                // [Read-write] Filter bank 27 register 1
    volatile uint32_t    F27R2;                // [Read-write] Filter bank 27 register 2

    static constexpr uint32_t MCR_DBF = 0x10000;        // DBF
    static constexpr uint32_t MCR_RESET = 0x8000;       // RESET
    static constexpr uint32_t MCR_TTCM = 0x80;          // TTCM
    static constexpr uint32_t MCR_ABOM = 0x40;          // ABOM
    static constexpr uint32_t MCR_AWUM = 0x20;          // AWUM
    static constexpr uint32_t MCR_NART = 0x10;          // NART
    static constexpr uint32_t MCR_RFLM = 0x8;           // RFLM
    static constexpr uint32_t MCR_TXFP = 0x4;           // TXFP
    static constexpr uint32_t MCR_SLEEP = 0x2;          // SLEEP
    static constexpr uint32_t MCR_INRQ = 0x1;           // INRQ
    static const uint32_t MCR_RESET_VALUE = 0x10002;

    static constexpr uint32_t MSR_RX = 0x800;           // RX, Read-only
    static constexpr uint32_t MSR_SAMP = 0x400;         // SAMP, Read-only
    static constexpr uint32_t MSR_RXM = 0x200;          // RXM, Read-only
    static constexpr uint32_t MSR_TXM = 0x100;          // TXM, Read-only
    static constexpr uint32_t MSR_SLAKI = 0x10;         // SLAKI, Read-write
    static constexpr uint32_t MSR_WKUI = 0x8;           // WKUI, Read-write
    static constexpr uint32_t MSR_ERRI = 0x4;           // ERRI, Read-write
    static constexpr uint32_t MSR_SLAK = 0x2;           // SLAK, Read-only
    static constexpr uint32_t MSR_INAK = 0x1;           // INAK, Read-only
    static const uint32_t MSR_RESET_VALUE = 0xc02;

    static constexpr uint32_t TSR_LOW2 = 0x80000000;    // Lowest priority flag for mailbox 2, Read-only
    static constexpr uint32_t TSR_LOW1 = 0x40000000;    // Lowest priority flag for mailbox 1, Read-only
    static constexpr uint32_t TSR_LOW0 = 0x20000000;    // Lowest priority flag for mailbox 0, Read-only
    static constexpr uint32_t TSR_TME2 = 0x10000000;    // Lowest priority flag for mailbox 2, Read-only
    static constexpr uint32_t TSR_TME1 = 0x8000000;     // Lowest priority flag for mailbox 1, Read-only
    static constexpr uint32_t TSR_TME0 = 0x4000000;     // Lowest priority flag for mailbox 0, Read-only
    template<uint32_t X>
    static constexpr uint32_t TSR_CODE =                // CODE (2 bits), Read-only
        bit_field_t<24, 0x3>::value<X>();
    static constexpr uint32_t TSR_ABRQ2 = 0x800000;     // ABRQ2, Read-write
    static constexpr uint32_t TSR_TERR2 = 0x80000;      // TERR2, Read-write
    static constexpr uint32_t TSR_ALST2 = 0x40000;      // ALST2, Read-write
    static constexpr uint32_t TSR_TXOK2 = 0x20000;      // TXOK2, Read-write
    static constexpr uint32_t TSR_RQCP2 = 0x10000;      // RQCP2, Read-write
    static constexpr uint32_t TSR_ABRQ1 = 0x8000;       // ABRQ1, Read-write
    static constexpr uint32_t TSR_TERR1 = 0x800;        // TERR1, Read-write
    static constexpr uint32_t TSR_ALST1 = 0x400;        // ALST1, Read-write
    static constexpr uint32_t TSR_TXOK1 = 0x200;        // TXOK1, Read-write
    static constexpr uint32_t TSR_RQCP1 = 0x100;        // RQCP1, Read-write
    static constexpr uint32_t TSR_ABRQ0 = 0x80;         // ABRQ0, Read-write
    static constexpr uint32_t TSR_TERR0 = 0x8;          // TERR0, Read-write
    static constexpr uint32_t TSR_ALST0 = 0x4;          // ALST0, Read-write
    static constexpr uint32_t TSR_TXOK0 = 0x2;          // TXOK0, Read-write
    static constexpr uint32_t TSR_RQCP0 = 0x1;          // RQCP0, Read-write
    static const uint32_t TSR_RESET_VALUE = 0x1c000000;

    static constexpr uint32_t RF0R_RFOM0 = 0x20;         // RFOM0, Read-write
    static constexpr uint32_t RF0R_FOVR0 = 0x10;         // FOVR0, Read-write
    static constexpr uint32_t RF0R_FULL0 = 0x8;          // FULL0, Read-write
    template<uint32_t X>
    static constexpr uint32_t RF0R_FMP0 =                // FMP0 (2 bits), Read-only
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t RF0R_RESET_VALUE = 0x0;

    static constexpr uint32_t RF1R_RFOM1 = 0x20;         // RFOM1, Read-write
    static constexpr uint32_t RF1R_FOVR1 = 0x10;         // FOVR1, Read-write
    static constexpr uint32_t RF1R_FULL1 = 0x8;          // FULL1, Read-write
    template<uint32_t X>
    static constexpr uint32_t RF1R_FMP1 =                // FMP1 (2 bits), Read-only
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t RF1R_RESET_VALUE = 0x0;

    static constexpr uint32_t IER_SLKIE = 0x20000;      // SLKIE
    static constexpr uint32_t IER_WKUIE = 0x10000;      // WKUIE
    static constexpr uint32_t IER_ERRIE = 0x8000;       // ERRIE
    static constexpr uint32_t IER_LECIE = 0x800;        // LECIE
    static constexpr uint32_t IER_BOFIE = 0x400;        // BOFIE
    static constexpr uint32_t IER_EPVIE = 0x200;        // EPVIE
    static constexpr uint32_t IER_EWGIE = 0x100;        // EWGIE
    static constexpr uint32_t IER_FOVIE1 = 0x40;        // FOVIE1
    static constexpr uint32_t IER_FFIE1 = 0x20;         // FFIE1
    static constexpr uint32_t IER_FMPIE1 = 0x10;        // FMPIE1
    static constexpr uint32_t IER_FOVIE0 = 0x8;         // FOVIE0
    static constexpr uint32_t IER_FFIE0 = 0x4;          // FFIE0
    static constexpr uint32_t IER_FMPIE0 = 0x2;         // FMPIE0
    static constexpr uint32_t IER_TMEIE = 0x1;          // TMEIE
    static const uint32_t IER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ESR_REC =                 // REC (8 bits), Read-only
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ESR_TEC =                 // TEC (8 bits), Read-only
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ESR_LEC =                 // LEC (3 bits), Read-write
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t ESR_BOFF = 0x4;           // BOFF, Read-only
    static constexpr uint32_t ESR_EPVF = 0x2;           // EPVF, Read-only
    static constexpr uint32_t ESR_EWGF = 0x1;           // EWGF, Read-only
    static const uint32_t ESR_RESET_VALUE = 0x0;

    static constexpr uint32_t BTR_SILM = 0x80000000;    // SILM
    static constexpr uint32_t BTR_LBKM = 0x40000000;    // LBKM
    template<uint32_t X>
    static constexpr uint32_t BTR_SJW =                 // SJW (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR_TS2 =                 // TS2 (3 bits)
        bit_field_t<20, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR_TS1 =                 // TS1 (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BTR_BRP =                 // BRP (10 bits)
        bit_field_t<0, 0x3ff>::value<X>();
    static const uint32_t BTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TI0R_STID =                // STID (11 bits)
        bit_field_t<21, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TI0R_EXID =                // EXID (18 bits)
        bit_field_t<3, 0x3ffff>::value<X>();
    static constexpr uint32_t TI0R_IDE = 0x4;            // IDE
    static constexpr uint32_t TI0R_RTR = 0x2;            // RTR
    static constexpr uint32_t TI0R_TXRQ = 0x1;           // TXRQ
    static const uint32_t TI0R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDT0R_TIME =                // TIME (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static constexpr uint32_t TDT0R_TGT = 0x100;          // TGT
    template<uint32_t X>
    static constexpr uint32_t TDT0R_DLC =                 // DLC (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t TDT0R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDL0R_DATA3 =               // DATA3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDL0R_DATA2 =               // DATA2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDL0R_DATA1 =               // DATA1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDL0R_DATA0 =               // DATA0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t TDL0R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDH0R_DATA7 =               // DATA7 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDH0R_DATA6 =               // DATA6 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDH0R_DATA5 =               // DATA5 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDH0R_DATA4 =               // DATA4 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t TDH0R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TI1R_STID =                // STID (11 bits)
        bit_field_t<21, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TI1R_EXID =                // EXID (18 bits)
        bit_field_t<3, 0x3ffff>::value<X>();
    static constexpr uint32_t TI1R_IDE = 0x4;            // IDE
    static constexpr uint32_t TI1R_RTR = 0x2;            // RTR
    static constexpr uint32_t TI1R_TXRQ = 0x1;           // TXRQ
    static const uint32_t TI1R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDT1R_TIME =                // TIME (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static constexpr uint32_t TDT1R_TGT = 0x100;          // TGT
    template<uint32_t X>
    static constexpr uint32_t TDT1R_DLC =                 // DLC (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t TDT1R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDL1R_DATA3 =               // DATA3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDL1R_DATA2 =               // DATA2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDL1R_DATA1 =               // DATA1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDL1R_DATA0 =               // DATA0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t TDL1R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDH1R_DATA7 =               // DATA7 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDH1R_DATA6 =               // DATA6 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDH1R_DATA5 =               // DATA5 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDH1R_DATA4 =               // DATA4 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t TDH1R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TI2R_STID =                // STID (11 bits)
        bit_field_t<21, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TI2R_EXID =                // EXID (18 bits)
        bit_field_t<3, 0x3ffff>::value<X>();
    static constexpr uint32_t TI2R_IDE = 0x4;            // IDE
    static constexpr uint32_t TI2R_RTR = 0x2;            // RTR
    static constexpr uint32_t TI2R_TXRQ = 0x1;           // TXRQ
    static const uint32_t TI2R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDT2R_TIME =                // TIME (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static constexpr uint32_t TDT2R_TGT = 0x100;          // TGT
    template<uint32_t X>
    static constexpr uint32_t TDT2R_DLC =                 // DLC (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t TDT2R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDL2R_DATA3 =               // DATA3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDL2R_DATA2 =               // DATA2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDL2R_DATA1 =               // DATA1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDL2R_DATA0 =               // DATA0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t TDL2R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDH2R_DATA7 =               // DATA7 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDH2R_DATA6 =               // DATA6 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDH2R_DATA5 =               // DATA5 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TDH2R_DATA4 =               // DATA4 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t TDH2R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RI0R_STID =                // STID (11 bits)
        bit_field_t<21, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RI0R_EXID =                // EXID (18 bits)
        bit_field_t<3, 0x3ffff>::value<X>();
    static constexpr uint32_t RI0R_IDE = 0x4;            // IDE
    static constexpr uint32_t RI0R_RTR = 0x2;            // RTR
    static const uint32_t RI0R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RDT0R_TIME =                // TIME (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDT0R_FMI =                 // FMI (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDT0R_DLC =                 // DLC (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t RDT0R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RDL0R_DATA3 =               // DATA3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDL0R_DATA2 =               // DATA2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDL0R_DATA1 =               // DATA1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDL0R_DATA0 =               // DATA0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t RDL0R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RDH0R_DATA7 =               // DATA7 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDH0R_DATA6 =               // DATA6 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDH0R_DATA5 =               // DATA5 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDH0R_DATA4 =               // DATA4 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t RDH0R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RI1R_STID =                // STID (11 bits)
        bit_field_t<21, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RI1R_EXID =                // EXID (18 bits)
        bit_field_t<3, 0x3ffff>::value<X>();
    static constexpr uint32_t RI1R_IDE = 0x4;            // IDE
    static constexpr uint32_t RI1R_RTR = 0x2;            // RTR
    static const uint32_t RI1R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RDT1R_TIME =                // TIME (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDT1R_FMI =                 // FMI (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDT1R_DLC =                 // DLC (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t RDT1R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RDL1R_DATA3 =               // DATA3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDL1R_DATA2 =               // DATA2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDL1R_DATA1 =               // DATA1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDL1R_DATA0 =               // DATA0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t RDL1R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RDH1R_DATA7 =               // DATA7 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDH1R_DATA6 =               // DATA6 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDH1R_DATA5 =               // DATA5 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RDH1R_DATA4 =               // DATA4 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t RDH1R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t FMR_CAN2SB =              // CAN2SB (6 bits)
        bit_field_t<8, 0x3f>::value<X>();
    static constexpr uint32_t FMR_FINIT = 0x1;          // FINIT
    static const uint32_t FMR_RESET_VALUE = 0x2a1c0e01;

    static constexpr uint32_t FM1R_FBM0 = 0x1;           // Filter mode
    static constexpr uint32_t FM1R_FBM1 = 0x2;           // Filter mode
    static constexpr uint32_t FM1R_FBM2 = 0x4;           // Filter mode
    static constexpr uint32_t FM1R_FBM3 = 0x8;           // Filter mode
    static constexpr uint32_t FM1R_FBM4 = 0x10;          // Filter mode
    static constexpr uint32_t FM1R_FBM5 = 0x20;          // Filter mode
    static constexpr uint32_t FM1R_FBM6 = 0x40;          // Filter mode
    static constexpr uint32_t FM1R_FBM7 = 0x80;          // Filter mode
    static constexpr uint32_t FM1R_FBM8 = 0x100;         // Filter mode
    static constexpr uint32_t FM1R_FBM9 = 0x200;         // Filter mode
    static constexpr uint32_t FM1R_FBM10 = 0x400;        // Filter mode
    static constexpr uint32_t FM1R_FBM11 = 0x800;        // Filter mode
    static constexpr uint32_t FM1R_FBM12 = 0x1000;       // Filter mode
    static constexpr uint32_t FM1R_FBM13 = 0x2000;       // Filter mode
    static constexpr uint32_t FM1R_FBM14 = 0x4000;       // Filter mode
    static constexpr uint32_t FM1R_FBM15 = 0x8000;       // Filter mode
    static constexpr uint32_t FM1R_FBM16 = 0x10000;      // Filter mode
    static constexpr uint32_t FM1R_FBM17 = 0x20000;      // Filter mode
    static constexpr uint32_t FM1R_FBM18 = 0x40000;      // Filter mode
    static constexpr uint32_t FM1R_FBM19 = 0x80000;      // Filter mode
    static constexpr uint32_t FM1R_FBM20 = 0x100000;     // Filter mode
    static constexpr uint32_t FM1R_FBM21 = 0x200000;     // Filter mode
    static constexpr uint32_t FM1R_FBM22 = 0x400000;     // Filter mode
    static constexpr uint32_t FM1R_FBM23 = 0x800000;     // Filter mode
    static constexpr uint32_t FM1R_FBM24 = 0x1000000;    // Filter mode
    static constexpr uint32_t FM1R_FBM25 = 0x2000000;    // Filter mode
    static constexpr uint32_t FM1R_FBM26 = 0x4000000;    // Filter mode
    static constexpr uint32_t FM1R_FBM27 = 0x8000000;    // Filter mode
    static const uint32_t FM1R_RESET_VALUE = 0x0;

    static constexpr uint32_t FS1R_FSC0 = 0x1;           // Filter scale configuration
    static constexpr uint32_t FS1R_FSC1 = 0x2;           // Filter scale configuration
    static constexpr uint32_t FS1R_FSC2 = 0x4;           // Filter scale configuration
    static constexpr uint32_t FS1R_FSC3 = 0x8;           // Filter scale configuration
    static constexpr uint32_t FS1R_FSC4 = 0x10;          // Filter scale configuration
    static constexpr uint32_t FS1R_FSC5 = 0x20;          // Filter scale configuration
    static constexpr uint32_t FS1R_FSC6 = 0x40;          // Filter scale configuration
    static constexpr uint32_t FS1R_FSC7 = 0x80;          // Filter scale configuration
    static constexpr uint32_t FS1R_FSC8 = 0x100;         // Filter scale configuration
    static constexpr uint32_t FS1R_FSC9 = 0x200;         // Filter scale configuration
    static constexpr uint32_t FS1R_FSC10 = 0x400;        // Filter scale configuration
    static constexpr uint32_t FS1R_FSC11 = 0x800;        // Filter scale configuration
    static constexpr uint32_t FS1R_FSC12 = 0x1000;       // Filter scale configuration
    static constexpr uint32_t FS1R_FSC13 = 0x2000;       // Filter scale configuration
    static constexpr uint32_t FS1R_FSC14 = 0x4000;       // Filter scale configuration
    static constexpr uint32_t FS1R_FSC15 = 0x8000;       // Filter scale configuration
    static constexpr uint32_t FS1R_FSC16 = 0x10000;      // Filter scale configuration
    static constexpr uint32_t FS1R_FSC17 = 0x20000;      // Filter scale configuration
    static constexpr uint32_t FS1R_FSC18 = 0x40000;      // Filter scale configuration
    static constexpr uint32_t FS1R_FSC19 = 0x80000;      // Filter scale configuration
    static constexpr uint32_t FS1R_FSC20 = 0x100000;     // Filter scale configuration
    static constexpr uint32_t FS1R_FSC21 = 0x200000;     // Filter scale configuration
    static constexpr uint32_t FS1R_FSC22 = 0x400000;     // Filter scale configuration
    static constexpr uint32_t FS1R_FSC23 = 0x800000;     // Filter scale configuration
    static constexpr uint32_t FS1R_FSC24 = 0x1000000;    // Filter scale configuration
    static constexpr uint32_t FS1R_FSC25 = 0x2000000;    // Filter scale configuration
    static constexpr uint32_t FS1R_FSC26 = 0x4000000;    // Filter scale configuration
    static constexpr uint32_t FS1R_FSC27 = 0x8000000;    // Filter scale configuration
    static const uint32_t FS1R_RESET_VALUE = 0x0;

    static constexpr uint32_t FFA1R_FFA0 = 0x1;           // Filter FIFO assignment for filter 0
    static constexpr uint32_t FFA1R_FFA1 = 0x2;           // Filter FIFO assignment for filter 1
    static constexpr uint32_t FFA1R_FFA2 = 0x4;           // Filter FIFO assignment for filter 2
    static constexpr uint32_t FFA1R_FFA3 = 0x8;           // Filter FIFO assignment for filter 3
    static constexpr uint32_t FFA1R_FFA4 = 0x10;          // Filter FIFO assignment for filter 4
    static constexpr uint32_t FFA1R_FFA5 = 0x20;          // Filter FIFO assignment for filter 5
    static constexpr uint32_t FFA1R_FFA6 = 0x40;          // Filter FIFO assignment for filter 6
    static constexpr uint32_t FFA1R_FFA7 = 0x80;          // Filter FIFO assignment for filter 7
    static constexpr uint32_t FFA1R_FFA8 = 0x100;         // Filter FIFO assignment for filter 8
    static constexpr uint32_t FFA1R_FFA9 = 0x200;         // Filter FIFO assignment for filter 9
    static constexpr uint32_t FFA1R_FFA10 = 0x400;        // Filter FIFO assignment for filter 10
    static constexpr uint32_t FFA1R_FFA11 = 0x800;        // Filter FIFO assignment for filter 11
    static constexpr uint32_t FFA1R_FFA12 = 0x1000;       // Filter FIFO assignment for filter 12
    static constexpr uint32_t FFA1R_FFA13 = 0x2000;       // Filter FIFO assignment for filter 13
    static constexpr uint32_t FFA1R_FFA14 = 0x4000;       // Filter FIFO assignment for filter 14
    static constexpr uint32_t FFA1R_FFA15 = 0x8000;       // Filter FIFO assignment for filter 15
    static constexpr uint32_t FFA1R_FFA16 = 0x10000;      // Filter FIFO assignment for filter 16
    static constexpr uint32_t FFA1R_FFA17 = 0x20000;      // Filter FIFO assignment for filter 17
    static constexpr uint32_t FFA1R_FFA18 = 0x40000;      // Filter FIFO assignment for filter 18
    static constexpr uint32_t FFA1R_FFA19 = 0x80000;      // Filter FIFO assignment for filter 19
    static constexpr uint32_t FFA1R_FFA20 = 0x100000;     // Filter FIFO assignment for filter 20
    static constexpr uint32_t FFA1R_FFA21 = 0x200000;     // Filter FIFO assignment for filter 21
    static constexpr uint32_t FFA1R_FFA22 = 0x400000;     // Filter FIFO assignment for filter 22
    static constexpr uint32_t FFA1R_FFA23 = 0x800000;     // Filter FIFO assignment for filter 23
    static constexpr uint32_t FFA1R_FFA24 = 0x1000000;    // Filter FIFO assignment for filter 24
    static constexpr uint32_t FFA1R_FFA25 = 0x2000000;    // Filter FIFO assignment for filter 25
    static constexpr uint32_t FFA1R_FFA26 = 0x4000000;    // Filter FIFO assignment for filter 26
    static constexpr uint32_t FFA1R_FFA27 = 0x8000000;    // Filter FIFO assignment for filter 27
    static const uint32_t FFA1R_RESET_VALUE = 0x0;

    static constexpr uint32_t FA1R_FACT0 = 0x1;          // Filter active
    static constexpr uint32_t FA1R_FACT1 = 0x2;          // Filter active
    static constexpr uint32_t FA1R_FACT2 = 0x4;          // Filter active
    static constexpr uint32_t FA1R_FACT3 = 0x8;          // Filter active
    static constexpr uint32_t FA1R_FACT4 = 0x10;         // Filter active
    static constexpr uint32_t FA1R_FACT5 = 0x20;         // Filter active
    static constexpr uint32_t FA1R_FACT6 = 0x40;         // Filter active
    static constexpr uint32_t FA1R_FACT7 = 0x80;         // Filter active
    static constexpr uint32_t FA1R_FACT8 = 0x100;        // Filter active
    static constexpr uint32_t FA1R_FACT9 = 0x200;        // Filter active
    static constexpr uint32_t FA1R_FACT10 = 0x400;       // Filter active
    static constexpr uint32_t FA1R_FACT11 = 0x800;       // Filter active
    static constexpr uint32_t FA1R_FACT12 = 0x1000;      // Filter active
    static constexpr uint32_t FA1R_FACT13 = 0x2000;      // Filter active
    static constexpr uint32_t FA1R_FACT14 = 0x4000;      // Filter active
    static constexpr uint32_t FA1R_FACT15 = 0x8000;      // Filter active
    static constexpr uint32_t FA1R_FACT16 = 0x10000;     // Filter active
    static constexpr uint32_t FA1R_FACT17 = 0x20000;     // Filter active
    static constexpr uint32_t FA1R_FACT18 = 0x40000;     // Filter active
    static constexpr uint32_t FA1R_FACT19 = 0x80000;     // Filter active
    static constexpr uint32_t FA1R_FACT20 = 0x100000;    // Filter active
    static constexpr uint32_t FA1R_FACT21 = 0x200000;    // Filter active
    static constexpr uint32_t FA1R_FACT22 = 0x400000;    // Filter active
    static constexpr uint32_t FA1R_FACT23 = 0x800000;    // Filter active
    static constexpr uint32_t FA1R_FACT24 = 0x1000000;   // Filter active
    static constexpr uint32_t FA1R_FACT25 = 0x2000000;   // Filter active
    static constexpr uint32_t FA1R_FACT26 = 0x4000000;   // Filter active
    static constexpr uint32_t FA1R_FACT27 = 0x8000000;   // Filter active
    static const uint32_t FA1R_RESET_VALUE = 0x0;

    static constexpr uint32_t F0R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F0R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F0R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F0R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F0R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F0R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F0R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F0R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F0R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F0R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F0R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F0R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F0R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F0R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F0R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F0R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F0R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F0R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F0R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F0R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F0R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F0R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F0R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F0R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F0R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F0R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F0R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F0R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F0R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F0R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F0R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F0R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F0R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F0R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F0R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F0R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F0R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F0R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F0R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F0R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F0R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F0R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F0R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F0R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F0R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F0R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F0R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F0R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F0R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F0R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F0R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F0R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F0R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F0R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F0R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F0R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F0R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F0R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F0R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F0R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F0R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F0R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F0R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F0R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F0R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F0R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F1R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F1R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F1R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F1R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F1R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F1R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F1R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F1R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F1R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F1R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F1R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F1R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F1R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F1R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F1R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F1R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F1R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F1R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F1R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F1R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F1R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F1R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F1R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F1R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F1R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F1R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F1R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F1R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F1R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F1R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F1R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F1R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F1R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F1R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F1R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F1R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F1R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F1R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F1R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F1R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F1R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F1R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F1R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F1R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F1R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F1R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F1R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F1R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F1R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F1R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F1R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F1R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F1R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F1R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F1R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F1R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F1R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F1R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F1R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F1R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F1R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F1R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F1R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F1R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F1R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F1R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F2R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F2R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F2R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F2R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F2R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F2R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F2R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F2R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F2R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F2R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F2R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F2R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F2R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F2R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F2R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F2R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F2R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F2R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F2R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F2R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F2R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F2R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F2R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F2R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F2R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F2R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F2R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F2R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F2R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F2R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F2R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F2R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F2R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F2R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F2R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F2R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F2R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F2R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F2R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F2R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F2R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F2R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F2R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F2R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F2R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F2R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F2R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F2R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F2R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F2R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F2R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F2R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F2R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F2R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F2R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F2R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F2R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F2R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F2R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F2R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F2R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F2R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F2R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F2R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F2R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F2R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F3R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F3R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F3R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F3R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F3R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F3R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F3R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F3R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F3R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F3R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F3R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F3R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F3R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F3R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F3R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F3R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F3R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F3R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F3R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F3R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F3R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F3R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F3R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F3R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F3R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F3R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F3R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F3R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F3R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F3R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F3R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F3R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F3R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F3R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F3R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F3R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F3R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F3R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F3R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F3R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F3R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F3R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F3R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F3R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F3R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F3R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F3R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F3R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F3R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F3R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F3R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F3R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F3R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F3R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F3R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F3R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F3R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F3R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F3R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F3R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F3R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F3R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F3R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F3R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F3R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F3R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F4R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F4R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F4R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F4R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F4R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F4R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F4R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F4R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F4R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F4R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F4R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F4R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F4R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F4R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F4R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F4R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F4R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F4R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F4R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F4R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F4R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F4R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F4R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F4R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F4R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F4R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F4R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F4R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F4R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F4R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F4R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F4R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F4R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F4R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F4R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F4R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F4R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F4R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F4R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F4R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F4R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F4R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F4R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F4R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F4R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F4R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F4R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F4R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F4R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F4R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F4R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F4R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F4R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F4R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F4R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F4R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F4R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F4R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F4R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F4R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F4R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F4R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F4R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F4R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F4R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F4R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F5R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F5R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F5R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F5R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F5R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F5R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F5R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F5R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F5R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F5R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F5R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F5R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F5R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F5R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F5R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F5R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F5R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F5R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F5R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F5R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F5R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F5R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F5R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F5R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F5R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F5R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F5R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F5R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F5R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F5R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F5R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F5R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F5R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F5R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F5R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F5R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F5R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F5R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F5R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F5R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F5R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F5R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F5R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F5R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F5R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F5R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F5R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F5R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F5R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F5R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F5R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F5R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F5R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F5R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F5R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F5R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F5R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F5R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F5R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F5R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F5R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F5R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F5R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F5R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F5R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F5R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F6R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F6R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F6R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F6R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F6R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F6R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F6R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F6R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F6R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F6R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F6R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F6R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F6R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F6R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F6R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F6R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F6R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F6R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F6R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F6R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F6R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F6R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F6R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F6R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F6R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F6R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F6R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F6R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F6R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F6R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F6R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F6R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F6R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F6R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F6R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F6R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F6R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F6R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F6R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F6R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F6R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F6R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F6R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F6R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F6R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F6R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F6R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F6R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F6R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F6R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F6R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F6R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F6R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F6R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F6R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F6R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F6R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F6R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F6R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F6R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F6R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F6R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F6R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F6R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F6R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F6R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F7R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F7R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F7R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F7R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F7R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F7R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F7R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F7R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F7R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F7R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F7R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F7R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F7R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F7R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F7R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F7R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F7R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F7R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F7R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F7R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F7R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F7R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F7R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F7R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F7R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F7R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F7R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F7R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F7R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F7R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F7R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F7R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F7R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F7R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F7R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F7R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F7R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F7R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F7R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F7R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F7R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F7R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F7R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F7R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F7R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F7R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F7R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F7R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F7R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F7R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F7R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F7R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F7R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F7R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F7R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F7R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F7R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F7R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F7R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F7R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F7R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F7R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F7R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F7R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F7R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F7R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F8R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F8R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F8R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F8R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F8R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F8R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F8R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F8R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F8R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F8R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F8R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F8R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F8R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F8R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F8R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F8R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F8R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F8R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F8R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F8R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F8R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F8R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F8R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F8R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F8R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F8R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F8R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F8R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F8R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F8R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F8R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F8R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F8R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F8R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F8R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F8R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F8R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F8R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F8R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F8R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F8R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F8R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F8R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F8R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F8R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F8R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F8R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F8R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F8R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F8R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F8R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F8R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F8R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F8R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F8R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F8R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F8R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F8R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F8R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F8R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F8R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F8R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F8R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F8R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F8R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F8R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F9R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F9R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F9R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F9R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F9R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F9R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F9R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F9R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F9R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F9R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F9R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F9R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F9R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F9R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F9R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F9R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F9R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F9R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F9R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F9R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F9R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F9R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F9R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F9R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F9R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F9R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F9R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F9R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F9R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F9R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F9R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F9R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F9R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F9R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F9R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F9R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F9R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F9R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F9R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F9R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F9R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F9R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F9R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F9R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F9R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F9R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F9R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F9R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F9R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F9R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F9R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F9R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F9R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F9R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F9R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F9R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F9R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F9R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F9R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F9R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F9R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F9R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F9R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F9R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F9R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F9R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F10R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F10R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F10R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F10R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F10R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F10R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F10R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F10R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F10R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F10R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F10R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F10R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F10R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F10R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F10R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F10R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F10R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F10R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F10R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F10R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F10R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F10R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F10R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F10R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F10R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F10R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F10R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F10R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F10R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F10R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F10R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F10R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F10R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F10R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F10R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F10R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F10R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F10R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F10R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F10R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F10R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F10R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F10R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F10R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F10R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F10R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F10R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F10R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F10R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F10R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F10R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F10R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F10R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F10R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F10R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F10R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F10R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F10R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F10R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F10R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F10R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F10R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F10R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F10R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F10R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F10R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F11R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F11R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F11R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F11R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F11R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F11R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F11R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F11R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F11R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F11R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F11R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F11R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F11R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F11R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F11R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F11R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F11R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F11R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F11R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F11R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F11R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F11R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F11R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F11R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F11R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F11R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F11R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F11R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F11R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F11R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F11R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F11R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F11R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F11R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F11R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F11R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F11R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F11R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F11R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F11R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F11R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F11R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F11R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F11R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F11R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F11R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F11R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F11R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F11R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F11R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F11R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F11R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F11R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F11R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F11R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F11R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F11R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F11R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F11R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F11R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F11R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F11R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F11R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F11R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F11R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F11R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F12R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F12R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F12R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F12R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F12R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F12R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F12R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F12R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F12R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F12R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F12R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F12R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F12R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F12R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F12R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F12R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F12R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F12R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F12R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F12R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F12R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F12R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F12R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F12R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F12R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F12R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F12R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F12R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F12R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F12R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F12R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F12R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F12R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F12R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F12R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F12R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F12R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F12R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F12R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F12R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F12R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F12R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F12R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F12R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F12R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F12R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F12R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F12R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F12R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F12R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F12R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F12R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F12R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F12R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F12R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F12R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F12R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F12R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F12R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F12R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F12R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F12R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F12R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F12R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F12R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F12R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F13R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F13R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F13R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F13R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F13R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F13R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F13R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F13R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F13R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F13R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F13R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F13R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F13R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F13R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F13R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F13R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F13R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F13R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F13R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F13R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F13R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F13R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F13R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F13R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F13R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F13R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F13R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F13R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F13R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F13R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F13R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F13R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F13R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F13R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F13R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F13R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F13R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F13R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F13R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F13R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F13R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F13R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F13R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F13R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F13R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F13R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F13R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F13R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F13R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F13R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F13R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F13R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F13R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F13R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F13R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F13R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F13R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F13R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F13R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F13R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F13R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F13R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F13R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F13R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F13R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F13R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F14R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F14R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F14R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F14R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F14R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F14R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F14R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F14R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F14R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F14R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F14R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F14R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F14R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F14R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F14R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F14R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F14R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F14R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F14R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F14R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F14R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F14R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F14R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F14R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F14R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F14R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F14R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F14R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F14R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F14R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F14R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F14R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F14R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F14R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F14R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F14R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F14R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F14R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F14R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F14R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F14R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F14R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F14R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F14R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F14R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F14R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F14R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F14R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F14R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F14R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F14R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F14R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F14R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F14R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F14R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F14R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F14R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F14R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F14R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F14R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F14R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F14R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F14R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F14R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F14R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F14R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F15R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F15R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F15R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F15R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F15R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F15R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F15R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F15R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F15R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F15R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F15R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F15R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F15R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F15R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F15R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F15R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F15R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F15R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F15R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F15R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F15R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F15R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F15R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F15R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F15R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F15R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F15R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F15R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F15R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F15R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F15R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F15R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F15R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F15R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F15R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F15R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F15R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F15R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F15R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F15R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F15R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F15R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F15R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F15R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F15R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F15R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F15R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F15R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F15R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F15R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F15R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F15R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F15R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F15R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F15R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F15R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F15R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F15R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F15R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F15R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F15R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F15R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F15R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F15R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F15R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F15R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F16R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F16R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F16R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F16R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F16R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F16R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F16R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F16R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F16R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F16R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F16R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F16R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F16R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F16R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F16R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F16R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F16R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F16R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F16R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F16R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F16R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F16R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F16R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F16R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F16R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F16R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F16R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F16R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F16R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F16R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F16R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F16R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F16R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F16R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F16R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F16R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F16R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F16R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F16R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F16R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F16R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F16R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F16R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F16R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F16R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F16R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F16R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F16R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F16R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F16R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F16R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F16R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F16R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F16R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F16R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F16R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F16R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F16R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F16R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F16R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F16R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F16R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F16R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F16R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F16R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F16R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F17R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F17R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F17R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F17R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F17R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F17R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F17R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F17R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F17R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F17R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F17R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F17R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F17R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F17R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F17R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F17R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F17R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F17R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F17R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F17R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F17R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F17R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F17R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F17R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F17R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F17R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F17R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F17R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F17R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F17R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F17R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F17R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F17R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F17R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F17R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F17R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F17R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F17R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F17R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F17R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F17R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F17R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F17R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F17R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F17R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F17R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F17R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F17R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F17R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F17R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F17R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F17R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F17R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F17R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F17R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F17R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F17R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F17R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F17R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F17R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F17R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F17R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F17R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F17R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F17R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F17R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F18R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F18R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F18R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F18R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F18R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F18R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F18R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F18R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F18R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F18R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F18R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F18R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F18R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F18R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F18R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F18R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F18R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F18R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F18R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F18R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F18R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F18R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F18R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F18R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F18R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F18R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F18R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F18R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F18R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F18R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F18R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F18R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F18R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F18R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F18R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F18R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F18R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F18R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F18R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F18R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F18R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F18R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F18R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F18R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F18R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F18R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F18R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F18R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F18R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F18R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F18R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F18R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F18R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F18R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F18R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F18R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F18R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F18R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F18R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F18R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F18R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F18R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F18R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F18R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F18R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F18R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F19R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F19R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F19R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F19R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F19R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F19R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F19R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F19R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F19R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F19R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F19R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F19R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F19R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F19R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F19R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F19R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F19R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F19R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F19R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F19R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F19R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F19R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F19R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F19R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F19R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F19R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F19R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F19R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F19R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F19R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F19R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F19R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F19R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F19R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F19R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F19R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F19R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F19R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F19R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F19R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F19R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F19R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F19R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F19R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F19R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F19R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F19R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F19R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F19R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F19R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F19R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F19R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F19R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F19R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F19R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F19R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F19R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F19R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F19R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F19R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F19R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F19R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F19R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F19R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F19R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F19R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F20R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F20R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F20R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F20R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F20R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F20R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F20R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F20R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F20R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F20R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F20R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F20R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F20R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F20R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F20R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F20R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F20R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F20R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F20R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F20R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F20R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F20R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F20R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F20R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F20R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F20R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F20R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F20R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F20R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F20R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F20R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F20R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F20R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F20R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F20R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F20R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F20R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F20R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F20R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F20R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F20R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F20R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F20R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F20R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F20R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F20R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F20R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F20R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F20R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F20R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F20R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F20R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F20R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F20R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F20R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F20R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F20R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F20R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F20R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F20R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F20R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F20R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F20R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F20R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F20R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F20R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F21R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F21R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F21R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F21R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F21R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F21R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F21R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F21R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F21R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F21R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F21R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F21R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F21R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F21R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F21R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F21R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F21R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F21R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F21R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F21R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F21R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F21R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F21R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F21R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F21R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F21R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F21R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F21R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F21R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F21R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F21R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F21R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F21R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F21R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F21R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F21R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F21R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F21R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F21R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F21R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F21R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F21R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F21R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F21R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F21R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F21R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F21R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F21R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F21R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F21R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F21R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F21R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F21R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F21R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F21R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F21R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F21R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F21R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F21R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F21R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F21R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F21R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F21R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F21R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F21R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F21R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F22R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F22R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F22R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F22R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F22R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F22R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F22R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F22R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F22R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F22R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F22R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F22R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F22R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F22R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F22R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F22R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F22R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F22R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F22R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F22R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F22R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F22R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F22R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F22R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F22R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F22R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F22R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F22R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F22R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F22R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F22R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F22R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F22R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F22R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F22R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F22R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F22R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F22R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F22R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F22R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F22R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F22R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F22R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F22R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F22R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F22R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F22R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F22R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F22R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F22R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F22R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F22R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F22R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F22R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F22R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F22R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F22R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F22R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F22R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F22R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F22R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F22R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F22R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F22R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F22R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F22R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F23R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F23R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F23R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F23R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F23R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F23R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F23R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F23R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F23R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F23R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F23R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F23R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F23R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F23R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F23R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F23R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F23R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F23R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F23R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F23R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F23R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F23R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F23R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F23R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F23R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F23R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F23R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F23R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F23R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F23R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F23R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F23R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F23R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F23R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F23R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F23R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F23R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F23R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F23R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F23R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F23R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F23R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F23R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F23R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F23R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F23R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F23R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F23R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F23R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F23R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F23R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F23R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F23R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F23R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F23R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F23R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F23R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F23R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F23R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F23R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F23R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F23R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F23R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F23R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F23R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F23R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F24R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F24R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F24R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F24R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F24R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F24R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F24R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F24R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F24R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F24R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F24R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F24R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F24R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F24R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F24R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F24R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F24R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F24R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F24R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F24R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F24R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F24R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F24R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F24R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F24R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F24R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F24R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F24R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F24R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F24R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F24R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F24R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F24R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F24R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F24R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F24R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F24R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F24R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F24R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F24R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F24R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F24R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F24R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F24R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F24R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F24R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F24R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F24R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F24R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F24R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F24R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F24R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F24R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F24R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F24R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F24R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F24R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F24R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F24R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F24R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F24R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F24R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F24R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F24R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F24R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F24R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F25R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F25R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F25R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F25R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F25R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F25R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F25R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F25R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F25R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F25R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F25R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F25R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F25R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F25R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F25R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F25R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F25R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F25R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F25R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F25R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F25R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F25R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F25R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F25R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F25R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F25R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F25R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F25R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F25R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F25R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F25R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F25R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F25R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F25R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F25R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F25R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F25R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F25R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F25R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F25R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F25R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F25R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F25R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F25R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F25R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F25R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F25R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F25R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F25R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F25R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F25R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F25R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F25R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F25R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F25R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F25R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F25R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F25R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F25R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F25R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F25R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F25R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F25R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F25R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F25R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F25R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F26R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F26R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F26R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F26R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F26R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F26R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F26R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F26R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F26R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F26R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F26R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F26R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F26R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F26R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F26R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F26R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F26R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F26R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F26R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F26R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F26R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F26R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F26R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F26R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F26R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F26R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F26R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F26R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F26R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F26R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F26R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F26R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F26R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F26R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F26R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F26R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F26R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F26R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F26R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F26R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F26R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F26R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F26R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F26R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F26R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F26R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F26R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F26R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F26R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F26R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F26R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F26R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F26R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F26R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F26R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F26R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F26R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F26R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F26R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F26R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F26R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F26R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F26R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F26R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F26R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F26R2_RESET_VALUE = 0x0;

    static constexpr uint32_t F27R1_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F27R1_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F27R1_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F27R1_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F27R1_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F27R1_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F27R1_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F27R1_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F27R1_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F27R1_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F27R1_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F27R1_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F27R1_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F27R1_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F27R1_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F27R1_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F27R1_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F27R1_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F27R1_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F27R1_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F27R1_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F27R1_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F27R1_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F27R1_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F27R1_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F27R1_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F27R1_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F27R1_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F27R1_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F27R1_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F27R1_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F27R1_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F27R1_RESET_VALUE = 0x0;

    static constexpr uint32_t F27R2_FB0 = 0x1;            // Filter bits
    static constexpr uint32_t F27R2_FB1 = 0x2;            // Filter bits
    static constexpr uint32_t F27R2_FB2 = 0x4;            // Filter bits
    static constexpr uint32_t F27R2_FB3 = 0x8;            // Filter bits
    static constexpr uint32_t F27R2_FB4 = 0x10;           // Filter bits
    static constexpr uint32_t F27R2_FB5 = 0x20;           // Filter bits
    static constexpr uint32_t F27R2_FB6 = 0x40;           // Filter bits
    static constexpr uint32_t F27R2_FB7 = 0x80;           // Filter bits
    static constexpr uint32_t F27R2_FB8 = 0x100;          // Filter bits
    static constexpr uint32_t F27R2_FB9 = 0x200;          // Filter bits
    static constexpr uint32_t F27R2_FB10 = 0x400;         // Filter bits
    static constexpr uint32_t F27R2_FB11 = 0x800;         // Filter bits
    static constexpr uint32_t F27R2_FB12 = 0x1000;        // Filter bits
    static constexpr uint32_t F27R2_FB13 = 0x2000;        // Filter bits
    static constexpr uint32_t F27R2_FB14 = 0x4000;        // Filter bits
    static constexpr uint32_t F27R2_FB15 = 0x8000;        // Filter bits
    static constexpr uint32_t F27R2_FB16 = 0x10000;       // Filter bits
    static constexpr uint32_t F27R2_FB17 = 0x20000;       // Filter bits
    static constexpr uint32_t F27R2_FB18 = 0x40000;       // Filter bits
    static constexpr uint32_t F27R2_FB19 = 0x80000;       // Filter bits
    static constexpr uint32_t F27R2_FB20 = 0x100000;      // Filter bits
    static constexpr uint32_t F27R2_FB21 = 0x200000;      // Filter bits
    static constexpr uint32_t F27R2_FB22 = 0x400000;      // Filter bits
    static constexpr uint32_t F27R2_FB23 = 0x800000;      // Filter bits
    static constexpr uint32_t F27R2_FB24 = 0x1000000;     // Filter bits
    static constexpr uint32_t F27R2_FB25 = 0x2000000;     // Filter bits
    static constexpr uint32_t F27R2_FB26 = 0x4000000;     // Filter bits
    static constexpr uint32_t F27R2_FB27 = 0x8000000;     // Filter bits
    static constexpr uint32_t F27R2_FB28 = 0x10000000;    // Filter bits
    static constexpr uint32_t F27R2_FB29 = 0x20000000;    // Filter bits
    static constexpr uint32_t F27R2_FB30 = 0x40000000;    // Filter bits
    static constexpr uint32_t F27R2_FB31 = 0x80000000;    // Filter bits
    static const uint32_t F27R2_RESET_VALUE = 0x0;

    static constexpr uint8_t CAN3_RX0 = 105; // CAN3 RX0 interrupt
    static constexpr uint8_t CAN3_RX1 = 106; // CAN3 RX1 interrupt
    static constexpr uint8_t CAN3_SCE = 107; // CAN3 SCE interrupt
    static constexpr uint8_t CAN3_TX = 104; // CAN3 TX interrupt
};

static can3_t& CAN3 = *reinterpret_cast<can3_t*>(0x40003400);

#define HAVE_PERIPHERAL_CAN3


////
//
//    FLASH
//
////

struct flash_t
{
    volatile uint32_t    ACR;                  // [Read-write] Flash access control register
    volatile uint32_t    KEYR;                 // [Write-only] Flash key register
    volatile uint32_t    OPTKEYR;              // [Write-only] Flash option key register
    volatile uint32_t    SR;                   // Status register
    volatile uint32_t    CR;                   // [Read-write] Control register
    volatile uint32_t    OPTCR;                // [Read-write] Flash option control register
    volatile uint32_t    OPTCR1;               // [Read-write] Flash option control register 1

    template<uint32_t X>
    static constexpr uint32_t ACR_LATENCY =             // Latency (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static constexpr uint32_t ACR_PRFTEN = 0x100;       // Prefetch enable
    static constexpr uint32_t ACR_ARTEN = 0x200;        // ART Accelerator Enable
    static constexpr uint32_t ACR_ARTRST = 0x800;       // ART Accelerator reset
    static const uint32_t ACR_RESET_VALUE = 0x0;


    static const uint32_t KEYR_RESET_VALUE = 0x0;


    static const uint32_t OPTKEYR_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_EOP = 0x1;            // End of operation, Read-write
    static constexpr uint32_t SR_OPERR = 0x2;          // Operation error, Read-write
    static constexpr uint32_t SR_WRPERR = 0x10;        // Write protection error, Read-write
    static constexpr uint32_t SR_PGAERR = 0x20;        // Programming alignment error, Read-write
    static constexpr uint32_t SR_PGPERR = 0x40;        // Programming parallelism error, Read-write
    static constexpr uint32_t SR_ERSERR = 0x80;        // Programming sequence error, Read-write
    static constexpr uint32_t SR_BSY = 0x10000;        // Busy, Read-only
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint32_t CR_PG = 0x1;             // Programming
    static constexpr uint32_t CR_SER = 0x2;            // Sector Erase
    static constexpr uint32_t CR_MER1 = 0x4;           // Mass Erase of sectors 0 to 11
    template<uint32_t X>
    static constexpr uint32_t CR_SNB =                 // Sector number (5 bits)
        bit_field_t<3, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR_PSIZE =               // Program size (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static constexpr uint32_t CR_MER2 = 0x8000;        // Mass Erase of sectors 12 to 23
    static constexpr uint32_t CR_STRT = 0x10000;       // Start
    static constexpr uint32_t CR_EOPIE = 0x1000000;    // End of operation interrupt enable
    static constexpr uint32_t CR_ERRIE = 0x2000000;    // Error interrupt enable
    static constexpr uint32_t CR_LOCK = 0x80000000;    // Lock
    static const uint32_t CR_RESET_VALUE = 0x80000000;

    static constexpr uint32_t OPTCR_OPTLOCK = 0x1;        // Option lock
    static constexpr uint32_t OPTCR_OPTSTRT = 0x2;        // Option start
    template<uint32_t X>
    static constexpr uint32_t OPTCR_BOR_LEV =             // BOR reset Level (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t OPTCR_WWDG_SW = 0x10;       // User option bytes
    static constexpr uint32_t OPTCR_IWDG_SW = 0x20;       // User option bytes
    static constexpr uint32_t OPTCR_nRST_STOP = 0x40;     // User option bytes
    static constexpr uint32_t OPTCR_nRST_STDBY = 0x80;    // User option bytes
    template<uint32_t X>
    static constexpr uint32_t OPTCR_RDP =                 // Read protect (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OPTCR_nWRP =                // Not write protect (12 bits)
        bit_field_t<16, 0xfff>::value<X>();
    static constexpr uint32_t OPTCR_nDBOOT = 0x10000000;  // Dual Boot mode (valid only when nDBANK=0)
    static constexpr uint32_t OPTCR_nDBANK = 0x20000000;  // Not dual bank mode
    static constexpr uint32_t OPTCR_IWDG_STDBY = 0x40000000;// Independent watchdog counter freeze in standby mode
    static constexpr uint32_t OPTCR_IWDG_STOP = 0x80000000;// Independent watchdog counter freeze in Stop mode
    static const uint32_t OPTCR_RESET_VALUE = 0xfffaaed;

    template<uint32_t X>
    static constexpr uint32_t OPTCR1_BOOT_ADD0 =           // Boot base address when Boot pin =0 (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OPTCR1_BOOT_ADD1 =           // Boot base address when Boot pin =1 (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OPTCR1_RESET_VALUE = 0xfff0000;

    static constexpr uint8_t FLASH = 4; // Flash global interrupt
};

static flash_t& FLASH = *reinterpret_cast<flash_t*>(0x40023c00);

#define HAVE_PERIPHERAL_FLASH


////
//
//    External interrupt/event controller
//
////

struct exti_t
{
    volatile uint32_t    IMR;                  // [Read-write] Interrupt mask register (EXTI_IMR)
    volatile uint32_t    EMR;                  // [Read-write] Event mask register (EXTI_EMR)
    volatile uint32_t    RTSR;                 // [Read-write] Rising Trigger selection register (EXTI_RTSR)
    volatile uint32_t    FTSR;                 // [Read-write] Falling Trigger selection register (EXTI_FTSR)
    volatile uint32_t    SWIER;                // [Read-write] Software interrupt event register (EXTI_SWIER)
    volatile uint32_t    PR;                   // [Read-write] Pending register (EXTI_PR)

    static constexpr uint32_t IMR_MR0 = 0x1;            // Interrupt Mask on line 0
    static constexpr uint32_t IMR_MR1 = 0x2;            // Interrupt Mask on line 1
    static constexpr uint32_t IMR_MR2 = 0x4;            // Interrupt Mask on line 2
    static constexpr uint32_t IMR_MR3 = 0x8;            // Interrupt Mask on line 3
    static constexpr uint32_t IMR_MR4 = 0x10;           // Interrupt Mask on line 4
    static constexpr uint32_t IMR_MR5 = 0x20;           // Interrupt Mask on line 5
    static constexpr uint32_t IMR_MR6 = 0x40;           // Interrupt Mask on line 6
    static constexpr uint32_t IMR_MR7 = 0x80;           // Interrupt Mask on line 7
    static constexpr uint32_t IMR_MR8 = 0x100;          // Interrupt Mask on line 8
    static constexpr uint32_t IMR_MR9 = 0x200;          // Interrupt Mask on line 9
    static constexpr uint32_t IMR_MR10 = 0x400;         // Interrupt Mask on line 10
    static constexpr uint32_t IMR_MR11 = 0x800;         // Interrupt Mask on line 11
    static constexpr uint32_t IMR_MR12 = 0x1000;        // Interrupt Mask on line 12
    static constexpr uint32_t IMR_MR13 = 0x2000;        // Interrupt Mask on line 13
    static constexpr uint32_t IMR_MR14 = 0x4000;        // Interrupt Mask on line 14
    static constexpr uint32_t IMR_MR15 = 0x8000;        // Interrupt Mask on line 15
    static constexpr uint32_t IMR_MR16 = 0x10000;       // Interrupt Mask on line 16
    static constexpr uint32_t IMR_MR17 = 0x20000;       // Interrupt Mask on line 17
    static constexpr uint32_t IMR_MR18 = 0x40000;       // Interrupt Mask on line 18
    static constexpr uint32_t IMR_MR19 = 0x80000;       // Interrupt Mask on line 19
    static constexpr uint32_t IMR_MR20 = 0x100000;      // Interrupt Mask on line 20
    static constexpr uint32_t IMR_MR21 = 0x200000;      // Interrupt Mask on line 21
    static constexpr uint32_t IMR_MR22 = 0x400000;      // Interrupt Mask on line 22
    static const uint32_t IMR_RESET_VALUE = 0x0;

    static constexpr uint32_t EMR_MR0 = 0x1;            // Event Mask on line 0
    static constexpr uint32_t EMR_MR1 = 0x2;            // Event Mask on line 1
    static constexpr uint32_t EMR_MR2 = 0x4;            // Event Mask on line 2
    static constexpr uint32_t EMR_MR3 = 0x8;            // Event Mask on line 3
    static constexpr uint32_t EMR_MR4 = 0x10;           // Event Mask on line 4
    static constexpr uint32_t EMR_MR5 = 0x20;           // Event Mask on line 5
    static constexpr uint32_t EMR_MR6 = 0x40;           // Event Mask on line 6
    static constexpr uint32_t EMR_MR7 = 0x80;           // Event Mask on line 7
    static constexpr uint32_t EMR_MR8 = 0x100;          // Event Mask on line 8
    static constexpr uint32_t EMR_MR9 = 0x200;          // Event Mask on line 9
    static constexpr uint32_t EMR_MR10 = 0x400;         // Event Mask on line 10
    static constexpr uint32_t EMR_MR11 = 0x800;         // Event Mask on line 11
    static constexpr uint32_t EMR_MR12 = 0x1000;        // Event Mask on line 12
    static constexpr uint32_t EMR_MR13 = 0x2000;        // Event Mask on line 13
    static constexpr uint32_t EMR_MR14 = 0x4000;        // Event Mask on line 14
    static constexpr uint32_t EMR_MR15 = 0x8000;        // Event Mask on line 15
    static constexpr uint32_t EMR_MR16 = 0x10000;       // Event Mask on line 16
    static constexpr uint32_t EMR_MR17 = 0x20000;       // Event Mask on line 17
    static constexpr uint32_t EMR_MR18 = 0x40000;       // Event Mask on line 18
    static constexpr uint32_t EMR_MR19 = 0x80000;       // Event Mask on line 19
    static constexpr uint32_t EMR_MR20 = 0x100000;      // Event Mask on line 20
    static constexpr uint32_t EMR_MR21 = 0x200000;      // Event Mask on line 21
    static constexpr uint32_t EMR_MR22 = 0x400000;      // Event Mask on line 22
    static const uint32_t EMR_RESET_VALUE = 0x0;

    static constexpr uint32_t RTSR_TR0 = 0x1;            // Rising trigger event configuration of line 0
    static constexpr uint32_t RTSR_TR1 = 0x2;            // Rising trigger event configuration of line 1
    static constexpr uint32_t RTSR_TR2 = 0x4;            // Rising trigger event configuration of line 2
    static constexpr uint32_t RTSR_TR3 = 0x8;            // Rising trigger event configuration of line 3
    static constexpr uint32_t RTSR_TR4 = 0x10;           // Rising trigger event configuration of line 4
    static constexpr uint32_t RTSR_TR5 = 0x20;           // Rising trigger event configuration of line 5
    static constexpr uint32_t RTSR_TR6 = 0x40;           // Rising trigger event configuration of line 6
    static constexpr uint32_t RTSR_TR7 = 0x80;           // Rising trigger event configuration of line 7
    static constexpr uint32_t RTSR_TR8 = 0x100;          // Rising trigger event configuration of line 8
    static constexpr uint32_t RTSR_TR9 = 0x200;          // Rising trigger event configuration of line 9
    static constexpr uint32_t RTSR_TR10 = 0x400;         // Rising trigger event configuration of line 10
    static constexpr uint32_t RTSR_TR11 = 0x800;         // Rising trigger event configuration of line 11
    static constexpr uint32_t RTSR_TR12 = 0x1000;        // Rising trigger event configuration of line 12
    static constexpr uint32_t RTSR_TR13 = 0x2000;        // Rising trigger event configuration of line 13
    static constexpr uint32_t RTSR_TR14 = 0x4000;        // Rising trigger event configuration of line 14
    static constexpr uint32_t RTSR_TR15 = 0x8000;        // Rising trigger event configuration of line 15
    static constexpr uint32_t RTSR_TR16 = 0x10000;       // Rising trigger event configuration of line 16
    static constexpr uint32_t RTSR_TR17 = 0x20000;       // Rising trigger event configuration of line 17
    static constexpr uint32_t RTSR_TR18 = 0x40000;       // Rising trigger event configuration of line 18
    static constexpr uint32_t RTSR_TR19 = 0x80000;       // Rising trigger event configuration of line 19
    static constexpr uint32_t RTSR_TR20 = 0x100000;      // Rising trigger event configuration of line 20
    static constexpr uint32_t RTSR_TR21 = 0x200000;      // Rising trigger event configuration of line 21
    static constexpr uint32_t RTSR_TR22 = 0x400000;      // Rising trigger event configuration of line 22
    static const uint32_t RTSR_RESET_VALUE = 0x0;

    static constexpr uint32_t FTSR_TR0 = 0x1;            // Falling trigger event configuration of line 0
    static constexpr uint32_t FTSR_TR1 = 0x2;            // Falling trigger event configuration of line 1
    static constexpr uint32_t FTSR_TR2 = 0x4;            // Falling trigger event configuration of line 2
    static constexpr uint32_t FTSR_TR3 = 0x8;            // Falling trigger event configuration of line 3
    static constexpr uint32_t FTSR_TR4 = 0x10;           // Falling trigger event configuration of line 4
    static constexpr uint32_t FTSR_TR5 = 0x20;           // Falling trigger event configuration of line 5
    static constexpr uint32_t FTSR_TR6 = 0x40;           // Falling trigger event configuration of line 6
    static constexpr uint32_t FTSR_TR7 = 0x80;           // Falling trigger event configuration of line 7
    static constexpr uint32_t FTSR_TR8 = 0x100;          // Falling trigger event configuration of line 8
    static constexpr uint32_t FTSR_TR9 = 0x200;          // Falling trigger event configuration of line 9
    static constexpr uint32_t FTSR_TR10 = 0x400;         // Falling trigger event configuration of line 10
    static constexpr uint32_t FTSR_TR11 = 0x800;         // Falling trigger event configuration of line 11
    static constexpr uint32_t FTSR_TR12 = 0x1000;        // Falling trigger event configuration of line 12
    static constexpr uint32_t FTSR_TR13 = 0x2000;        // Falling trigger event configuration of line 13
    static constexpr uint32_t FTSR_TR14 = 0x4000;        // Falling trigger event configuration of line 14
    static constexpr uint32_t FTSR_TR15 = 0x8000;        // Falling trigger event configuration of line 15
    static constexpr uint32_t FTSR_TR16 = 0x10000;       // Falling trigger event configuration of line 16
    static constexpr uint32_t FTSR_TR17 = 0x20000;       // Falling trigger event configuration of line 17
    static constexpr uint32_t FTSR_TR18 = 0x40000;       // Falling trigger event configuration of line 18
    static constexpr uint32_t FTSR_TR19 = 0x80000;       // Falling trigger event configuration of line 19
    static constexpr uint32_t FTSR_TR20 = 0x100000;      // Falling trigger event configuration of line 20
    static constexpr uint32_t FTSR_TR21 = 0x200000;      // Falling trigger event configuration of line 21
    static constexpr uint32_t FTSR_TR22 = 0x400000;      // Falling trigger event configuration of line 22
    static const uint32_t FTSR_RESET_VALUE = 0x0;

    static constexpr uint32_t SWIER_SWIER0 = 0x1;         // Software Interrupt on line 0
    static constexpr uint32_t SWIER_SWIER1 = 0x2;         // Software Interrupt on line 1
    static constexpr uint32_t SWIER_SWIER2 = 0x4;         // Software Interrupt on line 2
    static constexpr uint32_t SWIER_SWIER3 = 0x8;         // Software Interrupt on line 3
    static constexpr uint32_t SWIER_SWIER4 = 0x10;        // Software Interrupt on line 4
    static constexpr uint32_t SWIER_SWIER5 = 0x20;        // Software Interrupt on line 5
    static constexpr uint32_t SWIER_SWIER6 = 0x40;        // Software Interrupt on line 6
    static constexpr uint32_t SWIER_SWIER7 = 0x80;        // Software Interrupt on line 7
    static constexpr uint32_t SWIER_SWIER8 = 0x100;       // Software Interrupt on line 8
    static constexpr uint32_t SWIER_SWIER9 = 0x200;       // Software Interrupt on line 9
    static constexpr uint32_t SWIER_SWIER10 = 0x400;      // Software Interrupt on line 10
    static constexpr uint32_t SWIER_SWIER11 = 0x800;      // Software Interrupt on line 11
    static constexpr uint32_t SWIER_SWIER12 = 0x1000;     // Software Interrupt on line 12
    static constexpr uint32_t SWIER_SWIER13 = 0x2000;     // Software Interrupt on line 13
    static constexpr uint32_t SWIER_SWIER14 = 0x4000;     // Software Interrupt on line 14
    static constexpr uint32_t SWIER_SWIER15 = 0x8000;     // Software Interrupt on line 15
    static constexpr uint32_t SWIER_SWIER16 = 0x10000;    // Software Interrupt on line 16
    static constexpr uint32_t SWIER_SWIER17 = 0x20000;    // Software Interrupt on line 17
    static constexpr uint32_t SWIER_SWIER18 = 0x40000;    // Software Interrupt on line 18
    static constexpr uint32_t SWIER_SWIER19 = 0x80000;    // Software Interrupt on line 19
    static constexpr uint32_t SWIER_SWIER20 = 0x100000;   // Software Interrupt on line 20
    static constexpr uint32_t SWIER_SWIER21 = 0x200000;   // Software Interrupt on line 21
    static constexpr uint32_t SWIER_SWIER22 = 0x400000;   // Software Interrupt on line 22
    static const uint32_t SWIER_RESET_VALUE = 0x0;

    static constexpr uint32_t PR_PR0 = 0x1;            // Pending bit 0
    static constexpr uint32_t PR_PR1 = 0x2;            // Pending bit 1
    static constexpr uint32_t PR_PR2 = 0x4;            // Pending bit 2
    static constexpr uint32_t PR_PR3 = 0x8;            // Pending bit 3
    static constexpr uint32_t PR_PR4 = 0x10;           // Pending bit 4
    static constexpr uint32_t PR_PR5 = 0x20;           // Pending bit 5
    static constexpr uint32_t PR_PR6 = 0x40;           // Pending bit 6
    static constexpr uint32_t PR_PR7 = 0x80;           // Pending bit 7
    static constexpr uint32_t PR_PR8 = 0x100;          // Pending bit 8
    static constexpr uint32_t PR_PR9 = 0x200;          // Pending bit 9
    static constexpr uint32_t PR_PR10 = 0x400;         // Pending bit 10
    static constexpr uint32_t PR_PR11 = 0x800;         // Pending bit 11
    static constexpr uint32_t PR_PR12 = 0x1000;        // Pending bit 12
    static constexpr uint32_t PR_PR13 = 0x2000;        // Pending bit 13
    static constexpr uint32_t PR_PR14 = 0x4000;        // Pending bit 14
    static constexpr uint32_t PR_PR15 = 0x8000;        // Pending bit 15
    static constexpr uint32_t PR_PR16 = 0x10000;       // Pending bit 16
    static constexpr uint32_t PR_PR17 = 0x20000;       // Pending bit 17
    static constexpr uint32_t PR_PR18 = 0x40000;       // Pending bit 18
    static constexpr uint32_t PR_PR19 = 0x80000;       // Pending bit 19
    static constexpr uint32_t PR_PR20 = 0x100000;      // Pending bit 20
    static constexpr uint32_t PR_PR21 = 0x200000;      // Pending bit 21
    static constexpr uint32_t PR_PR22 = 0x400000;      // Pending bit 22
    static const uint32_t PR_RESET_VALUE = 0x0;

    static constexpr uint8_t EXTI0 = 6; // EXTI Line0 interrupt
    static constexpr uint8_t EXTI1 = 7; // EXTI Line1 interrupt
    static constexpr uint8_t EXTI15_10 = 40; // EXTI Line[15:10] interrupts
    static constexpr uint8_t EXTI2 = 8; // EXTI Line2 interrupt
    static constexpr uint8_t EXTI3 = 9; // EXTI Line3 interrupt
    static constexpr uint8_t EXTI4 = 10; // EXTI Line4 interrupt
    static constexpr uint8_t EXTI9_5 = 23; // EXTI Line[9:5] interrupts
    static constexpr uint8_t OTG_FS_WKUP = 42; // USB On-The-Go FS Wakeup through EXTI line interrupt
    static constexpr uint8_t PVD = 1; // PVD through EXTI line detection
    static constexpr uint8_t RTC_ALARM = 41; // RTC alarms through EXTI line 18 interrupts
    static constexpr uint8_t TAMP_STAMP = 2; // Tamper and TimeStamp interrupts through the EXTI line
};

static exti_t& EXTI = *reinterpret_cast<exti_t*>(0x40013c00);

#define HAVE_PERIPHERAL_EXTI


////
//
//    LCD-TFT Controller
//
////

struct ltcd_t
{
    volatile uint32_t    SSCR;                 // [Read-write] Synchronization Size Configuration Register
    volatile uint32_t    BPCR;                 // [Read-write] Back Porch Configuration Register
    volatile uint32_t    AWCR;                 // [Read-write] Active Width Configuration Register
    volatile uint32_t    TWCR;                 // [Read-write] Total Width Configuration Register
    volatile uint32_t    GCR;                  // Global Control Register
    reserved_t<2>        _0;
    volatile uint32_t    SRCR;                 // [Read-write] Shadow Reload Configuration Register
    reserved_t<1>        _1;
    volatile uint32_t    BCCR;                 // [Read-write] Background Color Configuration Register
    reserved_t<1>        _2;
    volatile uint32_t    IER;                  // [Read-write] Interrupt Enable Register
    volatile uint32_t    ISR;                  // [Read-only] Interrupt Status Register
    volatile uint32_t    ICR;                  // [Write-only] Interrupt Clear Register
    volatile uint32_t    LIPCR;                // [Read-write] Line Interrupt Position Configuration Register
    volatile uint32_t    CPSR;                 // [Read-only] Current Position Status Register
    volatile uint32_t    CDSR;                 // [Read-only] Current Display Status Register
    reserved_t<14>       _3;
    volatile uint32_t    L1CR;                 // [Read-write] Layerx Control Register
    volatile uint32_t    L1WHPCR;              // [Read-write] Layerx Window Horizontal Position Configuration Register
    volatile uint32_t    L1WVPCR;              // [Read-write] Layerx Window Vertical Position Configuration Register
    volatile uint32_t    L1CKCR;               // [Read-write] Layerx Color Keying Configuration Register
    volatile uint32_t    L1PFCR;               // [Read-write] Layerx Pixel Format Configuration Register
    volatile uint32_t    L1CACR;               // [Read-write] Layerx Constant Alpha Configuration Register
    volatile uint32_t    L1DCCR;               // [Read-write] Layerx Default Color Configuration Register
    volatile uint32_t    L1BFCR;               // [Read-write] Layerx Blending Factors Configuration Register
    reserved_t<2>        _4;
    volatile uint32_t    L1CFBAR;              // [Read-write] Layerx Color Frame Buffer Address Register
    volatile uint32_t    L1CFBLR;              // [Read-write] Layerx Color Frame Buffer Length Register
    volatile uint32_t    L1CFBLNR;             // [Read-write] Layerx ColorFrame Buffer Line Number Register
    reserved_t<3>        _5;
    volatile uint32_t    L1CLUTWR;             // [Write-only] Layerx CLUT Write Register
    reserved_t<15>       _6;
    volatile uint32_t    L2CR;                 // [Read-write] Layerx Control Register
    volatile uint32_t    L2WHPCR;              // [Read-write] Layerx Window Horizontal Position Configuration Register
    volatile uint32_t    L2WVPCR;              // [Read-write] Layerx Window Vertical Position Configuration Register
    volatile uint32_t    L2CKCR;               // [Read-write] Layerx Color Keying Configuration Register
    volatile uint32_t    L2PFCR;               // [Read-write] Layerx Pixel Format Configuration Register
    volatile uint32_t    L2CACR;               // [Read-write] Layerx Constant Alpha Configuration Register
    volatile uint32_t    L2DCCR;               // [Read-write] Layerx Default Color Configuration Register
    volatile uint32_t    L2BFCR;               // [Read-write] Layerx Blending Factors Configuration Register
    reserved_t<2>        _7;
    volatile uint32_t    L2CFBAR;              // [Read-write] Layerx Color Frame Buffer Address Register
    volatile uint32_t    L2CFBLR;              // [Read-write] Layerx Color Frame Buffer Length Register
    volatile uint32_t    L2CFBLNR;             // [Read-write] Layerx ColorFrame Buffer Line Number Register
    reserved_t<3>        _8;
    volatile uint32_t    L2CLUTWR;             // [Write-only] Layerx CLUT Write Register

    template<uint32_t X>
    static constexpr uint32_t SSCR_HSW =                 // Horizontal Synchronization Width (in units of pixel clock period) (10 bits)
        bit_field_t<16, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SSCR_VSH =                 // Vertical Synchronization Height (in units of horizontal scan line) (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    static const uint32_t SSCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BPCR_AHBP =                // Accumulated Horizontal back porch (in units of pixel clock period) (10 bits)
        bit_field_t<16, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BPCR_AVBP =                // Accumulated Vertical back porch (in units of horizontal scan line) (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    static const uint32_t BPCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AWCR_AAV =                 // AAV (10 bits)
        bit_field_t<16, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWCR_AAH =                 // Accumulated Active Height (in units of horizontal scan line) (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    static const uint32_t AWCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TWCR_TOTALW =              // Total Width (in units of pixel clock period) (10 bits)
        bit_field_t<16, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TWCR_TOTALH =              // Total Height (in units of horizontal scan line) (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    static const uint32_t TWCR_RESET_VALUE = 0x0;

    static constexpr uint32_t GCR_HSPOL = 0x80000000;   // Horizontal Synchronization Polarity, Read-write
    static constexpr uint32_t GCR_VSPOL = 0x40000000;   // Vertical Synchronization Polarity, Read-write
    static constexpr uint32_t GCR_DEPOL = 0x20000000;   // Data Enable Polarity, Read-write
    static constexpr uint32_t GCR_PCPOL = 0x10000000;   // Pixel Clock Polarity, Read-write
    static constexpr uint32_t GCR_DEN = 0x10000;        // Dither Enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t GCR_DRW =                 // Dither Red Width (3 bits), Read-only
        bit_field_t<12, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GCR_DGW =                 // Dither Green Width (3 bits), Read-only
        bit_field_t<8, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GCR_DBW =                 // Dither Blue Width (3 bits), Read-only
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t GCR_LTDCEN = 0x1;         // LCD-TFT controller enable bit, Read-write
    static const uint32_t GCR_RESET_VALUE = 0x2220;

    static constexpr uint32_t SRCR_VBR = 0x2;            // Vertical Blanking Reload
    static constexpr uint32_t SRCR_IMR = 0x1;            // Immediate Reload
    static const uint32_t SRCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BCCR_BC =                  // Background Color Red value (24 bits)
        bit_field_t<0, 0xffffff>::value<X>();
    static const uint32_t BCCR_RESET_VALUE = 0x0;

    static constexpr uint32_t IER_RRIE = 0x8;           // Register Reload interrupt enable
    static constexpr uint32_t IER_TERRIE = 0x4;         // Transfer Error Interrupt Enable
    static constexpr uint32_t IER_FUIE = 0x2;           // FIFO Underrun Interrupt Enable
    static constexpr uint32_t IER_LIE = 0x1;            // Line Interrupt Enable
    static const uint32_t IER_RESET_VALUE = 0x0;

    static constexpr uint32_t ISR_RRIF = 0x8;           // Register Reload Interrupt Flag
    static constexpr uint32_t ISR_TERRIF = 0x4;         // Transfer Error interrupt flag
    static constexpr uint32_t ISR_FUIF = 0x2;           // FIFO Underrun Interrupt flag
    static constexpr uint32_t ISR_LIF = 0x1;            // Line Interrupt flag
    static const uint32_t ISR_RESET_VALUE = 0x0;

    static constexpr uint32_t ICR_CRRIF = 0x8;          // Clears Register Reload Interrupt Flag
    static constexpr uint32_t ICR_CTERRIF = 0x4;        // Clears the Transfer Error Interrupt Flag
    static constexpr uint32_t ICR_CFUIF = 0x2;          // Clears the FIFO Underrun Interrupt flag
    static constexpr uint32_t ICR_CLIF = 0x1;           // Clears the Line Interrupt Flag
    static const uint32_t ICR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t LIPCR_LIPOS =               // Line Interrupt Position (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    static const uint32_t LIPCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CPSR_CXPOS =               // Current X Position (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CPSR_CYPOS =               // Current Y Position (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CPSR_RESET_VALUE = 0x0;

    static constexpr uint32_t CDSR_HSYNCS = 0x8;         // Horizontal Synchronization display Status
    static constexpr uint32_t CDSR_VSYNCS = 0x4;         // Vertical Synchronization display Status
    static constexpr uint32_t CDSR_HDES = 0x2;           // Horizontal Data Enable display Status
    static constexpr uint32_t CDSR_VDES = 0x1;           // Vertical Data Enable display Status
    static const uint32_t CDSR_RESET_VALUE = 0xf;

    static constexpr uint32_t L1CR_CLUTEN = 0x10;        // Color Look-Up Table Enable
    static constexpr uint32_t L1CR_COLKEN = 0x2;         // Color Keying Enable
    static constexpr uint32_t L1CR_LEN = 0x1;            // Layer Enable
    static const uint32_t L1CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t L1WHPCR_WHSPPOS =             // Window Horizontal Stop Position (12 bits)
        bit_field_t<16, 0xfff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L1WHPCR_WHSTPOS =             // Window Horizontal Start Position (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t L1WHPCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t L1WVPCR_WVSPPOS =             // Window Vertical Stop Position (11 bits)
        bit_field_t<16, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L1WVPCR_WVSTPOS =             // Window Vertical Start Position (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    static const uint32_t L1WVPCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t L1CKCR_CKRED =               // Color Key Red value (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L1CKCR_CKGREEN =             // Color Key Green value (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L1CKCR_CKBLUE =              // Color Key Blue value (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t L1CKCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t L1PFCR_PF =                  // Pixel Format (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t L1PFCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t L1CACR_CONSTA =              // Constant Alpha (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t L1CACR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t L1DCCR_DCALPHA =             // Default Color Alpha (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L1DCCR_DCRED =               // Default Color Red (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L1DCCR_DCGREEN =             // Default Color Green (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L1DCCR_DCBLUE =              // Default Color Blue (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t L1DCCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t L1BFCR_BF1 =                 // Blending Factor 1 (3 bits)
        bit_field_t<8, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L1BFCR_BF2 =                 // Blending Factor 2 (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t L1BFCR_RESET_VALUE = 0x607;


    static const uint32_t L1CFBAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t L1CFBLR_CFBP =                // Color Frame Buffer Pitch in bytes (13 bits)
        bit_field_t<16, 0x1fff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L1CFBLR_CFBLL =               // Color Frame Buffer Line Length (13 bits)
        bit_field_t<0, 0x1fff>::value<X>();
    static const uint32_t L1CFBLR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t L1CFBLNR_CFBLNBR =             // Frame Buffer Line Number (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    static const uint32_t L1CFBLNR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t L1CLUTWR_CLUTADD =             // CLUT Address (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L1CLUTWR_RED =                 // Red value (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L1CLUTWR_GREEN =               // Green value (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L1CLUTWR_BLUE =                // Blue value (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t L1CLUTWR_RESET_VALUE = 0x0;

    static constexpr uint32_t L2CR_CLUTEN = 0x10;        // Color Look-Up Table Enable
    static constexpr uint32_t L2CR_COLKEN = 0x2;         // Color Keying Enable
    static constexpr uint32_t L2CR_LEN = 0x1;            // Layer Enable
    static const uint32_t L2CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t L2WHPCR_WHSPPOS =             // Window Horizontal Stop Position (12 bits)
        bit_field_t<16, 0xfff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L2WHPCR_WHSTPOS =             // Window Horizontal Start Position (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t L2WHPCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t L2WVPCR_WVSPPOS =             // Window Vertical Stop Position (11 bits)
        bit_field_t<16, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L2WVPCR_WVSTPOS =             // Window Vertical Start Position (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    static const uint32_t L2WVPCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t L2CKCR_CKRED =               // Color Key Red value (9 bits)
        bit_field_t<15, 0x1ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L2CKCR_CKGREEN =             // Color Key Green value (7 bits)
        bit_field_t<8, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L2CKCR_CKBLUE =              // Color Key Blue value (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t L2CKCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t L2PFCR_PF =                  // Pixel Format (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t L2PFCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t L2CACR_CONSTA =              // Constant Alpha (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t L2CACR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t L2DCCR_DCALPHA =             // Default Color Alpha (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L2DCCR_DCRED =               // Default Color Red (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L2DCCR_DCGREEN =             // Default Color Green (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L2DCCR_DCBLUE =              // Default Color Blue (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t L2DCCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t L2BFCR_BF1 =                 // Blending Factor 1 (3 bits)
        bit_field_t<8, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L2BFCR_BF2 =                 // Blending Factor 2 (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t L2BFCR_RESET_VALUE = 0x607;


    static const uint32_t L2CFBAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t L2CFBLR_CFBP =                // Color Frame Buffer Pitch in bytes (13 bits)
        bit_field_t<16, 0x1fff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L2CFBLR_CFBLL =               // Color Frame Buffer Line Length (13 bits)
        bit_field_t<0, 0x1fff>::value<X>();
    static const uint32_t L2CFBLR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t L2CFBLNR_CFBLNBR =             // Frame Buffer Line Number (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    static const uint32_t L2CFBLNR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t L2CLUTWR_CLUTADD =             // CLUT Address (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L2CLUTWR_RED =                 // Red value (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L2CLUTWR_GREEN =               // Green value (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t L2CLUTWR_BLUE =                // Blue value (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t L2CLUTWR_RESET_VALUE = 0x0;

    static constexpr uint8_t LCD_TFT = 88; // LTDC global interrupt
};

static ltcd_t& LTCD = *reinterpret_cast<ltcd_t*>(0x40016800);

#define HAVE_PERIPHERAL_LTCD


////
//
//    Serial audio interface
//
////

struct sai1_t
{
    volatile uint32_t    GCR;                  // [Read-write] Global configuration register
    volatile uint32_t    ACR1;                 // [Read-write] AConfiguration register 1
    volatile uint32_t    ACR2;                 // [Read-write] AConfiguration register 2
    volatile uint32_t    AFRCR;                // [Read-write] AFRCR
    volatile uint32_t    ASLOTR;               // [Read-write] ASlot register
    volatile uint32_t    AIM;                  // [Read-write] AInterrupt mask register2
    volatile uint32_t    ASR;                  // [Read-write] AStatus register
    volatile uint32_t    ACLRFR;               // [Read-write] AClear flag register
    volatile uint32_t    ADR;                  // [Read-write] AData register
    volatile uint32_t    BCR1;                 // [Read-write] BConfiguration register 1
    volatile uint32_t    BCR2;                 // [Read-write] BConfiguration register 2
    volatile uint32_t    BFRCR;                // [Read-write] BFRCR
    volatile uint32_t    BSLOTR;               // [Read-write] BSlot register
    volatile uint32_t    BIM;                  // [Read-write] BInterrupt mask register2
    volatile uint32_t    BSR;                  // [Read-only] BStatus register
    volatile uint32_t    BCLRFR;               // [Write-only] BClear flag register
    volatile uint32_t    BDR;                  // [Read-write] BData register

    template<uint32_t X>
    static constexpr uint32_t GCR_SYNCIN =              // Synchronization inputs (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GCR_SYNCOUT =             // Synchronization outputs (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static const uint32_t GCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ACR1_MCJDIV =              // Master clock divider (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    static constexpr uint32_t ACR1_NODIV = 0x80000;      // No divider
    static constexpr uint32_t ACR1_DMAEN = 0x20000;      // DMA enable
    static constexpr uint32_t ACR1_SAIAEN = 0x10000;     // Audio block A enable
    static constexpr uint32_t ACR1_OutDri = 0x2000;      // Output drive
    static constexpr uint32_t ACR1_MONO = 0x1000;        // Mono mode
    template<uint32_t X>
    static constexpr uint32_t ACR1_SYNCEN =              // Synchronization enable (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    static constexpr uint32_t ACR1_CKSTR = 0x200;        // Clock strobing edge
    static constexpr uint32_t ACR1_LSBFIRST = 0x100;     // Least significant bit first
    template<uint32_t X>
    static constexpr uint32_t ACR1_DS =                  // Data size (3 bits)
        bit_field_t<5, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ACR1_PRTCFG =              // Protocol configuration (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ACR1_MODE =                // Audio block mode (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t ACR1_RESET_VALUE = 0x40;

    template<uint32_t X>
    static constexpr uint32_t ACR2_COMP =                // Companding mode (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t ACR2_CPL = 0x2000;         // Complement bit
    template<uint32_t X>
    static constexpr uint32_t ACR2_MUTECN =              // Mute counter (6 bits)
        bit_field_t<7, 0x3f>::value<X>();
    static constexpr uint32_t ACR2_MUTEVAL = 0x40;       // Mute value
    static constexpr uint32_t ACR2_MUTE = 0x20;          // Mute
    static constexpr uint32_t ACR2_TRIS = 0x10;          // Tristate management on data line
    static constexpr uint32_t ACR2_FFLUS = 0x8;          // FIFO flush
    template<uint32_t X>
    static constexpr uint32_t ACR2_FTH =                 // FIFO threshold (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t ACR2_RESET_VALUE = 0x0;

    static constexpr uint32_t AFRCR_FSOFF = 0x40000;      // Frame synchronization offset
    static constexpr uint32_t AFRCR_FSPOL = 0x20000;      // Frame synchronization polarity
    static constexpr uint32_t AFRCR_FSDEF = 0x10000;      // Frame synchronization definition
    template<uint32_t X>
    static constexpr uint32_t AFRCR_FSALL =               // Frame synchronization active level length (7 bits)
        bit_field_t<8, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRCR_FRL =                 // Frame length (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t AFRCR_RESET_VALUE = 0x7;

    template<uint32_t X>
    static constexpr uint32_t ASLOTR_SLOTEN =              // Slot enable (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ASLOTR_NBSLOT =              // Number of slots in an audio frame (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ASLOTR_SLOTSZ =              // Slot size (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ASLOTR_FBOFF =               // First bit offset (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t ASLOTR_RESET_VALUE = 0x0;

    static constexpr uint32_t AIM_LFSDET = 0x40;        // Late frame synchronization detection interrupt enable
    static constexpr uint32_t AIM_AFSDETIE = 0x20;      // Anticipated frame synchronization detection interrupt enable
    static constexpr uint32_t AIM_CNRDYIE = 0x10;       // Codec not ready interrupt enable
    static constexpr uint32_t AIM_FREQIE = 0x8;         // FIFO request interrupt enable
    static constexpr uint32_t AIM_WCKCFG = 0x4;         // Wrong clock configuration interrupt enable
    static constexpr uint32_t AIM_MUTEDET = 0x2;        // Mute detection interrupt enable
    static constexpr uint32_t AIM_OVRUDRIE = 0x1;       // Overrun/underrun interrupt enable
    static const uint32_t AIM_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ASR_FLVL =                // FIFO level threshold (3 bits)
        bit_field_t<16, 0x7>::value<X>();
    static constexpr uint32_t ASR_LFSDET = 0x40;        // Late frame synchronization detection
    static constexpr uint32_t ASR_AFSDET = 0x20;        // Anticipated frame synchronization detection
    static constexpr uint32_t ASR_CNRDY = 0x10;         // Codec not ready
    static constexpr uint32_t ASR_FREQ = 0x8;           // FIFO request
    static constexpr uint32_t ASR_WCKCFG = 0x4;         // Wrong clock configuration flag. This bit is read only.
    static constexpr uint32_t ASR_MUTEDET = 0x2;        // Mute detection
    static constexpr uint32_t ASR_OVRUDR = 0x1;         // Overrun / underrun
    static const uint32_t ASR_RESET_VALUE = 0x0;

    static constexpr uint32_t ACLRFR_LFSDET = 0x40;        // Clear late frame synchronization detection flag
    static constexpr uint32_t ACLRFR_CAFSDET = 0x20;       // Clear anticipated frame synchronization detection flag.
    static constexpr uint32_t ACLRFR_CNRDY = 0x10;         // Clear codec not ready flag
    static constexpr uint32_t ACLRFR_WCKCFG = 0x4;         // Clear wrong clock configuration flag
    static constexpr uint32_t ACLRFR_MUTEDET = 0x2;        // Mute detection flag
    static constexpr uint32_t ACLRFR_OVRUDR = 0x1;         // Clear overrun / underrun
    static const uint32_t ACLRFR_RESET_VALUE = 0x0;


    static const uint32_t ADR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BCR1_MCJDIV =              // Master clock divider (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    static constexpr uint32_t BCR1_NODIV = 0x80000;      // No divider
    static constexpr uint32_t BCR1_DMAEN = 0x20000;      // DMA enable
    static constexpr uint32_t BCR1_SAIBEN = 0x10000;     // Audio block B enable
    static constexpr uint32_t BCR1_OutDri = 0x2000;      // Output drive
    static constexpr uint32_t BCR1_MONO = 0x1000;        // Mono mode
    template<uint32_t X>
    static constexpr uint32_t BCR1_SYNCEN =              // Synchronization enable (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    static constexpr uint32_t BCR1_CKSTR = 0x200;        // Clock strobing edge
    static constexpr uint32_t BCR1_LSBFIRST = 0x100;     // Least significant bit first
    template<uint32_t X>
    static constexpr uint32_t BCR1_DS =                  // Data size (3 bits)
        bit_field_t<5, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BCR1_PRTCFG =              // Protocol configuration (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BCR1_MODE =                // Audio block mode (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t BCR1_RESET_VALUE = 0x40;

    template<uint32_t X>
    static constexpr uint32_t BCR2_COMP =                // Companding mode (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t BCR2_CPL = 0x2000;         // Complement bit
    template<uint32_t X>
    static constexpr uint32_t BCR2_MUTECN =              // Mute counter (6 bits)
        bit_field_t<7, 0x3f>::value<X>();
    static constexpr uint32_t BCR2_MUTEVAL = 0x40;       // Mute value
    static constexpr uint32_t BCR2_MUTE = 0x20;          // Mute
    static constexpr uint32_t BCR2_TRIS = 0x10;          // Tristate management on data line
    static constexpr uint32_t BCR2_FFLUS = 0x8;          // FIFO flush
    template<uint32_t X>
    static constexpr uint32_t BCR2_FTH =                 // FIFO threshold (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t BCR2_RESET_VALUE = 0x0;

    static constexpr uint32_t BFRCR_FSOFF = 0x40000;      // Frame synchronization offset
    static constexpr uint32_t BFRCR_FSPOL = 0x20000;      // Frame synchronization polarity
    static constexpr uint32_t BFRCR_FSDEF = 0x10000;      // Frame synchronization definition
    template<uint32_t X>
    static constexpr uint32_t BFRCR_FSALL =               // Frame synchronization active level length (7 bits)
        bit_field_t<8, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BFRCR_FRL =                 // Frame length (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t BFRCR_RESET_VALUE = 0x7;

    template<uint32_t X>
    static constexpr uint32_t BSLOTR_SLOTEN =              // Slot enable (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BSLOTR_NBSLOT =              // Number of slots in an audio frame (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BSLOTR_SLOTSZ =              // Slot size (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BSLOTR_FBOFF =               // First bit offset (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t BSLOTR_RESET_VALUE = 0x0;

    static constexpr uint32_t BIM_LFSDETIE = 0x40;      // Late frame synchronization detection interrupt enable
    static constexpr uint32_t BIM_AFSDETIE = 0x20;      // Anticipated frame synchronization detection interrupt enable
    static constexpr uint32_t BIM_CNRDYIE = 0x10;       // Codec not ready interrupt enable
    static constexpr uint32_t BIM_FREQIE = 0x8;         // FIFO request interrupt enable
    static constexpr uint32_t BIM_WCKCFG = 0x4;         // Wrong clock configuration interrupt enable
    static constexpr uint32_t BIM_MUTEDET = 0x2;        // Mute detection interrupt enable
    static constexpr uint32_t BIM_OVRUDRIE = 0x1;       // Overrun/underrun interrupt enable
    static const uint32_t BIM_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BSR_FLVL =                // FIFO level threshold (3 bits)
        bit_field_t<16, 0x7>::value<X>();
    static constexpr uint32_t BSR_LFSDET = 0x40;        // Late frame synchronization detection
    static constexpr uint32_t BSR_AFSDET = 0x20;        // Anticipated frame synchronization detection
    static constexpr uint32_t BSR_CNRDY = 0x10;         // Codec not ready
    static constexpr uint32_t BSR_FREQ = 0x8;           // FIFO request
    static constexpr uint32_t BSR_WCKCFG = 0x4;         // Wrong clock configuration flag
    static constexpr uint32_t BSR_MUTEDET = 0x2;        // Mute detection
    static constexpr uint32_t BSR_OVRUDR = 0x1;         // Overrun / underrun
    static const uint32_t BSR_RESET_VALUE = 0x0;

    static constexpr uint32_t BCLRFR_LFSDET = 0x40;        // Clear late frame synchronization detection flag
    static constexpr uint32_t BCLRFR_CAFSDET = 0x20;       // Clear anticipated frame synchronization detection flag
    static constexpr uint32_t BCLRFR_CNRDY = 0x10;         // Clear codec not ready flag
    static constexpr uint32_t BCLRFR_WCKCFG = 0x4;         // Clear wrong clock configuration flag
    static constexpr uint32_t BCLRFR_MUTEDET = 0x2;        // Mute detection flag
    static constexpr uint32_t BCLRFR_OVRUDR = 0x1;         // Clear overrun / underrun
    static const uint32_t BCLRFR_RESET_VALUE = 0x0;


    static const uint32_t BDR_RESET_VALUE = 0x0;

    static constexpr uint8_t SAI1 = 87; // SAI1 global interrupt
};

static sai1_t& SAI1 = *reinterpret_cast<sai1_t*>(0x40015800);

#define HAVE_PERIPHERAL_SAI1


////
//
//    Serial audio interface
//
////

struct sai2_t
{
    volatile uint32_t    GCR;                  // [Read-write] Global configuration register
    volatile uint32_t    ACR1;                 // [Read-write] AConfiguration register 1
    volatile uint32_t    ACR2;                 // [Read-write] AConfiguration register 2
    volatile uint32_t    AFRCR;                // [Read-write] AFRCR
    volatile uint32_t    ASLOTR;               // [Read-write] ASlot register
    volatile uint32_t    AIM;                  // [Read-write] AInterrupt mask register2
    volatile uint32_t    ASR;                  // [Read-write] AStatus register
    volatile uint32_t    ACLRFR;               // [Read-write] AClear flag register
    volatile uint32_t    ADR;                  // [Read-write] AData register
    volatile uint32_t    BCR1;                 // [Read-write] BConfiguration register 1
    volatile uint32_t    BCR2;                 // [Read-write] BConfiguration register 2
    volatile uint32_t    BFRCR;                // [Read-write] BFRCR
    volatile uint32_t    BSLOTR;               // [Read-write] BSlot register
    volatile uint32_t    BIM;                  // [Read-write] BInterrupt mask register2
    volatile uint32_t    BSR;                  // [Read-only] BStatus register
    volatile uint32_t    BCLRFR;               // [Write-only] BClear flag register
    volatile uint32_t    BDR;                  // [Read-write] BData register

    template<uint32_t X>
    static constexpr uint32_t GCR_SYNCIN =              // Synchronization inputs (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GCR_SYNCOUT =             // Synchronization outputs (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static const uint32_t GCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ACR1_MCJDIV =              // Master clock divider (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    static constexpr uint32_t ACR1_NODIV = 0x80000;      // No divider
    static constexpr uint32_t ACR1_DMAEN = 0x20000;      // DMA enable
    static constexpr uint32_t ACR1_SAIAEN = 0x10000;     // Audio block A enable
    static constexpr uint32_t ACR1_OutDri = 0x2000;      // Output drive
    static constexpr uint32_t ACR1_MONO = 0x1000;        // Mono mode
    template<uint32_t X>
    static constexpr uint32_t ACR1_SYNCEN =              // Synchronization enable (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    static constexpr uint32_t ACR1_CKSTR = 0x200;        // Clock strobing edge
    static constexpr uint32_t ACR1_LSBFIRST = 0x100;     // Least significant bit first
    template<uint32_t X>
    static constexpr uint32_t ACR1_DS =                  // Data size (3 bits)
        bit_field_t<5, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ACR1_PRTCFG =              // Protocol configuration (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ACR1_MODE =                // Audio block mode (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t ACR1_RESET_VALUE = 0x40;

    template<uint32_t X>
    static constexpr uint32_t ACR2_COMP =                // Companding mode (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t ACR2_CPL = 0x2000;         // Complement bit
    template<uint32_t X>
    static constexpr uint32_t ACR2_MUTECN =              // Mute counter (6 bits)
        bit_field_t<7, 0x3f>::value<X>();
    static constexpr uint32_t ACR2_MUTEVAL = 0x40;       // Mute value
    static constexpr uint32_t ACR2_MUTE = 0x20;          // Mute
    static constexpr uint32_t ACR2_TRIS = 0x10;          // Tristate management on data line
    static constexpr uint32_t ACR2_FFLUS = 0x8;          // FIFO flush
    template<uint32_t X>
    static constexpr uint32_t ACR2_FTH =                 // FIFO threshold (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t ACR2_RESET_VALUE = 0x0;

    static constexpr uint32_t AFRCR_FSOFF = 0x40000;      // Frame synchronization offset
    static constexpr uint32_t AFRCR_FSPOL = 0x20000;      // Frame synchronization polarity
    static constexpr uint32_t AFRCR_FSDEF = 0x10000;      // Frame synchronization definition
    template<uint32_t X>
    static constexpr uint32_t AFRCR_FSALL =               // Frame synchronization active level length (7 bits)
        bit_field_t<8, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AFRCR_FRL =                 // Frame length (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t AFRCR_RESET_VALUE = 0x7;

    template<uint32_t X>
    static constexpr uint32_t ASLOTR_SLOTEN =              // Slot enable (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ASLOTR_NBSLOT =              // Number of slots in an audio frame (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ASLOTR_SLOTSZ =              // Slot size (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ASLOTR_FBOFF =               // First bit offset (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t ASLOTR_RESET_VALUE = 0x0;

    static constexpr uint32_t AIM_LFSDET = 0x40;        // Late frame synchronization detection interrupt enable
    static constexpr uint32_t AIM_AFSDETIE = 0x20;      // Anticipated frame synchronization detection interrupt enable
    static constexpr uint32_t AIM_CNRDYIE = 0x10;       // Codec not ready interrupt enable
    static constexpr uint32_t AIM_FREQIE = 0x8;         // FIFO request interrupt enable
    static constexpr uint32_t AIM_WCKCFG = 0x4;         // Wrong clock configuration interrupt enable
    static constexpr uint32_t AIM_MUTEDET = 0x2;        // Mute detection interrupt enable
    static constexpr uint32_t AIM_OVRUDRIE = 0x1;       // Overrun/underrun interrupt enable
    static const uint32_t AIM_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ASR_FLVL =                // FIFO level threshold (3 bits)
        bit_field_t<16, 0x7>::value<X>();
    static constexpr uint32_t ASR_LFSDET = 0x40;        // Late frame synchronization detection
    static constexpr uint32_t ASR_AFSDET = 0x20;        // Anticipated frame synchronization detection
    static constexpr uint32_t ASR_CNRDY = 0x10;         // Codec not ready
    static constexpr uint32_t ASR_FREQ = 0x8;           // FIFO request
    static constexpr uint32_t ASR_WCKCFG = 0x4;         // Wrong clock configuration flag. This bit is read only.
    static constexpr uint32_t ASR_MUTEDET = 0x2;        // Mute detection
    static constexpr uint32_t ASR_OVRUDR = 0x1;         // Overrun / underrun
    static const uint32_t ASR_RESET_VALUE = 0x0;

    static constexpr uint32_t ACLRFR_LFSDET = 0x40;        // Clear late frame synchronization detection flag
    static constexpr uint32_t ACLRFR_CAFSDET = 0x20;       // Clear anticipated frame synchronization detection flag.
    static constexpr uint32_t ACLRFR_CNRDY = 0x10;         // Clear codec not ready flag
    static constexpr uint32_t ACLRFR_WCKCFG = 0x4;         // Clear wrong clock configuration flag
    static constexpr uint32_t ACLRFR_MUTEDET = 0x2;        // Mute detection flag
    static constexpr uint32_t ACLRFR_OVRUDR = 0x1;         // Clear overrun / underrun
    static const uint32_t ACLRFR_RESET_VALUE = 0x0;


    static const uint32_t ADR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BCR1_MCJDIV =              // Master clock divider (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    static constexpr uint32_t BCR1_NODIV = 0x80000;      // No divider
    static constexpr uint32_t BCR1_DMAEN = 0x20000;      // DMA enable
    static constexpr uint32_t BCR1_SAIBEN = 0x10000;     // Audio block B enable
    static constexpr uint32_t BCR1_OutDri = 0x2000;      // Output drive
    static constexpr uint32_t BCR1_MONO = 0x1000;        // Mono mode
    template<uint32_t X>
    static constexpr uint32_t BCR1_SYNCEN =              // Synchronization enable (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    static constexpr uint32_t BCR1_CKSTR = 0x200;        // Clock strobing edge
    static constexpr uint32_t BCR1_LSBFIRST = 0x100;     // Least significant bit first
    template<uint32_t X>
    static constexpr uint32_t BCR1_DS =                  // Data size (3 bits)
        bit_field_t<5, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BCR1_PRTCFG =              // Protocol configuration (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BCR1_MODE =                // Audio block mode (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t BCR1_RESET_VALUE = 0x40;

    template<uint32_t X>
    static constexpr uint32_t BCR2_COMP =                // Companding mode (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t BCR2_CPL = 0x2000;         // Complement bit
    template<uint32_t X>
    static constexpr uint32_t BCR2_MUTECN =              // Mute counter (6 bits)
        bit_field_t<7, 0x3f>::value<X>();
    static constexpr uint32_t BCR2_MUTEVAL = 0x40;       // Mute value
    static constexpr uint32_t BCR2_MUTE = 0x20;          // Mute
    static constexpr uint32_t BCR2_TRIS = 0x10;          // Tristate management on data line
    static constexpr uint32_t BCR2_FFLUS = 0x8;          // FIFO flush
    template<uint32_t X>
    static constexpr uint32_t BCR2_FTH =                 // FIFO threshold (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t BCR2_RESET_VALUE = 0x0;

    static constexpr uint32_t BFRCR_FSOFF = 0x40000;      // Frame synchronization offset
    static constexpr uint32_t BFRCR_FSPOL = 0x20000;      // Frame synchronization polarity
    static constexpr uint32_t BFRCR_FSDEF = 0x10000;      // Frame synchronization definition
    template<uint32_t X>
    static constexpr uint32_t BFRCR_FSALL =               // Frame synchronization active level length (7 bits)
        bit_field_t<8, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BFRCR_FRL =                 // Frame length (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t BFRCR_RESET_VALUE = 0x7;

    template<uint32_t X>
    static constexpr uint32_t BSLOTR_SLOTEN =              // Slot enable (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BSLOTR_NBSLOT =              // Number of slots in an audio frame (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BSLOTR_SLOTSZ =              // Slot size (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BSLOTR_FBOFF =               // First bit offset (5 bits)
        bit_field_t<0, 0x1f>::value<X>();
    static const uint32_t BSLOTR_RESET_VALUE = 0x0;

    static constexpr uint32_t BIM_LFSDETIE = 0x40;      // Late frame synchronization detection interrupt enable
    static constexpr uint32_t BIM_AFSDETIE = 0x20;      // Anticipated frame synchronization detection interrupt enable
    static constexpr uint32_t BIM_CNRDYIE = 0x10;       // Codec not ready interrupt enable
    static constexpr uint32_t BIM_FREQIE = 0x8;         // FIFO request interrupt enable
    static constexpr uint32_t BIM_WCKCFG = 0x4;         // Wrong clock configuration interrupt enable
    static constexpr uint32_t BIM_MUTEDET = 0x2;        // Mute detection interrupt enable
    static constexpr uint32_t BIM_OVRUDRIE = 0x1;       // Overrun/underrun interrupt enable
    static const uint32_t BIM_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BSR_FLVL =                // FIFO level threshold (3 bits)
        bit_field_t<16, 0x7>::value<X>();
    static constexpr uint32_t BSR_LFSDET = 0x40;        // Late frame synchronization detection
    static constexpr uint32_t BSR_AFSDET = 0x20;        // Anticipated frame synchronization detection
    static constexpr uint32_t BSR_CNRDY = 0x10;         // Codec not ready
    static constexpr uint32_t BSR_FREQ = 0x8;           // FIFO request
    static constexpr uint32_t BSR_WCKCFG = 0x4;         // Wrong clock configuration flag
    static constexpr uint32_t BSR_MUTEDET = 0x2;        // Mute detection
    static constexpr uint32_t BSR_OVRUDR = 0x1;         // Overrun / underrun
    static const uint32_t BSR_RESET_VALUE = 0x0;

    static constexpr uint32_t BCLRFR_LFSDET = 0x40;        // Clear late frame synchronization detection flag
    static constexpr uint32_t BCLRFR_CAFSDET = 0x20;       // Clear anticipated frame synchronization detection flag
    static constexpr uint32_t BCLRFR_CNRDY = 0x10;         // Clear codec not ready flag
    static constexpr uint32_t BCLRFR_WCKCFG = 0x4;         // Clear wrong clock configuration flag
    static constexpr uint32_t BCLRFR_MUTEDET = 0x2;        // Mute detection flag
    static constexpr uint32_t BCLRFR_OVRUDR = 0x1;         // Clear overrun / underrun
    static const uint32_t BCLRFR_RESET_VALUE = 0x0;


    static const uint32_t BDR_RESET_VALUE = 0x0;

    static constexpr uint8_t SAI2 = 91; // SAI2 global interrupt
};

static sai2_t& SAI2 = *reinterpret_cast<sai2_t*>(0x40015c00);

#define HAVE_PERIPHERAL_SAI2


////
//
//    DMA2D controller
//
////

struct dma2d_t
{
    volatile uint32_t    CR;                   // [Read-write] control register
    volatile uint32_t    ISR;                  // [Read-only] Interrupt Status Register
    volatile uint32_t    IFCR;                 // [Read-write] interrupt flag clear register
    volatile uint32_t    FGMAR;                // [Read-write] foreground memory address register
    volatile uint32_t    FGOR;                 // [Read-write] foreground offset register
    volatile uint32_t    BGMAR;                // [Read-write] background memory address register
    volatile uint32_t    BGOR;                 // [Read-write] background offset register
    volatile uint32_t    FGPFCCR;              // [Read-write] foreground PFC control register
    volatile uint32_t    FGCOLR;               // [Read-write] foreground color register
    volatile uint32_t    BGPFCCR;              // [Read-write] background PFC control register
    volatile uint32_t    BGCOLR;               // [Read-write] background color register
    volatile uint32_t    FGCMAR;               // [Read-write] foreground CLUT memory address register
    volatile uint32_t    BGCMAR;               // [Read-write] background CLUT memory address register
    volatile uint32_t    OPFCCR;               // [Read-write] output PFC control register
    volatile uint32_t    OCOLR;                // [Read-write] output color register
    volatile uint32_t    OMAR;                 // [Read-write] output memory address register
    volatile uint32_t    OOR;                  // [Read-write] output offset register
    volatile uint32_t    NLR;                  // [Read-write] number of line register
    volatile uint32_t    LWR;                  // [Read-write] line watermark register
    volatile uint32_t    AMTCR;                // [Read-write] AHB master timer configuration register
    reserved_t<236>      _0;
    volatile uint32_t    FGCLUT;               // [Read-write] FGCLUT
    reserved_t<255>      _1;
    volatile uint32_t    BGCLUT;               // [Read-write] BGCLUT

    template<uint32_t X>
    static constexpr uint32_t CR_MODE =                // DMA2D mode (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    static constexpr uint32_t CR_CEIE = 0x2000;        // Configuration Error Interrupt Enable
    static constexpr uint32_t CR_CTCIE = 0x1000;       // CLUT transfer complete interrupt enable
    static constexpr uint32_t CR_CAEIE = 0x800;        // CLUT access error interrupt enable
    static constexpr uint32_t CR_TWIE = 0x400;         // Transfer watermark interrupt enable
    static constexpr uint32_t CR_TCIE = 0x200;         // Transfer complete interrupt enable
    static constexpr uint32_t CR_TEIE = 0x100;         // Transfer error interrupt enable
    static constexpr uint32_t CR_ABORT = 0x4;          // Abort
    static constexpr uint32_t CR_SUSP = 0x2;           // Suspend
    static constexpr uint32_t CR_START = 0x1;          // Start
    static const uint32_t CR_RESET_VALUE = 0x0;

    static constexpr uint32_t ISR_CEIF = 0x20;          // Configuration error interrupt flag
    static constexpr uint32_t ISR_CTCIF = 0x10;         // CLUT transfer complete interrupt flag
    static constexpr uint32_t ISR_CAEIF = 0x8;          // CLUT access error interrupt flag
    static constexpr uint32_t ISR_TWIF = 0x4;           // Transfer watermark interrupt flag
    static constexpr uint32_t ISR_TCIF = 0x2;           // Transfer complete interrupt flag
    static constexpr uint32_t ISR_TEIF = 0x1;           // Transfer error interrupt flag
    static const uint32_t ISR_RESET_VALUE = 0x0;

    static constexpr uint32_t IFCR_CCEIF = 0x20;         // Clear configuration error interrupt flag
    static constexpr uint32_t IFCR_CCTCIF = 0x10;        // Clear CLUT transfer complete interrupt flag
    static constexpr uint32_t IFCR_CAECIF = 0x8;         // Clear CLUT access error interrupt flag
    static constexpr uint32_t IFCR_CTWIF = 0x4;          // Clear transfer watermark interrupt flag
    static constexpr uint32_t IFCR_CTCIF = 0x2;          // Clear transfer complete interrupt flag
    static constexpr uint32_t IFCR_CTEIF = 0x1;          // Clear Transfer error interrupt flag
    static const uint32_t IFCR_RESET_VALUE = 0x0;


    static const uint32_t FGMAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t FGOR_LO =                  // Line offset (14 bits)
        bit_field_t<0, 0x3fff>::value<X>();
    static const uint32_t FGOR_RESET_VALUE = 0x0;


    static const uint32_t BGMAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BGOR_LO =                  // Line offset (14 bits)
        bit_field_t<0, 0x3fff>::value<X>();
    static const uint32_t BGOR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t FGPFCCR_ALPHA =               // Alpha value (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FGPFCCR_AM =                  // Alpha mode (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FGPFCCR_CS =                  // CLUT size (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t FGPFCCR_START = 0x20;         // Start
    static constexpr uint32_t FGPFCCR_CCM = 0x10;           // CLUT color mode
    template<uint32_t X>
    static constexpr uint32_t FGPFCCR_CM =                  // Color mode (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t FGPFCCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t FGCOLR_RED =                 // Red Value (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FGCOLR_GREEN =               // Green Value (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FGCOLR_BLUE =                // Blue Value (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t FGCOLR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BGPFCCR_ALPHA =               // Alpha value (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BGPFCCR_AM =                  // Alpha mode (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BGPFCCR_CS =                  // CLUT size (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t BGPFCCR_START = 0x20;         // Start
    static constexpr uint32_t BGPFCCR_CCM = 0x10;           // CLUT Color mode
    template<uint32_t X>
    static constexpr uint32_t BGPFCCR_CM =                  // Color mode (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t BGPFCCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BGCOLR_RED =                 // Red Value (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BGCOLR_GREEN =               // Green Value (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BGCOLR_BLUE =                // Blue Value (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t BGCOLR_RESET_VALUE = 0x0;


    static const uint32_t FGCMAR_RESET_VALUE = 0x0;


    static const uint32_t BGCMAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OPFCCR_CM =                  // Color mode (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static const uint32_t OPFCCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OCOLR_APLHA =               // Alpha Channel Value (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OCOLR_RED =                 // Red Value (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OCOLR_GREEN =               // Green Value (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OCOLR_BLUE =                // Blue Value (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t OCOLR_RESET_VALUE = 0x0;


    static const uint32_t OMAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OOR_LO =                  // Line Offset (14 bits)
        bit_field_t<0, 0x3fff>::value<X>();
    static const uint32_t OOR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t NLR_PL =                  // Pixel per lines (14 bits)
        bit_field_t<16, 0x3fff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t NLR_NL =                  // Number of lines (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t NLR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t LWR_LW =                  // Line watermark (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t LWR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AMTCR_DT =                  // Dead Time (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t AMTCR_EN = 0x1;             // Enable
    static const uint32_t AMTCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t FGCLUT_APLHA =               // APLHA (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FGCLUT_RED =                 // RED (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FGCLUT_GREEN =               // GREEN (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FGCLUT_BLUE =                // BLUE (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t FGCLUT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BGCLUT_APLHA =               // APLHA (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BGCLUT_RED =                 // RED (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BGCLUT_GREEN =               // GREEN (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BGCLUT_BLUE =                // BLUE (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t BGCLUT_RESET_VALUE = 0x0;

    static constexpr uint8_t DMA2D = 90; // DMA2D global interrupt
};

static dma2d_t& DMA2D = *reinterpret_cast<dma2d_t*>(0x4002b000);

#define HAVE_PERIPHERAL_DMA2D


////
//
//    QuadSPI interface
//
////

struct quadspi_t
{
    volatile uint32_t    CR;                   // [Read-write] control register
    volatile uint32_t    DCR;                  // [Read-write] device configuration register
    volatile uint32_t    SR;                   // [Read-only] status register
    volatile uint32_t    FCR;                  // [Read-write] flag clear register
    volatile uint32_t    DLR;                  // [Read-write] data length register
    volatile uint32_t    CCR;                  // [Read-write] communication configuration register
    volatile uint32_t    AR;                   // [Read-write] address register
    volatile uint32_t    ABR;                  // [Read-write] ABR
    volatile uint32_t    DR;                   // [Read-write] data register
    volatile uint32_t    PSMKR;                // [Read-write] polling status mask register
    volatile uint32_t    PSMAR;                // [Read-write] polling status match register
    volatile uint32_t    PIR;                  // [Read-write] polling interval register
    volatile uint32_t    LPTR;                 // [Read-write] low-power timeout register

    template<uint32_t X>
    static constexpr uint32_t CR_PRESCALER =           // Clock prescaler (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static constexpr uint32_t CR_PMM = 0x800000;       // Polling match mode
    static constexpr uint32_t CR_APMS = 0x400000;      // Automatic poll mode stop
    static constexpr uint32_t CR_TOIE = 0x100000;      // TimeOut interrupt enable
    static constexpr uint32_t CR_SMIE = 0x80000;       // Status match interrupt enable
    static constexpr uint32_t CR_FTIE = 0x40000;       // FIFO threshold interrupt enable
    static constexpr uint32_t CR_TCIE = 0x20000;       // Transfer complete interrupt enable
    static constexpr uint32_t CR_TEIE = 0x10000;       // Transfer error interrupt enable
    template<uint32_t X>
    static constexpr uint32_t CR_FTHRES =              // IFO threshold level (5 bits)
        bit_field_t<8, 0x1f>::value<X>();
    static constexpr uint32_t CR_FSEL = 0x80;          // FLASH memory selection
    static constexpr uint32_t CR_DFM = 0x40;           // Dual-flash mode
    static constexpr uint32_t CR_SSHIFT = 0x10;        // Sample shift
    static constexpr uint32_t CR_TCEN = 0x8;           // Timeout counter enable
    static constexpr uint32_t CR_DMAEN = 0x4;          // DMA enable
    static constexpr uint32_t CR_ABORT = 0x2;          // Abort request
    static constexpr uint32_t CR_EN = 0x1;             // Enable
    static const uint32_t CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DCR_FSIZE =               // FLASH memory size (5 bits)
        bit_field_t<16, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DCR_CSHT =                // Chip select high time (3 bits)
        bit_field_t<8, 0x7>::value<X>();
    static constexpr uint32_t DCR_CKMODE = 0x1;         // Mode 0 / mode 3
    static const uint32_t DCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SR_FLEVEL =              // FIFO level (7 bits)
        bit_field_t<8, 0x7f>::value<X>();
    static constexpr uint32_t SR_BUSY = 0x20;          // Busy
    static constexpr uint32_t SR_TOF = 0x10;           // Timeout flag
    static constexpr uint32_t SR_SMF = 0x8;            // Status match flag
    static constexpr uint32_t SR_FTF = 0x4;            // FIFO threshold flag
    static constexpr uint32_t SR_TCF = 0x2;            // Transfer complete flag
    static constexpr uint32_t SR_TEF = 0x1;            // Transfer error flag
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint32_t FCR_CTOF = 0x10;          // Clear timeout flag
    static constexpr uint32_t FCR_CSMF = 0x8;           // Clear status match flag
    static constexpr uint32_t FCR_CTCF = 0x2;           // Clear transfer complete flag
    static constexpr uint32_t FCR_CTEF = 0x1;           // Clear transfer error flag
    static const uint32_t FCR_RESET_VALUE = 0x0;


    static const uint32_t DLR_RESET_VALUE = 0x0;

    static constexpr uint32_t CCR_DDRM = 0x80000000;    // Double data rate mode
    static constexpr uint32_t CCR_DHHC = 0x40000000;    // DDR hold half cycle
    static constexpr uint32_t CCR_SIOO = 0x10000000;    // Send instruction only once mode
    template<uint32_t X>
    static constexpr uint32_t CCR_FMODE =               // Functional mode (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR_DMODE =               // Data mode (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR_DCYC =                // Number of dummy cycles (5 bits)
        bit_field_t<18, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR_ABSIZE =              // Alternate bytes size (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR_ABMODE =              // Alternate bytes mode (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR_ADSIZE =              // Address size (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR_ADMODE =              // Address mode (2 bits)
        bit_field_t<10, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR_IMODE =               // Instruction mode (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR_INSTRUCTION =         // Instruction (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t CCR_RESET_VALUE = 0x0;


    static const uint32_t AR_RESET_VALUE = 0x0;


    static const uint32_t ABR_RESET_VALUE = 0x0;


    static const uint32_t DR_RESET_VALUE = 0x0;


    static const uint32_t PSMKR_RESET_VALUE = 0x0;


    static const uint32_t PSMAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PIR_INTERVAL =            // Polling interval (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t PIR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t LPTR_TIMEOUT =             // Timeout period (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t LPTR_RESET_VALUE = 0x0;

    static constexpr uint8_t QUADSPI = 92; // QuadSPI global interrupt
};

static quadspi_t& QUADSPI = *reinterpret_cast<quadspi_t*>(0xa0001000);

#define HAVE_PERIPHERAL_QUADSPI


////
//
//    HDMI-CEC controller
//
////

struct cec_t
{
    volatile uint32_t    CR;                   // [Read-write] control register
    volatile uint32_t    CFGR;                 // [Read-write] configuration register
    volatile uint32_t    TXDR;                 // [Write-only] Tx data register
    volatile uint32_t    RXDR;                 // [Read-only] Rx Data Register
    volatile uint32_t    ISR;                  // [Read-write] Interrupt and Status Register
    volatile uint32_t    IER;                  // [Read-write] interrupt enable register

    static constexpr uint32_t CR_TXEOM = 0x4;          // Tx End Of Message
    static constexpr uint32_t CR_TXSOM = 0x2;          // Tx start of message
    static constexpr uint32_t CR_CECEN = 0x1;          // CEC Enable
    static const uint32_t CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CFGR_SFT =                 // Signal Free Time (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static constexpr uint32_t CFGR_RXTOL = 0x8;          // Rx-Tolerance
    static constexpr uint32_t CFGR_BRESTP = 0x10;        // Rx-stop on bit rising error
    static constexpr uint32_t CFGR_BREGEN = 0x20;        // Generate error-bit on bit rising error
    static constexpr uint32_t CFGR_LBPEGEN = 0x40;       // Generate Error-Bit on Long Bit Period Error
    static constexpr uint32_t CFGR_BRDNOGEN = 0x80;      // Avoid Error-Bit Generation in Broadcast
    static constexpr uint32_t CFGR_SFTOP = 0x100;        // SFT Option Bit
    template<uint32_t X>
    static constexpr uint32_t CFGR_OAR =                 // Own addresses configuration (15 bits)
        bit_field_t<16, 0x7fff>::value<X>();
    static constexpr uint32_t CFGR_LSTN = 0x80000000;    // Listen mode
    static const uint32_t CFGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TXDR_TXD =                 // Tx Data register (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t TXDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RXDR_RXDR =                // CEC Rx Data Register (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t RXDR_RESET_VALUE = 0x0;

    static constexpr uint32_t ISR_TXACKE = 0x1000;      // Tx-Missing acknowledge error
    static constexpr uint32_t ISR_TXERR = 0x800;        // Tx-Error
    static constexpr uint32_t ISR_TXUDR = 0x400;        // Tx-Buffer Underrun
    static constexpr uint32_t ISR_TXEND = 0x200;        // End of Transmission
    static constexpr uint32_t ISR_TXBR = 0x100;         // Tx-Byte Request
    static constexpr uint32_t ISR_ARBLST = 0x80;        // Arbitration Lost
    static constexpr uint32_t ISR_RXACKE = 0x40;        // Rx-Missing Acknowledge
    static constexpr uint32_t ISR_LBPE = 0x20;          // Rx-Long Bit Period Error
    static constexpr uint32_t ISR_SBPE = 0x10;          // Rx-Short Bit period error
    static constexpr uint32_t ISR_BRE = 0x8;            // Rx-Bit rising error
    static constexpr uint32_t ISR_RXOVR = 0x4;          // Rx-Overrun
    static constexpr uint32_t ISR_RXEND = 0x2;          // End Of Reception
    static constexpr uint32_t ISR_RXBR = 0x1;           // Rx-Byte Received
    static const uint32_t ISR_RESET_VALUE = 0x0;

    static constexpr uint32_t IER_TXACKIE = 0x1000;     // Tx-Missing Acknowledge Error Interrupt Enable
    static constexpr uint32_t IER_TXERRIE = 0x800;      // Tx-Error Interrupt Enable
    static constexpr uint32_t IER_TXUDRIE = 0x400;      // Tx-Underrun interrupt enable
    static constexpr uint32_t IER_TXENDIE = 0x200;      // Tx-End of message interrupt enable
    static constexpr uint32_t IER_TXBRIE = 0x100;       // Tx-Byte Request Interrupt Enable
    static constexpr uint32_t IER_ARBLSTIE = 0x80;      // Arbitration Lost Interrupt Enable
    static constexpr uint32_t IER_RXACKIE = 0x40;       // Rx-Missing Acknowledge Error Interrupt Enable
    static constexpr uint32_t IER_LBPEIE = 0x20;        // Long Bit Period Error Interrupt Enable
    static constexpr uint32_t IER_SBPEIE = 0x10;        // Short Bit Period Error Interrupt Enable
    static constexpr uint32_t IER_BREIE = 0x8;          // Bit Rising Error Interrupt Enable
    static constexpr uint32_t IER_RXOVRIE = 0x4;        // Rx-Buffer Overrun Interrupt Enable
    static constexpr uint32_t IER_RXENDIE = 0x2;        // End Of Reception Interrupt Enable
    static constexpr uint32_t IER_RXBRIE = 0x1;         // Rx-Byte Received Interrupt Enable
    static const uint32_t IER_RESET_VALUE = 0x0;
};

static cec_t& CEC = *reinterpret_cast<cec_t*>(0x40006c00);

#define HAVE_PERIPHERAL_CEC


////
//
//    Receiver Interface
//
////

struct spdifrx_t
{
    volatile uint32_t    CR;                   // [Read-write] Control register
    volatile uint32_t    IMR;                  // [Read-write] Interrupt mask register
    volatile uint32_t    SR;                   // [Read-only] Status register
    volatile uint32_t    IFCR;                 // [Write-only] Interrupt Flag Clear register
    volatile uint32_t    DR;                   // [Read-only] Data input register
    volatile uint32_t    CSR;                  // [Read-only] Channel Status register
    volatile uint32_t    DIR;                  // [Read-only] Debug Information register

    template<uint32_t X>
    static constexpr uint32_t CR_SPDIFEN =             // Peripheral Block Enable (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static constexpr uint32_t CR_RXDMAEN = 0x4;        // Receiver DMA ENable for data flow
    static constexpr uint32_t CR_RXSTEO = 0x8;         // STerEO Mode
    template<uint32_t X>
    static constexpr uint32_t CR_DRFMT =               // RX Data format (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    static constexpr uint32_t CR_PMSK = 0x40;          // Mask Parity error bit
    static constexpr uint32_t CR_VMSK = 0x80;          // Mask of Validity bit
    static constexpr uint32_t CR_CUMSK = 0x100;        // Mask of channel status and user bits
    static constexpr uint32_t CR_PTMSK = 0x200;        // Mask of Preamble Type bits
    static constexpr uint32_t CR_CBDMAEN = 0x400;      // Control Buffer DMA ENable for control flow
    static constexpr uint32_t CR_CHSEL = 0x800;        // Channel Selection
    template<uint32_t X>
    static constexpr uint32_t CR_NBTR =                // Maximum allowed re-tries during synchronization phase (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    static constexpr uint32_t CR_WFA = 0x4000;         // Wait For Activity
    template<uint32_t X>
    static constexpr uint32_t CR_INSEL =               // input selection (3 bits)
        bit_field_t<16, 0x7>::value<X>();
    static const uint32_t CR_RESET_VALUE = 0x0;

    static constexpr uint32_t IMR_RXNEIE = 0x1;         // RXNE interrupt enable
    static constexpr uint32_t IMR_CSRNEIE = 0x2;        // Control Buffer Ready Interrupt Enable
    static constexpr uint32_t IMR_PERRIE = 0x4;         // Parity error interrupt enable
    static constexpr uint32_t IMR_OVRIE = 0x8;          // Overrun error Interrupt Enable
    static constexpr uint32_t IMR_SBLKIE = 0x10;        // Synchronization Block Detected Interrupt Enable
    static constexpr uint32_t IMR_SYNCDIE = 0x20;       // Synchronization Done
    static constexpr uint32_t IMR_IFEIE = 0x40;         // Serial Interface Error Interrupt Enable
    static const uint32_t IMR_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_RXNE = 0x1;           // Read data register not empty
    static constexpr uint32_t SR_CSRNE = 0x2;          // Control Buffer register is not empty
    static constexpr uint32_t SR_PERR = 0x4;           // Parity error
    static constexpr uint32_t SR_OVR = 0x8;            // Overrun error
    static constexpr uint32_t SR_SBD = 0x10;           // Synchronization Block Detected
    static constexpr uint32_t SR_SYNCD = 0x20;         // Synchronization Done
    static constexpr uint32_t SR_FERR = 0x40;          // Framing error
    static constexpr uint32_t SR_SERR = 0x80;          // Synchronization error
    static constexpr uint32_t SR_TERR = 0x100;         // Time-out error
    template<uint32_t X>
    static constexpr uint32_t SR_WIDTH5 =              // Duration of 5 symbols counted with SPDIF_CLK (15 bits)
        bit_field_t<16, 0x7fff>::value<X>();
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint32_t IFCR_PERRCF = 0x4;         // Clears the Parity error flag
    static constexpr uint32_t IFCR_OVRCF = 0x8;          // Clears the Overrun error flag
    static constexpr uint32_t IFCR_SBDCF = 0x10;         // Clears the Synchronization Block Detected flag
    static constexpr uint32_t IFCR_SYNCDCF = 0x20;       // Clears the Synchronization Done flag
    static const uint32_t IFCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DR_DR =                  // Parity Error bit (24 bits)
        bit_field_t<0, 0xffffff>::value<X>();
    static constexpr uint32_t DR_PE = 0x1000000;       // Parity Error bit
    static constexpr uint32_t DR_V = 0x2000000;        // Validity bit
    static constexpr uint32_t DR_U = 0x4000000;        // User bit
    static constexpr uint32_t DR_C = 0x8000000;        // Channel Status bit
    template<uint32_t X>
    static constexpr uint32_t DR_PT =                  // Preamble Type (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    static const uint32_t DR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CSR_USR =                 // User data information (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CSR_CS =                  // Channel A status information (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static constexpr uint32_t CSR_SOB = 0x1000000;      // Start Of Block
    static const uint32_t CSR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DIR_THI =                 // Threshold HIGH (13 bits)
        bit_field_t<0, 0x1fff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DIR_TLO =                 // Threshold LOW (13 bits)
        bit_field_t<16, 0x1fff>::value<X>();
    static const uint32_t DIR_RESET_VALUE = 0x0;

    static constexpr uint8_t SPDIFRX = 97; // SPDIFRX global interrupt
};

static spdifrx_t& SPDIFRX = *reinterpret_cast<spdifrx_t*>(0x40004000);

#define HAVE_PERIPHERAL_SPDIFRX


////
//
//    Secure digital input/output interface
//
////

struct sdmmc1_t
{
    volatile uint32_t    POWER;                // [Read-write] power control register
    volatile uint32_t    CLKCR;                // [Read-write] SDI clock control register
    volatile uint32_t    ARG;                  // [Read-write] argument register
    volatile uint32_t    CMD;                  // [Read-write] command register
    volatile uint32_t    RESPCMD;              // [Read-only] command response register
    volatile uint32_t    RESP1;                // [Read-only] response 1..4 register
    volatile uint32_t    RESP2;                // [Read-only] response 1..4 register
    volatile uint32_t    RESP3;                // [Read-only] response 1..4 register
    volatile uint32_t    RESP4;                // [Read-only] response 1..4 register
    volatile uint32_t    DTIMER;               // [Read-write] data timer register
    volatile uint32_t    DLEN;                 // [Read-write] data length register
    volatile uint32_t    DCTRL;                // [Read-write] data control register
    volatile uint32_t    DCOUNT;               // [Read-only] data counter register
    volatile uint32_t    STA;                  // [Read-only] status register
    volatile uint32_t    ICR;                  // [Read-write] interrupt clear register
    volatile uint32_t    MASK;                 // [Read-write] mask register
    reserved_t<2>        _0;
    volatile uint32_t    FIFOCNT;              // [Read-only] FIFO counter register
    reserved_t<13>       _1;
    volatile uint32_t    FIFO;                 // [Read-write] data FIFO register

    template<uint32_t X>
    static constexpr uint32_t POWER_PWRCTRL =             // PWRCTRL (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t POWER_RESET_VALUE = 0x0;

    static constexpr uint32_t CLKCR_HWFC_EN = 0x4000;     // HW Flow Control enable
    static constexpr uint32_t CLKCR_NEGEDGE = 0x2000;     // SDIO_CK dephasing selection bit
    template<uint32_t X>
    static constexpr uint32_t CLKCR_WIDBUS =              // Wide bus mode enable bit (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    static constexpr uint32_t CLKCR_BYPASS = 0x400;       // Clock divider bypass enable bit
    static constexpr uint32_t CLKCR_PWRSAV = 0x200;       // Power saving configuration bit
    static constexpr uint32_t CLKCR_CLKEN = 0x100;        // Clock enable bit
    template<uint32_t X>
    static constexpr uint32_t CLKCR_CLKDIV =              // Clock divide factor (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t CLKCR_RESET_VALUE = 0x0;


    static const uint32_t ARG_RESET_VALUE = 0x0;

    static constexpr uint32_t CMD_CE_ATACMD = 0x4000;   // CE-ATA command
    static constexpr uint32_t CMD_nIEN = 0x2000;        // not Interrupt Enable
    static constexpr uint32_t CMD_ENCMDcompl = 0x1000;  // Enable CMD completion
    static constexpr uint32_t CMD_SDIOSuspend = 0x800;  // SD I/O suspend command
    static constexpr uint32_t CMD_CPSMEN = 0x400;       // Command path state machine (CPSM) Enable bit
    static constexpr uint32_t CMD_WAITPEND = 0x200;     // CPSM Waits for ends of data transfer (CmdPend internal signal)
    static constexpr uint32_t CMD_WAITINT = 0x100;      // CPSM waits for interrupt request
    template<uint32_t X>
    static constexpr uint32_t CMD_WAITRESP =            // Wait for response bits (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CMD_CMDINDEX =            // Command index (6 bits)
        bit_field_t<0, 0x3f>::value<X>();
    static const uint32_t CMD_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RESPCMD_RESPCMD =             // Response command index (6 bits)
        bit_field_t<0, 0x3f>::value<X>();
    static const uint32_t RESPCMD_RESET_VALUE = 0x0;


    static const uint32_t RESP1_RESET_VALUE = 0x0;


    static const uint32_t RESP2_RESET_VALUE = 0x0;


    static const uint32_t RESP3_RESET_VALUE = 0x0;


    static const uint32_t RESP4_RESET_VALUE = 0x0;


    static const uint32_t DTIMER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DLEN_DATALENGTH =          // Data length value (25 bits)
        bit_field_t<0, 0x1ffffff>::value<X>();
    static const uint32_t DLEN_RESET_VALUE = 0x0;

    static constexpr uint32_t DCTRL_SDIOEN = 0x800;       // SD I/O enable functions
    static constexpr uint32_t DCTRL_RWMOD = 0x400;        // Read wait mode
    static constexpr uint32_t DCTRL_RWSTOP = 0x200;       // Read wait stop
    static constexpr uint32_t DCTRL_RWSTART = 0x100;      // Read wait start
    template<uint32_t X>
    static constexpr uint32_t DCTRL_DBLOCKSIZE =          // Data block size (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    static constexpr uint32_t DCTRL_DMAEN = 0x8;          // DMA enable bit
    static constexpr uint32_t DCTRL_DTMODE = 0x4;         // Data transfer mode selection 1: Stream or SDIO multibyte data transfer
    static constexpr uint32_t DCTRL_DTDIR = 0x2;          // Data transfer direction selection
    static constexpr uint32_t DCTRL_DTEN = 0x1;           // DTEN
    static const uint32_t DCTRL_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DCOUNT_DATACOUNT =           // Data count value (25 bits)
        bit_field_t<0, 0x1ffffff>::value<X>();
    static const uint32_t DCOUNT_RESET_VALUE = 0x0;

    static constexpr uint32_t STA_CEATAEND = 0x800000;  // CE-ATA command completion signal received for CMD61
    static constexpr uint32_t STA_SDIOIT = 0x400000;    // SDIO interrupt received
    static constexpr uint32_t STA_RXDAVL = 0x200000;    // Data available in receive FIFO
    static constexpr uint32_t STA_TXDAVL = 0x100000;    // Data available in transmit FIFO
    static constexpr uint32_t STA_RXFIFOE = 0x80000;    // Receive FIFO empty
    static constexpr uint32_t STA_TXFIFOE = 0x40000;    // Transmit FIFO empty
    static constexpr uint32_t STA_RXFIFOF = 0x20000;    // Receive FIFO full
    static constexpr uint32_t STA_TXFIFOF = 0x10000;    // Transmit FIFO full
    static constexpr uint32_t STA_RXFIFOHF = 0x8000;    // Receive FIFO half full: there are at least 8 words in the FIFO
    static constexpr uint32_t STA_TXFIFOHE = 0x4000;    // Transmit FIFO half empty: at least 8 words can be written into the FIFO
    static constexpr uint32_t STA_RXACT = 0x2000;       // Data receive in progress
    static constexpr uint32_t STA_TXACT = 0x1000;       // Data transmit in progress
    static constexpr uint32_t STA_CMDACT = 0x800;       // Command transfer in progress
    static constexpr uint32_t STA_DBCKEND = 0x400;      // Data block sent/received (CRC check passed)
    static constexpr uint32_t STA_STBITERR = 0x200;     // Start bit not detected on all data signals in wide bus mode
    static constexpr uint32_t STA_DATAEND = 0x100;      // Data end (data counter, SDIDCOUNT, is zero)
    static constexpr uint32_t STA_CMDSENT = 0x80;       // Command sent (no response required)
    static constexpr uint32_t STA_CMDREND = 0x40;       // Command response received (CRC check passed)
    static constexpr uint32_t STA_RXOVERR = 0x20;       // Received FIFO overrun error
    static constexpr uint32_t STA_TXUNDERR = 0x10;      // Transmit FIFO underrun error
    static constexpr uint32_t STA_DTIMEOUT = 0x8;       // Data timeout
    static constexpr uint32_t STA_CTIMEOUT = 0x4;       // Command response timeout
    static constexpr uint32_t STA_DCRCFAIL = 0x2;       // Data block sent/received (CRC check failed)
    static constexpr uint32_t STA_CCRCFAIL = 0x1;       // Command response received (CRC check failed)
    static const uint32_t STA_RESET_VALUE = 0x0;

    static constexpr uint32_t ICR_CEATAENDC = 0x800000; // CEATAEND flag clear bit
    static constexpr uint32_t ICR_SDIOITC = 0x400000;   // SDIOIT flag clear bit
    static constexpr uint32_t ICR_DBCKENDC = 0x400;     // DBCKEND flag clear bit
    static constexpr uint32_t ICR_STBITERRC = 0x200;    // STBITERR flag clear bit
    static constexpr uint32_t ICR_DATAENDC = 0x100;     // DATAEND flag clear bit
    static constexpr uint32_t ICR_CMDSENTC = 0x80;      // CMDSENT flag clear bit
    static constexpr uint32_t ICR_CMDRENDC = 0x40;      // CMDREND flag clear bit
    static constexpr uint32_t ICR_RXOVERRC = 0x20;      // RXOVERR flag clear bit
    static constexpr uint32_t ICR_TXUNDERRC = 0x10;     // TXUNDERR flag clear bit
    static constexpr uint32_t ICR_DTIMEOUTC = 0x8;      // DTIMEOUT flag clear bit
    static constexpr uint32_t ICR_CTIMEOUTC = 0x4;      // CTIMEOUT flag clear bit
    static constexpr uint32_t ICR_DCRCFAILC = 0x2;      // DCRCFAIL flag clear bit
    static constexpr uint32_t ICR_CCRCFAILC = 0x1;      // CCRCFAIL flag clear bit
    static const uint32_t ICR_RESET_VALUE = 0x0;

    static constexpr uint32_t MASK_CEATAENDIE = 0x800000;// CE-ATA command completion signal received interrupt enable
    static constexpr uint32_t MASK_SDIOITIE = 0x400000;  // SDIO mode interrupt received interrupt enable
    static constexpr uint32_t MASK_RXDAVLIE = 0x200000;  // Data available in Rx FIFO interrupt enable
    static constexpr uint32_t MASK_TXDAVLIE = 0x100000;  // Data available in Tx FIFO interrupt enable
    static constexpr uint32_t MASK_RXFIFOEIE = 0x80000;  // Rx FIFO empty interrupt enable
    static constexpr uint32_t MASK_TXFIFOEIE = 0x40000;  // Tx FIFO empty interrupt enable
    static constexpr uint32_t MASK_RXFIFOFIE = 0x20000;  // Rx FIFO full interrupt enable
    static constexpr uint32_t MASK_TXFIFOFIE = 0x10000;  // Tx FIFO full interrupt enable
    static constexpr uint32_t MASK_RXFIFOHFIE = 0x8000;  // Rx FIFO half full interrupt enable
    static constexpr uint32_t MASK_TXFIFOHEIE = 0x4000;  // Tx FIFO half empty interrupt enable
    static constexpr uint32_t MASK_RXACTIE = 0x2000;     // Data receive acting interrupt enable
    static constexpr uint32_t MASK_TXACTIE = 0x1000;     // Data transmit acting interrupt enable
    static constexpr uint32_t MASK_CMDACTIE = 0x800;     // Command acting interrupt enable
    static constexpr uint32_t MASK_DBCKENDIE = 0x400;    // Data block end interrupt enable
    static constexpr uint32_t MASK_STBITERRIE = 0x200;   // Start bit error interrupt enable
    static constexpr uint32_t MASK_DATAENDIE = 0x100;    // Data end interrupt enable
    static constexpr uint32_t MASK_CMDSENTIE = 0x80;     // Command sent interrupt enable
    static constexpr uint32_t MASK_CMDRENDIE = 0x40;     // Command response received interrupt enable
    static constexpr uint32_t MASK_RXOVERRIE = 0x20;     // Rx FIFO overrun error interrupt enable
    static constexpr uint32_t MASK_TXUNDERRIE = 0x10;    // Tx FIFO underrun error interrupt enable
    static constexpr uint32_t MASK_DTIMEOUTIE = 0x8;     // Data timeout interrupt enable
    static constexpr uint32_t MASK_CTIMEOUTIE = 0x4;     // Command timeout interrupt enable
    static constexpr uint32_t MASK_DCRCFAILIE = 0x2;     // Data CRC fail interrupt enable
    static constexpr uint32_t MASK_CCRCFAILIE = 0x1;     // Command CRC fail interrupt enable
    static const uint32_t MASK_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t FIFOCNT_FIFOCOUNT =           // Remaining number of words to be written to or read from the FIFO (24 bits)
        bit_field_t<0, 0xffffff>::value<X>();
    static const uint32_t FIFOCNT_RESET_VALUE = 0x0;


    static const uint32_t FIFO_RESET_VALUE = 0x0;

    static constexpr uint8_t SDMMC1 = 49; // SDMMC1 global interrupt
};

static sdmmc1_t& SDMMC1 = *reinterpret_cast<sdmmc1_t*>(0x40012c00);

#define HAVE_PERIPHERAL_SDMMC1


////
//
//    Secure digital input/output interface
//
////

struct sdmmc2_t
{
    volatile uint32_t    POWER;                // [Read-write] power control register
    volatile uint32_t    CLKCR;                // [Read-write] SDI clock control register
    volatile uint32_t    ARG;                  // [Read-write] argument register
    volatile uint32_t    CMD;                  // [Read-write] command register
    volatile uint32_t    RESPCMD;              // [Read-only] command response register
    volatile uint32_t    RESP1;                // [Read-only] response 1..4 register
    volatile uint32_t    RESP2;                // [Read-only] response 1..4 register
    volatile uint32_t    RESP3;                // [Read-only] response 1..4 register
    volatile uint32_t    RESP4;                // [Read-only] response 1..4 register
    volatile uint32_t    DTIMER;               // [Read-write] data timer register
    volatile uint32_t    DLEN;                 // [Read-write] data length register
    volatile uint32_t    DCTRL;                // [Read-write] data control register
    volatile uint32_t    DCOUNT;               // [Read-only] data counter register
    volatile uint32_t    STA;                  // [Read-only] status register
    volatile uint32_t    ICR;                  // [Read-write] interrupt clear register
    volatile uint32_t    MASK;                 // [Read-write] mask register
    reserved_t<2>        _0;
    volatile uint32_t    FIFOCNT;              // [Read-only] FIFO counter register
    reserved_t<13>       _1;
    volatile uint32_t    FIFO;                 // [Read-write] data FIFO register

    template<uint32_t X>
    static constexpr uint32_t POWER_PWRCTRL =             // PWRCTRL (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t POWER_RESET_VALUE = 0x0;

    static constexpr uint32_t CLKCR_HWFC_EN = 0x4000;     // HW Flow Control enable
    static constexpr uint32_t CLKCR_NEGEDGE = 0x2000;     // SDIO_CK dephasing selection bit
    template<uint32_t X>
    static constexpr uint32_t CLKCR_WIDBUS =              // Wide bus mode enable bit (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    static constexpr uint32_t CLKCR_BYPASS = 0x400;       // Clock divider bypass enable bit
    static constexpr uint32_t CLKCR_PWRSAV = 0x200;       // Power saving configuration bit
    static constexpr uint32_t CLKCR_CLKEN = 0x100;        // Clock enable bit
    template<uint32_t X>
    static constexpr uint32_t CLKCR_CLKDIV =              // Clock divide factor (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t CLKCR_RESET_VALUE = 0x0;


    static const uint32_t ARG_RESET_VALUE = 0x0;

    static constexpr uint32_t CMD_CE_ATACMD = 0x4000;   // CE-ATA command
    static constexpr uint32_t CMD_nIEN = 0x2000;        // not Interrupt Enable
    static constexpr uint32_t CMD_ENCMDcompl = 0x1000;  // Enable CMD completion
    static constexpr uint32_t CMD_SDIOSuspend = 0x800;  // SD I/O suspend command
    static constexpr uint32_t CMD_CPSMEN = 0x400;       // Command path state machine (CPSM) Enable bit
    static constexpr uint32_t CMD_WAITPEND = 0x200;     // CPSM Waits for ends of data transfer (CmdPend internal signal)
    static constexpr uint32_t CMD_WAITINT = 0x100;      // CPSM waits for interrupt request
    template<uint32_t X>
    static constexpr uint32_t CMD_WAITRESP =            // Wait for response bits (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CMD_CMDINDEX =            // Command index (6 bits)
        bit_field_t<0, 0x3f>::value<X>();
    static const uint32_t CMD_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RESPCMD_RESPCMD =             // Response command index (6 bits)
        bit_field_t<0, 0x3f>::value<X>();
    static const uint32_t RESPCMD_RESET_VALUE = 0x0;


    static const uint32_t RESP1_RESET_VALUE = 0x0;


    static const uint32_t RESP2_RESET_VALUE = 0x0;


    static const uint32_t RESP3_RESET_VALUE = 0x0;


    static const uint32_t RESP4_RESET_VALUE = 0x0;


    static const uint32_t DTIMER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DLEN_DATALENGTH =          // Data length value (25 bits)
        bit_field_t<0, 0x1ffffff>::value<X>();
    static const uint32_t DLEN_RESET_VALUE = 0x0;

    static constexpr uint32_t DCTRL_SDIOEN = 0x800;       // SD I/O enable functions
    static constexpr uint32_t DCTRL_RWMOD = 0x400;        // Read wait mode
    static constexpr uint32_t DCTRL_RWSTOP = 0x200;       // Read wait stop
    static constexpr uint32_t DCTRL_RWSTART = 0x100;      // Read wait start
    template<uint32_t X>
    static constexpr uint32_t DCTRL_DBLOCKSIZE =          // Data block size (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    static constexpr uint32_t DCTRL_DMAEN = 0x8;          // DMA enable bit
    static constexpr uint32_t DCTRL_DTMODE = 0x4;         // Data transfer mode selection 1: Stream or SDIO multibyte data transfer
    static constexpr uint32_t DCTRL_DTDIR = 0x2;          // Data transfer direction selection
    static constexpr uint32_t DCTRL_DTEN = 0x1;           // DTEN
    static const uint32_t DCTRL_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DCOUNT_DATACOUNT =           // Data count value (25 bits)
        bit_field_t<0, 0x1ffffff>::value<X>();
    static const uint32_t DCOUNT_RESET_VALUE = 0x0;

    static constexpr uint32_t STA_CEATAEND = 0x800000;  // CE-ATA command completion signal received for CMD61
    static constexpr uint32_t STA_SDIOIT = 0x400000;    // SDIO interrupt received
    static constexpr uint32_t STA_RXDAVL = 0x200000;    // Data available in receive FIFO
    static constexpr uint32_t STA_TXDAVL = 0x100000;    // Data available in transmit FIFO
    static constexpr uint32_t STA_RXFIFOE = 0x80000;    // Receive FIFO empty
    static constexpr uint32_t STA_TXFIFOE = 0x40000;    // Transmit FIFO empty
    static constexpr uint32_t STA_RXFIFOF = 0x20000;    // Receive FIFO full
    static constexpr uint32_t STA_TXFIFOF = 0x10000;    // Transmit FIFO full
    static constexpr uint32_t STA_RXFIFOHF = 0x8000;    // Receive FIFO half full: there are at least 8 words in the FIFO
    static constexpr uint32_t STA_TXFIFOHE = 0x4000;    // Transmit FIFO half empty: at least 8 words can be written into the FIFO
    static constexpr uint32_t STA_RXACT = 0x2000;       // Data receive in progress
    static constexpr uint32_t STA_TXACT = 0x1000;       // Data transmit in progress
    static constexpr uint32_t STA_CMDACT = 0x800;       // Command transfer in progress
    static constexpr uint32_t STA_DBCKEND = 0x400;      // Data block sent/received (CRC check passed)
    static constexpr uint32_t STA_STBITERR = 0x200;     // Start bit not detected on all data signals in wide bus mode
    static constexpr uint32_t STA_DATAEND = 0x100;      // Data end (data counter, SDIDCOUNT, is zero)
    static constexpr uint32_t STA_CMDSENT = 0x80;       // Command sent (no response required)
    static constexpr uint32_t STA_CMDREND = 0x40;       // Command response received (CRC check passed)
    static constexpr uint32_t STA_RXOVERR = 0x20;       // Received FIFO overrun error
    static constexpr uint32_t STA_TXUNDERR = 0x10;      // Transmit FIFO underrun error
    static constexpr uint32_t STA_DTIMEOUT = 0x8;       // Data timeout
    static constexpr uint32_t STA_CTIMEOUT = 0x4;       // Command response timeout
    static constexpr uint32_t STA_DCRCFAIL = 0x2;       // Data block sent/received (CRC check failed)
    static constexpr uint32_t STA_CCRCFAIL = 0x1;       // Command response received (CRC check failed)
    static const uint32_t STA_RESET_VALUE = 0x0;

    static constexpr uint32_t ICR_CEATAENDC = 0x800000; // CEATAEND flag clear bit
    static constexpr uint32_t ICR_SDIOITC = 0x400000;   // SDIOIT flag clear bit
    static constexpr uint32_t ICR_DBCKENDC = 0x400;     // DBCKEND flag clear bit
    static constexpr uint32_t ICR_STBITERRC = 0x200;    // STBITERR flag clear bit
    static constexpr uint32_t ICR_DATAENDC = 0x100;     // DATAEND flag clear bit
    static constexpr uint32_t ICR_CMDSENTC = 0x80;      // CMDSENT flag clear bit
    static constexpr uint32_t ICR_CMDRENDC = 0x40;      // CMDREND flag clear bit
    static constexpr uint32_t ICR_RXOVERRC = 0x20;      // RXOVERR flag clear bit
    static constexpr uint32_t ICR_TXUNDERRC = 0x10;     // TXUNDERR flag clear bit
    static constexpr uint32_t ICR_DTIMEOUTC = 0x8;      // DTIMEOUT flag clear bit
    static constexpr uint32_t ICR_CTIMEOUTC = 0x4;      // CTIMEOUT flag clear bit
    static constexpr uint32_t ICR_DCRCFAILC = 0x2;      // DCRCFAIL flag clear bit
    static constexpr uint32_t ICR_CCRCFAILC = 0x1;      // CCRCFAIL flag clear bit
    static const uint32_t ICR_RESET_VALUE = 0x0;

    static constexpr uint32_t MASK_CEATAENDIE = 0x800000;// CE-ATA command completion signal received interrupt enable
    static constexpr uint32_t MASK_SDIOITIE = 0x400000;  // SDIO mode interrupt received interrupt enable
    static constexpr uint32_t MASK_RXDAVLIE = 0x200000;  // Data available in Rx FIFO interrupt enable
    static constexpr uint32_t MASK_TXDAVLIE = 0x100000;  // Data available in Tx FIFO interrupt enable
    static constexpr uint32_t MASK_RXFIFOEIE = 0x80000;  // Rx FIFO empty interrupt enable
    static constexpr uint32_t MASK_TXFIFOEIE = 0x40000;  // Tx FIFO empty interrupt enable
    static constexpr uint32_t MASK_RXFIFOFIE = 0x20000;  // Rx FIFO full interrupt enable
    static constexpr uint32_t MASK_TXFIFOFIE = 0x10000;  // Tx FIFO full interrupt enable
    static constexpr uint32_t MASK_RXFIFOHFIE = 0x8000;  // Rx FIFO half full interrupt enable
    static constexpr uint32_t MASK_TXFIFOHEIE = 0x4000;  // Tx FIFO half empty interrupt enable
    static constexpr uint32_t MASK_RXACTIE = 0x2000;     // Data receive acting interrupt enable
    static constexpr uint32_t MASK_TXACTIE = 0x1000;     // Data transmit acting interrupt enable
    static constexpr uint32_t MASK_CMDACTIE = 0x800;     // Command acting interrupt enable
    static constexpr uint32_t MASK_DBCKENDIE = 0x400;    // Data block end interrupt enable
    static constexpr uint32_t MASK_STBITERRIE = 0x200;   // Start bit error interrupt enable
    static constexpr uint32_t MASK_DATAENDIE = 0x100;    // Data end interrupt enable
    static constexpr uint32_t MASK_CMDSENTIE = 0x80;     // Command sent interrupt enable
    static constexpr uint32_t MASK_CMDRENDIE = 0x40;     // Command response received interrupt enable
    static constexpr uint32_t MASK_RXOVERRIE = 0x20;     // Rx FIFO overrun error interrupt enable
    static constexpr uint32_t MASK_TXUNDERRIE = 0x10;    // Tx FIFO underrun error interrupt enable
    static constexpr uint32_t MASK_DTIMEOUTIE = 0x8;     // Data timeout interrupt enable
    static constexpr uint32_t MASK_CTIMEOUTIE = 0x4;     // Command timeout interrupt enable
    static constexpr uint32_t MASK_DCRCFAILIE = 0x2;     // Data CRC fail interrupt enable
    static constexpr uint32_t MASK_CCRCFAILIE = 0x1;     // Command CRC fail interrupt enable
    static const uint32_t MASK_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t FIFOCNT_FIFOCOUNT =           // Remaining number of words to be written to or read from the FIFO (24 bits)
        bit_field_t<0, 0xffffff>::value<X>();
    static const uint32_t FIFOCNT_RESET_VALUE = 0x0;


    static const uint32_t FIFO_RESET_VALUE = 0x0;

    static constexpr uint8_t SDMMC2 = 103; // SDMMC2 global interrupt
};

static sdmmc2_t& SDMMC2 = *reinterpret_cast<sdmmc2_t*>(0x40011c00);

#define HAVE_PERIPHERAL_SDMMC2


////
//
//    Low power timer
//
////

struct lptim1_t
{
    volatile uint32_t    ISR;                  // [Read-only] Interrupt and Status Register
    volatile uint32_t    ICR;                  // [Write-only] Interrupt Clear Register
    volatile uint32_t    IER;                  // [Read-write] Interrupt Enable Register
    volatile uint32_t    CFGR;                 // [Read-write] Configuration Register
    volatile uint32_t    CR;                   // [Read-write] Control Register
    volatile uint32_t    CMP;                  // [Read-write] Compare Register
    volatile uint32_t    ARR;                  // [Read-write] Autoreload Register
    volatile uint32_t    CNT;                  // [Read-only] Counter Register

    static constexpr uint32_t ISR_DOWN = 0x40;          // Counter direction change up to down
    static constexpr uint32_t ISR_UP = 0x20;            // Counter direction change down to up
    static constexpr uint32_t ISR_ARROK = 0x10;         // Autoreload register update OK
    static constexpr uint32_t ISR_CMPOK = 0x8;          // Compare register update OK
    static constexpr uint32_t ISR_EXTTRIG = 0x4;        // External trigger edge event
    static constexpr uint32_t ISR_ARRM = 0x2;           // Autoreload match
    static constexpr uint32_t ISR_CMPM = 0x1;           // Compare match
    static const uint32_t ISR_RESET_VALUE = 0x0;

    static constexpr uint32_t ICR_DOWNCF = 0x40;        // Direction change to down Clear Flag
    static constexpr uint32_t ICR_UPCF = 0x20;          // Direction change to UP Clear Flag
    static constexpr uint32_t ICR_ARROKCF = 0x10;       // Autoreload register update OK Clear Flag
    static constexpr uint32_t ICR_CMPOKCF = 0x8;        // Compare register update OK Clear Flag
    static constexpr uint32_t ICR_EXTTRIGCF = 0x4;      // External trigger valid edge Clear Flag
    static constexpr uint32_t ICR_ARRMCF = 0x2;         // Autoreload match Clear Flag
    static constexpr uint32_t ICR_CMPMCF = 0x1;         // compare match Clear Flag
    static const uint32_t ICR_RESET_VALUE = 0x0;

    static constexpr uint32_t IER_DOWNIE = 0x40;        // Direction change to down Interrupt Enable
    static constexpr uint32_t IER_UPIE = 0x20;          // Direction change to UP Interrupt Enable
    static constexpr uint32_t IER_ARROKIE = 0x10;       // Autoreload register update OK Interrupt Enable
    static constexpr uint32_t IER_CMPOKIE = 0x8;        // Compare register update OK Interrupt Enable
    static constexpr uint32_t IER_EXTTRIGIE = 0x4;      // External trigger valid edge Interrupt Enable
    static constexpr uint32_t IER_ARRMIE = 0x2;         // Autoreload match Interrupt Enable
    static constexpr uint32_t IER_CMPMIE = 0x1;         // Compare match Interrupt Enable
    static const uint32_t IER_RESET_VALUE = 0x0;

    static constexpr uint32_t CFGR_ENC = 0x1000000;      // Encoder mode enable
    static constexpr uint32_t CFGR_COUNTMODE = 0x800000; // counter mode enabled
    static constexpr uint32_t CFGR_PRELOAD = 0x400000;   // Registers update mode
    static constexpr uint32_t CFGR_WAVPOL = 0x200000;    // Waveform shape polarity
    static constexpr uint32_t CFGR_WAVE = 0x100000;      // Waveform shape
    static constexpr uint32_t CFGR_TIMOUT = 0x80000;     // Timeout enable
    template<uint32_t X>
    static constexpr uint32_t CFGR_TRIGEN =              // Trigger enable and polarity (2 bits)
        bit_field_t<17, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_TRIGSEL =             // Trigger selector (3 bits)
        bit_field_t<13, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_PRESC =               // Clock prescaler (3 bits)
        bit_field_t<9, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_TRGFLT =              // Configurable digital filter for trigger (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_CKFLT =               // Configurable digital filter for external clock (2 bits)
        bit_field_t<3, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CFGR_CKPOL =               // Clock Polarity (2 bits)
        bit_field_t<1, 0x3>::value<X>();
    static constexpr uint32_t CFGR_CKSEL = 0x1;          // Clock selector
    static const uint32_t CFGR_RESET_VALUE = 0x0;

    static constexpr uint32_t CR_CNTSTRT = 0x4;        // Timer start in continuous mode
    static constexpr uint32_t CR_SNGSTRT = 0x2;        // LPTIM start in single mode
    static constexpr uint32_t CR_ENABLE = 0x1;         // LPTIM Enable
    static const uint32_t CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CMP_CMP =                 // Compare value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CMP_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ARR_ARR =                 // Auto reload value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t ARR_RESET_VALUE = 0x1;

    template<uint32_t X>
    static constexpr uint32_t CNT_CNT =                 // Counter value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CNT_RESET_VALUE = 0x0;

    static constexpr uint8_t LP_TIMER1 = 93; // LP Timer1 global interrupt
};

static lptim1_t& LPTIM1 = *reinterpret_cast<lptim1_t*>(0x40002400);

#define HAVE_PERIPHERAL_LPTIM1


////
//
//    Inter-integrated circuit
//
////

struct i2c1_t
{
    volatile uint32_t    CR1;                  // [Read-write] Control register 1
    volatile uint32_t    CR2;                  // [Read-write] Control register 2
    volatile uint32_t    OAR1;                 // [Read-write] Own address register 1
    volatile uint32_t    OAR2;                 // [Read-write] Own address register 2
    volatile uint32_t    TIMINGR;              // [Read-write] Timing register
    volatile uint32_t    TIMEOUTR;             // [Read-write] Status register 1
    volatile uint32_t    ISR;                  // Interrupt and Status register
    volatile uint32_t    ICR;                  // [Write-only] Interrupt clear register
    volatile uint32_t    PECR;                 // [Read-only] PEC register
    volatile uint32_t    RXDR;                 // [Read-only] Receive data register
    volatile uint32_t    TXDR;                 // [Read-write] Transmit data register

    static constexpr uint32_t CR1_PE = 0x1;             // Peripheral enable
    static constexpr uint32_t CR1_TXIE = 0x2;           // TX Interrupt enable
    static constexpr uint32_t CR1_RXIE = 0x4;           // RX Interrupt enable
    static constexpr uint32_t CR1_ADDRIE = 0x8;         // Address match interrupt enable (slave only)
    static constexpr uint32_t CR1_NACKIE = 0x10;        // Not acknowledge received interrupt enable
    static constexpr uint32_t CR1_STOPIE = 0x20;        // STOP detection Interrupt enable
    static constexpr uint32_t CR1_TCIE = 0x40;          // Transfer Complete interrupt enable
    static constexpr uint32_t CR1_ERRIE = 0x80;         // Error interrupts enable
    template<uint32_t X>
    static constexpr uint32_t CR1_DNF =                 // Digital noise filter (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    static constexpr uint32_t CR1_ANFOFF = 0x1000;      // Analog noise filter OFF
    static constexpr uint32_t CR1_TXDMAEN = 0x4000;     // DMA transmission requests enable
    static constexpr uint32_t CR1_RXDMAEN = 0x8000;     // DMA reception requests enable
    static constexpr uint32_t CR1_SBC = 0x10000;        // Slave byte control
    static constexpr uint32_t CR1_NOSTRETCH = 0x20000;  // Clock stretching disable
    static constexpr uint32_t CR1_WUPEN = 0x40000;      // Wakeup from STOP enable
    static constexpr uint32_t CR1_GCEN = 0x80000;       // General call enable
    static constexpr uint32_t CR1_SMBHEN = 0x100000;    // SMBus Host address enable
    static constexpr uint32_t CR1_SMBDEN = 0x200000;    // SMBus Device Default address enable
    static constexpr uint32_t CR1_ALERTEN = 0x400000;   // SMBUS alert enable
    static constexpr uint32_t CR1_PECEN = 0x800000;     // PEC enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CR2_PECBYTE = 0x4000000;  // Packet error checking byte
    static constexpr uint32_t CR2_AUTOEND = 0x2000000;  // Automatic end mode (master mode)
    static constexpr uint32_t CR2_RELOAD = 0x1000000;   // NBYTES reload mode
    template<uint32_t X>
    static constexpr uint32_t CR2_NBYTES =              // Number of bytes (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static constexpr uint32_t CR2_NACK = 0x8000;        // NACK generation (slave mode)
    static constexpr uint32_t CR2_STOP = 0x4000;        // Stop generation (master mode)
    static constexpr uint32_t CR2_START = 0x2000;       // Start generation
    static constexpr uint32_t CR2_HEAD10R = 0x1000;     // 10-bit address header only read direction (master receiver mode)
    static constexpr uint32_t CR2_ADD10 = 0x800;        // 10-bit addressing mode (master mode)
    static constexpr uint32_t CR2_RD_WRN = 0x400;       // Transfer direction (master mode)
    template<uint32_t X>
    static constexpr uint32_t CR2_SADD =                // Slave address bit (master mode) (10 bits)
        bit_field_t<0, 0x3ff>::value<X>();
    static const uint32_t CR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OAR1_OA1 =                 // Interface address (10 bits)
        bit_field_t<0, 0x3ff>::value<X>();
    static constexpr uint32_t OAR1_OA1MODE = 0x400;      // Own Address 1 10-bit mode
    static constexpr uint32_t OAR1_OA1EN = 0x8000;       // Own Address 1 enable
    static const uint32_t OAR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OAR2_OA2 =                 // Interface address (7 bits)
        bit_field_t<1, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OAR2_OA2MSK =              // Own Address 2 masks (3 bits)
        bit_field_t<8, 0x7>::value<X>();
    static constexpr uint32_t OAR2_OA2EN = 0x8000;       // Own Address 2 enable
    static const uint32_t OAR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TIMINGR_SCLL =                // SCL low period (master mode) (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TIMINGR_SCLH =                // SCL high period (master mode) (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TIMINGR_SDADEL =              // Data hold time (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TIMINGR_SCLDEL =              // Data setup time (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TIMINGR_PRESC =               // Timing prescaler (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    static const uint32_t TIMINGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TIMEOUTR_TIMEOUTA =            // Bus timeout A (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static constexpr uint32_t TIMEOUTR_TIDLE = 0x1000;       // Idle clock timeout detection
    static constexpr uint32_t TIMEOUTR_TIMOUTEN = 0x8000;    // Clock timeout enable
    template<uint32_t X>
    static constexpr uint32_t TIMEOUTR_TIMEOUTB =            // Bus timeout B (12 bits)
        bit_field_t<16, 0xfff>::value<X>();
    static constexpr uint32_t TIMEOUTR_TEXTEN = 0x80000000;  // Extended clock timeout enable
    static const uint32_t TIMEOUTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ISR_ADDCODE =             // Address match code (Slave mode) (7 bits), Read-only
        bit_field_t<17, 0x7f>::value<X>();
    static constexpr uint32_t ISR_DIR = 0x10000;        // Transfer direction (Slave mode), Read-only
    static constexpr uint32_t ISR_BUSY = 0x8000;        // Bus busy, Read-only
    static constexpr uint32_t ISR_ALERT = 0x2000;       // SMBus alert, Read-only
    static constexpr uint32_t ISR_TIMEOUT = 0x1000;     // Timeout or t_low detection flag, Read-only
    static constexpr uint32_t ISR_PECERR = 0x800;       // PEC Error in reception, Read-only
    static constexpr uint32_t ISR_OVR = 0x400;          // Overrun/Underrun (slave mode), Read-only
    static constexpr uint32_t ISR_ARLO = 0x200;         // Arbitration lost, Read-only
    static constexpr uint32_t ISR_BERR = 0x100;         // Bus error, Read-only
    static constexpr uint32_t ISR_TCR = 0x80;           // Transfer Complete Reload, Read-only
    static constexpr uint32_t ISR_TC = 0x40;            // Transfer Complete (master mode), Read-only
    static constexpr uint32_t ISR_STOPF = 0x20;         // Stop detection flag, Read-only
    static constexpr uint32_t ISR_NACKF = 0x10;         // Not acknowledge received flag, Read-only
    static constexpr uint32_t ISR_ADDR = 0x8;           // Address matched (slave mode), Read-only
    static constexpr uint32_t ISR_RXNE = 0x4;           // Receive data register not empty (receivers), Read-only
    static constexpr uint32_t ISR_TXIS = 0x2;           // Transmit interrupt status (transmitters), Read-write
    static constexpr uint32_t ISR_TXE = 0x1;            // Transmit data register empty (transmitters), Read-write
    static const uint32_t ISR_RESET_VALUE = 0x1;

    static constexpr uint32_t ICR_ALERTCF = 0x2000;     // Alert flag clear
    static constexpr uint32_t ICR_TIMOUTCF = 0x1000;    // Timeout detection flag clear
    static constexpr uint32_t ICR_PECCF = 0x800;        // PEC Error flag clear
    static constexpr uint32_t ICR_OVRCF = 0x400;        // Overrun/Underrun flag clear
    static constexpr uint32_t ICR_ARLOCF = 0x200;       // Arbitration lost flag clear
    static constexpr uint32_t ICR_BERRCF = 0x100;       // Bus error flag clear
    static constexpr uint32_t ICR_STOPCF = 0x20;        // Stop detection flag clear
    static constexpr uint32_t ICR_NACKCF = 0x10;        // Not Acknowledge flag clear
    static constexpr uint32_t ICR_ADDRCF = 0x8;         // Address Matched flag clear
    static const uint32_t ICR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PECR_PEC =                 // Packet error checking register (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t PECR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RXDR_RXDATA =              // 8-bit receive data (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t RXDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TXDR_TXDATA =              // 8-bit transmit data (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t TXDR_RESET_VALUE = 0x0;

    static constexpr uint8_t I2C1_ER = 32; // I2C1 error interrupt
    static constexpr uint8_t I2C1_EV = 31; // I2C1 event interrupt
};

static i2c1_t& I2C1 = *reinterpret_cast<i2c1_t*>(0x40005400);

#define HAVE_PERIPHERAL_I2C1


////
//
//    Inter-integrated circuit
//
////

struct i2c2_t
{
    volatile uint32_t    CR1;                  // [Read-write] Control register 1
    volatile uint32_t    CR2;                  // [Read-write] Control register 2
    volatile uint32_t    OAR1;                 // [Read-write] Own address register 1
    volatile uint32_t    OAR2;                 // [Read-write] Own address register 2
    volatile uint32_t    TIMINGR;              // [Read-write] Timing register
    volatile uint32_t    TIMEOUTR;             // [Read-write] Status register 1
    volatile uint32_t    ISR;                  // Interrupt and Status register
    volatile uint32_t    ICR;                  // [Write-only] Interrupt clear register
    volatile uint32_t    PECR;                 // [Read-only] PEC register
    volatile uint32_t    RXDR;                 // [Read-only] Receive data register
    volatile uint32_t    TXDR;                 // [Read-write] Transmit data register

    static constexpr uint32_t CR1_PE = 0x1;             // Peripheral enable
    static constexpr uint32_t CR1_TXIE = 0x2;           // TX Interrupt enable
    static constexpr uint32_t CR1_RXIE = 0x4;           // RX Interrupt enable
    static constexpr uint32_t CR1_ADDRIE = 0x8;         // Address match interrupt enable (slave only)
    static constexpr uint32_t CR1_NACKIE = 0x10;        // Not acknowledge received interrupt enable
    static constexpr uint32_t CR1_STOPIE = 0x20;        // STOP detection Interrupt enable
    static constexpr uint32_t CR1_TCIE = 0x40;          // Transfer Complete interrupt enable
    static constexpr uint32_t CR1_ERRIE = 0x80;         // Error interrupts enable
    template<uint32_t X>
    static constexpr uint32_t CR1_DNF =                 // Digital noise filter (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    static constexpr uint32_t CR1_ANFOFF = 0x1000;      // Analog noise filter OFF
    static constexpr uint32_t CR1_TXDMAEN = 0x4000;     // DMA transmission requests enable
    static constexpr uint32_t CR1_RXDMAEN = 0x8000;     // DMA reception requests enable
    static constexpr uint32_t CR1_SBC = 0x10000;        // Slave byte control
    static constexpr uint32_t CR1_NOSTRETCH = 0x20000;  // Clock stretching disable
    static constexpr uint32_t CR1_WUPEN = 0x40000;      // Wakeup from STOP enable
    static constexpr uint32_t CR1_GCEN = 0x80000;       // General call enable
    static constexpr uint32_t CR1_SMBHEN = 0x100000;    // SMBus Host address enable
    static constexpr uint32_t CR1_SMBDEN = 0x200000;    // SMBus Device Default address enable
    static constexpr uint32_t CR1_ALERTEN = 0x400000;   // SMBUS alert enable
    static constexpr uint32_t CR1_PECEN = 0x800000;     // PEC enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CR2_PECBYTE = 0x4000000;  // Packet error checking byte
    static constexpr uint32_t CR2_AUTOEND = 0x2000000;  // Automatic end mode (master mode)
    static constexpr uint32_t CR2_RELOAD = 0x1000000;   // NBYTES reload mode
    template<uint32_t X>
    static constexpr uint32_t CR2_NBYTES =              // Number of bytes (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static constexpr uint32_t CR2_NACK = 0x8000;        // NACK generation (slave mode)
    static constexpr uint32_t CR2_STOP = 0x4000;        // Stop generation (master mode)
    static constexpr uint32_t CR2_START = 0x2000;       // Start generation
    static constexpr uint32_t CR2_HEAD10R = 0x1000;     // 10-bit address header only read direction (master receiver mode)
    static constexpr uint32_t CR2_ADD10 = 0x800;        // 10-bit addressing mode (master mode)
    static constexpr uint32_t CR2_RD_WRN = 0x400;       // Transfer direction (master mode)
    template<uint32_t X>
    static constexpr uint32_t CR2_SADD =                // Slave address bit (master mode) (10 bits)
        bit_field_t<0, 0x3ff>::value<X>();
    static const uint32_t CR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OAR1_OA1 =                 // Interface address (10 bits)
        bit_field_t<0, 0x3ff>::value<X>();
    static constexpr uint32_t OAR1_OA1MODE = 0x400;      // Own Address 1 10-bit mode
    static constexpr uint32_t OAR1_OA1EN = 0x8000;       // Own Address 1 enable
    static const uint32_t OAR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OAR2_OA2 =                 // Interface address (7 bits)
        bit_field_t<1, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OAR2_OA2MSK =              // Own Address 2 masks (3 bits)
        bit_field_t<8, 0x7>::value<X>();
    static constexpr uint32_t OAR2_OA2EN = 0x8000;       // Own Address 2 enable
    static const uint32_t OAR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TIMINGR_SCLL =                // SCL low period (master mode) (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TIMINGR_SCLH =                // SCL high period (master mode) (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TIMINGR_SDADEL =              // Data hold time (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TIMINGR_SCLDEL =              // Data setup time (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TIMINGR_PRESC =               // Timing prescaler (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    static const uint32_t TIMINGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TIMEOUTR_TIMEOUTA =            // Bus timeout A (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static constexpr uint32_t TIMEOUTR_TIDLE = 0x1000;       // Idle clock timeout detection
    static constexpr uint32_t TIMEOUTR_TIMOUTEN = 0x8000;    // Clock timeout enable
    template<uint32_t X>
    static constexpr uint32_t TIMEOUTR_TIMEOUTB =            // Bus timeout B (12 bits)
        bit_field_t<16, 0xfff>::value<X>();
    static constexpr uint32_t TIMEOUTR_TEXTEN = 0x80000000;  // Extended clock timeout enable
    static const uint32_t TIMEOUTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ISR_ADDCODE =             // Address match code (Slave mode) (7 bits), Read-only
        bit_field_t<17, 0x7f>::value<X>();
    static constexpr uint32_t ISR_DIR = 0x10000;        // Transfer direction (Slave mode), Read-only
    static constexpr uint32_t ISR_BUSY = 0x8000;        // Bus busy, Read-only
    static constexpr uint32_t ISR_ALERT = 0x2000;       // SMBus alert, Read-only
    static constexpr uint32_t ISR_TIMEOUT = 0x1000;     // Timeout or t_low detection flag, Read-only
    static constexpr uint32_t ISR_PECERR = 0x800;       // PEC Error in reception, Read-only
    static constexpr uint32_t ISR_OVR = 0x400;          // Overrun/Underrun (slave mode), Read-only
    static constexpr uint32_t ISR_ARLO = 0x200;         // Arbitration lost, Read-only
    static constexpr uint32_t ISR_BERR = 0x100;         // Bus error, Read-only
    static constexpr uint32_t ISR_TCR = 0x80;           // Transfer Complete Reload, Read-only
    static constexpr uint32_t ISR_TC = 0x40;            // Transfer Complete (master mode), Read-only
    static constexpr uint32_t ISR_STOPF = 0x20;         // Stop detection flag, Read-only
    static constexpr uint32_t ISR_NACKF = 0x10;         // Not acknowledge received flag, Read-only
    static constexpr uint32_t ISR_ADDR = 0x8;           // Address matched (slave mode), Read-only
    static constexpr uint32_t ISR_RXNE = 0x4;           // Receive data register not empty (receivers), Read-only
    static constexpr uint32_t ISR_TXIS = 0x2;           // Transmit interrupt status (transmitters), Read-write
    static constexpr uint32_t ISR_TXE = 0x1;            // Transmit data register empty (transmitters), Read-write
    static const uint32_t ISR_RESET_VALUE = 0x1;

    static constexpr uint32_t ICR_ALERTCF = 0x2000;     // Alert flag clear
    static constexpr uint32_t ICR_TIMOUTCF = 0x1000;    // Timeout detection flag clear
    static constexpr uint32_t ICR_PECCF = 0x800;        // PEC Error flag clear
    static constexpr uint32_t ICR_OVRCF = 0x400;        // Overrun/Underrun flag clear
    static constexpr uint32_t ICR_ARLOCF = 0x200;       // Arbitration lost flag clear
    static constexpr uint32_t ICR_BERRCF = 0x100;       // Bus error flag clear
    static constexpr uint32_t ICR_STOPCF = 0x20;        // Stop detection flag clear
    static constexpr uint32_t ICR_NACKCF = 0x10;        // Not Acknowledge flag clear
    static constexpr uint32_t ICR_ADDRCF = 0x8;         // Address Matched flag clear
    static const uint32_t ICR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PECR_PEC =                 // Packet error checking register (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t PECR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RXDR_RXDATA =              // 8-bit receive data (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t RXDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TXDR_TXDATA =              // 8-bit transmit data (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t TXDR_RESET_VALUE = 0x0;

    static constexpr uint8_t I2C2_ER = 34; // I2C2 error interrupt
    static constexpr uint8_t I2C2_EV = 33; // I2C2 event interrupt
};

static i2c2_t& I2C2 = *reinterpret_cast<i2c2_t*>(0x40005800);

#define HAVE_PERIPHERAL_I2C2


////
//
//    Inter-integrated circuit
//
////

struct i2c3_t
{
    volatile uint32_t    CR1;                  // [Read-write] Control register 1
    volatile uint32_t    CR2;                  // [Read-write] Control register 2
    volatile uint32_t    OAR1;                 // [Read-write] Own address register 1
    volatile uint32_t    OAR2;                 // [Read-write] Own address register 2
    volatile uint32_t    TIMINGR;              // [Read-write] Timing register
    volatile uint32_t    TIMEOUTR;             // [Read-write] Status register 1
    volatile uint32_t    ISR;                  // Interrupt and Status register
    volatile uint32_t    ICR;                  // [Write-only] Interrupt clear register
    volatile uint32_t    PECR;                 // [Read-only] PEC register
    volatile uint32_t    RXDR;                 // [Read-only] Receive data register
    volatile uint32_t    TXDR;                 // [Read-write] Transmit data register

    static constexpr uint32_t CR1_PE = 0x1;             // Peripheral enable
    static constexpr uint32_t CR1_TXIE = 0x2;           // TX Interrupt enable
    static constexpr uint32_t CR1_RXIE = 0x4;           // RX Interrupt enable
    static constexpr uint32_t CR1_ADDRIE = 0x8;         // Address match interrupt enable (slave only)
    static constexpr uint32_t CR1_NACKIE = 0x10;        // Not acknowledge received interrupt enable
    static constexpr uint32_t CR1_STOPIE = 0x20;        // STOP detection Interrupt enable
    static constexpr uint32_t CR1_TCIE = 0x40;          // Transfer Complete interrupt enable
    static constexpr uint32_t CR1_ERRIE = 0x80;         // Error interrupts enable
    template<uint32_t X>
    static constexpr uint32_t CR1_DNF =                 // Digital noise filter (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    static constexpr uint32_t CR1_ANFOFF = 0x1000;      // Analog noise filter OFF
    static constexpr uint32_t CR1_TXDMAEN = 0x4000;     // DMA transmission requests enable
    static constexpr uint32_t CR1_RXDMAEN = 0x8000;     // DMA reception requests enable
    static constexpr uint32_t CR1_SBC = 0x10000;        // Slave byte control
    static constexpr uint32_t CR1_NOSTRETCH = 0x20000;  // Clock stretching disable
    static constexpr uint32_t CR1_WUPEN = 0x40000;      // Wakeup from STOP enable
    static constexpr uint32_t CR1_GCEN = 0x80000;       // General call enable
    static constexpr uint32_t CR1_SMBHEN = 0x100000;    // SMBus Host address enable
    static constexpr uint32_t CR1_SMBDEN = 0x200000;    // SMBus Device Default address enable
    static constexpr uint32_t CR1_ALERTEN = 0x400000;   // SMBUS alert enable
    static constexpr uint32_t CR1_PECEN = 0x800000;     // PEC enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CR2_PECBYTE = 0x4000000;  // Packet error checking byte
    static constexpr uint32_t CR2_AUTOEND = 0x2000000;  // Automatic end mode (master mode)
    static constexpr uint32_t CR2_RELOAD = 0x1000000;   // NBYTES reload mode
    template<uint32_t X>
    static constexpr uint32_t CR2_NBYTES =              // Number of bytes (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static constexpr uint32_t CR2_NACK = 0x8000;        // NACK generation (slave mode)
    static constexpr uint32_t CR2_STOP = 0x4000;        // Stop generation (master mode)
    static constexpr uint32_t CR2_START = 0x2000;       // Start generation
    static constexpr uint32_t CR2_HEAD10R = 0x1000;     // 10-bit address header only read direction (master receiver mode)
    static constexpr uint32_t CR2_ADD10 = 0x800;        // 10-bit addressing mode (master mode)
    static constexpr uint32_t CR2_RD_WRN = 0x400;       // Transfer direction (master mode)
    template<uint32_t X>
    static constexpr uint32_t CR2_SADD =                // Slave address bit (master mode) (10 bits)
        bit_field_t<0, 0x3ff>::value<X>();
    static const uint32_t CR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OAR1_OA1 =                 // Interface address (10 bits)
        bit_field_t<0, 0x3ff>::value<X>();
    static constexpr uint32_t OAR1_OA1MODE = 0x400;      // Own Address 1 10-bit mode
    static constexpr uint32_t OAR1_OA1EN = 0x8000;       // Own Address 1 enable
    static const uint32_t OAR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OAR2_OA2 =                 // Interface address (7 bits)
        bit_field_t<1, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OAR2_OA2MSK =              // Own Address 2 masks (3 bits)
        bit_field_t<8, 0x7>::value<X>();
    static constexpr uint32_t OAR2_OA2EN = 0x8000;       // Own Address 2 enable
    static const uint32_t OAR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TIMINGR_SCLL =                // SCL low period (master mode) (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TIMINGR_SCLH =                // SCL high period (master mode) (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TIMINGR_SDADEL =              // Data hold time (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TIMINGR_SCLDEL =              // Data setup time (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TIMINGR_PRESC =               // Timing prescaler (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    static const uint32_t TIMINGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TIMEOUTR_TIMEOUTA =            // Bus timeout A (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static constexpr uint32_t TIMEOUTR_TIDLE = 0x1000;       // Idle clock timeout detection
    static constexpr uint32_t TIMEOUTR_TIMOUTEN = 0x8000;    // Clock timeout enable
    template<uint32_t X>
    static constexpr uint32_t TIMEOUTR_TIMEOUTB =            // Bus timeout B (12 bits)
        bit_field_t<16, 0xfff>::value<X>();
    static constexpr uint32_t TIMEOUTR_TEXTEN = 0x80000000;  // Extended clock timeout enable
    static const uint32_t TIMEOUTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ISR_ADDCODE =             // Address match code (Slave mode) (7 bits), Read-only
        bit_field_t<17, 0x7f>::value<X>();
    static constexpr uint32_t ISR_DIR = 0x10000;        // Transfer direction (Slave mode), Read-only
    static constexpr uint32_t ISR_BUSY = 0x8000;        // Bus busy, Read-only
    static constexpr uint32_t ISR_ALERT = 0x2000;       // SMBus alert, Read-only
    static constexpr uint32_t ISR_TIMEOUT = 0x1000;     // Timeout or t_low detection flag, Read-only
    static constexpr uint32_t ISR_PECERR = 0x800;       // PEC Error in reception, Read-only
    static constexpr uint32_t ISR_OVR = 0x400;          // Overrun/Underrun (slave mode), Read-only
    static constexpr uint32_t ISR_ARLO = 0x200;         // Arbitration lost, Read-only
    static constexpr uint32_t ISR_BERR = 0x100;         // Bus error, Read-only
    static constexpr uint32_t ISR_TCR = 0x80;           // Transfer Complete Reload, Read-only
    static constexpr uint32_t ISR_TC = 0x40;            // Transfer Complete (master mode), Read-only
    static constexpr uint32_t ISR_STOPF = 0x20;         // Stop detection flag, Read-only
    static constexpr uint32_t ISR_NACKF = 0x10;         // Not acknowledge received flag, Read-only
    static constexpr uint32_t ISR_ADDR = 0x8;           // Address matched (slave mode), Read-only
    static constexpr uint32_t ISR_RXNE = 0x4;           // Receive data register not empty (receivers), Read-only
    static constexpr uint32_t ISR_TXIS = 0x2;           // Transmit interrupt status (transmitters), Read-write
    static constexpr uint32_t ISR_TXE = 0x1;            // Transmit data register empty (transmitters), Read-write
    static const uint32_t ISR_RESET_VALUE = 0x1;

    static constexpr uint32_t ICR_ALERTCF = 0x2000;     // Alert flag clear
    static constexpr uint32_t ICR_TIMOUTCF = 0x1000;    // Timeout detection flag clear
    static constexpr uint32_t ICR_PECCF = 0x800;        // PEC Error flag clear
    static constexpr uint32_t ICR_OVRCF = 0x400;        // Overrun/Underrun flag clear
    static constexpr uint32_t ICR_ARLOCF = 0x200;       // Arbitration lost flag clear
    static constexpr uint32_t ICR_BERRCF = 0x100;       // Bus error flag clear
    static constexpr uint32_t ICR_STOPCF = 0x20;        // Stop detection flag clear
    static constexpr uint32_t ICR_NACKCF = 0x10;        // Not Acknowledge flag clear
    static constexpr uint32_t ICR_ADDRCF = 0x8;         // Address Matched flag clear
    static const uint32_t ICR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PECR_PEC =                 // Packet error checking register (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t PECR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RXDR_RXDATA =              // 8-bit receive data (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t RXDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TXDR_TXDATA =              // 8-bit transmit data (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t TXDR_RESET_VALUE = 0x0;

    static constexpr uint8_t I2C3_ER = 73; // I2C3 error interrupt
    static constexpr uint8_t I2C3_EV = 72; // I2C3 event interrupt
};

static i2c3_t& I2C3 = *reinterpret_cast<i2c3_t*>(0x40005c00);

#define HAVE_PERIPHERAL_I2C3


////
//
//    Inter-integrated circuit
//
////

struct i2c4_t
{
    volatile uint32_t    CR1;                  // [Read-write] Control register 1
    volatile uint32_t    CR2;                  // [Read-write] Control register 2
    volatile uint32_t    OAR1;                 // [Read-write] Own address register 1
    volatile uint32_t    OAR2;                 // [Read-write] Own address register 2
    volatile uint32_t    TIMINGR;              // [Read-write] Timing register
    volatile uint32_t    TIMEOUTR;             // [Read-write] Status register 1
    volatile uint32_t    ISR;                  // Interrupt and Status register
    volatile uint32_t    ICR;                  // [Write-only] Interrupt clear register
    volatile uint32_t    PECR;                 // [Read-only] PEC register
    volatile uint32_t    RXDR;                 // [Read-only] Receive data register
    volatile uint32_t    TXDR;                 // [Read-write] Transmit data register

    static constexpr uint32_t CR1_PE = 0x1;             // Peripheral enable
    static constexpr uint32_t CR1_TXIE = 0x2;           // TX Interrupt enable
    static constexpr uint32_t CR1_RXIE = 0x4;           // RX Interrupt enable
    static constexpr uint32_t CR1_ADDRIE = 0x8;         // Address match interrupt enable (slave only)
    static constexpr uint32_t CR1_NACKIE = 0x10;        // Not acknowledge received interrupt enable
    static constexpr uint32_t CR1_STOPIE = 0x20;        // STOP detection Interrupt enable
    static constexpr uint32_t CR1_TCIE = 0x40;          // Transfer Complete interrupt enable
    static constexpr uint32_t CR1_ERRIE = 0x80;         // Error interrupts enable
    template<uint32_t X>
    static constexpr uint32_t CR1_DNF =                 // Digital noise filter (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    static constexpr uint32_t CR1_ANFOFF = 0x1000;      // Analog noise filter OFF
    static constexpr uint32_t CR1_TXDMAEN = 0x4000;     // DMA transmission requests enable
    static constexpr uint32_t CR1_RXDMAEN = 0x8000;     // DMA reception requests enable
    static constexpr uint32_t CR1_SBC = 0x10000;        // Slave byte control
    static constexpr uint32_t CR1_NOSTRETCH = 0x20000;  // Clock stretching disable
    static constexpr uint32_t CR1_WUPEN = 0x40000;      // Wakeup from STOP enable
    static constexpr uint32_t CR1_GCEN = 0x80000;       // General call enable
    static constexpr uint32_t CR1_SMBHEN = 0x100000;    // SMBus Host address enable
    static constexpr uint32_t CR1_SMBDEN = 0x200000;    // SMBus Device Default address enable
    static constexpr uint32_t CR1_ALERTEN = 0x400000;   // SMBUS alert enable
    static constexpr uint32_t CR1_PECEN = 0x800000;     // PEC enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t CR2_PECBYTE = 0x4000000;  // Packet error checking byte
    static constexpr uint32_t CR2_AUTOEND = 0x2000000;  // Automatic end mode (master mode)
    static constexpr uint32_t CR2_RELOAD = 0x1000000;   // NBYTES reload mode
    template<uint32_t X>
    static constexpr uint32_t CR2_NBYTES =              // Number of bytes (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static constexpr uint32_t CR2_NACK = 0x8000;        // NACK generation (slave mode)
    static constexpr uint32_t CR2_STOP = 0x4000;        // Stop generation (master mode)
    static constexpr uint32_t CR2_START = 0x2000;       // Start generation
    static constexpr uint32_t CR2_HEAD10R = 0x1000;     // 10-bit address header only read direction (master receiver mode)
    static constexpr uint32_t CR2_ADD10 = 0x800;        // 10-bit addressing mode (master mode)
    static constexpr uint32_t CR2_RD_WRN = 0x400;       // Transfer direction (master mode)
    template<uint32_t X>
    static constexpr uint32_t CR2_SADD =                // Slave address bit (master mode) (10 bits)
        bit_field_t<0, 0x3ff>::value<X>();
    static const uint32_t CR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OAR1_OA1 =                 // Interface address (10 bits)
        bit_field_t<0, 0x3ff>::value<X>();
    static constexpr uint32_t OAR1_OA1MODE = 0x400;      // Own Address 1 10-bit mode
    static constexpr uint32_t OAR1_OA1EN = 0x8000;       // Own Address 1 enable
    static const uint32_t OAR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OAR2_OA2 =                 // Interface address (7 bits)
        bit_field_t<1, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OAR2_OA2MSK =              // Own Address 2 masks (3 bits)
        bit_field_t<8, 0x7>::value<X>();
    static constexpr uint32_t OAR2_OA2EN = 0x8000;       // Own Address 2 enable
    static const uint32_t OAR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TIMINGR_SCLL =                // SCL low period (master mode) (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TIMINGR_SCLH =                // SCL high period (master mode) (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TIMINGR_SDADEL =              // Data hold time (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TIMINGR_SCLDEL =              // Data setup time (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TIMINGR_PRESC =               // Timing prescaler (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    static const uint32_t TIMINGR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TIMEOUTR_TIMEOUTA =            // Bus timeout A (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static constexpr uint32_t TIMEOUTR_TIDLE = 0x1000;       // Idle clock timeout detection
    static constexpr uint32_t TIMEOUTR_TIMOUTEN = 0x8000;    // Clock timeout enable
    template<uint32_t X>
    static constexpr uint32_t TIMEOUTR_TIMEOUTB =            // Bus timeout B (12 bits)
        bit_field_t<16, 0xfff>::value<X>();
    static constexpr uint32_t TIMEOUTR_TEXTEN = 0x80000000;  // Extended clock timeout enable
    static const uint32_t TIMEOUTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ISR_ADDCODE =             // Address match code (Slave mode) (7 bits), Read-only
        bit_field_t<17, 0x7f>::value<X>();
    static constexpr uint32_t ISR_DIR = 0x10000;        // Transfer direction (Slave mode), Read-only
    static constexpr uint32_t ISR_BUSY = 0x8000;        // Bus busy, Read-only
    static constexpr uint32_t ISR_ALERT = 0x2000;       // SMBus alert, Read-only
    static constexpr uint32_t ISR_TIMEOUT = 0x1000;     // Timeout or t_low detection flag, Read-only
    static constexpr uint32_t ISR_PECERR = 0x800;       // PEC Error in reception, Read-only
    static constexpr uint32_t ISR_OVR = 0x400;          // Overrun/Underrun (slave mode), Read-only
    static constexpr uint32_t ISR_ARLO = 0x200;         // Arbitration lost, Read-only
    static constexpr uint32_t ISR_BERR = 0x100;         // Bus error, Read-only
    static constexpr uint32_t ISR_TCR = 0x80;           // Transfer Complete Reload, Read-only
    static constexpr uint32_t ISR_TC = 0x40;            // Transfer Complete (master mode), Read-only
    static constexpr uint32_t ISR_STOPF = 0x20;         // Stop detection flag, Read-only
    static constexpr uint32_t ISR_NACKF = 0x10;         // Not acknowledge received flag, Read-only
    static constexpr uint32_t ISR_ADDR = 0x8;           // Address matched (slave mode), Read-only
    static constexpr uint32_t ISR_RXNE = 0x4;           // Receive data register not empty (receivers), Read-only
    static constexpr uint32_t ISR_TXIS = 0x2;           // Transmit interrupt status (transmitters), Read-write
    static constexpr uint32_t ISR_TXE = 0x1;            // Transmit data register empty (transmitters), Read-write
    static const uint32_t ISR_RESET_VALUE = 0x1;

    static constexpr uint32_t ICR_ALERTCF = 0x2000;     // Alert flag clear
    static constexpr uint32_t ICR_TIMOUTCF = 0x1000;    // Timeout detection flag clear
    static constexpr uint32_t ICR_PECCF = 0x800;        // PEC Error flag clear
    static constexpr uint32_t ICR_OVRCF = 0x400;        // Overrun/Underrun flag clear
    static constexpr uint32_t ICR_ARLOCF = 0x200;       // Arbitration lost flag clear
    static constexpr uint32_t ICR_BERRCF = 0x100;       // Bus error flag clear
    static constexpr uint32_t ICR_STOPCF = 0x20;        // Stop detection flag clear
    static constexpr uint32_t ICR_NACKCF = 0x10;        // Not Acknowledge flag clear
    static constexpr uint32_t ICR_ADDRCF = 0x8;         // Address Matched flag clear
    static const uint32_t ICR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PECR_PEC =                 // Packet error checking register (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t PECR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RXDR_RXDATA =              // 8-bit receive data (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t RXDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TXDR_TXDATA =              // 8-bit transmit data (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t TXDR_RESET_VALUE = 0x0;

    static constexpr uint8_t I2C4_ER = 96; // I2C4 Error interrupt
    static constexpr uint8_t I2C4_EV = 95; // I2C4 event interrupt
};

static i2c4_t& I2C4 = *reinterpret_cast<i2c4_t*>(0x40006000);

#define HAVE_PERIPHERAL_I2C4


////
//
//    Real-time clock
//
////

struct rtc_t
{
    volatile uint32_t    TR;                   // [Read-write] time register
    volatile uint32_t    DR;                   // [Read-write] date register
    volatile uint32_t    CR;                   // [Read-write] control register
    volatile uint32_t    ISR;                  // initialization and status register
    volatile uint32_t    PRER;                 // [Read-write] prescaler register
    volatile uint32_t    WUTR;                 // [Read-write] wakeup timer register
    reserved_t<1>        _0;
    volatile uint32_t    ALRMAR;               // [Read-write] alarm A register
    volatile uint32_t    ALRMBR;               // [Read-write] alarm B register
    volatile uint32_t    WPR;                  // [Write-only] write protection register
    volatile uint32_t    SSR;                  // [Read-only] sub second register
    volatile uint32_t    SHIFTR;               // [Write-only] shift control register
    volatile uint32_t    TSTR;                 // [Read-only] time stamp time register
    volatile uint32_t    TSDR;                 // [Read-only] time stamp date register
    volatile uint32_t    TSSSR;                // [Read-only] timestamp sub second register
    volatile uint32_t    CALR;                 // [Read-write] calibration register
    volatile uint32_t    TAMPCR;               // [Read-write] tamper configuration register
    volatile uint32_t    ALRMASSR;             // [Read-write] alarm A sub second register
    volatile uint32_t    ALRMBSSR;             // [Read-write] alarm B sub second register
    volatile uint32_t    OR;                   // [Read-write] option register
    volatile uint32_t    BKP0R;                // [Read-write] backup register
    volatile uint32_t    BKP1R;                // [Read-write] backup register
    volatile uint32_t    BKP2R;                // [Read-write] backup register
    volatile uint32_t    BKP3R;                // [Read-write] backup register
    volatile uint32_t    BKP4R;                // [Read-write] backup register
    volatile uint32_t    BKP5R;                // [Read-write] backup register
    volatile uint32_t    BKP6R;                // [Read-write] backup register
    volatile uint32_t    BKP7R;                // [Read-write] backup register
    volatile uint32_t    BKP8R;                // [Read-write] backup register
    volatile uint32_t    BKP9R;                // [Read-write] backup register
    volatile uint32_t    BKP10R;               // [Read-write] backup register
    volatile uint32_t    BKP11R;               // [Read-write] backup register
    volatile uint32_t    BKP12R;               // [Read-write] backup register
    volatile uint32_t    BKP13R;               // [Read-write] backup register
    volatile uint32_t    BKP14R;               // [Read-write] backup register
    volatile uint32_t    BKP15R;               // [Read-write] backup register
    volatile uint32_t    BKP16R;               // [Read-write] backup register
    volatile uint32_t    BKP17R;               // [Read-write] backup register
    volatile uint32_t    BKP18R;               // [Read-write] backup register
    volatile uint32_t    BKP19R;               // [Read-write] backup register
    volatile uint32_t    BKP20R;               // [Read-write] backup register
    volatile uint32_t    BKP21R;               // [Read-write] backup register
    volatile uint32_t    BKP22R;               // [Read-write] backup register
    volatile uint32_t    BKP23R;               // [Read-write] backup register
    volatile uint32_t    BKP24R;               // [Read-write] backup register
    volatile uint32_t    BKP25R;               // [Read-write] backup register
    volatile uint32_t    BKP26R;               // [Read-write] backup register
    volatile uint32_t    BKP27R;               // [Read-write] backup register
    volatile uint32_t    BKP28R;               // [Read-write] backup register
    volatile uint32_t    BKP29R;               // [Read-write] backup register
    volatile uint32_t    BKP30R;               // [Read-write] backup register
    volatile uint32_t    BKP31R;               // [Read-write] backup register

    static constexpr uint32_t TR_PM = 0x400000;        // AM/PM notation
    template<uint32_t X>
    static constexpr uint32_t TR_HT =                  // Hour tens in BCD format (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TR_HU =                  // Hour units in BCD format (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TR_MNT =                 // Minute tens in BCD format (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TR_MNU =                 // Minute units in BCD format (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TR_ST =                  // Second tens in BCD format (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TR_SU =                  // Second units in BCD format (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t TR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DR_YT =                  // Year tens in BCD format (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DR_YU =                  // Year units in BCD format (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DR_WDU =                 // Week day units (3 bits)
        bit_field_t<13, 0x7>::value<X>();
    static constexpr uint32_t DR_MT = 0x1000;          // Month tens in BCD format
    template<uint32_t X>
    static constexpr uint32_t DR_MU =                  // Month units in BCD format (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DR_DT =                  // Date tens in BCD format (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DR_DU =                  // Date units in BCD format (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t DR_RESET_VALUE = 0x2101;

    template<uint32_t X>
    static constexpr uint32_t CR_WCKSEL =              // Wakeup clock selection (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static constexpr uint32_t CR_TSEDGE = 0x8;         // Time-stamp event active edge
    static constexpr uint32_t CR_REFCKON = 0x10;       // Reference clock detection enable (50 or 60 Hz)
    static constexpr uint32_t CR_BYPSHAD = 0x20;       // Bypass the shadow registers
    static constexpr uint32_t CR_FMT = 0x40;           // Hour format
    static constexpr uint32_t CR_ALRAE = 0x100;        // Alarm A enable
    static constexpr uint32_t CR_ALRBE = 0x200;        // Alarm B enable
    static constexpr uint32_t CR_WUTE = 0x400;         // Wakeup timer enable
    static constexpr uint32_t CR_TSE = 0x800;          // Time stamp enable
    static constexpr uint32_t CR_ALRAIE = 0x1000;      // Alarm A interrupt enable
    static constexpr uint32_t CR_ALRBIE = 0x2000;      // Alarm B interrupt enable
    static constexpr uint32_t CR_WUTIE = 0x4000;       // Wakeup timer interrupt enable
    static constexpr uint32_t CR_TSIE = 0x8000;        // Time-stamp interrupt enable
    static constexpr uint32_t CR_ADD1H = 0x10000;      // Add 1 hour (summer time change)
    static constexpr uint32_t CR_SUB1H = 0x20000;      // Subtract 1 hour (winter time change)
    static constexpr uint32_t CR_BKP = 0x40000;        // Backup
    static constexpr uint32_t CR_COSEL = 0x80000;      // Calibration output selection
    static constexpr uint32_t CR_POL = 0x100000;       // Output polarity
    template<uint32_t X>
    static constexpr uint32_t CR_OSEL =                // Output selection (2 bits)
        bit_field_t<21, 0x3>::value<X>();
    static constexpr uint32_t CR_COE = 0x800000;       // Calibration output enable
    static constexpr uint32_t CR_ITSE = 0x1000000;     // timestamp on internal event enable
    static const uint32_t CR_RESET_VALUE = 0x0;

    static constexpr uint32_t ISR_ALRAWF = 0x1;         // Alarm A write flag, Read-only
    static constexpr uint32_t ISR_ALRBWF = 0x2;         // Alarm B write flag, Read-only
    static constexpr uint32_t ISR_WUTWF = 0x4;          // Wakeup timer write flag, Read-only
    static constexpr uint32_t ISR_SHPF = 0x8;           // Shift operation pending, Read-write
    static constexpr uint32_t ISR_INITS = 0x10;         // Initialization status flag, Read-only
    static constexpr uint32_t ISR_RSF = 0x20;           // Registers synchronization flag, Read-write
    static constexpr uint32_t ISR_INITF = 0x40;         // Initialization flag, Read-only
    static constexpr uint32_t ISR_INIT = 0x80;          // Initialization mode, Read-write
    static constexpr uint32_t ISR_ALRAF = 0x100;        // Alarm A flag, Read-write
    static constexpr uint32_t ISR_ALRBF = 0x200;        // Alarm B flag, Read-write
    static constexpr uint32_t ISR_WUTF = 0x400;         // Wakeup timer flag, Read-write
    static constexpr uint32_t ISR_TSF = 0x800;          // Time-stamp flag, Read-write
    static constexpr uint32_t ISR_TSOVF = 0x1000;       // Time-stamp overflow flag, Read-write
    static constexpr uint32_t ISR_TAMP1F = 0x2000;      // Tamper detection flag, Read-write
    static constexpr uint32_t ISR_TAMP2F = 0x4000;      // RTC_TAMP2 detection flag, Read-write
    static constexpr uint32_t ISR_TAMP3F = 0x8000;      // RTC_TAMP3 detection flag, Read-write
    static constexpr uint32_t ISR_RECALPF = 0x10000;    // Recalibration pending Flag, Read-only
    static const uint32_t ISR_RESET_VALUE = 0x7;

    template<uint32_t X>
    static constexpr uint32_t PRER_PREDIV_A =            // Asynchronous prescaler factor (7 bits)
        bit_field_t<16, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PRER_PREDIV_S =            // Synchronous prescaler factor (15 bits)
        bit_field_t<0, 0x7fff>::value<X>();
    static const uint32_t PRER_RESET_VALUE = 0x7f00ff;

    template<uint32_t X>
    static constexpr uint32_t WUTR_WUT =                 // Wakeup auto-reload value bits (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t WUTR_RESET_VALUE = 0xffff;

    static constexpr uint32_t ALRMAR_MSK4 = 0x80000000;    // Alarm A date mask
    static constexpr uint32_t ALRMAR_WDSEL = 0x40000000;   // Week day selection
    template<uint32_t X>
    static constexpr uint32_t ALRMAR_DT =                  // Date tens in BCD format (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ALRMAR_DU =                  // Date units or day in BCD format (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    static constexpr uint32_t ALRMAR_MSK3 = 0x800000;      // Alarm A hours mask
    static constexpr uint32_t ALRMAR_PM = 0x400000;        // AM/PM notation
    template<uint32_t X>
    static constexpr uint32_t ALRMAR_HT =                  // Hour tens in BCD format (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ALRMAR_HU =                  // Hour units in BCD format (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    static constexpr uint32_t ALRMAR_MSK2 = 0x8000;        // Alarm A minutes mask
    template<uint32_t X>
    static constexpr uint32_t ALRMAR_MNT =                 // Minute tens in BCD format (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ALRMAR_MNU =                 // Minute units in BCD format (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    static constexpr uint32_t ALRMAR_MSK1 = 0x80;          // Alarm A seconds mask
    template<uint32_t X>
    static constexpr uint32_t ALRMAR_ST =                  // Second tens in BCD format (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ALRMAR_SU =                  // Second units in BCD format (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t ALRMAR_RESET_VALUE = 0x0;

    static constexpr uint32_t ALRMBR_MSK4 = 0x80000000;    // Alarm B date mask
    static constexpr uint32_t ALRMBR_WDSEL = 0x40000000;   // Week day selection
    template<uint32_t X>
    static constexpr uint32_t ALRMBR_DT =                  // Date tens in BCD format (2 bits)
        bit_field_t<28, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ALRMBR_DU =                  // Date units or day in BCD format (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    static constexpr uint32_t ALRMBR_MSK3 = 0x800000;      // Alarm B hours mask
    static constexpr uint32_t ALRMBR_PM = 0x400000;        // AM/PM notation
    template<uint32_t X>
    static constexpr uint32_t ALRMBR_HT =                  // Hour tens in BCD format (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ALRMBR_HU =                  // Hour units in BCD format (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    static constexpr uint32_t ALRMBR_MSK2 = 0x8000;        // Alarm B minutes mask
    template<uint32_t X>
    static constexpr uint32_t ALRMBR_MNT =                 // Minute tens in BCD format (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ALRMBR_MNU =                 // Minute units in BCD format (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    static constexpr uint32_t ALRMBR_MSK1 = 0x80;          // Alarm B seconds mask
    template<uint32_t X>
    static constexpr uint32_t ALRMBR_ST =                  // Second tens in BCD format (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ALRMBR_SU =                  // Second units in BCD format (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t ALRMBR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t WPR_KEY =                 // Write protection key (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t WPR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SSR_SS =                  // Sub second value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t SSR_RESET_VALUE = 0x0;

    static constexpr uint32_t SHIFTR_ADD1S = 0x80000000;   // Add one second
    template<uint32_t X>
    static constexpr uint32_t SHIFTR_SUBFS =               // Subtract a fraction of a second (15 bits)
        bit_field_t<0, 0x7fff>::value<X>();
    static const uint32_t SHIFTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TSTR_SU =                  // Second units in BCD format (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TSTR_ST =                  // Second tens in BCD format (3 bits)
        bit_field_t<4, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TSTR_MNU =                 // Minute units in BCD format (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TSTR_MNT =                 // Minute tens in BCD format (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TSTR_HU =                  // Hour units in BCD format (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TSTR_HT =                  // Hour tens in BCD format (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    static constexpr uint32_t TSTR_PM = 0x400000;        // AM/PM notation
    static const uint32_t TSTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TSDR_WDU =                 // Week day units (3 bits)
        bit_field_t<13, 0x7>::value<X>();
    static constexpr uint32_t TSDR_MT = 0x1000;          // Month tens in BCD format
    template<uint32_t X>
    static constexpr uint32_t TSDR_MU =                  // Month units in BCD format (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TSDR_DT =                  // Date tens in BCD format (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TSDR_DU =                  // Date units in BCD format (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t TSDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TSSSR_SS =                  // Sub second value (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t TSSSR_RESET_VALUE = 0x0;

    static constexpr uint32_t CALR_CALP = 0x8000;        // Increase frequency of RTC by 488.5 ppm
    static constexpr uint32_t CALR_CALW8 = 0x4000;       // Use an 8-second calibration cycle period
    static constexpr uint32_t CALR_CALW16 = 0x2000;      // Use a 16-second calibration cycle period
    template<uint32_t X>
    static constexpr uint32_t CALR_CALM =                // Calibration minus (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static const uint32_t CALR_RESET_VALUE = 0x0;

    static constexpr uint32_t TAMPCR_TAMP1E = 0x1;         // Tamper 1 detection enable
    static constexpr uint32_t TAMPCR_TAMP1TRG = 0x2;       // Active level for tamper 1
    static constexpr uint32_t TAMPCR_TAMPIE = 0x4;         // Tamper interrupt enable
    static constexpr uint32_t TAMPCR_TAMP2E = 0x8;         // Tamper 2 detection enable
    static constexpr uint32_t TAMPCR_TAMP2TRG = 0x10;      // Active level for tamper 2
    static constexpr uint32_t TAMPCR_TAMP3E = 0x20;        // Tamper 3 detection enable
    static constexpr uint32_t TAMPCR_TAMP3TRG = 0x40;      // Active level for tamper 3
    static constexpr uint32_t TAMPCR_TAMPTS = 0x80;        // Activate timestamp on tamper detection event
    template<uint32_t X>
    static constexpr uint32_t TAMPCR_TAMPFREQ =            // Tamper sampling frequency (3 bits)
        bit_field_t<8, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TAMPCR_TAMPFLT =             // Tamper filter count (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TAMPCR_TAMPPRCH =            // Tamper precharge duration (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    static constexpr uint32_t TAMPCR_TAMPPUDIS = 0x8000;   // TAMPER pull-up disable
    static constexpr uint32_t TAMPCR_TAMP1IE = 0x10000;    // Tamper 1 interrupt enable
    static constexpr uint32_t TAMPCR_TAMP1NOERASE = 0x20000;// Tamper 1 no erase
    static constexpr uint32_t TAMPCR_TAMP1MF = 0x40000;    // Tamper 1 mask flag
    static constexpr uint32_t TAMPCR_TAMP2IE = 0x80000;    // Tamper 2 interrupt enable
    static constexpr uint32_t TAMPCR_TAMP2NOERASE = 0x100000;// Tamper 2 no erase
    static constexpr uint32_t TAMPCR_TAMP2MF = 0x200000;   // Tamper 2 mask flag
    static constexpr uint32_t TAMPCR_TAMP3IE = 0x400000;   // Tamper 3 interrupt enable
    static constexpr uint32_t TAMPCR_TAMP3NOERASE = 0x800000;// Tamper 3 no erase
    static constexpr uint32_t TAMPCR_TAMP3MF = 0x1000000;  // Tamper 3 mask flag
    static const uint32_t TAMPCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ALRMASSR_MASKSS =              // Mask the most-significant bits starting at this bit (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ALRMASSR_SS =                  // Sub seconds value (15 bits)
        bit_field_t<0, 0x7fff>::value<X>();
    static const uint32_t ALRMASSR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t ALRMBSSR_MASKSS =              // Mask the most-significant bits starting at this bit (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t ALRMBSSR_SS =                  // Sub seconds value (15 bits)
        bit_field_t<0, 0x7fff>::value<X>();
    static const uint32_t ALRMBSSR_RESET_VALUE = 0x0;

    static constexpr uint32_t OR_RTC_ALARM_TYPE = 0x1; // RTC_ALARM on PC13 output type
    static constexpr uint32_t OR_RTC_OUT_RMP = 0x2;    // RTC_OUT remap
    static const uint32_t OR_RESET_VALUE = 0x0;


    static const uint32_t BKP0R_RESET_VALUE = 0x0;


    static const uint32_t BKP1R_RESET_VALUE = 0x0;


    static const uint32_t BKP2R_RESET_VALUE = 0x0;


    static const uint32_t BKP3R_RESET_VALUE = 0x0;


    static const uint32_t BKP4R_RESET_VALUE = 0x0;


    static const uint32_t BKP5R_RESET_VALUE = 0x0;


    static const uint32_t BKP6R_RESET_VALUE = 0x0;


    static const uint32_t BKP7R_RESET_VALUE = 0x0;


    static const uint32_t BKP8R_RESET_VALUE = 0x0;


    static const uint32_t BKP9R_RESET_VALUE = 0x0;


    static const uint32_t BKP10R_RESET_VALUE = 0x0;


    static const uint32_t BKP11R_RESET_VALUE = 0x0;


    static const uint32_t BKP12R_RESET_VALUE = 0x0;


    static const uint32_t BKP13R_RESET_VALUE = 0x0;


    static const uint32_t BKP14R_RESET_VALUE = 0x0;


    static const uint32_t BKP15R_RESET_VALUE = 0x0;


    static const uint32_t BKP16R_RESET_VALUE = 0x0;


    static const uint32_t BKP17R_RESET_VALUE = 0x0;


    static const uint32_t BKP18R_RESET_VALUE = 0x0;


    static const uint32_t BKP19R_RESET_VALUE = 0x0;


    static const uint32_t BKP20R_RESET_VALUE = 0x0;


    static const uint32_t BKP21R_RESET_VALUE = 0x0;


    static const uint32_t BKP22R_RESET_VALUE = 0x0;


    static const uint32_t BKP23R_RESET_VALUE = 0x0;


    static const uint32_t BKP24R_RESET_VALUE = 0x0;


    static const uint32_t BKP25R_RESET_VALUE = 0x0;


    static const uint32_t BKP26R_RESET_VALUE = 0x0;


    static const uint32_t BKP27R_RESET_VALUE = 0x0;


    static const uint32_t BKP28R_RESET_VALUE = 0x0;


    static const uint32_t BKP29R_RESET_VALUE = 0x0;


    static const uint32_t BKP30R_RESET_VALUE = 0x0;


    static const uint32_t BKP31R_RESET_VALUE = 0x0;

    static constexpr uint8_t RTC_WKUP = 3; // RTC Tamper or TimeStamp /CSS on LSE through EXTI line 19 interrupts
};

static rtc_t& RTC = *reinterpret_cast<rtc_t*>(0x40002800);

#define HAVE_PERIPHERAL_RTC


////
//
//    Universal synchronous asynchronous receiver transmitter
//
////

struct usart6_t
{
    volatile uint32_t    CR1;                  // [Read-write] Control register 1
    volatile uint32_t    CR2;                  // [Read-write] Control register 2
    volatile uint32_t    CR3;                  // [Read-write] Control register 3
    volatile uint32_t    BRR;                  // [Read-write] Baud rate register
    volatile uint32_t    GTPR;                 // [Read-write] Guard time and prescaler register
    volatile uint32_t    RTOR;                 // [Read-write] Receiver timeout register
    volatile uint32_t    RQR;                  // [Write-only] Request register
    volatile uint32_t    ISR;                  // [Read-only] Interrupt &amp; status register
    volatile uint32_t    ICR;                  // [Write-only] Interrupt flag clear register
    volatile uint32_t    RDR;                  // [Read-only] Receive data register
    volatile uint32_t    TDR;                  // [Read-write] Transmit data register

    static constexpr uint32_t CR1_M1 = 0x10000000;      // Word length
    static constexpr uint32_t CR1_EOBIE = 0x8000000;    // End of Block interrupt enable
    static constexpr uint32_t CR1_RTOIE = 0x4000000;    // Receiver timeout interrupt enable
    static constexpr uint32_t CR1_DEAT4 = 0x2000000;    // Driver Enable assertion time
    static constexpr uint32_t CR1_DEAT3 = 0x1000000;    // DEAT3
    static constexpr uint32_t CR1_DEAT2 = 0x800000;     // DEAT2
    static constexpr uint32_t CR1_DEAT1 = 0x400000;     // DEAT1
    static constexpr uint32_t CR1_DEAT0 = 0x200000;     // DEAT0
    static constexpr uint32_t CR1_DEDT4 = 0x100000;     // Driver Enable de-assertion time
    static constexpr uint32_t CR1_DEDT3 = 0x80000;      // DEDT3
    static constexpr uint32_t CR1_DEDT2 = 0x40000;      // DEDT2
    static constexpr uint32_t CR1_DEDT1 = 0x20000;      // DEDT1
    static constexpr uint32_t CR1_DEDT0 = 0x10000;      // DEDT0
    static constexpr uint32_t CR1_OVER8 = 0x8000;       // Oversampling mode
    static constexpr uint32_t CR1_CMIE = 0x4000;        // Character match interrupt enable
    static constexpr uint32_t CR1_MME = 0x2000;         // Mute mode enable
    static constexpr uint32_t CR1_M0 = 0x1000;          // Word length
    static constexpr uint32_t CR1_WAKE = 0x800;         // Receiver wakeup method
    static constexpr uint32_t CR1_PCE = 0x400;          // Parity control enable
    static constexpr uint32_t CR1_PS = 0x200;           // Parity selection
    static constexpr uint32_t CR1_PEIE = 0x100;         // PE interrupt enable
    static constexpr uint32_t CR1_TXEIE = 0x80;         // interrupt enable
    static constexpr uint32_t CR1_TCIE = 0x40;          // Transmission complete interrupt enable
    static constexpr uint32_t CR1_RXNEIE = 0x20;        // RXNE interrupt enable
    static constexpr uint32_t CR1_IDLEIE = 0x10;        // IDLE interrupt enable
    static constexpr uint32_t CR1_TE = 0x8;             // Transmitter enable
    static constexpr uint32_t CR1_RE = 0x4;             // Receiver enable
    static constexpr uint32_t CR1_UESM = 0x2;           // USART enable in Stop mode
    static constexpr uint32_t CR1_UE = 0x1;             // USART enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CR2_ADD4_7 =              // Address of the USART node (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR2_ADD0_3 =              // Address of the USART node (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    static constexpr uint32_t CR2_RTOEN = 0x800000;     // Receiver timeout enable
    static constexpr uint32_t CR2_ABRMOD1 = 0x400000;   // Auto baud rate mode
    static constexpr uint32_t CR2_ABRMOD0 = 0x200000;   // ABRMOD0
    static constexpr uint32_t CR2_ABREN = 0x100000;     // Auto baud rate enable
    static constexpr uint32_t CR2_MSBFIRST = 0x80000;   // Most significant bit first
    static constexpr uint32_t CR2_TAINV = 0x40000;      // Binary data inversion
    static constexpr uint32_t CR2_TXINV = 0x20000;      // TX pin active level inversion
    static constexpr uint32_t CR2_RXINV = 0x10000;      // RX pin active level inversion
    static constexpr uint32_t CR2_SWAP = 0x8000;        // Swap TX/RX pins
    static constexpr uint32_t CR2_LINEN = 0x4000;       // LIN mode enable
    template<uint32_t X>
    static constexpr uint32_t CR2_STOP =                // STOP bits (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    static constexpr uint32_t CR2_CLKEN = 0x800;        // Clock enable
    static constexpr uint32_t CR2_CPOL = 0x400;         // Clock polarity
    static constexpr uint32_t CR2_CPHA = 0x200;         // Clock phase
    static constexpr uint32_t CR2_LBCL = 0x100;         // Last bit clock pulse
    static constexpr uint32_t CR2_LBDIE = 0x40;         // LIN break detection interrupt enable
    static constexpr uint32_t CR2_LBDL = 0x20;          // LIN break detection length
    static constexpr uint32_t CR2_ADDM7 = 0x10;         // 7-bit Address Detection/4-bit Address Detection
    static const uint32_t CR2_RESET_VALUE = 0x0;

    static constexpr uint32_t CR3_WUFIE = 0x400000;     // Wakeup from Stop mode interrupt enable
    template<uint32_t X>
    static constexpr uint32_t CR3_WUS =                 // Wakeup from Stop mode interrupt flag selection (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR3_SCARCNT =             // Smartcard auto-retry count (3 bits)
        bit_field_t<17, 0x7>::value<X>();
    static constexpr uint32_t CR3_DEP = 0x8000;         // Driver enable polarity selection
    static constexpr uint32_t CR3_DEM = 0x4000;         // Driver enable mode
    static constexpr uint32_t CR3_DDRE = 0x2000;        // DMA Disable on Reception Error
    static constexpr uint32_t CR3_OVRDIS = 0x1000;      // Overrun Disable
    static constexpr uint32_t CR3_ONEBIT = 0x800;       // One sample bit method enable
    static constexpr uint32_t CR3_CTSIE = 0x400;        // CTS interrupt enable
    static constexpr uint32_t CR3_CTSE = 0x200;         // CTS enable
    static constexpr uint32_t CR3_RTSE = 0x100;         // RTS enable
    static constexpr uint32_t CR3_DMAT = 0x80;          // DMA enable transmitter
    static constexpr uint32_t CR3_DMAR = 0x40;          // DMA enable receiver
    static constexpr uint32_t CR3_SCEN = 0x20;          // Smartcard mode enable
    static constexpr uint32_t CR3_NACK = 0x10;          // Smartcard NACK enable
    static constexpr uint32_t CR3_HDSEL = 0x8;          // Half-duplex selection
    static constexpr uint32_t CR3_IRLP = 0x4;           // Ir low-power
    static constexpr uint32_t CR3_IREN = 0x2;           // Ir mode enable
    static constexpr uint32_t CR3_EIE = 0x1;            // Error interrupt enable
    static const uint32_t CR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BRR_DIV_Mantissa =        // DIV_Mantissa (12 bits)
        bit_field_t<4, 0xfff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BRR_DIV_Fraction =        // DIV_Fraction (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t BRR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t GTPR_GT =                  // Guard time value (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GTPR_PSC =                 // Prescaler value (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t GTPR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RTOR_BLEN =                // Block Length (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RTOR_RTO =                 // Receiver timeout value (24 bits)
        bit_field_t<0, 0xffffff>::value<X>();
    static const uint32_t RTOR_RESET_VALUE = 0x0;

    static constexpr uint32_t RQR_TXFRQ = 0x10;         // Transmit data flush request
    static constexpr uint32_t RQR_RXFRQ = 0x8;          // Receive data flush request
    static constexpr uint32_t RQR_MMRQ = 0x4;           // Mute mode request
    static constexpr uint32_t RQR_SBKRQ = 0x2;          // Send break request
    static constexpr uint32_t RQR_ABRRQ = 0x1;          // Auto baud rate request
    static const uint32_t RQR_RESET_VALUE = 0x0;

    static constexpr uint32_t ISR_REACK = 0x400000;     // REACK
    static constexpr uint32_t ISR_TEACK = 0x200000;     // TEACK
    static constexpr uint32_t ISR_WUF = 0x100000;       // WUF
    static constexpr uint32_t ISR_RWU = 0x80000;        // RWU
    static constexpr uint32_t ISR_SBKF = 0x40000;       // SBKF
    static constexpr uint32_t ISR_CMF = 0x20000;        // CMF
    static constexpr uint32_t ISR_BUSY = 0x10000;       // BUSY
    static constexpr uint32_t ISR_ABRF = 0x8000;        // ABRF
    static constexpr uint32_t ISR_ABRE = 0x4000;        // ABRE
    static constexpr uint32_t ISR_EOBF = 0x1000;        // EOBF
    static constexpr uint32_t ISR_RTOF = 0x800;         // RTOF
    static constexpr uint32_t ISR_CTS = 0x400;          // CTS
    static constexpr uint32_t ISR_CTSIF = 0x200;        // CTSIF
    static constexpr uint32_t ISR_LBDF = 0x100;         // LBDF
    static constexpr uint32_t ISR_TXE = 0x80;           // TXE
    static constexpr uint32_t ISR_TC = 0x40;            // TC
    static constexpr uint32_t ISR_RXNE = 0x20;          // RXNE
    static constexpr uint32_t ISR_IDLE = 0x10;          // IDLE
    static constexpr uint32_t ISR_ORE = 0x8;            // ORE
    static constexpr uint32_t ISR_NF = 0x4;             // NF
    static constexpr uint32_t ISR_FE = 0x2;             // FE
    static constexpr uint32_t ISR_PE = 0x1;             // PE
    static const uint32_t ISR_RESET_VALUE = 0xc0;

    static constexpr uint32_t ICR_WUCF = 0x100000;      // Wakeup from Stop mode clear flag
    static constexpr uint32_t ICR_CMCF = 0x20000;       // Character match clear flag
    static constexpr uint32_t ICR_EOBCF = 0x1000;       // End of block clear flag
    static constexpr uint32_t ICR_RTOCF = 0x800;        // Receiver timeout clear flag
    static constexpr uint32_t ICR_CTSCF = 0x200;        // CTS clear flag
    static constexpr uint32_t ICR_LBDCF = 0x100;        // LIN break detection clear flag
    static constexpr uint32_t ICR_TCCF = 0x40;          // Transmission complete clear flag
    static constexpr uint32_t ICR_IDLECF = 0x10;        // Idle line detected clear flag
    static constexpr uint32_t ICR_ORECF = 0x8;          // Overrun error clear flag
    static constexpr uint32_t ICR_NCF = 0x4;            // Noise detected clear flag
    static constexpr uint32_t ICR_FECF = 0x2;           // Framing error clear flag
    static constexpr uint32_t ICR_PECF = 0x1;           // Parity error clear flag
    static const uint32_t ICR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RDR_RDR =                 // Receive data value (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static const uint32_t RDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDR_TDR =                 // Transmit data value (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static const uint32_t TDR_RESET_VALUE = 0x0;

    static constexpr uint8_t USART6 = 71; // USART6 global interrupt
};

static usart6_t& USART6 = *reinterpret_cast<usart6_t*>(0x40011400);

#define HAVE_PERIPHERAL_USART6


////
//
//    Universal synchronous asynchronous receiver transmitter
//
////

struct usart1_t
{
    volatile uint32_t    CR1;                  // [Read-write] Control register 1
    volatile uint32_t    CR2;                  // [Read-write] Control register 2
    volatile uint32_t    CR3;                  // [Read-write] Control register 3
    volatile uint32_t    BRR;                  // [Read-write] Baud rate register
    volatile uint32_t    GTPR;                 // [Read-write] Guard time and prescaler register
    volatile uint32_t    RTOR;                 // [Read-write] Receiver timeout register
    volatile uint32_t    RQR;                  // [Write-only] Request register
    volatile uint32_t    ISR;                  // [Read-only] Interrupt &amp; status register
    volatile uint32_t    ICR;                  // [Write-only] Interrupt flag clear register
    volatile uint32_t    RDR;                  // [Read-only] Receive data register
    volatile uint32_t    TDR;                  // [Read-write] Transmit data register

    static constexpr uint32_t CR1_M1 = 0x10000000;      // Word length
    static constexpr uint32_t CR1_EOBIE = 0x8000000;    // End of Block interrupt enable
    static constexpr uint32_t CR1_RTOIE = 0x4000000;    // Receiver timeout interrupt enable
    static constexpr uint32_t CR1_DEAT4 = 0x2000000;    // Driver Enable assertion time
    static constexpr uint32_t CR1_DEAT3 = 0x1000000;    // DEAT3
    static constexpr uint32_t CR1_DEAT2 = 0x800000;     // DEAT2
    static constexpr uint32_t CR1_DEAT1 = 0x400000;     // DEAT1
    static constexpr uint32_t CR1_DEAT0 = 0x200000;     // DEAT0
    static constexpr uint32_t CR1_DEDT4 = 0x100000;     // Driver Enable de-assertion time
    static constexpr uint32_t CR1_DEDT3 = 0x80000;      // DEDT3
    static constexpr uint32_t CR1_DEDT2 = 0x40000;      // DEDT2
    static constexpr uint32_t CR1_DEDT1 = 0x20000;      // DEDT1
    static constexpr uint32_t CR1_DEDT0 = 0x10000;      // DEDT0
    static constexpr uint32_t CR1_OVER8 = 0x8000;       // Oversampling mode
    static constexpr uint32_t CR1_CMIE = 0x4000;        // Character match interrupt enable
    static constexpr uint32_t CR1_MME = 0x2000;         // Mute mode enable
    static constexpr uint32_t CR1_M0 = 0x1000;          // Word length
    static constexpr uint32_t CR1_WAKE = 0x800;         // Receiver wakeup method
    static constexpr uint32_t CR1_PCE = 0x400;          // Parity control enable
    static constexpr uint32_t CR1_PS = 0x200;           // Parity selection
    static constexpr uint32_t CR1_PEIE = 0x100;         // PE interrupt enable
    static constexpr uint32_t CR1_TXEIE = 0x80;         // interrupt enable
    static constexpr uint32_t CR1_TCIE = 0x40;          // Transmission complete interrupt enable
    static constexpr uint32_t CR1_RXNEIE = 0x20;        // RXNE interrupt enable
    static constexpr uint32_t CR1_IDLEIE = 0x10;        // IDLE interrupt enable
    static constexpr uint32_t CR1_TE = 0x8;             // Transmitter enable
    static constexpr uint32_t CR1_RE = 0x4;             // Receiver enable
    static constexpr uint32_t CR1_UESM = 0x2;           // USART enable in Stop mode
    static constexpr uint32_t CR1_UE = 0x1;             // USART enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CR2_ADD4_7 =              // Address of the USART node (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR2_ADD0_3 =              // Address of the USART node (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    static constexpr uint32_t CR2_RTOEN = 0x800000;     // Receiver timeout enable
    static constexpr uint32_t CR2_ABRMOD1 = 0x400000;   // Auto baud rate mode
    static constexpr uint32_t CR2_ABRMOD0 = 0x200000;   // ABRMOD0
    static constexpr uint32_t CR2_ABREN = 0x100000;     // Auto baud rate enable
    static constexpr uint32_t CR2_MSBFIRST = 0x80000;   // Most significant bit first
    static constexpr uint32_t CR2_TAINV = 0x40000;      // Binary data inversion
    static constexpr uint32_t CR2_TXINV = 0x20000;      // TX pin active level inversion
    static constexpr uint32_t CR2_RXINV = 0x10000;      // RX pin active level inversion
    static constexpr uint32_t CR2_SWAP = 0x8000;        // Swap TX/RX pins
    static constexpr uint32_t CR2_LINEN = 0x4000;       // LIN mode enable
    template<uint32_t X>
    static constexpr uint32_t CR2_STOP =                // STOP bits (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    static constexpr uint32_t CR2_CLKEN = 0x800;        // Clock enable
    static constexpr uint32_t CR2_CPOL = 0x400;         // Clock polarity
    static constexpr uint32_t CR2_CPHA = 0x200;         // Clock phase
    static constexpr uint32_t CR2_LBCL = 0x100;         // Last bit clock pulse
    static constexpr uint32_t CR2_LBDIE = 0x40;         // LIN break detection interrupt enable
    static constexpr uint32_t CR2_LBDL = 0x20;          // LIN break detection length
    static constexpr uint32_t CR2_ADDM7 = 0x10;         // 7-bit Address Detection/4-bit Address Detection
    static const uint32_t CR2_RESET_VALUE = 0x0;

    static constexpr uint32_t CR3_WUFIE = 0x400000;     // Wakeup from Stop mode interrupt enable
    template<uint32_t X>
    static constexpr uint32_t CR3_WUS =                 // Wakeup from Stop mode interrupt flag selection (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR3_SCARCNT =             // Smartcard auto-retry count (3 bits)
        bit_field_t<17, 0x7>::value<X>();
    static constexpr uint32_t CR3_DEP = 0x8000;         // Driver enable polarity selection
    static constexpr uint32_t CR3_DEM = 0x4000;         // Driver enable mode
    static constexpr uint32_t CR3_DDRE = 0x2000;        // DMA Disable on Reception Error
    static constexpr uint32_t CR3_OVRDIS = 0x1000;      // Overrun Disable
    static constexpr uint32_t CR3_ONEBIT = 0x800;       // One sample bit method enable
    static constexpr uint32_t CR3_CTSIE = 0x400;        // CTS interrupt enable
    static constexpr uint32_t CR3_CTSE = 0x200;         // CTS enable
    static constexpr uint32_t CR3_RTSE = 0x100;         // RTS enable
    static constexpr uint32_t CR3_DMAT = 0x80;          // DMA enable transmitter
    static constexpr uint32_t CR3_DMAR = 0x40;          // DMA enable receiver
    static constexpr uint32_t CR3_SCEN = 0x20;          // Smartcard mode enable
    static constexpr uint32_t CR3_NACK = 0x10;          // Smartcard NACK enable
    static constexpr uint32_t CR3_HDSEL = 0x8;          // Half-duplex selection
    static constexpr uint32_t CR3_IRLP = 0x4;           // Ir low-power
    static constexpr uint32_t CR3_IREN = 0x2;           // Ir mode enable
    static constexpr uint32_t CR3_EIE = 0x1;            // Error interrupt enable
    static const uint32_t CR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BRR_DIV_Mantissa =        // DIV_Mantissa (12 bits)
        bit_field_t<4, 0xfff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BRR_DIV_Fraction =        // DIV_Fraction (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t BRR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t GTPR_GT =                  // Guard time value (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GTPR_PSC =                 // Prescaler value (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t GTPR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RTOR_BLEN =                // Block Length (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RTOR_RTO =                 // Receiver timeout value (24 bits)
        bit_field_t<0, 0xffffff>::value<X>();
    static const uint32_t RTOR_RESET_VALUE = 0x0;

    static constexpr uint32_t RQR_TXFRQ = 0x10;         // Transmit data flush request
    static constexpr uint32_t RQR_RXFRQ = 0x8;          // Receive data flush request
    static constexpr uint32_t RQR_MMRQ = 0x4;           // Mute mode request
    static constexpr uint32_t RQR_SBKRQ = 0x2;          // Send break request
    static constexpr uint32_t RQR_ABRRQ = 0x1;          // Auto baud rate request
    static const uint32_t RQR_RESET_VALUE = 0x0;

    static constexpr uint32_t ISR_REACK = 0x400000;     // REACK
    static constexpr uint32_t ISR_TEACK = 0x200000;     // TEACK
    static constexpr uint32_t ISR_WUF = 0x100000;       // WUF
    static constexpr uint32_t ISR_RWU = 0x80000;        // RWU
    static constexpr uint32_t ISR_SBKF = 0x40000;       // SBKF
    static constexpr uint32_t ISR_CMF = 0x20000;        // CMF
    static constexpr uint32_t ISR_BUSY = 0x10000;       // BUSY
    static constexpr uint32_t ISR_ABRF = 0x8000;        // ABRF
    static constexpr uint32_t ISR_ABRE = 0x4000;        // ABRE
    static constexpr uint32_t ISR_EOBF = 0x1000;        // EOBF
    static constexpr uint32_t ISR_RTOF = 0x800;         // RTOF
    static constexpr uint32_t ISR_CTS = 0x400;          // CTS
    static constexpr uint32_t ISR_CTSIF = 0x200;        // CTSIF
    static constexpr uint32_t ISR_LBDF = 0x100;         // LBDF
    static constexpr uint32_t ISR_TXE = 0x80;           // TXE
    static constexpr uint32_t ISR_TC = 0x40;            // TC
    static constexpr uint32_t ISR_RXNE = 0x20;          // RXNE
    static constexpr uint32_t ISR_IDLE = 0x10;          // IDLE
    static constexpr uint32_t ISR_ORE = 0x8;            // ORE
    static constexpr uint32_t ISR_NF = 0x4;             // NF
    static constexpr uint32_t ISR_FE = 0x2;             // FE
    static constexpr uint32_t ISR_PE = 0x1;             // PE
    static const uint32_t ISR_RESET_VALUE = 0xc0;

    static constexpr uint32_t ICR_WUCF = 0x100000;      // Wakeup from Stop mode clear flag
    static constexpr uint32_t ICR_CMCF = 0x20000;       // Character match clear flag
    static constexpr uint32_t ICR_EOBCF = 0x1000;       // End of block clear flag
    static constexpr uint32_t ICR_RTOCF = 0x800;        // Receiver timeout clear flag
    static constexpr uint32_t ICR_CTSCF = 0x200;        // CTS clear flag
    static constexpr uint32_t ICR_LBDCF = 0x100;        // LIN break detection clear flag
    static constexpr uint32_t ICR_TCCF = 0x40;          // Transmission complete clear flag
    static constexpr uint32_t ICR_IDLECF = 0x10;        // Idle line detected clear flag
    static constexpr uint32_t ICR_ORECF = 0x8;          // Overrun error clear flag
    static constexpr uint32_t ICR_NCF = 0x4;            // Noise detected clear flag
    static constexpr uint32_t ICR_FECF = 0x2;           // Framing error clear flag
    static constexpr uint32_t ICR_PECF = 0x1;           // Parity error clear flag
    static const uint32_t ICR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RDR_RDR =                 // Receive data value (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static const uint32_t RDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDR_TDR =                 // Transmit data value (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static const uint32_t TDR_RESET_VALUE = 0x0;

    static constexpr uint8_t USART1 = 37; // USART1 global interrupt
};

static usart1_t& USART1 = *reinterpret_cast<usart1_t*>(0x40011000);

#define HAVE_PERIPHERAL_USART1


////
//
//    Universal synchronous asynchronous receiver transmitter
//
////

struct usart3_t
{
    volatile uint32_t    CR1;                  // [Read-write] Control register 1
    volatile uint32_t    CR2;                  // [Read-write] Control register 2
    volatile uint32_t    CR3;                  // [Read-write] Control register 3
    volatile uint32_t    BRR;                  // [Read-write] Baud rate register
    volatile uint32_t    GTPR;                 // [Read-write] Guard time and prescaler register
    volatile uint32_t    RTOR;                 // [Read-write] Receiver timeout register
    volatile uint32_t    RQR;                  // [Write-only] Request register
    volatile uint32_t    ISR;                  // [Read-only] Interrupt &amp; status register
    volatile uint32_t    ICR;                  // [Write-only] Interrupt flag clear register
    volatile uint32_t    RDR;                  // [Read-only] Receive data register
    volatile uint32_t    TDR;                  // [Read-write] Transmit data register

    static constexpr uint32_t CR1_M1 = 0x10000000;      // Word length
    static constexpr uint32_t CR1_EOBIE = 0x8000000;    // End of Block interrupt enable
    static constexpr uint32_t CR1_RTOIE = 0x4000000;    // Receiver timeout interrupt enable
    static constexpr uint32_t CR1_DEAT4 = 0x2000000;    // Driver Enable assertion time
    static constexpr uint32_t CR1_DEAT3 = 0x1000000;    // DEAT3
    static constexpr uint32_t CR1_DEAT2 = 0x800000;     // DEAT2
    static constexpr uint32_t CR1_DEAT1 = 0x400000;     // DEAT1
    static constexpr uint32_t CR1_DEAT0 = 0x200000;     // DEAT0
    static constexpr uint32_t CR1_DEDT4 = 0x100000;     // Driver Enable de-assertion time
    static constexpr uint32_t CR1_DEDT3 = 0x80000;      // DEDT3
    static constexpr uint32_t CR1_DEDT2 = 0x40000;      // DEDT2
    static constexpr uint32_t CR1_DEDT1 = 0x20000;      // DEDT1
    static constexpr uint32_t CR1_DEDT0 = 0x10000;      // DEDT0
    static constexpr uint32_t CR1_OVER8 = 0x8000;       // Oversampling mode
    static constexpr uint32_t CR1_CMIE = 0x4000;        // Character match interrupt enable
    static constexpr uint32_t CR1_MME = 0x2000;         // Mute mode enable
    static constexpr uint32_t CR1_M0 = 0x1000;          // Word length
    static constexpr uint32_t CR1_WAKE = 0x800;         // Receiver wakeup method
    static constexpr uint32_t CR1_PCE = 0x400;          // Parity control enable
    static constexpr uint32_t CR1_PS = 0x200;           // Parity selection
    static constexpr uint32_t CR1_PEIE = 0x100;         // PE interrupt enable
    static constexpr uint32_t CR1_TXEIE = 0x80;         // interrupt enable
    static constexpr uint32_t CR1_TCIE = 0x40;          // Transmission complete interrupt enable
    static constexpr uint32_t CR1_RXNEIE = 0x20;        // RXNE interrupt enable
    static constexpr uint32_t CR1_IDLEIE = 0x10;        // IDLE interrupt enable
    static constexpr uint32_t CR1_TE = 0x8;             // Transmitter enable
    static constexpr uint32_t CR1_RE = 0x4;             // Receiver enable
    static constexpr uint32_t CR1_UESM = 0x2;           // USART enable in Stop mode
    static constexpr uint32_t CR1_UE = 0x1;             // USART enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CR2_ADD4_7 =              // Address of the USART node (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR2_ADD0_3 =              // Address of the USART node (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    static constexpr uint32_t CR2_RTOEN = 0x800000;     // Receiver timeout enable
    static constexpr uint32_t CR2_ABRMOD1 = 0x400000;   // Auto baud rate mode
    static constexpr uint32_t CR2_ABRMOD0 = 0x200000;   // ABRMOD0
    static constexpr uint32_t CR2_ABREN = 0x100000;     // Auto baud rate enable
    static constexpr uint32_t CR2_MSBFIRST = 0x80000;   // Most significant bit first
    static constexpr uint32_t CR2_TAINV = 0x40000;      // Binary data inversion
    static constexpr uint32_t CR2_TXINV = 0x20000;      // TX pin active level inversion
    static constexpr uint32_t CR2_RXINV = 0x10000;      // RX pin active level inversion
    static constexpr uint32_t CR2_SWAP = 0x8000;        // Swap TX/RX pins
    static constexpr uint32_t CR2_LINEN = 0x4000;       // LIN mode enable
    template<uint32_t X>
    static constexpr uint32_t CR2_STOP =                // STOP bits (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    static constexpr uint32_t CR2_CLKEN = 0x800;        // Clock enable
    static constexpr uint32_t CR2_CPOL = 0x400;         // Clock polarity
    static constexpr uint32_t CR2_CPHA = 0x200;         // Clock phase
    static constexpr uint32_t CR2_LBCL = 0x100;         // Last bit clock pulse
    static constexpr uint32_t CR2_LBDIE = 0x40;         // LIN break detection interrupt enable
    static constexpr uint32_t CR2_LBDL = 0x20;          // LIN break detection length
    static constexpr uint32_t CR2_ADDM7 = 0x10;         // 7-bit Address Detection/4-bit Address Detection
    static const uint32_t CR2_RESET_VALUE = 0x0;

    static constexpr uint32_t CR3_WUFIE = 0x400000;     // Wakeup from Stop mode interrupt enable
    template<uint32_t X>
    static constexpr uint32_t CR3_WUS =                 // Wakeup from Stop mode interrupt flag selection (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR3_SCARCNT =             // Smartcard auto-retry count (3 bits)
        bit_field_t<17, 0x7>::value<X>();
    static constexpr uint32_t CR3_DEP = 0x8000;         // Driver enable polarity selection
    static constexpr uint32_t CR3_DEM = 0x4000;         // Driver enable mode
    static constexpr uint32_t CR3_DDRE = 0x2000;        // DMA Disable on Reception Error
    static constexpr uint32_t CR3_OVRDIS = 0x1000;      // Overrun Disable
    static constexpr uint32_t CR3_ONEBIT = 0x800;       // One sample bit method enable
    static constexpr uint32_t CR3_CTSIE = 0x400;        // CTS interrupt enable
    static constexpr uint32_t CR3_CTSE = 0x200;         // CTS enable
    static constexpr uint32_t CR3_RTSE = 0x100;         // RTS enable
    static constexpr uint32_t CR3_DMAT = 0x80;          // DMA enable transmitter
    static constexpr uint32_t CR3_DMAR = 0x40;          // DMA enable receiver
    static constexpr uint32_t CR3_SCEN = 0x20;          // Smartcard mode enable
    static constexpr uint32_t CR3_NACK = 0x10;          // Smartcard NACK enable
    static constexpr uint32_t CR3_HDSEL = 0x8;          // Half-duplex selection
    static constexpr uint32_t CR3_IRLP = 0x4;           // Ir low-power
    static constexpr uint32_t CR3_IREN = 0x2;           // Ir mode enable
    static constexpr uint32_t CR3_EIE = 0x1;            // Error interrupt enable
    static const uint32_t CR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BRR_DIV_Mantissa =        // DIV_Mantissa (12 bits)
        bit_field_t<4, 0xfff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BRR_DIV_Fraction =        // DIV_Fraction (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t BRR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t GTPR_GT =                  // Guard time value (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GTPR_PSC =                 // Prescaler value (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t GTPR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RTOR_BLEN =                // Block Length (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RTOR_RTO =                 // Receiver timeout value (24 bits)
        bit_field_t<0, 0xffffff>::value<X>();
    static const uint32_t RTOR_RESET_VALUE = 0x0;

    static constexpr uint32_t RQR_TXFRQ = 0x10;         // Transmit data flush request
    static constexpr uint32_t RQR_RXFRQ = 0x8;          // Receive data flush request
    static constexpr uint32_t RQR_MMRQ = 0x4;           // Mute mode request
    static constexpr uint32_t RQR_SBKRQ = 0x2;          // Send break request
    static constexpr uint32_t RQR_ABRRQ = 0x1;          // Auto baud rate request
    static const uint32_t RQR_RESET_VALUE = 0x0;

    static constexpr uint32_t ISR_REACK = 0x400000;     // REACK
    static constexpr uint32_t ISR_TEACK = 0x200000;     // TEACK
    static constexpr uint32_t ISR_WUF = 0x100000;       // WUF
    static constexpr uint32_t ISR_RWU = 0x80000;        // RWU
    static constexpr uint32_t ISR_SBKF = 0x40000;       // SBKF
    static constexpr uint32_t ISR_CMF = 0x20000;        // CMF
    static constexpr uint32_t ISR_BUSY = 0x10000;       // BUSY
    static constexpr uint32_t ISR_ABRF = 0x8000;        // ABRF
    static constexpr uint32_t ISR_ABRE = 0x4000;        // ABRE
    static constexpr uint32_t ISR_EOBF = 0x1000;        // EOBF
    static constexpr uint32_t ISR_RTOF = 0x800;         // RTOF
    static constexpr uint32_t ISR_CTS = 0x400;          // CTS
    static constexpr uint32_t ISR_CTSIF = 0x200;        // CTSIF
    static constexpr uint32_t ISR_LBDF = 0x100;         // LBDF
    static constexpr uint32_t ISR_TXE = 0x80;           // TXE
    static constexpr uint32_t ISR_TC = 0x40;            // TC
    static constexpr uint32_t ISR_RXNE = 0x20;          // RXNE
    static constexpr uint32_t ISR_IDLE = 0x10;          // IDLE
    static constexpr uint32_t ISR_ORE = 0x8;            // ORE
    static constexpr uint32_t ISR_NF = 0x4;             // NF
    static constexpr uint32_t ISR_FE = 0x2;             // FE
    static constexpr uint32_t ISR_PE = 0x1;             // PE
    static const uint32_t ISR_RESET_VALUE = 0xc0;

    static constexpr uint32_t ICR_WUCF = 0x100000;      // Wakeup from Stop mode clear flag
    static constexpr uint32_t ICR_CMCF = 0x20000;       // Character match clear flag
    static constexpr uint32_t ICR_EOBCF = 0x1000;       // End of block clear flag
    static constexpr uint32_t ICR_RTOCF = 0x800;        // Receiver timeout clear flag
    static constexpr uint32_t ICR_CTSCF = 0x200;        // CTS clear flag
    static constexpr uint32_t ICR_LBDCF = 0x100;        // LIN break detection clear flag
    static constexpr uint32_t ICR_TCCF = 0x40;          // Transmission complete clear flag
    static constexpr uint32_t ICR_IDLECF = 0x10;        // Idle line detected clear flag
    static constexpr uint32_t ICR_ORECF = 0x8;          // Overrun error clear flag
    static constexpr uint32_t ICR_NCF = 0x4;            // Noise detected clear flag
    static constexpr uint32_t ICR_FECF = 0x2;           // Framing error clear flag
    static constexpr uint32_t ICR_PECF = 0x1;           // Parity error clear flag
    static const uint32_t ICR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RDR_RDR =                 // Receive data value (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static const uint32_t RDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDR_TDR =                 // Transmit data value (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static const uint32_t TDR_RESET_VALUE = 0x0;

    static constexpr uint8_t USART3 = 39; // USART3 global interrupt
};

static usart3_t& USART3 = *reinterpret_cast<usart3_t*>(0x40004800);

#define HAVE_PERIPHERAL_USART3


////
//
//    Universal synchronous asynchronous receiver transmitter
//
////

struct usart2_t
{
    volatile uint32_t    CR1;                  // [Read-write] Control register 1
    volatile uint32_t    CR2;                  // [Read-write] Control register 2
    volatile uint32_t    CR3;                  // [Read-write] Control register 3
    volatile uint32_t    BRR;                  // [Read-write] Baud rate register
    volatile uint32_t    GTPR;                 // [Read-write] Guard time and prescaler register
    volatile uint32_t    RTOR;                 // [Read-write] Receiver timeout register
    volatile uint32_t    RQR;                  // [Write-only] Request register
    volatile uint32_t    ISR;                  // [Read-only] Interrupt &amp; status register
    volatile uint32_t    ICR;                  // [Write-only] Interrupt flag clear register
    volatile uint32_t    RDR;                  // [Read-only] Receive data register
    volatile uint32_t    TDR;                  // [Read-write] Transmit data register

    static constexpr uint32_t CR1_M1 = 0x10000000;      // Word length
    static constexpr uint32_t CR1_EOBIE = 0x8000000;    // End of Block interrupt enable
    static constexpr uint32_t CR1_RTOIE = 0x4000000;    // Receiver timeout interrupt enable
    static constexpr uint32_t CR1_DEAT4 = 0x2000000;    // Driver Enable assertion time
    static constexpr uint32_t CR1_DEAT3 = 0x1000000;    // DEAT3
    static constexpr uint32_t CR1_DEAT2 = 0x800000;     // DEAT2
    static constexpr uint32_t CR1_DEAT1 = 0x400000;     // DEAT1
    static constexpr uint32_t CR1_DEAT0 = 0x200000;     // DEAT0
    static constexpr uint32_t CR1_DEDT4 = 0x100000;     // Driver Enable de-assertion time
    static constexpr uint32_t CR1_DEDT3 = 0x80000;      // DEDT3
    static constexpr uint32_t CR1_DEDT2 = 0x40000;      // DEDT2
    static constexpr uint32_t CR1_DEDT1 = 0x20000;      // DEDT1
    static constexpr uint32_t CR1_DEDT0 = 0x10000;      // DEDT0
    static constexpr uint32_t CR1_OVER8 = 0x8000;       // Oversampling mode
    static constexpr uint32_t CR1_CMIE = 0x4000;        // Character match interrupt enable
    static constexpr uint32_t CR1_MME = 0x2000;         // Mute mode enable
    static constexpr uint32_t CR1_M0 = 0x1000;          // Word length
    static constexpr uint32_t CR1_WAKE = 0x800;         // Receiver wakeup method
    static constexpr uint32_t CR1_PCE = 0x400;          // Parity control enable
    static constexpr uint32_t CR1_PS = 0x200;           // Parity selection
    static constexpr uint32_t CR1_PEIE = 0x100;         // PE interrupt enable
    static constexpr uint32_t CR1_TXEIE = 0x80;         // interrupt enable
    static constexpr uint32_t CR1_TCIE = 0x40;          // Transmission complete interrupt enable
    static constexpr uint32_t CR1_RXNEIE = 0x20;        // RXNE interrupt enable
    static constexpr uint32_t CR1_IDLEIE = 0x10;        // IDLE interrupt enable
    static constexpr uint32_t CR1_TE = 0x8;             // Transmitter enable
    static constexpr uint32_t CR1_RE = 0x4;             // Receiver enable
    static constexpr uint32_t CR1_UESM = 0x2;           // USART enable in Stop mode
    static constexpr uint32_t CR1_UE = 0x1;             // USART enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CR2_ADD4_7 =              // Address of the USART node (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR2_ADD0_3 =              // Address of the USART node (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    static constexpr uint32_t CR2_RTOEN = 0x800000;     // Receiver timeout enable
    static constexpr uint32_t CR2_ABRMOD1 = 0x400000;   // Auto baud rate mode
    static constexpr uint32_t CR2_ABRMOD0 = 0x200000;   // ABRMOD0
    static constexpr uint32_t CR2_ABREN = 0x100000;     // Auto baud rate enable
    static constexpr uint32_t CR2_MSBFIRST = 0x80000;   // Most significant bit first
    static constexpr uint32_t CR2_TAINV = 0x40000;      // Binary data inversion
    static constexpr uint32_t CR2_TXINV = 0x20000;      // TX pin active level inversion
    static constexpr uint32_t CR2_RXINV = 0x10000;      // RX pin active level inversion
    static constexpr uint32_t CR2_SWAP = 0x8000;        // Swap TX/RX pins
    static constexpr uint32_t CR2_LINEN = 0x4000;       // LIN mode enable
    template<uint32_t X>
    static constexpr uint32_t CR2_STOP =                // STOP bits (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    static constexpr uint32_t CR2_CLKEN = 0x800;        // Clock enable
    static constexpr uint32_t CR2_CPOL = 0x400;         // Clock polarity
    static constexpr uint32_t CR2_CPHA = 0x200;         // Clock phase
    static constexpr uint32_t CR2_LBCL = 0x100;         // Last bit clock pulse
    static constexpr uint32_t CR2_LBDIE = 0x40;         // LIN break detection interrupt enable
    static constexpr uint32_t CR2_LBDL = 0x20;          // LIN break detection length
    static constexpr uint32_t CR2_ADDM7 = 0x10;         // 7-bit Address Detection/4-bit Address Detection
    static const uint32_t CR2_RESET_VALUE = 0x0;

    static constexpr uint32_t CR3_WUFIE = 0x400000;     // Wakeup from Stop mode interrupt enable
    template<uint32_t X>
    static constexpr uint32_t CR3_WUS =                 // Wakeup from Stop mode interrupt flag selection (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR3_SCARCNT =             // Smartcard auto-retry count (3 bits)
        bit_field_t<17, 0x7>::value<X>();
    static constexpr uint32_t CR3_DEP = 0x8000;         // Driver enable polarity selection
    static constexpr uint32_t CR3_DEM = 0x4000;         // Driver enable mode
    static constexpr uint32_t CR3_DDRE = 0x2000;        // DMA Disable on Reception Error
    static constexpr uint32_t CR3_OVRDIS = 0x1000;      // Overrun Disable
    static constexpr uint32_t CR3_ONEBIT = 0x800;       // One sample bit method enable
    static constexpr uint32_t CR3_CTSIE = 0x400;        // CTS interrupt enable
    static constexpr uint32_t CR3_CTSE = 0x200;         // CTS enable
    static constexpr uint32_t CR3_RTSE = 0x100;         // RTS enable
    static constexpr uint32_t CR3_DMAT = 0x80;          // DMA enable transmitter
    static constexpr uint32_t CR3_DMAR = 0x40;          // DMA enable receiver
    static constexpr uint32_t CR3_SCEN = 0x20;          // Smartcard mode enable
    static constexpr uint32_t CR3_NACK = 0x10;          // Smartcard NACK enable
    static constexpr uint32_t CR3_HDSEL = 0x8;          // Half-duplex selection
    static constexpr uint32_t CR3_IRLP = 0x4;           // Ir low-power
    static constexpr uint32_t CR3_IREN = 0x2;           // Ir mode enable
    static constexpr uint32_t CR3_EIE = 0x1;            // Error interrupt enable
    static const uint32_t CR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BRR_DIV_Mantissa =        // DIV_Mantissa (12 bits)
        bit_field_t<4, 0xfff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BRR_DIV_Fraction =        // DIV_Fraction (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t BRR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t GTPR_GT =                  // Guard time value (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GTPR_PSC =                 // Prescaler value (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t GTPR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RTOR_BLEN =                // Block Length (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RTOR_RTO =                 // Receiver timeout value (24 bits)
        bit_field_t<0, 0xffffff>::value<X>();
    static const uint32_t RTOR_RESET_VALUE = 0x0;

    static constexpr uint32_t RQR_TXFRQ = 0x10;         // Transmit data flush request
    static constexpr uint32_t RQR_RXFRQ = 0x8;          // Receive data flush request
    static constexpr uint32_t RQR_MMRQ = 0x4;           // Mute mode request
    static constexpr uint32_t RQR_SBKRQ = 0x2;          // Send break request
    static constexpr uint32_t RQR_ABRRQ = 0x1;          // Auto baud rate request
    static const uint32_t RQR_RESET_VALUE = 0x0;

    static constexpr uint32_t ISR_REACK = 0x400000;     // REACK
    static constexpr uint32_t ISR_TEACK = 0x200000;     // TEACK
    static constexpr uint32_t ISR_WUF = 0x100000;       // WUF
    static constexpr uint32_t ISR_RWU = 0x80000;        // RWU
    static constexpr uint32_t ISR_SBKF = 0x40000;       // SBKF
    static constexpr uint32_t ISR_CMF = 0x20000;        // CMF
    static constexpr uint32_t ISR_BUSY = 0x10000;       // BUSY
    static constexpr uint32_t ISR_ABRF = 0x8000;        // ABRF
    static constexpr uint32_t ISR_ABRE = 0x4000;        // ABRE
    static constexpr uint32_t ISR_EOBF = 0x1000;        // EOBF
    static constexpr uint32_t ISR_RTOF = 0x800;         // RTOF
    static constexpr uint32_t ISR_CTS = 0x400;          // CTS
    static constexpr uint32_t ISR_CTSIF = 0x200;        // CTSIF
    static constexpr uint32_t ISR_LBDF = 0x100;         // LBDF
    static constexpr uint32_t ISR_TXE = 0x80;           // TXE
    static constexpr uint32_t ISR_TC = 0x40;            // TC
    static constexpr uint32_t ISR_RXNE = 0x20;          // RXNE
    static constexpr uint32_t ISR_IDLE = 0x10;          // IDLE
    static constexpr uint32_t ISR_ORE = 0x8;            // ORE
    static constexpr uint32_t ISR_NF = 0x4;             // NF
    static constexpr uint32_t ISR_FE = 0x2;             // FE
    static constexpr uint32_t ISR_PE = 0x1;             // PE
    static const uint32_t ISR_RESET_VALUE = 0xc0;

    static constexpr uint32_t ICR_WUCF = 0x100000;      // Wakeup from Stop mode clear flag
    static constexpr uint32_t ICR_CMCF = 0x20000;       // Character match clear flag
    static constexpr uint32_t ICR_EOBCF = 0x1000;       // End of block clear flag
    static constexpr uint32_t ICR_RTOCF = 0x800;        // Receiver timeout clear flag
    static constexpr uint32_t ICR_CTSCF = 0x200;        // CTS clear flag
    static constexpr uint32_t ICR_LBDCF = 0x100;        // LIN break detection clear flag
    static constexpr uint32_t ICR_TCCF = 0x40;          // Transmission complete clear flag
    static constexpr uint32_t ICR_IDLECF = 0x10;        // Idle line detected clear flag
    static constexpr uint32_t ICR_ORECF = 0x8;          // Overrun error clear flag
    static constexpr uint32_t ICR_NCF = 0x4;            // Noise detected clear flag
    static constexpr uint32_t ICR_FECF = 0x2;           // Framing error clear flag
    static constexpr uint32_t ICR_PECF = 0x1;           // Parity error clear flag
    static const uint32_t ICR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RDR_RDR =                 // Receive data value (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static const uint32_t RDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDR_TDR =                 // Transmit data value (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static const uint32_t TDR_RESET_VALUE = 0x0;

    static constexpr uint8_t USART2 = 38; // USART2 global interrupt
};

static usart2_t& USART2 = *reinterpret_cast<usart2_t*>(0x40004400);

#define HAVE_PERIPHERAL_USART2


////
//
//    Universal synchronous asynchronous receiver transmitter
//
////

struct uart5_t
{
    volatile uint32_t    CR1;                  // [Read-write] Control register 1
    volatile uint32_t    CR2;                  // [Read-write] Control register 2
    volatile uint32_t    CR3;                  // [Read-write] Control register 3
    volatile uint32_t    BRR;                  // [Read-write] Baud rate register
    volatile uint32_t    GTPR;                 // [Read-write] Guard time and prescaler register
    volatile uint32_t    RTOR;                 // [Read-write] Receiver timeout register
    volatile uint32_t    RQR;                  // [Write-only] Request register
    volatile uint32_t    ISR;                  // [Read-only] Interrupt &amp; status register
    volatile uint32_t    ICR;                  // [Write-only] Interrupt flag clear register
    volatile uint32_t    RDR;                  // [Read-only] Receive data register
    volatile uint32_t    TDR;                  // [Read-write] Transmit data register

    static constexpr uint32_t CR1_M1 = 0x10000000;      // Word length
    static constexpr uint32_t CR1_EOBIE = 0x8000000;    // End of Block interrupt enable
    static constexpr uint32_t CR1_RTOIE = 0x4000000;    // Receiver timeout interrupt enable
    static constexpr uint32_t CR1_DEAT4 = 0x2000000;    // Driver Enable assertion time
    static constexpr uint32_t CR1_DEAT3 = 0x1000000;    // DEAT3
    static constexpr uint32_t CR1_DEAT2 = 0x800000;     // DEAT2
    static constexpr uint32_t CR1_DEAT1 = 0x400000;     // DEAT1
    static constexpr uint32_t CR1_DEAT0 = 0x200000;     // DEAT0
    static constexpr uint32_t CR1_DEDT4 = 0x100000;     // Driver Enable de-assertion time
    static constexpr uint32_t CR1_DEDT3 = 0x80000;      // DEDT3
    static constexpr uint32_t CR1_DEDT2 = 0x40000;      // DEDT2
    static constexpr uint32_t CR1_DEDT1 = 0x20000;      // DEDT1
    static constexpr uint32_t CR1_DEDT0 = 0x10000;      // DEDT0
    static constexpr uint32_t CR1_OVER8 = 0x8000;       // Oversampling mode
    static constexpr uint32_t CR1_CMIE = 0x4000;        // Character match interrupt enable
    static constexpr uint32_t CR1_MME = 0x2000;         // Mute mode enable
    static constexpr uint32_t CR1_M0 = 0x1000;          // Word length
    static constexpr uint32_t CR1_WAKE = 0x800;         // Receiver wakeup method
    static constexpr uint32_t CR1_PCE = 0x400;          // Parity control enable
    static constexpr uint32_t CR1_PS = 0x200;           // Parity selection
    static constexpr uint32_t CR1_PEIE = 0x100;         // PE interrupt enable
    static constexpr uint32_t CR1_TXEIE = 0x80;         // interrupt enable
    static constexpr uint32_t CR1_TCIE = 0x40;          // Transmission complete interrupt enable
    static constexpr uint32_t CR1_RXNEIE = 0x20;        // RXNE interrupt enable
    static constexpr uint32_t CR1_IDLEIE = 0x10;        // IDLE interrupt enable
    static constexpr uint32_t CR1_TE = 0x8;             // Transmitter enable
    static constexpr uint32_t CR1_RE = 0x4;             // Receiver enable
    static constexpr uint32_t CR1_UESM = 0x2;           // USART enable in Stop mode
    static constexpr uint32_t CR1_UE = 0x1;             // USART enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CR2_ADD4_7 =              // Address of the USART node (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR2_ADD0_3 =              // Address of the USART node (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    static constexpr uint32_t CR2_RTOEN = 0x800000;     // Receiver timeout enable
    static constexpr uint32_t CR2_ABRMOD1 = 0x400000;   // Auto baud rate mode
    static constexpr uint32_t CR2_ABRMOD0 = 0x200000;   // ABRMOD0
    static constexpr uint32_t CR2_ABREN = 0x100000;     // Auto baud rate enable
    static constexpr uint32_t CR2_MSBFIRST = 0x80000;   // Most significant bit first
    static constexpr uint32_t CR2_TAINV = 0x40000;      // Binary data inversion
    static constexpr uint32_t CR2_TXINV = 0x20000;      // TX pin active level inversion
    static constexpr uint32_t CR2_RXINV = 0x10000;      // RX pin active level inversion
    static constexpr uint32_t CR2_SWAP = 0x8000;        // Swap TX/RX pins
    static constexpr uint32_t CR2_LINEN = 0x4000;       // LIN mode enable
    template<uint32_t X>
    static constexpr uint32_t CR2_STOP =                // STOP bits (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    static constexpr uint32_t CR2_CLKEN = 0x800;        // Clock enable
    static constexpr uint32_t CR2_CPOL = 0x400;         // Clock polarity
    static constexpr uint32_t CR2_CPHA = 0x200;         // Clock phase
    static constexpr uint32_t CR2_LBCL = 0x100;         // Last bit clock pulse
    static constexpr uint32_t CR2_LBDIE = 0x40;         // LIN break detection interrupt enable
    static constexpr uint32_t CR2_LBDL = 0x20;          // LIN break detection length
    static constexpr uint32_t CR2_ADDM7 = 0x10;         // 7-bit Address Detection/4-bit Address Detection
    static const uint32_t CR2_RESET_VALUE = 0x0;

    static constexpr uint32_t CR3_WUFIE = 0x400000;     // Wakeup from Stop mode interrupt enable
    template<uint32_t X>
    static constexpr uint32_t CR3_WUS =                 // Wakeup from Stop mode interrupt flag selection (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR3_SCARCNT =             // Smartcard auto-retry count (3 bits)
        bit_field_t<17, 0x7>::value<X>();
    static constexpr uint32_t CR3_DEP = 0x8000;         // Driver enable polarity selection
    static constexpr uint32_t CR3_DEM = 0x4000;         // Driver enable mode
    static constexpr uint32_t CR3_DDRE = 0x2000;        // DMA Disable on Reception Error
    static constexpr uint32_t CR3_OVRDIS = 0x1000;      // Overrun Disable
    static constexpr uint32_t CR3_ONEBIT = 0x800;       // One sample bit method enable
    static constexpr uint32_t CR3_CTSIE = 0x400;        // CTS interrupt enable
    static constexpr uint32_t CR3_CTSE = 0x200;         // CTS enable
    static constexpr uint32_t CR3_RTSE = 0x100;         // RTS enable
    static constexpr uint32_t CR3_DMAT = 0x80;          // DMA enable transmitter
    static constexpr uint32_t CR3_DMAR = 0x40;          // DMA enable receiver
    static constexpr uint32_t CR3_SCEN = 0x20;          // Smartcard mode enable
    static constexpr uint32_t CR3_NACK = 0x10;          // Smartcard NACK enable
    static constexpr uint32_t CR3_HDSEL = 0x8;          // Half-duplex selection
    static constexpr uint32_t CR3_IRLP = 0x4;           // Ir low-power
    static constexpr uint32_t CR3_IREN = 0x2;           // Ir mode enable
    static constexpr uint32_t CR3_EIE = 0x1;            // Error interrupt enable
    static const uint32_t CR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BRR_DIV_Mantissa =        // DIV_Mantissa (12 bits)
        bit_field_t<4, 0xfff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BRR_DIV_Fraction =        // DIV_Fraction (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t BRR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t GTPR_GT =                  // Guard time value (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GTPR_PSC =                 // Prescaler value (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t GTPR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RTOR_BLEN =                // Block Length (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RTOR_RTO =                 // Receiver timeout value (24 bits)
        bit_field_t<0, 0xffffff>::value<X>();
    static const uint32_t RTOR_RESET_VALUE = 0x0;

    static constexpr uint32_t RQR_TXFRQ = 0x10;         // Transmit data flush request
    static constexpr uint32_t RQR_RXFRQ = 0x8;          // Receive data flush request
    static constexpr uint32_t RQR_MMRQ = 0x4;           // Mute mode request
    static constexpr uint32_t RQR_SBKRQ = 0x2;          // Send break request
    static constexpr uint32_t RQR_ABRRQ = 0x1;          // Auto baud rate request
    static const uint32_t RQR_RESET_VALUE = 0x0;

    static constexpr uint32_t ISR_REACK = 0x400000;     // REACK
    static constexpr uint32_t ISR_TEACK = 0x200000;     // TEACK
    static constexpr uint32_t ISR_WUF = 0x100000;       // WUF
    static constexpr uint32_t ISR_RWU = 0x80000;        // RWU
    static constexpr uint32_t ISR_SBKF = 0x40000;       // SBKF
    static constexpr uint32_t ISR_CMF = 0x20000;        // CMF
    static constexpr uint32_t ISR_BUSY = 0x10000;       // BUSY
    static constexpr uint32_t ISR_ABRF = 0x8000;        // ABRF
    static constexpr uint32_t ISR_ABRE = 0x4000;        // ABRE
    static constexpr uint32_t ISR_EOBF = 0x1000;        // EOBF
    static constexpr uint32_t ISR_RTOF = 0x800;         // RTOF
    static constexpr uint32_t ISR_CTS = 0x400;          // CTS
    static constexpr uint32_t ISR_CTSIF = 0x200;        // CTSIF
    static constexpr uint32_t ISR_LBDF = 0x100;         // LBDF
    static constexpr uint32_t ISR_TXE = 0x80;           // TXE
    static constexpr uint32_t ISR_TC = 0x40;            // TC
    static constexpr uint32_t ISR_RXNE = 0x20;          // RXNE
    static constexpr uint32_t ISR_IDLE = 0x10;          // IDLE
    static constexpr uint32_t ISR_ORE = 0x8;            // ORE
    static constexpr uint32_t ISR_NF = 0x4;             // NF
    static constexpr uint32_t ISR_FE = 0x2;             // FE
    static constexpr uint32_t ISR_PE = 0x1;             // PE
    static const uint32_t ISR_RESET_VALUE = 0xc0;

    static constexpr uint32_t ICR_WUCF = 0x100000;      // Wakeup from Stop mode clear flag
    static constexpr uint32_t ICR_CMCF = 0x20000;       // Character match clear flag
    static constexpr uint32_t ICR_EOBCF = 0x1000;       // End of block clear flag
    static constexpr uint32_t ICR_RTOCF = 0x800;        // Receiver timeout clear flag
    static constexpr uint32_t ICR_CTSCF = 0x200;        // CTS clear flag
    static constexpr uint32_t ICR_LBDCF = 0x100;        // LIN break detection clear flag
    static constexpr uint32_t ICR_TCCF = 0x40;          // Transmission complete clear flag
    static constexpr uint32_t ICR_IDLECF = 0x10;        // Idle line detected clear flag
    static constexpr uint32_t ICR_ORECF = 0x8;          // Overrun error clear flag
    static constexpr uint32_t ICR_NCF = 0x4;            // Noise detected clear flag
    static constexpr uint32_t ICR_FECF = 0x2;           // Framing error clear flag
    static constexpr uint32_t ICR_PECF = 0x1;           // Parity error clear flag
    static const uint32_t ICR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RDR_RDR =                 // Receive data value (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static const uint32_t RDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDR_TDR =                 // Transmit data value (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static const uint32_t TDR_RESET_VALUE = 0x0;

    static constexpr uint8_t UART5 = 53; // UART5 global interrupt
};

static uart5_t& UART5 = *reinterpret_cast<uart5_t*>(0x40005000);

#define HAVE_PERIPHERAL_UART5


////
//
//    Universal synchronous asynchronous receiver transmitter
//
////

struct uart4_t
{
    volatile uint32_t    CR1;                  // [Read-write] Control register 1
    volatile uint32_t    CR2;                  // [Read-write] Control register 2
    volatile uint32_t    CR3;                  // [Read-write] Control register 3
    volatile uint32_t    BRR;                  // [Read-write] Baud rate register
    volatile uint32_t    GTPR;                 // [Read-write] Guard time and prescaler register
    volatile uint32_t    RTOR;                 // [Read-write] Receiver timeout register
    volatile uint32_t    RQR;                  // [Write-only] Request register
    volatile uint32_t    ISR;                  // [Read-only] Interrupt &amp; status register
    volatile uint32_t    ICR;                  // [Write-only] Interrupt flag clear register
    volatile uint32_t    RDR;                  // [Read-only] Receive data register
    volatile uint32_t    TDR;                  // [Read-write] Transmit data register

    static constexpr uint32_t CR1_M1 = 0x10000000;      // Word length
    static constexpr uint32_t CR1_EOBIE = 0x8000000;    // End of Block interrupt enable
    static constexpr uint32_t CR1_RTOIE = 0x4000000;    // Receiver timeout interrupt enable
    static constexpr uint32_t CR1_DEAT4 = 0x2000000;    // Driver Enable assertion time
    static constexpr uint32_t CR1_DEAT3 = 0x1000000;    // DEAT3
    static constexpr uint32_t CR1_DEAT2 = 0x800000;     // DEAT2
    static constexpr uint32_t CR1_DEAT1 = 0x400000;     // DEAT1
    static constexpr uint32_t CR1_DEAT0 = 0x200000;     // DEAT0
    static constexpr uint32_t CR1_DEDT4 = 0x100000;     // Driver Enable de-assertion time
    static constexpr uint32_t CR1_DEDT3 = 0x80000;      // DEDT3
    static constexpr uint32_t CR1_DEDT2 = 0x40000;      // DEDT2
    static constexpr uint32_t CR1_DEDT1 = 0x20000;      // DEDT1
    static constexpr uint32_t CR1_DEDT0 = 0x10000;      // DEDT0
    static constexpr uint32_t CR1_OVER8 = 0x8000;       // Oversampling mode
    static constexpr uint32_t CR1_CMIE = 0x4000;        // Character match interrupt enable
    static constexpr uint32_t CR1_MME = 0x2000;         // Mute mode enable
    static constexpr uint32_t CR1_M0 = 0x1000;          // Word length
    static constexpr uint32_t CR1_WAKE = 0x800;         // Receiver wakeup method
    static constexpr uint32_t CR1_PCE = 0x400;          // Parity control enable
    static constexpr uint32_t CR1_PS = 0x200;           // Parity selection
    static constexpr uint32_t CR1_PEIE = 0x100;         // PE interrupt enable
    static constexpr uint32_t CR1_TXEIE = 0x80;         // interrupt enable
    static constexpr uint32_t CR1_TCIE = 0x40;          // Transmission complete interrupt enable
    static constexpr uint32_t CR1_RXNEIE = 0x20;        // RXNE interrupt enable
    static constexpr uint32_t CR1_IDLEIE = 0x10;        // IDLE interrupt enable
    static constexpr uint32_t CR1_TE = 0x8;             // Transmitter enable
    static constexpr uint32_t CR1_RE = 0x4;             // Receiver enable
    static constexpr uint32_t CR1_UESM = 0x2;           // USART enable in Stop mode
    static constexpr uint32_t CR1_UE = 0x1;             // USART enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CR2_ADD4_7 =              // Address of the USART node (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR2_ADD0_3 =              // Address of the USART node (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    static constexpr uint32_t CR2_RTOEN = 0x800000;     // Receiver timeout enable
    static constexpr uint32_t CR2_ABRMOD1 = 0x400000;   // Auto baud rate mode
    static constexpr uint32_t CR2_ABRMOD0 = 0x200000;   // ABRMOD0
    static constexpr uint32_t CR2_ABREN = 0x100000;     // Auto baud rate enable
    static constexpr uint32_t CR2_MSBFIRST = 0x80000;   // Most significant bit first
    static constexpr uint32_t CR2_TAINV = 0x40000;      // Binary data inversion
    static constexpr uint32_t CR2_TXINV = 0x20000;      // TX pin active level inversion
    static constexpr uint32_t CR2_RXINV = 0x10000;      // RX pin active level inversion
    static constexpr uint32_t CR2_SWAP = 0x8000;        // Swap TX/RX pins
    static constexpr uint32_t CR2_LINEN = 0x4000;       // LIN mode enable
    template<uint32_t X>
    static constexpr uint32_t CR2_STOP =                // STOP bits (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    static constexpr uint32_t CR2_CLKEN = 0x800;        // Clock enable
    static constexpr uint32_t CR2_CPOL = 0x400;         // Clock polarity
    static constexpr uint32_t CR2_CPHA = 0x200;         // Clock phase
    static constexpr uint32_t CR2_LBCL = 0x100;         // Last bit clock pulse
    static constexpr uint32_t CR2_LBDIE = 0x40;         // LIN break detection interrupt enable
    static constexpr uint32_t CR2_LBDL = 0x20;          // LIN break detection length
    static constexpr uint32_t CR2_ADDM7 = 0x10;         // 7-bit Address Detection/4-bit Address Detection
    static const uint32_t CR2_RESET_VALUE = 0x0;

    static constexpr uint32_t CR3_WUFIE = 0x400000;     // Wakeup from Stop mode interrupt enable
    template<uint32_t X>
    static constexpr uint32_t CR3_WUS =                 // Wakeup from Stop mode interrupt flag selection (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR3_SCARCNT =             // Smartcard auto-retry count (3 bits)
        bit_field_t<17, 0x7>::value<X>();
    static constexpr uint32_t CR3_DEP = 0x8000;         // Driver enable polarity selection
    static constexpr uint32_t CR3_DEM = 0x4000;         // Driver enable mode
    static constexpr uint32_t CR3_DDRE = 0x2000;        // DMA Disable on Reception Error
    static constexpr uint32_t CR3_OVRDIS = 0x1000;      // Overrun Disable
    static constexpr uint32_t CR3_ONEBIT = 0x800;       // One sample bit method enable
    static constexpr uint32_t CR3_CTSIE = 0x400;        // CTS interrupt enable
    static constexpr uint32_t CR3_CTSE = 0x200;         // CTS enable
    static constexpr uint32_t CR3_RTSE = 0x100;         // RTS enable
    static constexpr uint32_t CR3_DMAT = 0x80;          // DMA enable transmitter
    static constexpr uint32_t CR3_DMAR = 0x40;          // DMA enable receiver
    static constexpr uint32_t CR3_SCEN = 0x20;          // Smartcard mode enable
    static constexpr uint32_t CR3_NACK = 0x10;          // Smartcard NACK enable
    static constexpr uint32_t CR3_HDSEL = 0x8;          // Half-duplex selection
    static constexpr uint32_t CR3_IRLP = 0x4;           // Ir low-power
    static constexpr uint32_t CR3_IREN = 0x2;           // Ir mode enable
    static constexpr uint32_t CR3_EIE = 0x1;            // Error interrupt enable
    static const uint32_t CR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BRR_DIV_Mantissa =        // DIV_Mantissa (12 bits)
        bit_field_t<4, 0xfff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BRR_DIV_Fraction =        // DIV_Fraction (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t BRR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t GTPR_GT =                  // Guard time value (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GTPR_PSC =                 // Prescaler value (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t GTPR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RTOR_BLEN =                // Block Length (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RTOR_RTO =                 // Receiver timeout value (24 bits)
        bit_field_t<0, 0xffffff>::value<X>();
    static const uint32_t RTOR_RESET_VALUE = 0x0;

    static constexpr uint32_t RQR_TXFRQ = 0x10;         // Transmit data flush request
    static constexpr uint32_t RQR_RXFRQ = 0x8;          // Receive data flush request
    static constexpr uint32_t RQR_MMRQ = 0x4;           // Mute mode request
    static constexpr uint32_t RQR_SBKRQ = 0x2;          // Send break request
    static constexpr uint32_t RQR_ABRRQ = 0x1;          // Auto baud rate request
    static const uint32_t RQR_RESET_VALUE = 0x0;

    static constexpr uint32_t ISR_REACK = 0x400000;     // REACK
    static constexpr uint32_t ISR_TEACK = 0x200000;     // TEACK
    static constexpr uint32_t ISR_WUF = 0x100000;       // WUF
    static constexpr uint32_t ISR_RWU = 0x80000;        // RWU
    static constexpr uint32_t ISR_SBKF = 0x40000;       // SBKF
    static constexpr uint32_t ISR_CMF = 0x20000;        // CMF
    static constexpr uint32_t ISR_BUSY = 0x10000;       // BUSY
    static constexpr uint32_t ISR_ABRF = 0x8000;        // ABRF
    static constexpr uint32_t ISR_ABRE = 0x4000;        // ABRE
    static constexpr uint32_t ISR_EOBF = 0x1000;        // EOBF
    static constexpr uint32_t ISR_RTOF = 0x800;         // RTOF
    static constexpr uint32_t ISR_CTS = 0x400;          // CTS
    static constexpr uint32_t ISR_CTSIF = 0x200;        // CTSIF
    static constexpr uint32_t ISR_LBDF = 0x100;         // LBDF
    static constexpr uint32_t ISR_TXE = 0x80;           // TXE
    static constexpr uint32_t ISR_TC = 0x40;            // TC
    static constexpr uint32_t ISR_RXNE = 0x20;          // RXNE
    static constexpr uint32_t ISR_IDLE = 0x10;          // IDLE
    static constexpr uint32_t ISR_ORE = 0x8;            // ORE
    static constexpr uint32_t ISR_NF = 0x4;             // NF
    static constexpr uint32_t ISR_FE = 0x2;             // FE
    static constexpr uint32_t ISR_PE = 0x1;             // PE
    static const uint32_t ISR_RESET_VALUE = 0xc0;

    static constexpr uint32_t ICR_WUCF = 0x100000;      // Wakeup from Stop mode clear flag
    static constexpr uint32_t ICR_CMCF = 0x20000;       // Character match clear flag
    static constexpr uint32_t ICR_EOBCF = 0x1000;       // End of block clear flag
    static constexpr uint32_t ICR_RTOCF = 0x800;        // Receiver timeout clear flag
    static constexpr uint32_t ICR_CTSCF = 0x200;        // CTS clear flag
    static constexpr uint32_t ICR_LBDCF = 0x100;        // LIN break detection clear flag
    static constexpr uint32_t ICR_TCCF = 0x40;          // Transmission complete clear flag
    static constexpr uint32_t ICR_IDLECF = 0x10;        // Idle line detected clear flag
    static constexpr uint32_t ICR_ORECF = 0x8;          // Overrun error clear flag
    static constexpr uint32_t ICR_NCF = 0x4;            // Noise detected clear flag
    static constexpr uint32_t ICR_FECF = 0x2;           // Framing error clear flag
    static constexpr uint32_t ICR_PECF = 0x1;           // Parity error clear flag
    static const uint32_t ICR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RDR_RDR =                 // Receive data value (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static const uint32_t RDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDR_TDR =                 // Transmit data value (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static const uint32_t TDR_RESET_VALUE = 0x0;

    static constexpr uint8_t UART4 = 52; // UART4 global interrupt
};

static uart4_t& UART4 = *reinterpret_cast<uart4_t*>(0x40004c00);

#define HAVE_PERIPHERAL_UART4


////
//
//    Universal synchronous asynchronous receiver transmitter
//
////

struct uart8_t
{
    volatile uint32_t    CR1;                  // [Read-write] Control register 1
    volatile uint32_t    CR2;                  // [Read-write] Control register 2
    volatile uint32_t    CR3;                  // [Read-write] Control register 3
    volatile uint32_t    BRR;                  // [Read-write] Baud rate register
    volatile uint32_t    GTPR;                 // [Read-write] Guard time and prescaler register
    volatile uint32_t    RTOR;                 // [Read-write] Receiver timeout register
    volatile uint32_t    RQR;                  // [Write-only] Request register
    volatile uint32_t    ISR;                  // [Read-only] Interrupt &amp; status register
    volatile uint32_t    ICR;                  // [Write-only] Interrupt flag clear register
    volatile uint32_t    RDR;                  // [Read-only] Receive data register
    volatile uint32_t    TDR;                  // [Read-write] Transmit data register

    static constexpr uint32_t CR1_M1 = 0x10000000;      // Word length
    static constexpr uint32_t CR1_EOBIE = 0x8000000;    // End of Block interrupt enable
    static constexpr uint32_t CR1_RTOIE = 0x4000000;    // Receiver timeout interrupt enable
    static constexpr uint32_t CR1_DEAT4 = 0x2000000;    // Driver Enable assertion time
    static constexpr uint32_t CR1_DEAT3 = 0x1000000;    // DEAT3
    static constexpr uint32_t CR1_DEAT2 = 0x800000;     // DEAT2
    static constexpr uint32_t CR1_DEAT1 = 0x400000;     // DEAT1
    static constexpr uint32_t CR1_DEAT0 = 0x200000;     // DEAT0
    static constexpr uint32_t CR1_DEDT4 = 0x100000;     // Driver Enable de-assertion time
    static constexpr uint32_t CR1_DEDT3 = 0x80000;      // DEDT3
    static constexpr uint32_t CR1_DEDT2 = 0x40000;      // DEDT2
    static constexpr uint32_t CR1_DEDT1 = 0x20000;      // DEDT1
    static constexpr uint32_t CR1_DEDT0 = 0x10000;      // DEDT0
    static constexpr uint32_t CR1_OVER8 = 0x8000;       // Oversampling mode
    static constexpr uint32_t CR1_CMIE = 0x4000;        // Character match interrupt enable
    static constexpr uint32_t CR1_MME = 0x2000;         // Mute mode enable
    static constexpr uint32_t CR1_M0 = 0x1000;          // Word length
    static constexpr uint32_t CR1_WAKE = 0x800;         // Receiver wakeup method
    static constexpr uint32_t CR1_PCE = 0x400;          // Parity control enable
    static constexpr uint32_t CR1_PS = 0x200;           // Parity selection
    static constexpr uint32_t CR1_PEIE = 0x100;         // PE interrupt enable
    static constexpr uint32_t CR1_TXEIE = 0x80;         // interrupt enable
    static constexpr uint32_t CR1_TCIE = 0x40;          // Transmission complete interrupt enable
    static constexpr uint32_t CR1_RXNEIE = 0x20;        // RXNE interrupt enable
    static constexpr uint32_t CR1_IDLEIE = 0x10;        // IDLE interrupt enable
    static constexpr uint32_t CR1_TE = 0x8;             // Transmitter enable
    static constexpr uint32_t CR1_RE = 0x4;             // Receiver enable
    static constexpr uint32_t CR1_UESM = 0x2;           // USART enable in Stop mode
    static constexpr uint32_t CR1_UE = 0x1;             // USART enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CR2_ADD4_7 =              // Address of the USART node (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR2_ADD0_3 =              // Address of the USART node (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    static constexpr uint32_t CR2_RTOEN = 0x800000;     // Receiver timeout enable
    static constexpr uint32_t CR2_ABRMOD1 = 0x400000;   // Auto baud rate mode
    static constexpr uint32_t CR2_ABRMOD0 = 0x200000;   // ABRMOD0
    static constexpr uint32_t CR2_ABREN = 0x100000;     // Auto baud rate enable
    static constexpr uint32_t CR2_MSBFIRST = 0x80000;   // Most significant bit first
    static constexpr uint32_t CR2_TAINV = 0x40000;      // Binary data inversion
    static constexpr uint32_t CR2_TXINV = 0x20000;      // TX pin active level inversion
    static constexpr uint32_t CR2_RXINV = 0x10000;      // RX pin active level inversion
    static constexpr uint32_t CR2_SWAP = 0x8000;        // Swap TX/RX pins
    static constexpr uint32_t CR2_LINEN = 0x4000;       // LIN mode enable
    template<uint32_t X>
    static constexpr uint32_t CR2_STOP =                // STOP bits (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    static constexpr uint32_t CR2_CLKEN = 0x800;        // Clock enable
    static constexpr uint32_t CR2_CPOL = 0x400;         // Clock polarity
    static constexpr uint32_t CR2_CPHA = 0x200;         // Clock phase
    static constexpr uint32_t CR2_LBCL = 0x100;         // Last bit clock pulse
    static constexpr uint32_t CR2_LBDIE = 0x40;         // LIN break detection interrupt enable
    static constexpr uint32_t CR2_LBDL = 0x20;          // LIN break detection length
    static constexpr uint32_t CR2_ADDM7 = 0x10;         // 7-bit Address Detection/4-bit Address Detection
    static const uint32_t CR2_RESET_VALUE = 0x0;

    static constexpr uint32_t CR3_WUFIE = 0x400000;     // Wakeup from Stop mode interrupt enable
    template<uint32_t X>
    static constexpr uint32_t CR3_WUS =                 // Wakeup from Stop mode interrupt flag selection (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR3_SCARCNT =             // Smartcard auto-retry count (3 bits)
        bit_field_t<17, 0x7>::value<X>();
    static constexpr uint32_t CR3_DEP = 0x8000;         // Driver enable polarity selection
    static constexpr uint32_t CR3_DEM = 0x4000;         // Driver enable mode
    static constexpr uint32_t CR3_DDRE = 0x2000;        // DMA Disable on Reception Error
    static constexpr uint32_t CR3_OVRDIS = 0x1000;      // Overrun Disable
    static constexpr uint32_t CR3_ONEBIT = 0x800;       // One sample bit method enable
    static constexpr uint32_t CR3_CTSIE = 0x400;        // CTS interrupt enable
    static constexpr uint32_t CR3_CTSE = 0x200;         // CTS enable
    static constexpr uint32_t CR3_RTSE = 0x100;         // RTS enable
    static constexpr uint32_t CR3_DMAT = 0x80;          // DMA enable transmitter
    static constexpr uint32_t CR3_DMAR = 0x40;          // DMA enable receiver
    static constexpr uint32_t CR3_SCEN = 0x20;          // Smartcard mode enable
    static constexpr uint32_t CR3_NACK = 0x10;          // Smartcard NACK enable
    static constexpr uint32_t CR3_HDSEL = 0x8;          // Half-duplex selection
    static constexpr uint32_t CR3_IRLP = 0x4;           // Ir low-power
    static constexpr uint32_t CR3_IREN = 0x2;           // Ir mode enable
    static constexpr uint32_t CR3_EIE = 0x1;            // Error interrupt enable
    static const uint32_t CR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BRR_DIV_Mantissa =        // DIV_Mantissa (12 bits)
        bit_field_t<4, 0xfff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BRR_DIV_Fraction =        // DIV_Fraction (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t BRR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t GTPR_GT =                  // Guard time value (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GTPR_PSC =                 // Prescaler value (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t GTPR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RTOR_BLEN =                // Block Length (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RTOR_RTO =                 // Receiver timeout value (24 bits)
        bit_field_t<0, 0xffffff>::value<X>();
    static const uint32_t RTOR_RESET_VALUE = 0x0;

    static constexpr uint32_t RQR_TXFRQ = 0x10;         // Transmit data flush request
    static constexpr uint32_t RQR_RXFRQ = 0x8;          // Receive data flush request
    static constexpr uint32_t RQR_MMRQ = 0x4;           // Mute mode request
    static constexpr uint32_t RQR_SBKRQ = 0x2;          // Send break request
    static constexpr uint32_t RQR_ABRRQ = 0x1;          // Auto baud rate request
    static const uint32_t RQR_RESET_VALUE = 0x0;

    static constexpr uint32_t ISR_REACK = 0x400000;     // REACK
    static constexpr uint32_t ISR_TEACK = 0x200000;     // TEACK
    static constexpr uint32_t ISR_WUF = 0x100000;       // WUF
    static constexpr uint32_t ISR_RWU = 0x80000;        // RWU
    static constexpr uint32_t ISR_SBKF = 0x40000;       // SBKF
    static constexpr uint32_t ISR_CMF = 0x20000;        // CMF
    static constexpr uint32_t ISR_BUSY = 0x10000;       // BUSY
    static constexpr uint32_t ISR_ABRF = 0x8000;        // ABRF
    static constexpr uint32_t ISR_ABRE = 0x4000;        // ABRE
    static constexpr uint32_t ISR_EOBF = 0x1000;        // EOBF
    static constexpr uint32_t ISR_RTOF = 0x800;         // RTOF
    static constexpr uint32_t ISR_CTS = 0x400;          // CTS
    static constexpr uint32_t ISR_CTSIF = 0x200;        // CTSIF
    static constexpr uint32_t ISR_LBDF = 0x100;         // LBDF
    static constexpr uint32_t ISR_TXE = 0x80;           // TXE
    static constexpr uint32_t ISR_TC = 0x40;            // TC
    static constexpr uint32_t ISR_RXNE = 0x20;          // RXNE
    static constexpr uint32_t ISR_IDLE = 0x10;          // IDLE
    static constexpr uint32_t ISR_ORE = 0x8;            // ORE
    static constexpr uint32_t ISR_NF = 0x4;             // NF
    static constexpr uint32_t ISR_FE = 0x2;             // FE
    static constexpr uint32_t ISR_PE = 0x1;             // PE
    static const uint32_t ISR_RESET_VALUE = 0xc0;

    static constexpr uint32_t ICR_WUCF = 0x100000;      // Wakeup from Stop mode clear flag
    static constexpr uint32_t ICR_CMCF = 0x20000;       // Character match clear flag
    static constexpr uint32_t ICR_EOBCF = 0x1000;       // End of block clear flag
    static constexpr uint32_t ICR_RTOCF = 0x800;        // Receiver timeout clear flag
    static constexpr uint32_t ICR_CTSCF = 0x200;        // CTS clear flag
    static constexpr uint32_t ICR_LBDCF = 0x100;        // LIN break detection clear flag
    static constexpr uint32_t ICR_TCCF = 0x40;          // Transmission complete clear flag
    static constexpr uint32_t ICR_IDLECF = 0x10;        // Idle line detected clear flag
    static constexpr uint32_t ICR_ORECF = 0x8;          // Overrun error clear flag
    static constexpr uint32_t ICR_NCF = 0x4;            // Noise detected clear flag
    static constexpr uint32_t ICR_FECF = 0x2;           // Framing error clear flag
    static constexpr uint32_t ICR_PECF = 0x1;           // Parity error clear flag
    static const uint32_t ICR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RDR_RDR =                 // Receive data value (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static const uint32_t RDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDR_TDR =                 // Transmit data value (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static const uint32_t TDR_RESET_VALUE = 0x0;

    static constexpr uint8_t UART8 = 83; // UART 8 global interrupt
};

static uart8_t& UART8 = *reinterpret_cast<uart8_t*>(0x40007c00);

#define HAVE_PERIPHERAL_UART8


////
//
//    Universal synchronous asynchronous receiver transmitter
//
////

struct uart7_t
{
    volatile uint32_t    CR1;                  // [Read-write] Control register 1
    volatile uint32_t    CR2;                  // [Read-write] Control register 2
    volatile uint32_t    CR3;                  // [Read-write] Control register 3
    volatile uint32_t    BRR;                  // [Read-write] Baud rate register
    volatile uint32_t    GTPR;                 // [Read-write] Guard time and prescaler register
    volatile uint32_t    RTOR;                 // [Read-write] Receiver timeout register
    volatile uint32_t    RQR;                  // [Write-only] Request register
    volatile uint32_t    ISR;                  // [Read-only] Interrupt &amp; status register
    volatile uint32_t    ICR;                  // [Write-only] Interrupt flag clear register
    volatile uint32_t    RDR;                  // [Read-only] Receive data register
    volatile uint32_t    TDR;                  // [Read-write] Transmit data register

    static constexpr uint32_t CR1_M1 = 0x10000000;      // Word length
    static constexpr uint32_t CR1_EOBIE = 0x8000000;    // End of Block interrupt enable
    static constexpr uint32_t CR1_RTOIE = 0x4000000;    // Receiver timeout interrupt enable
    static constexpr uint32_t CR1_DEAT4 = 0x2000000;    // Driver Enable assertion time
    static constexpr uint32_t CR1_DEAT3 = 0x1000000;    // DEAT3
    static constexpr uint32_t CR1_DEAT2 = 0x800000;     // DEAT2
    static constexpr uint32_t CR1_DEAT1 = 0x400000;     // DEAT1
    static constexpr uint32_t CR1_DEAT0 = 0x200000;     // DEAT0
    static constexpr uint32_t CR1_DEDT4 = 0x100000;     // Driver Enable de-assertion time
    static constexpr uint32_t CR1_DEDT3 = 0x80000;      // DEDT3
    static constexpr uint32_t CR1_DEDT2 = 0x40000;      // DEDT2
    static constexpr uint32_t CR1_DEDT1 = 0x20000;      // DEDT1
    static constexpr uint32_t CR1_DEDT0 = 0x10000;      // DEDT0
    static constexpr uint32_t CR1_OVER8 = 0x8000;       // Oversampling mode
    static constexpr uint32_t CR1_CMIE = 0x4000;        // Character match interrupt enable
    static constexpr uint32_t CR1_MME = 0x2000;         // Mute mode enable
    static constexpr uint32_t CR1_M0 = 0x1000;          // Word length
    static constexpr uint32_t CR1_WAKE = 0x800;         // Receiver wakeup method
    static constexpr uint32_t CR1_PCE = 0x400;          // Parity control enable
    static constexpr uint32_t CR1_PS = 0x200;           // Parity selection
    static constexpr uint32_t CR1_PEIE = 0x100;         // PE interrupt enable
    static constexpr uint32_t CR1_TXEIE = 0x80;         // interrupt enable
    static constexpr uint32_t CR1_TCIE = 0x40;          // Transmission complete interrupt enable
    static constexpr uint32_t CR1_RXNEIE = 0x20;        // RXNE interrupt enable
    static constexpr uint32_t CR1_IDLEIE = 0x10;        // IDLE interrupt enable
    static constexpr uint32_t CR1_TE = 0x8;             // Transmitter enable
    static constexpr uint32_t CR1_RE = 0x4;             // Receiver enable
    static constexpr uint32_t CR1_UESM = 0x2;           // USART enable in Stop mode
    static constexpr uint32_t CR1_UE = 0x1;             // USART enable
    static const uint32_t CR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CR2_ADD4_7 =              // Address of the USART node (4 bits)
        bit_field_t<28, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR2_ADD0_3 =              // Address of the USART node (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    static constexpr uint32_t CR2_RTOEN = 0x800000;     // Receiver timeout enable
    static constexpr uint32_t CR2_ABRMOD1 = 0x400000;   // Auto baud rate mode
    static constexpr uint32_t CR2_ABRMOD0 = 0x200000;   // ABRMOD0
    static constexpr uint32_t CR2_ABREN = 0x100000;     // Auto baud rate enable
    static constexpr uint32_t CR2_MSBFIRST = 0x80000;   // Most significant bit first
    static constexpr uint32_t CR2_TAINV = 0x40000;      // Binary data inversion
    static constexpr uint32_t CR2_TXINV = 0x20000;      // TX pin active level inversion
    static constexpr uint32_t CR2_RXINV = 0x10000;      // RX pin active level inversion
    static constexpr uint32_t CR2_SWAP = 0x8000;        // Swap TX/RX pins
    static constexpr uint32_t CR2_LINEN = 0x4000;       // LIN mode enable
    template<uint32_t X>
    static constexpr uint32_t CR2_STOP =                // STOP bits (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    static constexpr uint32_t CR2_CLKEN = 0x800;        // Clock enable
    static constexpr uint32_t CR2_CPOL = 0x400;         // Clock polarity
    static constexpr uint32_t CR2_CPHA = 0x200;         // Clock phase
    static constexpr uint32_t CR2_LBCL = 0x100;         // Last bit clock pulse
    static constexpr uint32_t CR2_LBDIE = 0x40;         // LIN break detection interrupt enable
    static constexpr uint32_t CR2_LBDL = 0x20;          // LIN break detection length
    static constexpr uint32_t CR2_ADDM7 = 0x10;         // 7-bit Address Detection/4-bit Address Detection
    static const uint32_t CR2_RESET_VALUE = 0x0;

    static constexpr uint32_t CR3_WUFIE = 0x400000;     // Wakeup from Stop mode interrupt enable
    template<uint32_t X>
    static constexpr uint32_t CR3_WUS =                 // Wakeup from Stop mode interrupt flag selection (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CR3_SCARCNT =             // Smartcard auto-retry count (3 bits)
        bit_field_t<17, 0x7>::value<X>();
    static constexpr uint32_t CR3_DEP = 0x8000;         // Driver enable polarity selection
    static constexpr uint32_t CR3_DEM = 0x4000;         // Driver enable mode
    static constexpr uint32_t CR3_DDRE = 0x2000;        // DMA Disable on Reception Error
    static constexpr uint32_t CR3_OVRDIS = 0x1000;      // Overrun Disable
    static constexpr uint32_t CR3_ONEBIT = 0x800;       // One sample bit method enable
    static constexpr uint32_t CR3_CTSIE = 0x400;        // CTS interrupt enable
    static constexpr uint32_t CR3_CTSE = 0x200;         // CTS enable
    static constexpr uint32_t CR3_RTSE = 0x100;         // RTS enable
    static constexpr uint32_t CR3_DMAT = 0x80;          // DMA enable transmitter
    static constexpr uint32_t CR3_DMAR = 0x40;          // DMA enable receiver
    static constexpr uint32_t CR3_SCEN = 0x20;          // Smartcard mode enable
    static constexpr uint32_t CR3_NACK = 0x10;          // Smartcard NACK enable
    static constexpr uint32_t CR3_HDSEL = 0x8;          // Half-duplex selection
    static constexpr uint32_t CR3_IRLP = 0x4;           // Ir low-power
    static constexpr uint32_t CR3_IREN = 0x2;           // Ir mode enable
    static constexpr uint32_t CR3_EIE = 0x1;            // Error interrupt enable
    static const uint32_t CR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t BRR_DIV_Mantissa =        // DIV_Mantissa (12 bits)
        bit_field_t<4, 0xfff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t BRR_DIV_Fraction =        // DIV_Fraction (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t BRR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t GTPR_GT =                  // Guard time value (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GTPR_PSC =                 // Prescaler value (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t GTPR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RTOR_BLEN =                // Block Length (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RTOR_RTO =                 // Receiver timeout value (24 bits)
        bit_field_t<0, 0xffffff>::value<X>();
    static const uint32_t RTOR_RESET_VALUE = 0x0;

    static constexpr uint32_t RQR_TXFRQ = 0x10;         // Transmit data flush request
    static constexpr uint32_t RQR_RXFRQ = 0x8;          // Receive data flush request
    static constexpr uint32_t RQR_MMRQ = 0x4;           // Mute mode request
    static constexpr uint32_t RQR_SBKRQ = 0x2;          // Send break request
    static constexpr uint32_t RQR_ABRRQ = 0x1;          // Auto baud rate request
    static const uint32_t RQR_RESET_VALUE = 0x0;

    static constexpr uint32_t ISR_REACK = 0x400000;     // REACK
    static constexpr uint32_t ISR_TEACK = 0x200000;     // TEACK
    static constexpr uint32_t ISR_WUF = 0x100000;       // WUF
    static constexpr uint32_t ISR_RWU = 0x80000;        // RWU
    static constexpr uint32_t ISR_SBKF = 0x40000;       // SBKF
    static constexpr uint32_t ISR_CMF = 0x20000;        // CMF
    static constexpr uint32_t ISR_BUSY = 0x10000;       // BUSY
    static constexpr uint32_t ISR_ABRF = 0x8000;        // ABRF
    static constexpr uint32_t ISR_ABRE = 0x4000;        // ABRE
    static constexpr uint32_t ISR_EOBF = 0x1000;        // EOBF
    static constexpr uint32_t ISR_RTOF = 0x800;         // RTOF
    static constexpr uint32_t ISR_CTS = 0x400;          // CTS
    static constexpr uint32_t ISR_CTSIF = 0x200;        // CTSIF
    static constexpr uint32_t ISR_LBDF = 0x100;         // LBDF
    static constexpr uint32_t ISR_TXE = 0x80;           // TXE
    static constexpr uint32_t ISR_TC = 0x40;            // TC
    static constexpr uint32_t ISR_RXNE = 0x20;          // RXNE
    static constexpr uint32_t ISR_IDLE = 0x10;          // IDLE
    static constexpr uint32_t ISR_ORE = 0x8;            // ORE
    static constexpr uint32_t ISR_NF = 0x4;             // NF
    static constexpr uint32_t ISR_FE = 0x2;             // FE
    static constexpr uint32_t ISR_PE = 0x1;             // PE
    static const uint32_t ISR_RESET_VALUE = 0xc0;

    static constexpr uint32_t ICR_WUCF = 0x100000;      // Wakeup from Stop mode clear flag
    static constexpr uint32_t ICR_CMCF = 0x20000;       // Character match clear flag
    static constexpr uint32_t ICR_EOBCF = 0x1000;       // End of block clear flag
    static constexpr uint32_t ICR_RTOCF = 0x800;        // Receiver timeout clear flag
    static constexpr uint32_t ICR_CTSCF = 0x200;        // CTS clear flag
    static constexpr uint32_t ICR_LBDCF = 0x100;        // LIN break detection clear flag
    static constexpr uint32_t ICR_TCCF = 0x40;          // Transmission complete clear flag
    static constexpr uint32_t ICR_IDLECF = 0x10;        // Idle line detected clear flag
    static constexpr uint32_t ICR_ORECF = 0x8;          // Overrun error clear flag
    static constexpr uint32_t ICR_NCF = 0x4;            // Noise detected clear flag
    static constexpr uint32_t ICR_FECF = 0x2;           // Framing error clear flag
    static constexpr uint32_t ICR_PECF = 0x1;           // Parity error clear flag
    static const uint32_t ICR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RDR_RDR =                 // Receive data value (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static const uint32_t RDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TDR_TDR =                 // Transmit data value (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static const uint32_t TDR_RESET_VALUE = 0x0;

    static constexpr uint8_t UART7 = 82; // UART7 global interrupt
};

static uart7_t& UART7 = *reinterpret_cast<uart7_t*>(0x40007800);

#define HAVE_PERIPHERAL_UART7


////
//
//    USB on the go full speed
//
////

struct otg_fs_global_t
{
    volatile uint32_t    OTG_FS_GOTGCTL;       // OTG_FS control and status register (OTG_FS_GOTGCTL)
    volatile uint32_t    OTG_FS_GOTGINT;       // [Read-write] OTG_FS interrupt register (OTG_FS_GOTGINT)
    volatile uint32_t    OTG_FS_GAHBCFG;       // [Read-write] OTG_FS AHB configuration register (OTG_FS_GAHBCFG)
    volatile uint32_t    OTG_FS_GUSBCFG;       // OTG_FS USB configuration register (OTG_FS_GUSBCFG)
    volatile uint32_t    OTG_FS_GRSTCTL;       // OTG_FS reset register (OTG_FS_GRSTCTL)
    volatile uint32_t    OTG_FS_GINTSTS;       // OTG_FS core interrupt register (OTG_FS_GINTSTS)
    volatile uint32_t    OTG_FS_GINTMSK;       // OTG_FS interrupt mask register (OTG_FS_GINTMSK)
    volatile uint32_t    OTG_FS_GRXSTSR_Device;// [Read-only] OTG_FS Receive status debug read(Device mode)
    volatile uint32_t    OTG_FS_GRXSTSP_Device;// [Read-only] OTG status read and pop register (Device mode)
    volatile uint32_t    OTG_FS_GRXFSIZ;       // [Read-write] OTG_FS Receive FIFO size register (OTG_FS_GRXFSIZ)
    volatile uint32_t    OTG_FS_DIEPTXF0_Device;// [Read-write] OTG_FS Endpoint 0 Transmit FIFO size
    volatile uint32_t    OTG_FS_HNPTXSTS;      // [Read-only] OTG_FS non-periodic transmit FIFO/queue status register (OTG_FS_GNPTXSTS)
    volatile uint32_t    OTG_FS_GI2CCTL;       // [Read-write] OTG I2C access register
    reserved_t<1>        _0;
    volatile uint32_t    OTG_FS_GCCFG;         // [Read-write] OTG_FS general core configuration register (OTG_FS_GCCFG)
    volatile uint32_t    OTG_FS_CID;           // [Read-write] core ID register
    reserved_t<5>        _1;
    volatile uint32_t    OTG_FS_GLPMCFG;       // OTG core LPM configuration register
    volatile uint32_t    OTG_FS_GPWRDN;        // [Read-write] OTG power down register
    reserved_t<1>        _2;
    volatile uint32_t    OTG_FS_GADPCTL;       // OTG ADP timer, control and status register
    reserved_t<39>       _3;
    volatile uint32_t    OTG_FS_HPTXFSIZ;      // [Read-write] OTG_FS Host periodic transmit FIFO size register (OTG_FS_HPTXFSIZ)
    volatile uint32_t    OTG_FS_DIEPTXF1;      // [Read-write] OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF1)
    volatile uint32_t    OTG_FS_DIEPTXF2;      // [Read-write] OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF2)
    volatile uint32_t    OTG_FS_DIEPTXF3;      // [Read-write] OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF3)
    volatile uint32_t    OTG_FS_DIEPTXF4;      // [Read-write] OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF4)
    volatile uint32_t    OTG_FS_DIEPTXF5;      // [Read-write] OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF5)

    static constexpr uint32_t OTG_FS_GOTGCTL_SRQSCS = 0x1;         // Session request success, Read-only
    static constexpr uint32_t OTG_FS_GOTGCTL_SRQ = 0x2;            // Session request, Read-write
    static constexpr uint32_t OTG_FS_GOTGCTL_HNGSCS = 0x100;       // Host negotiation success, Read-only
    static constexpr uint32_t OTG_FS_GOTGCTL_HNPRQ = 0x200;        // HNP request, Read-write
    static constexpr uint32_t OTG_FS_GOTGCTL_HSHNPEN = 0x400;      // Host set HNP enable, Read-write
    static constexpr uint32_t OTG_FS_GOTGCTL_DHNPEN = 0x800;       // Device HNP enabled, Read-write
    static constexpr uint32_t OTG_FS_GOTGCTL_CIDSTS = 0x10000;     // Connector ID status, Read-only
    static constexpr uint32_t OTG_FS_GOTGCTL_DBCT = 0x20000;       // Long/short debounce time, Read-only
    static constexpr uint32_t OTG_FS_GOTGCTL_ASVLD = 0x40000;      // A-session valid, Read-only
    static constexpr uint32_t OTG_FS_GOTGCTL_BSVLD = 0x80000;      // B-session valid, Read-only
    static constexpr uint32_t OTG_FS_GOTGCTL_VBVALOEN = 0x4;       // VBUS valid override enable, Read-write
    static constexpr uint32_t OTG_FS_GOTGCTL_VBVALOVAL = 0x8;      // VBUS valid override value, Read-write
    static constexpr uint32_t OTG_FS_GOTGCTL_AVALOEN = 0x10;       // A-peripheral session valid override enable, Read-write
    static constexpr uint32_t OTG_FS_GOTGCTL_AVALOVAL = 0x20;      // A-peripheral session valid override value, Read-write
    static constexpr uint32_t OTG_FS_GOTGCTL_BVALOEN = 0x40;       // B-peripheral session valid override enable, Read-write
    static constexpr uint32_t OTG_FS_GOTGCTL_BVALOVAL = 0x80;      // B-peripheral session valid override value, Read-write
    static constexpr uint32_t OTG_FS_GOTGCTL_EHEN = 0x1000;        // Embedded host enable, Read-write
    static constexpr uint32_t OTG_FS_GOTGCTL_OTGVER = 0x100000;    // OTG version, Read-write
    static const uint32_t OTG_FS_GOTGCTL_RESET_VALUE = 0x800;

    static constexpr uint32_t OTG_FS_GOTGINT_SEDET = 0x4;          // Session end detected
    static constexpr uint32_t OTG_FS_GOTGINT_SRSSCHG = 0x100;      // Session request success status change
    static constexpr uint32_t OTG_FS_GOTGINT_HNSSCHG = 0x200;      // Host negotiation success status change
    static constexpr uint32_t OTG_FS_GOTGINT_HNGDET = 0x20000;     // Host negotiation detected
    static constexpr uint32_t OTG_FS_GOTGINT_ADTOCHG = 0x40000;    // A-device timeout change
    static constexpr uint32_t OTG_FS_GOTGINT_DBCDNE = 0x80000;     // Debounce done
    static constexpr uint32_t OTG_FS_GOTGINT_IDCHNG = 0x100000;    // ID input pin changed
    static const uint32_t OTG_FS_GOTGINT_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_GAHBCFG_GINT = 0x1;           // Global interrupt mask
    static constexpr uint32_t OTG_FS_GAHBCFG_TXFELVL = 0x80;       // TxFIFO empty level
    static constexpr uint32_t OTG_FS_GAHBCFG_PTXFELVL = 0x100;     // Periodic TxFIFO empty level
    static const uint32_t OTG_FS_GAHBCFG_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_GUSBCFG_TOCAL =               // FS timeout calibration (3 bits), Read-write
        bit_field_t<0, 0x7>::value<X>();
    static constexpr uint32_t OTG_FS_GUSBCFG_PHYSEL = 0x40;        // Full Speed serial transceiver select, Write-only
    static constexpr uint32_t OTG_FS_GUSBCFG_SRPCAP = 0x100;       // SRP-capable, Read-write
    static constexpr uint32_t OTG_FS_GUSBCFG_HNPCAP = 0x200;       // HNP-capable, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_GUSBCFG_TRDT =                // USB turnaround time (4 bits), Read-write
        bit_field_t<10, 0xf>::value<X>();
    static constexpr uint32_t OTG_FS_GUSBCFG_FHMOD = 0x20000000;   // Force host mode, Read-write
    static constexpr uint32_t OTG_FS_GUSBCFG_FDMOD = 0x40000000;   // Force device mode, Read-write
    static const uint32_t OTG_FS_GUSBCFG_RESET_VALUE = 0xa00;

    static constexpr uint32_t OTG_FS_GRSTCTL_CSRST = 0x1;          // Core soft reset, Read-write
    static constexpr uint32_t OTG_FS_GRSTCTL_HSRST = 0x2;          // HCLK soft reset, Read-write
    static constexpr uint32_t OTG_FS_GRSTCTL_FCRST = 0x4;          // Host frame counter reset, Read-write
    static constexpr uint32_t OTG_FS_GRSTCTL_RXFFLSH = 0x10;       // RxFIFO flush, Read-write
    static constexpr uint32_t OTG_FS_GRSTCTL_TXFFLSH = 0x20;       // TxFIFO flush, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_GRSTCTL_TXFNUM =              // TxFIFO number (5 bits), Read-write
        bit_field_t<6, 0x1f>::value<X>();
    static constexpr uint32_t OTG_FS_GRSTCTL_AHBIDL = 0x80000000;  // AHB master idle, Read-only
    static const uint32_t OTG_FS_GRSTCTL_RESET_VALUE = 0x20000000;

    static constexpr uint32_t OTG_FS_GINTSTS_CMOD = 0x1;           // Current mode of operation, Read-only
    static constexpr uint32_t OTG_FS_GINTSTS_MMIS = 0x2;           // Mode mismatch interrupt, Read-write
    static constexpr uint32_t OTG_FS_GINTSTS_OTGINT = 0x4;         // OTG interrupt, Read-only
    static constexpr uint32_t OTG_FS_GINTSTS_SOF = 0x8;            // Start of frame, Read-write
    static constexpr uint32_t OTG_FS_GINTSTS_RXFLVL = 0x10;        // RxFIFO non-empty, Read-only
    static constexpr uint32_t OTG_FS_GINTSTS_NPTXFE = 0x20;        // Non-periodic TxFIFO empty, Read-only
    static constexpr uint32_t OTG_FS_GINTSTS_GINAKEFF = 0x40;      // Global IN non-periodic NAK effective, Read-only
    static constexpr uint32_t OTG_FS_GINTSTS_GOUTNAKEFF = 0x80;    // Global OUT NAK effective, Read-only
    static constexpr uint32_t OTG_FS_GINTSTS_ESUSP = 0x400;        // Early suspend, Read-write
    static constexpr uint32_t OTG_FS_GINTSTS_USBSUSP = 0x800;      // USB suspend, Read-write
    static constexpr uint32_t OTG_FS_GINTSTS_USBRST = 0x1000;      // USB reset, Read-write
    static constexpr uint32_t OTG_FS_GINTSTS_ENUMDNE = 0x2000;     // Enumeration done, Read-write
    static constexpr uint32_t OTG_FS_GINTSTS_ISOODRP = 0x4000;     // Isochronous OUT packet dropped interrupt, Read-write
    static constexpr uint32_t OTG_FS_GINTSTS_EOPF = 0x8000;        // End of periodic frame interrupt, Read-write
    static constexpr uint32_t OTG_FS_GINTSTS_IEPINT = 0x40000;     // IN endpoint interrupt, Read-only
    static constexpr uint32_t OTG_FS_GINTSTS_OEPINT = 0x80000;     // OUT endpoint interrupt, Read-only
    static constexpr uint32_t OTG_FS_GINTSTS_IISOIXFR = 0x100000;  // Incomplete isochronous IN transfer, Read-write
    static constexpr uint32_t OTG_FS_GINTSTS_IPXFR_INCOMPISOOUT = 0x200000;// Incomplete periodic transfer(Host mode)/Incomplete isochronous OUT transfer(Device mode), Read-write
    static constexpr uint32_t OTG_FS_GINTSTS_HPRTINT = 0x1000000;  // Host port interrupt, Read-only
    static constexpr uint32_t OTG_FS_GINTSTS_HCINT = 0x2000000;    // Host channels interrupt, Read-only
    static constexpr uint32_t OTG_FS_GINTSTS_PTXFE = 0x4000000;    // Periodic TxFIFO empty, Read-only
    static constexpr uint32_t OTG_FS_GINTSTS_CIDSCHG = 0x10000000; // Connector ID status change, Read-write
    static constexpr uint32_t OTG_FS_GINTSTS_DISCINT = 0x20000000; // Disconnect detected interrupt, Read-write
    static constexpr uint32_t OTG_FS_GINTSTS_SRQINT = 0x40000000;  // Session request/new session detected interrupt, Read-write
    static constexpr uint32_t OTG_FS_GINTSTS_WKUPINT = 0x80000000; // Resume/remote wakeup detected interrupt, Read-write
    static constexpr uint32_t OTG_FS_GINTSTS_RSTDET = 0x800000;    // Reset detected interrupt, Read-write
    static const uint32_t OTG_FS_GINTSTS_RESET_VALUE = 0x4000020;

    static constexpr uint32_t OTG_FS_GINTMSK_MMISM = 0x2;          // Mode mismatch interrupt mask, Read-write
    static constexpr uint32_t OTG_FS_GINTMSK_OTGINT = 0x4;         // OTG interrupt mask, Read-write
    static constexpr uint32_t OTG_FS_GINTMSK_SOFM = 0x8;           // Start of frame mask, Read-write
    static constexpr uint32_t OTG_FS_GINTMSK_RXFLVLM = 0x10;       // Receive FIFO non-empty mask, Read-write
    static constexpr uint32_t OTG_FS_GINTMSK_NPTXFEM = 0x20;       // Non-periodic TxFIFO empty mask, Read-write
    static constexpr uint32_t OTG_FS_GINTMSK_GINAKEFFM = 0x40;     // Global non-periodic IN NAK effective mask, Read-write
    static constexpr uint32_t OTG_FS_GINTMSK_GONAKEFFM = 0x80;     // Global OUT NAK effective mask, Read-write
    static constexpr uint32_t OTG_FS_GINTMSK_ESUSPM = 0x400;       // Early suspend mask, Read-write
    static constexpr uint32_t OTG_FS_GINTMSK_USBSUSPM = 0x800;     // USB suspend mask, Read-write
    static constexpr uint32_t OTG_FS_GINTMSK_USBRST = 0x1000;      // USB reset mask, Read-write
    static constexpr uint32_t OTG_FS_GINTMSK_ENUMDNEM = 0x2000;    // Enumeration done mask, Read-write
    static constexpr uint32_t OTG_FS_GINTMSK_ISOODRPM = 0x4000;    // Isochronous OUT packet dropped interrupt mask, Read-write
    static constexpr uint32_t OTG_FS_GINTMSK_EOPFM = 0x8000;       // End of periodic frame interrupt mask, Read-write
    static constexpr uint32_t OTG_FS_GINTMSK_IEPINT = 0x40000;     // IN endpoints interrupt mask, Read-write
    static constexpr uint32_t OTG_FS_GINTMSK_OEPINT = 0x80000;     // OUT endpoints interrupt mask, Read-write
    static constexpr uint32_t OTG_FS_GINTMSK_IISOIXFRM = 0x100000; // Incomplete isochronous IN transfer mask, Read-write
    static constexpr uint32_t OTG_FS_GINTMSK_IPXFRM_IISOOXFRM = 0x200000;// Incomplete periodic transfer mask(Host mode)/Incomplete isochronous OUT transfer mask(Device mode), Read-write
    static constexpr uint32_t OTG_FS_GINTMSK_PRTIM = 0x1000000;    // Host port interrupt mask, Read-only
    static constexpr uint32_t OTG_FS_GINTMSK_HCIM = 0x2000000;     // Host channels interrupt mask, Read-write
    static constexpr uint32_t OTG_FS_GINTMSK_PTXFEM = 0x4000000;   // Periodic TxFIFO empty mask, Read-write
    static constexpr uint32_t OTG_FS_GINTMSK_CIDSCHGM = 0x10000000;// Connector ID status change mask, Read-write
    static constexpr uint32_t OTG_FS_GINTMSK_DISCINT = 0x20000000; // Disconnect detected interrupt mask, Read-write
    static constexpr uint32_t OTG_FS_GINTMSK_SRQIM = 0x40000000;   // Session request/new session detected interrupt mask, Read-write
    static constexpr uint32_t OTG_FS_GINTMSK_WUIM = 0x80000000;    // Resume/remote wakeup detected interrupt mask, Read-write
    static constexpr uint32_t OTG_FS_GINTMSK_RSTDETM = 0x800000;   // Reset detected interrupt mask, Read-write
    static constexpr uint32_t OTG_FS_GINTMSK_LPMIN = 0x8000000;    // LPM interrupt mask, Read-write
    static const uint32_t OTG_FS_GINTMSK_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_GRXSTSR_Device_BCNT =                // Byte count (11 bits)
        bit_field_t<4, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_GRXSTSR_Device_CHNUM =               // Endpoint number (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_GRXSTSR_Device_DPID =                // Data PID (2 bits)
        bit_field_t<15, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_GRXSTSR_Device_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_GRXSTSR_Device_FRMNUM =              // Frame number (4 bits)
        bit_field_t<21, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_GRXSTSR_Device_PKTSTS =              // Packet status (4 bits)
        bit_field_t<17, 0xf>::value<X>();
    static const uint32_t OTG_FS_GRXSTSR_Device_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_GRXSTSP_Device_BCNT =                // Byte count (11 bits)
        bit_field_t<4, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_GRXSTSP_Device_CHNUM =               // Channel number (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_GRXSTSP_Device_DPID =                // Data PID (2 bits)
        bit_field_t<15, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_GRXSTSP_Device_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_GRXSTSP_Device_FRMNUM =              // Frame number (4 bits)
        bit_field_t<21, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_GRXSTSP_Device_PKTSTS =              // Packet status (4 bits)
        bit_field_t<17, 0xf>::value<X>();
    static const uint32_t OTG_FS_GRXSTSP_Device_RESET_VALUE = 0x2000400;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_GRXFSIZ_RXFD =                // RxFIFO depth (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_FS_GRXFSIZ_RESET_VALUE = 0x200;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPTXF0_Device_NPTXFD =              // Non-periodic TxFIFO depth (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPTXF0_Device_NPTXFSA =             // Non-periodic transmit RAM start address (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPTXF0_Device_TX0FD =               // Endpoint 0 TxFIFO depth (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPTXF0_Device_TX0FSA =              // Endpoint 0 transmit RAM start address (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_FS_DIEPTXF0_Device_RESET_VALUE = 0x200;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HNPTXSTS_NPTXFSAV =            // Non-periodic TxFIFO space available (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HNPTXSTS_NPTQXSAV =            // Non-periodic transmit request queue space available (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HNPTXSTS_NPTXQTOP =            // Top of the non-periodic transmit request queue (7 bits)
        bit_field_t<24, 0x7f>::value<X>();
    static const uint32_t OTG_FS_HNPTXSTS_RESET_VALUE = 0x80200;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_GI2CCTL_RWDATA =              // I2C Read/Write Data (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_GI2CCTL_REGADDR =             // I2C Register Address (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_GI2CCTL_ADDR =                // I2C Address (7 bits)
        bit_field_t<16, 0x7f>::value<X>();
    static constexpr uint32_t OTG_FS_GI2CCTL_I2CEN = 0x800000;     // I2C Enable
    static constexpr uint32_t OTG_FS_GI2CCTL_ACK = 0x1000000;      // I2C ACK
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_GI2CCTL_I2CDEVADR =           // I2C Device Address (2 bits)
        bit_field_t<26, 0x3>::value<X>();
    static constexpr uint32_t OTG_FS_GI2CCTL_I2CDATSE0 = 0x10000000;// I2C DatSe0 USB mode
    static constexpr uint32_t OTG_FS_GI2CCTL_RW = 0x40000000;      // Read/Write Indicator
    static constexpr uint32_t OTG_FS_GI2CCTL_BSYDNE = 0x80000000;  // I2C Busy/Done
    static const uint32_t OTG_FS_GI2CCTL_RESET_VALUE = 0x2000400;

    static constexpr uint32_t OTG_FS_GCCFG_PWRDWN = 0x10000;     // Power down
    static constexpr uint32_t OTG_FS_GCCFG_BCDEN = 0x20000;      // Battery charging detector (BCD) enable
    static constexpr uint32_t OTG_FS_GCCFG_DCDEN = 0x40000;      // Data contact detection (DCD) mode enable
    static constexpr uint32_t OTG_FS_GCCFG_PDEN = 0x80000;       // Primary detection (PD) mode enable
    static constexpr uint32_t OTG_FS_GCCFG_SDEN = 0x100000;      // Secondary detection (SD) mode enable
    static constexpr uint32_t OTG_FS_GCCFG_VBDEN = 0x200000;     // USB VBUS detection enable
    static constexpr uint32_t OTG_FS_GCCFG_DCDET = 0x1;          // Data contact detection (DCD) status
    static constexpr uint32_t OTG_FS_GCCFG_PDET = 0x2;           // Primary detection (PD) status
    static constexpr uint32_t OTG_FS_GCCFG_SDET = 0x4;           // Secondary detection (SD) status
    static constexpr uint32_t OTG_FS_GCCFG_PS2DET = 0x8;         // DM pull-up detection status
    static const uint32_t OTG_FS_GCCFG_RESET_VALUE = 0x0;


    static const uint32_t OTG_FS_CID_RESET_VALUE = 0x1000;

    static constexpr uint32_t OTG_FS_GLPMCFG_LPMEN = 0x1;          // LPM support enable, Read-write
    static constexpr uint32_t OTG_FS_GLPMCFG_LPMACK = 0x2;         // LPM token acknowledge enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_GLPMCFG_BESL =                // Best effort service latency (4 bits), Read-write
        bit_field_t<2, 0xf>::value<X>();
    static constexpr uint32_t OTG_FS_GLPMCFG_REMWAKE = 0x40;       // bRemoteWake value, Read-write
    static constexpr uint32_t OTG_FS_GLPMCFG_L1SSEN = 0x80;        // L1 Shallow Sleep enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_GLPMCFG_BESLTHRS =            // BESL threshold (4 bits), Read-write
        bit_field_t<8, 0xf>::value<X>();
    static constexpr uint32_t OTG_FS_GLPMCFG_L1DSEN = 0x1000;      // L1 deep sleep enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_GLPMCFG_LPMRST =              // LPM response (2 bits), Read-only
        bit_field_t<13, 0x3>::value<X>();
    static constexpr uint32_t OTG_FS_GLPMCFG_SLPSTS = 0x8000;      // Port sleep status, Read-only
    static constexpr uint32_t OTG_FS_GLPMCFG_L1RSMOK = 0x10000;    // Sleep State Resume OK, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_GLPMCFG_LPMCHIDX =            // LPM Channel Index (4 bits), Read-write
        bit_field_t<17, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_GLPMCFG_LPMRCNT =             // LPM retry count (3 bits), Read-write
        bit_field_t<21, 0x7>::value<X>();
    static constexpr uint32_t OTG_FS_GLPMCFG_SNDLPM = 0x1000000;   // Send LPM transaction, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_GLPMCFG_LPMRCNTSTS =          // LPM retry count status (3 bits), Read-only
        bit_field_t<25, 0x7>::value<X>();
    static constexpr uint32_t OTG_FS_GLPMCFG_ENBESL = 0x10000000;  // Enable best effort service latency, Read-write
    static const uint32_t OTG_FS_GLPMCFG_RESET_VALUE = 0x2000400;

    static constexpr uint32_t OTG_FS_GPWRDN_ADPMEN = 0x1;         // ADP module enable
    static constexpr uint32_t OTG_FS_GPWRDN_ADPIF = 0x800000;     // ADP interrupt flag
    static const uint32_t OTG_FS_GPWRDN_RESET_VALUE = 0x2000400;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_GADPCTL_PRBDSCHG =            // Probe discharge (2 bits), Read-write
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_GADPCTL_PRBDELTA =            // Probe delta (2 bits), Read-write
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_GADPCTL_PRBPER =              // Probe period (2 bits), Read-write
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_GADPCTL_RTIM =                // Ramp time (11 bits), Read-only
        bit_field_t<6, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_FS_GADPCTL_ENAPRB = 0x20000;     // Enable probe, Read-write
    static constexpr uint32_t OTG_FS_GADPCTL_ENASNS = 0x40000;     // Enable sense, Read-write
    static constexpr uint32_t OTG_FS_GADPCTL_ADPRST = 0x80000;     // ADP reset, Read-only
    static constexpr uint32_t OTG_FS_GADPCTL_ADPEN = 0x100000;     // ADP enable, Read-write
    static constexpr uint32_t OTG_FS_GADPCTL_ADPPRBIF = 0x200000;  // ADP probe interrupt flag, Read-write
    static constexpr uint32_t OTG_FS_GADPCTL_ADPSNSIF = 0x400000;  // ADP sense interrupt flag, Read-write
    static constexpr uint32_t OTG_FS_GADPCTL_ADPTOIF = 0x800000;   // ADP timeout interrupt flag, Read-write
    static constexpr uint32_t OTG_FS_GADPCTL_ADPPRBIM = 0x1000000; // ADP probe interrupt mask, Read-write
    static constexpr uint32_t OTG_FS_GADPCTL_ADPSNSIM = 0x2000000; // ADP sense interrupt mask, Read-write
    static constexpr uint32_t OTG_FS_GADPCTL_ADPTOIM = 0x4000000;  // ADP timeout interrupt mask, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_GADPCTL_AR =                  // Access request (2 bits), Read-write
        bit_field_t<27, 0x3>::value<X>();
    static const uint32_t OTG_FS_GADPCTL_RESET_VALUE = 0x2000400;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HPTXFSIZ_PTXSA =               // Host periodic TxFIFO start address (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HPTXFSIZ_PTXFSIZ =             // Host periodic TxFIFO depth (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OTG_FS_HPTXFSIZ_RESET_VALUE = 0x2000600;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPTXF1_INEPTXSA =            // IN endpoint FIFO2 transmit RAM start address (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPTXF1_INEPTXFD =            // IN endpoint TxFIFO depth (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OTG_FS_DIEPTXF1_RESET_VALUE = 0x2000400;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPTXF2_INEPTXSA =            // IN endpoint FIFO3 transmit RAM start address (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPTXF2_INEPTXFD =            // IN endpoint TxFIFO depth (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OTG_FS_DIEPTXF2_RESET_VALUE = 0x2000400;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPTXF3_INEPTXSA =            // IN endpoint FIFO4 transmit RAM start address (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPTXF3_INEPTXFD =            // IN endpoint TxFIFO depth (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OTG_FS_DIEPTXF3_RESET_VALUE = 0x2000400;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPTXF4_INEPTXSA =            // IN endpoint FIFOx transmit RAM start address (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPTXF4_INEPTXFD =            // IN endpoint Tx FIFO depth (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OTG_FS_DIEPTXF4_RESET_VALUE = 0x2000400;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPTXF5_INEPTXSA =            // IN endpoint FIFOx transmit RAM start address (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPTXF5_INEPTXFD =            // IN endpoint Tx FIFO depth (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OTG_FS_DIEPTXF5_RESET_VALUE = 0x2000400;

    static constexpr uint8_t OTG_FS = 67; // USB On The Go FS global interrupt
};

static otg_fs_global_t& OTG_FS_GLOBAL = *reinterpret_cast<otg_fs_global_t*>(0x50000000);

#define HAVE_PERIPHERAL_OTG_FS_GLOBAL


////
//
//    USB on the go high speed
//
////

struct otg_hs_global_t
{
    volatile uint32_t    OTG_HS_GOTGCTL;       // OTG_HS control and status register
    volatile uint32_t    OTG_HS_GOTGINT;       // [Read-write] OTG_HS interrupt register
    volatile uint32_t    OTG_HS_GAHBCFG;       // [Read-write] OTG_HS AHB configuration register
    volatile uint32_t    OTG_HS_GUSBCFG;       // OTG_HS USB configuration register
    volatile uint32_t    OTG_HS_GRSTCTL;       // OTG_HS reset register
    volatile uint32_t    OTG_HS_GINTSTS;       // OTG_HS core interrupt register
    volatile uint32_t    OTG_HS_GINTMSK;       // OTG_HS interrupt mask register
    volatile uint32_t    OTG_HS_GRXSTSR_Host;  // [Read-only] OTG_HS Receive status debug read register (host mode)
    volatile uint32_t    OTG_HS_GRXSTSP_Host;  // [Read-only] OTG_HS status read and pop register (host mode)
    volatile uint32_t    OTG_HS_GRXFSIZ;       // [Read-write] OTG_HS Receive FIFO size register
    volatile uint32_t    OTG_HS_HNPTXFSIZ_Host;// [Read-write] OTG_HS nonperiodic transmit FIFO size register (host mode)
    volatile uint32_t    OTG_HS_GNPTXSTS;      // [Read-only] OTG_HS nonperiodic transmit FIFO/queue status register
    reserved_t<2>        _0;
    volatile uint32_t    OTG_HS_GCCFG;         // [Read-write] OTG_HS general core configuration register
    volatile uint32_t    OTG_HS_CID;           // [Read-write] OTG_HS core ID register
    reserved_t<5>        _1;
    volatile uint32_t    OTG_HS_GLPMCFG;       // OTG core LPM configuration register
    reserved_t<42>       _2;
    volatile uint32_t    OTG_HS_HPTXFSIZ;      // [Read-write] OTG_HS Host periodic transmit FIFO size register
    volatile uint32_t    OTG_HS_DIEPTXF1;      // [Read-write] OTG_HS device IN endpoint transmit FIFO size register
    volatile uint32_t    OTG_HS_DIEPTXF2;      // [Read-write] OTG_HS device IN endpoint transmit FIFO size register
    reserved_t<4>        _3;
    volatile uint32_t    OTG_HS_DIEPTXF3;      // [Read-write] OTG_HS device IN endpoint transmit FIFO size register
    volatile uint32_t    OTG_HS_DIEPTXF4;      // [Read-write] OTG_HS device IN endpoint transmit FIFO size register
    volatile uint32_t    OTG_HS_DIEPTXF5;      // [Read-write] OTG_HS device IN endpoint transmit FIFO size register
    volatile uint32_t    OTG_HS_DIEPTXF6;      // [Read-write] OTG_HS device IN endpoint transmit FIFO size register
    volatile uint32_t    OTG_HS_DIEPTXF7;      // [Read-write] OTG_HS device IN endpoint transmit FIFO size register

    static constexpr uint32_t OTG_HS_GOTGCTL_SRQSCS = 0x1;         // Session request success, Read-only
    static constexpr uint32_t OTG_HS_GOTGCTL_SRQ = 0x2;            // Session request, Read-write
    static constexpr uint32_t OTG_HS_GOTGCTL_HNGSCS = 0x100;       // Host negotiation success, Read-only
    static constexpr uint32_t OTG_HS_GOTGCTL_HNPRQ = 0x200;        // HNP request, Read-write
    static constexpr uint32_t OTG_HS_GOTGCTL_HSHNPEN = 0x400;      // Host set HNP enable, Read-write
    static constexpr uint32_t OTG_HS_GOTGCTL_DHNPEN = 0x800;       // Device HNP enabled, Read-write
    static constexpr uint32_t OTG_HS_GOTGCTL_CIDSTS = 0x10000;     // Connector ID status, Read-only
    static constexpr uint32_t OTG_HS_GOTGCTL_DBCT = 0x20000;       // Long/short debounce time, Read-only
    static constexpr uint32_t OTG_HS_GOTGCTL_ASVLD = 0x40000;      // A-session valid, Read-only
    static constexpr uint32_t OTG_HS_GOTGCTL_BSVLD = 0x80000;      // B-session valid, Read-only
    static constexpr uint32_t OTG_HS_GOTGCTL_EHEN = 0x1000;        // Embedded host enable, Read-write
    static const uint32_t OTG_HS_GOTGCTL_RESET_VALUE = 0x800;

    static constexpr uint32_t OTG_HS_GOTGINT_SEDET = 0x4;          // Session end detected
    static constexpr uint32_t OTG_HS_GOTGINT_SRSSCHG = 0x100;      // Session request success status change
    static constexpr uint32_t OTG_HS_GOTGINT_HNSSCHG = 0x200;      // Host negotiation success status change
    static constexpr uint32_t OTG_HS_GOTGINT_HNGDET = 0x20000;     // Host negotiation detected
    static constexpr uint32_t OTG_HS_GOTGINT_ADTOCHG = 0x40000;    // A-device timeout change
    static constexpr uint32_t OTG_HS_GOTGINT_DBCDNE = 0x80000;     // Debounce done
    static constexpr uint32_t OTG_HS_GOTGINT_IDCHNG = 0x100000;    // ID input pin changed
    static const uint32_t OTG_HS_GOTGINT_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_GAHBCFG_GINT = 0x1;           // Global interrupt mask
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GAHBCFG_HBSTLEN =             // Burst length/type (4 bits)
        bit_field_t<1, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_GAHBCFG_DMAEN = 0x20;         // DMA enable
    static constexpr uint32_t OTG_HS_GAHBCFG_TXFELVL = 0x80;       // TxFIFO empty level
    static constexpr uint32_t OTG_HS_GAHBCFG_PTXFELVL = 0x100;     // Periodic TxFIFO empty level
    static const uint32_t OTG_HS_GAHBCFG_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GUSBCFG_TOCAL =               // FS timeout calibration (3 bits), Read-write
        bit_field_t<0, 0x7>::value<X>();
    static constexpr uint32_t OTG_HS_GUSBCFG_PHYSEL = 0x40;        // USB 2.0 high-speed ULPI PHY or USB 1.1 full-speed serial transceiver select, Write-only
    static constexpr uint32_t OTG_HS_GUSBCFG_SRPCAP = 0x100;       // SRP-capable, Read-write
    static constexpr uint32_t OTG_HS_GUSBCFG_HNPCAP = 0x200;       // HNP-capable, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GUSBCFG_TRDT =                // USB turnaround time (4 bits), Read-write
        bit_field_t<10, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_GUSBCFG_PHYLPCS = 0x8000;     // PHY Low-power clock select, Read-write
    static constexpr uint32_t OTG_HS_GUSBCFG_ULPIFSLS = 0x20000;   // ULPI FS/LS select, Read-write
    static constexpr uint32_t OTG_HS_GUSBCFG_ULPIAR = 0x40000;     // ULPI Auto-resume, Read-write
    static constexpr uint32_t OTG_HS_GUSBCFG_ULPICSM = 0x80000;    // ULPI Clock SuspendM, Read-write
    static constexpr uint32_t OTG_HS_GUSBCFG_ULPIEVBUSD = 0x100000;// ULPI External VBUS Drive, Read-write
    static constexpr uint32_t OTG_HS_GUSBCFG_ULPIEVBUSI = 0x200000;// ULPI external VBUS indicator, Read-write
    static constexpr uint32_t OTG_HS_GUSBCFG_TSDPS = 0x400000;     // TermSel DLine pulsing selection, Read-write
    static constexpr uint32_t OTG_HS_GUSBCFG_PCCI = 0x800000;      // Indicator complement, Read-write
    static constexpr uint32_t OTG_HS_GUSBCFG_PTCI = 0x1000000;     // Indicator pass through, Read-write
    static constexpr uint32_t OTG_HS_GUSBCFG_ULPIIPD = 0x2000000;  // ULPI interface protect disable, Read-write
    static constexpr uint32_t OTG_HS_GUSBCFG_FHMOD = 0x20000000;   // Forced host mode, Read-write
    static constexpr uint32_t OTG_HS_GUSBCFG_FDMOD = 0x40000000;   // Forced peripheral mode, Read-write
    static const uint32_t OTG_HS_GUSBCFG_RESET_VALUE = 0xa00;

    static constexpr uint32_t OTG_HS_GRSTCTL_CSRST = 0x1;          // Core soft reset, Read-write
    static constexpr uint32_t OTG_HS_GRSTCTL_HSRST = 0x2;          // HCLK soft reset, Read-write
    static constexpr uint32_t OTG_HS_GRSTCTL_FCRST = 0x4;          // Host frame counter reset, Read-write
    static constexpr uint32_t OTG_HS_GRSTCTL_RXFFLSH = 0x10;       // RxFIFO flush, Read-write
    static constexpr uint32_t OTG_HS_GRSTCTL_TXFFLSH = 0x20;       // TxFIFO flush, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GRSTCTL_TXFNUM =              // TxFIFO number (5 bits), Read-write
        bit_field_t<6, 0x1f>::value<X>();
    static constexpr uint32_t OTG_HS_GRSTCTL_AHBIDL = 0x80000000;  // AHB master idle, Read-only
    static constexpr uint32_t OTG_HS_GRSTCTL_DMAREQ = 0x40000000;  // DMA request signal enabled for USB OTG HS, Read-only
    static const uint32_t OTG_HS_GRSTCTL_RESET_VALUE = 0x20000000;

    static constexpr uint32_t OTG_HS_GINTSTS_CMOD = 0x1;           // Current mode of operation, Read-only
    static constexpr uint32_t OTG_HS_GINTSTS_MMIS = 0x2;           // Mode mismatch interrupt, Read-write
    static constexpr uint32_t OTG_HS_GINTSTS_OTGINT = 0x4;         // OTG interrupt, Read-only
    static constexpr uint32_t OTG_HS_GINTSTS_SOF = 0x8;            // Start of frame, Read-write
    static constexpr uint32_t OTG_HS_GINTSTS_RXFLVL = 0x10;        // RxFIFO nonempty, Read-only
    static constexpr uint32_t OTG_HS_GINTSTS_NPTXFE = 0x20;        // Nonperiodic TxFIFO empty, Read-only
    static constexpr uint32_t OTG_HS_GINTSTS_GINAKEFF = 0x40;      // Global IN nonperiodic NAK effective, Read-only
    static constexpr uint32_t OTG_HS_GINTSTS_BOUTNAKEFF = 0x80;    // Global OUT NAK effective, Read-only
    static constexpr uint32_t OTG_HS_GINTSTS_ESUSP = 0x400;        // Early suspend, Read-write
    static constexpr uint32_t OTG_HS_GINTSTS_USBSUSP = 0x800;      // USB suspend, Read-write
    static constexpr uint32_t OTG_HS_GINTSTS_USBRST = 0x1000;      // USB reset, Read-write
    static constexpr uint32_t OTG_HS_GINTSTS_ENUMDNE = 0x2000;     // Enumeration done, Read-write
    static constexpr uint32_t OTG_HS_GINTSTS_ISOODRP = 0x4000;     // Isochronous OUT packet dropped interrupt, Read-write
    static constexpr uint32_t OTG_HS_GINTSTS_EOPF = 0x8000;        // End of periodic frame interrupt, Read-write
    static constexpr uint32_t OTG_HS_GINTSTS_IEPINT = 0x40000;     // IN endpoint interrupt, Read-only
    static constexpr uint32_t OTG_HS_GINTSTS_OEPINT = 0x80000;     // OUT endpoint interrupt, Read-only
    static constexpr uint32_t OTG_HS_GINTSTS_IISOIXFR = 0x100000;  // Incomplete isochronous IN transfer, Read-write
    static constexpr uint32_t OTG_HS_GINTSTS_PXFR_INCOMPISOOUT = 0x200000;// Incomplete periodic transfer, Read-write
    static constexpr uint32_t OTG_HS_GINTSTS_DATAFSUSP = 0x400000; // Data fetch suspended, Read-write
    static constexpr uint32_t OTG_HS_GINTSTS_HPRTINT = 0x1000000;  // Host port interrupt, Read-only
    static constexpr uint32_t OTG_HS_GINTSTS_HCINT = 0x2000000;    // Host channels interrupt, Read-only
    static constexpr uint32_t OTG_HS_GINTSTS_PTXFE = 0x4000000;    // Periodic TxFIFO empty, Read-only
    static constexpr uint32_t OTG_HS_GINTSTS_CIDSCHG = 0x10000000; // Connector ID status change, Read-write
    static constexpr uint32_t OTG_HS_GINTSTS_DISCINT = 0x20000000; // Disconnect detected interrupt, Read-write
    static constexpr uint32_t OTG_HS_GINTSTS_SRQINT = 0x40000000;  // Session request/new session detected interrupt, Read-write
    static constexpr uint32_t OTG_HS_GINTSTS_WKUINT = 0x80000000;  // Resume/remote wakeup detected interrupt, Read-write
    static const uint32_t OTG_HS_GINTSTS_RESET_VALUE = 0x4000020;

    static constexpr uint32_t OTG_HS_GINTMSK_MMISM = 0x2;          // Mode mismatch interrupt mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_OTGINT = 0x4;         // OTG interrupt mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_SOFM = 0x8;           // Start of frame mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_RXFLVLM = 0x10;       // Receive FIFO nonempty mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_NPTXFEM = 0x20;       // Nonperiodic TxFIFO empty mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_GINAKEFFM = 0x40;     // Global nonperiodic IN NAK effective mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_GONAKEFFM = 0x80;     // Global OUT NAK effective mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_ESUSPM = 0x400;       // Early suspend mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_USBSUSPM = 0x800;     // USB suspend mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_USBRST = 0x1000;      // USB reset mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_ENUMDNEM = 0x2000;    // Enumeration done mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_ISOODRPM = 0x4000;    // Isochronous OUT packet dropped interrupt mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_EOPFM = 0x8000;       // End of periodic frame interrupt mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_IEPINT = 0x40000;     // IN endpoints interrupt mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_OEPINT = 0x80000;     // OUT endpoints interrupt mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_IISOIXFRM = 0x100000; // Incomplete isochronous IN transfer mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_PXFRM_IISOOXFRM = 0x200000;// Incomplete periodic transfer mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_FSUSPM = 0x400000;    // Data fetch suspended mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_PRTIM = 0x1000000;    // Host port interrupt mask, Read-only
    static constexpr uint32_t OTG_HS_GINTMSK_HCIM = 0x2000000;     // Host channels interrupt mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_PTXFEM = 0x4000000;   // Periodic TxFIFO empty mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_CIDSCHGM = 0x10000000;// Connector ID status change mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_DISCINT = 0x20000000; // Disconnect detected interrupt mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_SRQIM = 0x40000000;   // Session request/new session detected interrupt mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_WUIM = 0x80000000;    // Resume/remote wakeup detected interrupt mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_RSTDE = 0x800000;     // Reset detected interrupt mask, Read-write
    static constexpr uint32_t OTG_HS_GINTMSK_LPMINTM = 0x8000000;  // LPM interrupt mask, Read-write
    static const uint32_t OTG_HS_GINTMSK_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GRXSTSR_Host_BCNT =                // Byte count (11 bits)
        bit_field_t<4, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GRXSTSR_Host_CHNUM =               // Channel number (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GRXSTSR_Host_DPID =                // Data PID (2 bits)
        bit_field_t<15, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GRXSTSR_Host_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GRXSTSR_Host_FRMNUM =              // Frame number (4 bits)
        bit_field_t<21, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GRXSTSR_Host_PKTSTS =              // Packet status (4 bits)
        bit_field_t<17, 0xf>::value<X>();
    static const uint32_t OTG_HS_GRXSTSR_Host_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GRXSTSP_Host_BCNT =                // Byte count (11 bits)
        bit_field_t<4, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GRXSTSP_Host_CHNUM =               // Channel number (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GRXSTSP_Host_DPID =                // Data PID (2 bits)
        bit_field_t<15, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GRXSTSP_Host_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GRXSTSP_Host_FRMNUM =              // Frame number (4 bits)
        bit_field_t<21, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GRXSTSP_Host_PKTSTS =              // Packet status (4 bits)
        bit_field_t<17, 0xf>::value<X>();
    static const uint32_t OTG_HS_GRXSTSP_Host_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GRXFSIZ_RXFD =                // RxFIFO depth (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_GRXFSIZ_RESET_VALUE = 0x200;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HNPTXFSIZ_Host_NPTXFD =              // Nonperiodic TxFIFO depth (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HNPTXFSIZ_Host_NPTXFSA =             // Nonperiodic transmit RAM start address (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HNPTXFSIZ_Host_TX0FD =               // Endpoint 0 TxFIFO depth (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HNPTXFSIZ_Host_TX0FSA =              // Endpoint 0 transmit RAM start address (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_HNPTXFSIZ_Host_RESET_VALUE = 0x200;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GNPTXSTS_NPTXFSAV =            // Nonperiodic TxFIFO space available (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GNPTXSTS_NPTQXSAV =            // Nonperiodic transmit request queue space available (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GNPTXSTS_NPTXQTOP =            // Top of the nonperiodic transmit request queue (7 bits)
        bit_field_t<24, 0x7f>::value<X>();
    static const uint32_t OTG_HS_GNPTXSTS_RESET_VALUE = 0x80200;

    static constexpr uint32_t OTG_HS_GCCFG_PWRDWN = 0x10000;     // Power down
    static constexpr uint32_t OTG_HS_GCCFG_BCDEN = 0x20000;      // Battery charging detector (BCD) enable
    static constexpr uint32_t OTG_HS_GCCFG_DCDEN = 0x40000;      // Data contact detection (DCD) mode enable
    static constexpr uint32_t OTG_HS_GCCFG_PDEN = 0x80000;       // Primary detection (PD) mode enable
    static constexpr uint32_t OTG_HS_GCCFG_SDEN = 0x100000;      // Secondary detection (SD) mode enable
    static constexpr uint32_t OTG_HS_GCCFG_VBDEN = 0x200000;     // USB VBUS detection enable
    static constexpr uint32_t OTG_HS_GCCFG_DCDET = 0x1;          // Data contact detection (DCD) status
    static constexpr uint32_t OTG_HS_GCCFG_PDET = 0x2;           // Primary detection (PD) status
    static constexpr uint32_t OTG_HS_GCCFG_SDET = 0x4;           // Secondary detection (SD) status
    static constexpr uint32_t OTG_HS_GCCFG_PS2DET = 0x8;         // DM pull-up detection status
    static const uint32_t OTG_HS_GCCFG_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_CID_RESET_VALUE = 0x1200;

    static constexpr uint32_t OTG_HS_GLPMCFG_LPMEN = 0x1;          // LPM support enable, Read-write
    static constexpr uint32_t OTG_HS_GLPMCFG_LPMACK = 0x2;         // LPM token acknowledge enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GLPMCFG_BESL =                // Best effort service latency (4 bits), Read-only
        bit_field_t<2, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_GLPMCFG_REMWAKE = 0x40;       // bRemoteWake value, Read-only
    static constexpr uint32_t OTG_HS_GLPMCFG_L1SSEN = 0x80;        // L1 Shallow Sleep enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GLPMCFG_BESLTHRS =            // BESL threshold (4 bits), Read-write
        bit_field_t<8, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_GLPMCFG_L1DSEN = 0x1000;      // L1 deep sleep enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GLPMCFG_LPMRST =              // LPM response (2 bits), Read-only
        bit_field_t<13, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_GLPMCFG_SLPSTS = 0x8000;      // Port sleep status, Read-only
    static constexpr uint32_t OTG_HS_GLPMCFG_L1RSMOK = 0x10000;    // Sleep State Resume OK, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GLPMCFG_LPMCHIDX =            // LPM Channel Index (4 bits), Read-write
        bit_field_t<17, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GLPMCFG_LPMRCNT =             // LPM retry count (3 bits), Read-write
        bit_field_t<21, 0x7>::value<X>();
    static constexpr uint32_t OTG_HS_GLPMCFG_SNDLPM = 0x1000000;   // Send LPM transaction, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_GLPMCFG_LPMRCNTSTS =          // LPM retry count status (3 bits), Read-only
        bit_field_t<25, 0x7>::value<X>();
    static constexpr uint32_t OTG_HS_GLPMCFG_ENBESL = 0x10000000;  // Enable best effort service latency, Read-write
    static const uint32_t OTG_HS_GLPMCFG_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HPTXFSIZ_PTXSA =               // Host periodic TxFIFO start address (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HPTXFSIZ_PTXFD =               // Host periodic TxFIFO depth (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OTG_HS_HPTXFSIZ_RESET_VALUE = 0x2000600;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTXF1_INEPTXSA =            // IN endpoint FIFOx transmit RAM start address (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTXF1_INEPTXFD =            // IN endpoint TxFIFO depth (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DIEPTXF1_RESET_VALUE = 0x2000400;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTXF2_INEPTXSA =            // IN endpoint FIFOx transmit RAM start address (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTXF2_INEPTXFD =            // IN endpoint TxFIFO depth (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DIEPTXF2_RESET_VALUE = 0x2000400;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTXF3_INEPTXSA =            // IN endpoint FIFOx transmit RAM start address (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTXF3_INEPTXFD =            // IN endpoint TxFIFO depth (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DIEPTXF3_RESET_VALUE = 0x2000400;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTXF4_INEPTXSA =            // IN endpoint FIFOx transmit RAM start address (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTXF4_INEPTXFD =            // IN endpoint TxFIFO depth (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DIEPTXF4_RESET_VALUE = 0x2000400;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTXF5_INEPTXSA =            // IN endpoint FIFOx transmit RAM start address (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTXF5_INEPTXFD =            // IN endpoint TxFIFO depth (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DIEPTXF5_RESET_VALUE = 0x2000400;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTXF6_INEPTXSA =            // IN endpoint FIFOx transmit RAM start address (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTXF6_INEPTXFD =            // IN endpoint TxFIFO depth (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DIEPTXF6_RESET_VALUE = 0x2000400;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTXF7_INEPTXSA =            // IN endpoint FIFOx transmit RAM start address (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTXF7_INEPTXFD =            // IN endpoint TxFIFO depth (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DIEPTXF7_RESET_VALUE = 0x2000400;

    static constexpr uint8_t OTG_HS = 77; // USB On The Go HS global interrupt
    static constexpr uint8_t OTG_HS_EP1_IN = 75; // USB On The Go HS End Point 1 In global interrupt
    static constexpr uint8_t OTG_HS_EP1_OUT = 74; // USB On The Go HS End Point 1 Out global interrupt
    static constexpr uint8_t OTG_HS_WKUP = 76; // USB On The Go HS Wakeup through EXTI interrupt
};

static otg_hs_global_t& OTG_HS_GLOBAL = *reinterpret_cast<otg_hs_global_t*>(0x40040000);

#define HAVE_PERIPHERAL_OTG_HS_GLOBAL


////
//
//    Management data input/output slave
//
////

struct mdios_t
{
    volatile uint32_t    CR;                   // [Read-write] MDIOS configuration register
    volatile uint32_t    WRFR;                 // [Read-only] MDIOS write flag register
    volatile uint32_t    CWRFR;                // [Read-write] MDIOS clear write flag register
    volatile uint32_t    RDFR;                 // [Read-only] MDIOS read flag register
    volatile uint32_t    CRDFR;                // [Read-write] MDIOS clear read flag register
    volatile uint32_t    SR;                   // [Read-only] MDIOS status register
    volatile uint32_t    CLRFR;                // [Read-write] MDIOS clear flag register
    volatile uint32_t    DINR0;                // [Read-only] MDIOS input data register 0
    volatile uint32_t    DINR1;                // [Read-only] MDIOS input data register 1
    volatile uint32_t    DINR2;                // [Read-only] MDIOS input data register 2
    volatile uint32_t    DINR3;                // [Read-only] MDIOS input data register 3
    volatile uint32_t    DINR4;                // [Read-only] MDIOS input data register 4
    volatile uint32_t    DINR5;                // [Read-only] MDIOS input data register 5
    volatile uint32_t    DINR6;                // [Read-only] MDIOS input data register 6
    volatile uint32_t    DINR7;                // [Read-only] MDIOS input data register 7
    volatile uint32_t    DINR8;                // [Read-only] MDIOS input data register 8
    volatile uint32_t    DINR9;                // [Read-only] MDIOS input data register 9
    volatile uint32_t    DINR10;               // [Read-only] MDIOS input data register 10
    volatile uint32_t    DINR11;               // [Read-only] MDIOS input data register 11
    volatile uint32_t    DINR12;               // [Read-only] MDIOS input data register 12
    volatile uint32_t    DINR13;               // [Read-only] MDIOS input data register 13
    volatile uint32_t    DINR14;               // [Read-only] MDIOS input data register 14
    volatile uint32_t    DINR15;               // [Read-only] MDIOS input data register 15
    volatile uint32_t    DINR16;               // [Read-only] MDIOS input data register 16
    volatile uint32_t    DINR17;               // [Read-only] MDIOS input data register 17
    volatile uint32_t    DINR18;               // [Read-only] MDIOS input data register 18
    volatile uint32_t    DINR19;               // [Read-only] MDIOS input data register 19
    volatile uint32_t    DINR20;               // [Read-only] MDIOS input data register 20
    volatile uint32_t    DINR21;               // [Read-only] MDIOS input data register 21
    volatile uint32_t    DINR22;               // [Read-only] MDIOS input data register 22
    volatile uint32_t    DINR23;               // [Read-only] MDIOS input data register 23
    volatile uint32_t    DINR24;               // [Read-only] MDIOS input data register 24
    volatile uint32_t    DINR25;               // [Read-only] MDIOS input data register 25
    volatile uint32_t    DINR26;               // [Read-only] MDIOS input data register 26
    volatile uint32_t    DINR27;               // [Read-only] MDIOS input data register 27
    volatile uint32_t    DINR28;               // [Read-only] MDIOS input data register 28
    volatile uint32_t    DINR29;               // [Read-only] MDIOS input data register 29
    volatile uint32_t    DINR30;               // [Read-only] MDIOS input data register 30
    volatile uint32_t    DINR31;               // [Read-only] MDIOS input data register 31
    volatile uint32_t    DOUTR0;               // [Read-write] MDIOS output data register 0
    volatile uint32_t    DOUTR1;               // [Read-write] MDIOS output data register 1
    volatile uint32_t    DOUTR2;               // [Read-write] MDIOS output data register 2
    volatile uint32_t    DOUTR3;               // [Read-write] MDIOS output data register 3
    volatile uint32_t    DOUTR4;               // [Read-write] MDIOS output data register 4
    volatile uint32_t    DOUTR5;               // [Read-write] MDIOS output data register 5
    volatile uint32_t    DOUTR6;               // [Read-write] MDIOS output data register 6
    volatile uint32_t    DOUTR7;               // [Read-write] MDIOS output data register 7
    volatile uint32_t    DOUTR8;               // [Read-write] MDIOS output data register 8
    volatile uint32_t    DOUTR9;               // [Read-write] MDIOS output data register 9
    volatile uint32_t    DOUTR10;              // [Read-write] MDIOS output data register 10
    volatile uint32_t    DOUTR11;              // [Read-write] MDIOS output data register 11
    volatile uint32_t    DOUTR12;              // [Read-write] MDIOS output data register 12
    volatile uint32_t    DOUTR13;              // [Read-write] MDIOS output data register 13
    volatile uint32_t    DOUTR14;              // [Read-write] MDIOS output data register 14
    volatile uint32_t    DOUTR15;              // [Read-write] MDIOS output data register 15
    volatile uint32_t    DOUTR16;              // [Read-write] MDIOS output data register 16
    volatile uint32_t    DOUTR17;              // [Read-write] MDIOS output data register 17
    volatile uint32_t    DOUTR18;              // [Read-write] MDIOS output data register 18
    volatile uint32_t    DOUTR19;              // [Read-write] MDIOS output data register 19
    volatile uint32_t    DOUTR20;              // [Read-write] MDIOS output data register 20
    volatile uint32_t    DOUTR21;              // [Read-write] MDIOS output data register 21
    volatile uint32_t    DOUTR22;              // [Read-write] MDIOS output data register 22
    volatile uint32_t    DOUTR23;              // [Read-write] MDIOS output data register 23
    volatile uint32_t    DOUTR24;              // [Read-write] MDIOS output data register 24
    volatile uint32_t    DOUTR25;              // [Read-write] MDIOS output data register 25
    volatile uint32_t    DOUTR26;              // [Read-write] MDIOS output data register 26
    volatile uint32_t    DOUTR27;              // [Read-write] MDIOS output data register 27
    volatile uint32_t    DOUTR28;              // [Read-write] MDIOS output data register 28
    volatile uint32_t    DOUTR29;              // [Read-write] MDIOS output data register 29
    volatile uint32_t    DOUTR30;              // [Read-write] MDIOS output data register 30
    volatile uint32_t    DOUTR31;              // [Read-write] MDIOS output data register 31

    static constexpr uint32_t CR_EN = 0x1;             // Peripheral enable
    static constexpr uint32_t CR_WRIE = 0x2;           // Register write interrupt enable
    static constexpr uint32_t CR_RDIE = 0x4;           // Register Read Interrupt Enable
    static constexpr uint32_t CR_EIE = 0x8;            // Error interrupt enable
    static constexpr uint32_t CR_DPC = 0x80;           // Disable Preamble Check
    template<uint32_t X>
    static constexpr uint32_t CR_PORT_ADDRESS =        // Slaves's address (5 bits)
        bit_field_t<8, 0x1f>::value<X>();
    static const uint32_t CR_RESET_VALUE = 0x0;


    static const uint32_t WRFR_RESET_VALUE = 0x0;


    static const uint32_t CWRFR_RESET_VALUE = 0x0;


    static const uint32_t RDFR_RESET_VALUE = 0x0;


    static const uint32_t CRDFR_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_PERF = 0x1;           // Preamble error flag
    static constexpr uint32_t SR_SERF = 0x2;           // Start error flag
    static constexpr uint32_t SR_TERF = 0x4;           // Turnaround error flag
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint32_t CLRFR_CPERF = 0x1;          // Clear the preamble error flag
    static constexpr uint32_t CLRFR_CSERF = 0x2;          // Clear the start error flag
    static constexpr uint32_t CLRFR_CTERF = 0x4;          // Clear the turnaround error flag
    static const uint32_t CLRFR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR0_DIN0 =                // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR0_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR1_DIN1 =                // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR2_DIN2 =                // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR3_DIN3 =                // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR4_DIN4 =                // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR5_DIN5 =                // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR6_DIN6 =                // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR6_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR7_DIN7 =                // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR7_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR8_DIN8 =                // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR8_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR9_DIN9 =                // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR9_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR10_DIN10 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR10_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR11_DIN11 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR11_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR12_DIN12 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR12_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR13_DIN13 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR13_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR14_DIN14 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR14_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR15_DIN15 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR15_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR16_DIN16 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR16_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR17_DIN17 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR17_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR18_DIN18 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR18_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR19_DIN19 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR19_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR20_DIN20 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR20_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR21_DIN21 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR21_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR22_DIN22 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR22_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR23_DIN23 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR23_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR24_DIN24 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR24_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR25_DIN25 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR25_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR26_DIN26 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR26_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR27_DIN27 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR27_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR28_DIN28 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR28_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR29_DIN29 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR29_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR30_DIN30 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR30_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DINR31_DIN31 =               // Input data received from MDIO Master during write frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DINR31_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR0_DOUT0 =               // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR0_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR1_DOUT1 =               // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR2_DOUT2 =               // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR3_DOUT3 =               // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR4_DOUT4 =               // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR5_DOUT5 =               // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR6_DOUT6 =               // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR6_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR7_DOUT7 =               // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR7_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR8_DOUT8 =               // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR8_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR9_DOUT9 =               // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR9_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR10_DOUT10 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR10_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR11_DOUT11 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR11_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR12_DOUT12 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR12_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR13_DOUT13 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR13_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR14_DOUT14 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR14_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR15_DOUT15 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR15_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR16_DOUT16 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR16_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR17_DOUT17 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR17_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR18_DOUT18 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR18_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR19_DOUT19 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR19_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR20_DOUT20 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR20_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR21_DOUT21 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR21_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR22_DOUT22 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR22_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR23_DOUT23 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR23_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR24_DOUT24 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR24_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR25_DOUT25 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR25_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR26_DOUT26 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR26_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR27_DOUT27 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR27_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR28_DOUT28 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR28_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR29_DOUT29 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR29_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR30_DOUT30 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR30_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DOUTR31_DOUT31 =              // Output data sent to MDIO Master during read frames (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t DOUTR31_RESET_VALUE = 0x0;

    static constexpr uint8_t MDIOS = 109; // MDIO slave global interrupt
};

static mdios_t& MDIOS = *reinterpret_cast<mdios_t*>(0x40017800);

#define HAVE_PERIPHERAL_MDIOS


////
//
//    Digital filter for sigma delta modulators
//
////

struct dfsdm_t
{
    volatile uint32_t    CHCFG0R1;             // [Read-write] DFSDM channel configuration 0 register 1
    volatile uint32_t    CHCFG0R2;             // [Read-write] DFSDM channel configuration 0 register 2
    volatile uint32_t    AWSCD0R;              // [Read-write] DFSDM analog watchdog and short-circuit detector register
    volatile uint32_t    CHWDAT0R;             // [Read-only] DFSDM channel watchdog filter data register
    volatile uint32_t    CHDATIN0R;            // [Read-write] DFSDM channel data input register
    reserved_t<3>        _0;
    volatile uint32_t    CHCFG1R1;             // [Read-write] DFSDM channel configuration 1 register 1
    volatile uint32_t    CHCFG1R2;             // [Read-write] DFSDM channel configuration 1 register 2
    volatile uint32_t    AWSCD1R;              // [Read-write] DFSDM analog watchdog and short-circuit detector register
    volatile uint32_t    CHWDAT1R;             // [Read-only] DFSDM channel watchdog filter data register
    volatile uint32_t    CHDATIN1R;            // [Read-write] DFSDM channel data input register
    reserved_t<3>        _1;
    volatile uint32_t    CHCFG2R1;             // [Read-write] DFSDM channel configuration 2 register 1
    volatile uint32_t    CHCFG2R2;             // [Read-write] DFSDM channel configuration 2 register 2
    volatile uint32_t    AWSCD2R;              // [Read-write] DFSDM analog watchdog and short-circuit detector register
    volatile uint32_t    CHWDAT2R;             // [Read-only] DFSDM channel watchdog filter data register
    volatile uint32_t    CHDATIN2R;            // [Read-write] DFSDM channel data input register
    reserved_t<3>        _2;
    volatile uint32_t    CHCFG3R1;             // [Read-write] DFSDM channel configuration 3 register 1
    volatile uint32_t    CHCFG3R2;             // [Read-write] DFSDM channel configuration 3 register 2
    volatile uint32_t    AWSCD3R;              // [Read-write] DFSDM analog watchdog and short-circuit detector register
    volatile uint32_t    CHWDAT3R;             // [Read-only] DFSDM channel watchdog filter data register
    volatile uint32_t    CHDATIN3R;            // [Read-write] DFSDM channel data input register
    reserved_t<3>        _3;
    volatile uint32_t    CHCFG4R1;             // [Read-write] DFSDM channel configuration 4 register 1
    volatile uint32_t    CHCFG4R2;             // [Read-write] DFSDM channel configuration 4 register 2
    volatile uint32_t    AWSCD4R;              // [Read-write] DFSDM analog watchdog and short-circuit detector register
    volatile uint32_t    CHWDAT4R;             // [Read-only] DFSDM channel watchdog filter data register
    volatile uint32_t    CHDATIN4R;            // [Read-write] DFSDM channel data input register
    reserved_t<3>        _4;
    volatile uint32_t    CHCFG5R1;             // [Read-write] DFSDM channel configuration 5 register 1
    volatile uint32_t    CHCFG5R2;             // [Read-write] DFSDM channel configuration 5 register 2
    volatile uint32_t    AWSCD5R;              // [Read-write] DFSDM analog watchdog and short-circuit detector register
    volatile uint32_t    CHWDAT5R;             // [Read-only] DFSDM channel watchdog filter data register
    volatile uint32_t    CHDATIN5R;            // [Read-write] DFSDM channel data input register
    reserved_t<3>        _5;
    volatile uint32_t    CHCFG6R1;             // [Read-write] DFSDM channel configuration 6 register 1
    volatile uint32_t    CHCFG6R2;             // [Read-write] DFSDM channel configuration 6 register 2
    volatile uint32_t    AWSCD6R;              // [Read-write] DFSDM analog watchdog and short-circuit detector register
    volatile uint32_t    CHWDAT6R;             // [Read-only] DFSDM channel watchdog filter data register
    volatile uint32_t    CHDATIN6R;            // [Read-write] DFSDM channel data input register
    reserved_t<3>        _6;
    volatile uint32_t    CHCFG7R1;             // [Read-write] DFSDM channel configuration 7 register 1
    volatile uint32_t    CHCFG7R2;             // [Read-write] DFSDM channel configuration 7 register 2
    volatile uint32_t    AWSCD7R;              // [Read-write] DFSDM analog watchdog and short-circuit detector register
    volatile uint32_t    CHWDAT7R;             // [Read-only] DFSDM channel watchdog filter data register
    volatile uint32_t    CHDATIN7R;            // [Read-write] DFSDM channel data input register
    reserved_t<3>        _7;
    volatile uint32_t    DFSDM0_CR1;           // [Read-write] DFSDM control register 1
    volatile uint32_t    DFSDM0_CR2;           // [Read-write] DFSDM control register 2
    volatile uint32_t    DFSDM0_ISR;           // [Read-only] DFSDM interrupt and status register
    volatile uint32_t    DFSDM0_ICR;           // [Read-write] DFSDM interrupt flag clear register
    volatile uint32_t    DFSDM0_JCHGR;         // [Read-write] DFSDM injected channel group selection register
    volatile uint32_t    DFSDM0_FCR;           // [Read-write] DFSDM filter control register
    volatile uint32_t    DFSDM0_JDATAR;        // [Read-only] DFSDM data register for injected group
    volatile uint32_t    DFSDM0_RDATAR;        // [Read-only] DFSDM data register for the regular channel
    volatile uint32_t    DFSDM0_AWHTR;         // [Read-write] DFSDM analog watchdog high threshold register
    volatile uint32_t    DFSDM0_AWLTR;         // [Read-write] DFSDM analog watchdog low threshold register
    volatile uint32_t    DFSDM0_AWSR;          // [Read-only] DFSDM analog watchdog status register
    volatile uint32_t    DFSDM0_AWCFR;         // [Read-write] DFSDM analog watchdog clear flag register
    volatile uint32_t    DFSDM0_EXMAX;         // [Read-only] DFSDM Extremes detector maximum register
    volatile uint32_t    DFSDM0_EXMIN;         // [Read-only] DFSDM Extremes detector minimum register
    volatile uint32_t    DFSDM0_CNVTIMR;       // [Read-only] DFSDM conversion timer register
    reserved_t<17>       _8;
    volatile uint32_t    DFSDM1_CR1;           // [Read-write] DFSDM control register 1
    volatile uint32_t    DFSDM1_CR2;           // [Read-write] DFSDM control register 2
    volatile uint32_t    DFSDM1_ISR;           // [Read-only] DFSDM interrupt and status register
    volatile uint32_t    DFSDM1_ICR;           // [Read-write] DFSDM interrupt flag clear register
    volatile uint32_t    DFSDM1_JCHGR;         // [Read-write] DFSDM injected channel group selection register
    volatile uint32_t    DFSDM1_FCR;           // [Read-write] DFSDM filter control register
    volatile uint32_t    DFSDM1_JDATAR;        // [Read-only] DFSDM data register for injected group
    reserved_t<1>        _9;
    volatile uint32_t    DFSDM1_AWHTR;         // [Read-write] DFSDM analog watchdog high threshold register
    volatile uint32_t    DFSDM1_AWLTR;         // [Read-write] DFSDM analog watchdog low threshold register
    volatile uint32_t    DFSDM1_AWSR;          // [Read-only] DFSDM analog watchdog status register
    volatile uint32_t    DFSDM1_AWCFR;         // [Read-write] DFSDM analog watchdog clear flag register
    volatile uint32_t    DFSDM1_EXMAX;         // [Read-only] DFSDM Extremes detector maximum register
    volatile uint32_t    DFSDM1_EXMIN;         // [Read-only] DFSDM Extremes detector minimum register
    volatile uint32_t    DFSDM1_CNVTIMR;       // [Read-only] DFSDM conversion timer register
    reserved_t<17>       _10;
    volatile uint32_t    DFSDM2_CR1;           // [Read-write] DFSDM control register 1
    volatile uint32_t    DFSDM2_CR2;           // [Read-write] DFSDM control register 2
    volatile uint32_t    DFSDM2_ISR;           // [Read-only] DFSDM interrupt and status register
    volatile uint32_t    DFSDM2_ICR;           // [Read-write] DFSDM interrupt flag clear register
    volatile uint32_t    DFSDM2_JCHGR;         // [Read-write] DFSDM injected channel group selection register
    volatile uint32_t    DFSDM2_FCR;           // [Read-write] DFSDM filter control register
    volatile uint32_t    DFSDM2_JDATAR;        // [Read-only] DFSDM data register for injected group
    reserved_t<1>        _11;
    volatile uint32_t    DFSDM2_AWHTR;         // [Read-write] DFSDM analog watchdog high threshold register
    volatile uint32_t    DFSDM2_AWLTR;         // [Read-write] DFSDM analog watchdog low threshold register
    volatile uint32_t    DFSDM2_AWSR;          // [Read-only] DFSDM analog watchdog status register
    volatile uint32_t    DFSDM2_AWCFR;         // [Read-write] DFSDM analog watchdog clear flag register
    volatile uint32_t    DFSDM2_EXMAX;         // [Read-only] DFSDM Extremes detector maximum register
    volatile uint32_t    DFSDM2_EXMIN;         // [Read-only] DFSDM Extremes detector minimum register
    volatile uint32_t    DFSDM2_CNVTIMR;       // [Read-only] DFSDM conversion timer register
    reserved_t<25>       _12;
    volatile uint32_t    DFSDM3_AWHTR;         // [Read-write] DFSDM analog watchdog high threshold register
    volatile uint32_t    DFSDM3_AWLTR;         // [Read-write] DFSDM analog watchdog low threshold register
    volatile uint32_t    DFSDM3_AWSR;          // [Read-only] DFSDM analog watchdog status register
    volatile uint32_t    DFSDM3_AWCFR;         // [Read-write] DFSDM analog watchdog clear flag register
    volatile uint32_t    DFSDM3_EXMAX;         // [Read-only] DFSDM Extremes detector maximum register
    volatile uint32_t    DFSDM3_EXMIN;         // [Read-only] DFSDM Extremes detector minimum register
    volatile uint32_t    DFSDM3_CNVTIMR;       // [Read-only] DFSDM conversion timer register
    reserved_t<21>       _13;
    volatile uint32_t    DFSDM3_JCHGR;         // [Read-write] DFSDM injected channel group selection register
    volatile uint32_t    DFSDM3_FCR;           // [Read-write] DFSDM filter control register
    volatile uint32_t    DFSDM3_JDATAR;        // [Read-only] DFSDM data register for injected group
    reserved_t<25>       _14;
    volatile uint32_t    DFSDM3_CR1;           // [Read-write] DFSDM control register 1
    volatile uint32_t    DFSDM3_CR2;           // [Read-write] DFSDM control register 2
    volatile uint32_t    DFSDM3_ISR;           // [Read-only] DFSDM interrupt and status register
    volatile uint32_t    DFSDM3_ICR;           // [Read-write] DFSDM interrupt flag clear register

    template<uint32_t X>
    static constexpr uint32_t CHCFG0R1_SITP =                // Serial interface type for channel 0 (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG0R1_SPICKSEL =            // SPI clock select for channel 0 (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t CHCFG0R1_SCDEN = 0x20;         // Short-circuit detector enable on channel 0
    static constexpr uint32_t CHCFG0R1_CKABEN = 0x40;        // Clock absence detector enable on channel 0
    static constexpr uint32_t CHCFG0R1_CHEN = 0x80;          // Channel 0 enable
    static constexpr uint32_t CHCFG0R1_CHINSEL = 0x100;      // Channel inputs selection
    template<uint32_t X>
    static constexpr uint32_t CHCFG0R1_DATMPX =              // Input data multiplexer for channel 0 (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG0R1_DATPACK =             // Data packing mode in DFSDM_CHDATINyR register (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG0R1_CKOUTDIV =            // Output serial clock divider (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static constexpr uint32_t CHCFG0R1_CKOUTSRC = 0x40000000;// Output serial clock source selection
    static constexpr uint32_t CHCFG0R1_DFSDMEN = 0x80000000; // Global enable for DFSDM interface
    static const uint32_t CHCFG0R1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHCFG0R2_DTRBS =               // Data right bit-shift for channel 0 (5 bits)
        bit_field_t<3, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG0R2_OFFSET =              // 24-bit calibration offset for channel 0 (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t CHCFG0R2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AWSCD0R_SCDT =                // short-circuit detector threshold for channel 0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD0R_BKSCD =               // Break signal assignment for short-circuit detector on channel 0 (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD0R_AWFOSR =              // Analog watchdog filter oversampling ratio (decimation rate) on channel 0 (5 bits)
        bit_field_t<16, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD0R_AWFORD =              // Analog watchdog Sinc filter order on channel 0 (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    static const uint32_t AWSCD0R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHWDAT0R_WDATA =               // Input channel y watchdog data (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CHWDAT0R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHDATIN0R_INDAT0 =              // Input data for channel 0 (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHDATIN0R_INDAT1 =              // Input data for channel 1 (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t CHDATIN0R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHCFG1R1_SITP =                // Serial interface type for channel 1 (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG1R1_SPICKSEL =            // SPI clock select for channel 1 (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t CHCFG1R1_SCDEN = 0x20;         // Short-circuit detector enable on channel 1
    static constexpr uint32_t CHCFG1R1_CKABEN = 0x40;        // Clock absence detector enable on channel 1
    static constexpr uint32_t CHCFG1R1_CHEN = 0x80;          // Channel 1 enable
    static constexpr uint32_t CHCFG1R1_CHINSEL = 0x100;      // Channel inputs selection
    template<uint32_t X>
    static constexpr uint32_t CHCFG1R1_DATMPX =              // Input data multiplexer for channel 1 (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG1R1_DATPACK =             // Data packing mode in DFSDM_CHDATINyR register (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG1R1_CKOUTDIV =            // Output serial clock divider (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static constexpr uint32_t CHCFG1R1_CKOUTSRC = 0x40000000;// Output serial clock source selection
    static constexpr uint32_t CHCFG1R1_DFSDMEN = 0x80000000; // Global enable for DFSDM interface
    static const uint32_t CHCFG1R1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHCFG1R2_DTRBS =               // Data right bit-shift for channel 1 (5 bits)
        bit_field_t<3, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG1R2_OFFSET =              // 24-bit calibration offset for channel 1 (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t CHCFG1R2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AWSCD1R_SCDT =                // short-circuit detector threshold for channel 1 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD1R_BKSCD =               // Break signal assignment for short-circuit detector on channel 1 (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD1R_AWFOSR =              // Analog watchdog filter oversampling ratio (decimation rate) on channel 1 (5 bits)
        bit_field_t<16, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD1R_AWFORD =              // Analog watchdog Sinc filter order on channel 1 (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    static const uint32_t AWSCD1R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHWDAT1R_WDATA =               // Input channel y watchdog data (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CHWDAT1R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHDATIN1R_INDAT0 =              // Input data for channel 1 (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHDATIN1R_INDAT1 =              // Input data for channel 2 (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t CHDATIN1R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHCFG2R1_SITP =                // Serial interface type for channel 2 (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG2R1_SPICKSEL =            // SPI clock select for channel 2 (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t CHCFG2R1_SCDEN = 0x20;         // Short-circuit detector enable on channel 2
    static constexpr uint32_t CHCFG2R1_CKABEN = 0x40;        // Clock absence detector enable on channel 2
    static constexpr uint32_t CHCFG2R1_CHEN = 0x80;          // Channel 2 enable
    static constexpr uint32_t CHCFG2R1_CHINSEL = 0x100;      // Channel inputs selection
    template<uint32_t X>
    static constexpr uint32_t CHCFG2R1_DATMPX =              // Input data multiplexer for channel 2 (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG2R1_DATPACK =             // Data packing mode in DFSDM_CHDATINyR register (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG2R1_CKOUTDIV =            // Output serial clock divider (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static constexpr uint32_t CHCFG2R1_CKOUTSRC = 0x40000000;// Output serial clock source selection
    static constexpr uint32_t CHCFG2R1_DFSDMEN = 0x80000000; // Global enable for DFSDM interface
    static const uint32_t CHCFG2R1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHCFG2R2_DTRBS =               // Data right bit-shift for channel 2 (5 bits)
        bit_field_t<3, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG2R2_OFFSET =              // 24-bit calibration offset for channel 2 (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t CHCFG2R2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AWSCD2R_SCDT =                // short-circuit detector threshold for channel 2 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD2R_BKSCD =               // Break signal assignment for short-circuit detector on channel 2 (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD2R_AWFOSR =              // Analog watchdog filter oversampling ratio (decimation rate) on channel 2 (5 bits)
        bit_field_t<16, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD2R_AWFORD =              // Analog watchdog Sinc filter order on channel 2 (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    static const uint32_t AWSCD2R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHWDAT2R_WDATA =               // Input channel y watchdog data (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CHWDAT2R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHDATIN2R_INDAT0 =              // Input data for channel 2 (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHDATIN2R_INDAT1 =              // Input data for channel 3 (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t CHDATIN2R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHCFG3R1_SITP =                // Serial interface type for channel 3 (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG3R1_SPICKSEL =            // SPI clock select for channel 3 (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t CHCFG3R1_SCDEN = 0x20;         // Short-circuit detector enable on channel 3
    static constexpr uint32_t CHCFG3R1_CKABEN = 0x40;        // Clock absence detector enable on channel 3
    static constexpr uint32_t CHCFG3R1_CHEN = 0x80;          // Channel 3 enable
    static constexpr uint32_t CHCFG3R1_CHINSEL = 0x100;      // Channel inputs selection
    template<uint32_t X>
    static constexpr uint32_t CHCFG3R1_DATMPX =              // Input data multiplexer for channel 3 (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG3R1_DATPACK =             // Data packing mode in DFSDM_CHDATINyR register (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG3R1_CKOUTDIV =            // Output serial clock divider (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static constexpr uint32_t CHCFG3R1_CKOUTSRC = 0x40000000;// Output serial clock source selection
    static constexpr uint32_t CHCFG3R1_DFSDMEN = 0x80000000; // Global enable for DFSDM interface
    static const uint32_t CHCFG3R1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHCFG3R2_DTRBS =               // Data right bit-shift for channel 3 (5 bits)
        bit_field_t<3, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG3R2_OFFSET =              // 24-bit calibration offset for channel 3 (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t CHCFG3R2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AWSCD3R_SCDT =                // short-circuit detector threshold for channel 3 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD3R_BKSCD =               // Break signal assignment for short-circuit detector on channel 3 (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD3R_AWFOSR =              // Analog watchdog filter oversampling ratio (decimation rate) on channel 3 (5 bits)
        bit_field_t<16, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD3R_AWFORD =              // Analog watchdog Sinc filter order on channel 3 (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    static const uint32_t AWSCD3R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHWDAT3R_WDATA =               // Input channel y watchdog data (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CHWDAT3R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHDATIN3R_INDAT0 =              // Input data for channel 3 (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHDATIN3R_INDAT1 =              // Input data for channel 4 (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t CHDATIN3R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHCFG4R1_SITP =                // Serial interface type for channel 4 (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG4R1_SPICKSEL =            // SPI clock select for channel 4 (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t CHCFG4R1_SCDEN = 0x20;         // Short-circuit detector enable on channel 4
    static constexpr uint32_t CHCFG4R1_CKABEN = 0x40;        // Clock absence detector enable on channel 4
    static constexpr uint32_t CHCFG4R1_CHEN = 0x80;          // Channel 4 enable
    static constexpr uint32_t CHCFG4R1_CHINSEL = 0x100;      // Channel inputs selection
    template<uint32_t X>
    static constexpr uint32_t CHCFG4R1_DATMPX =              // Input data multiplexer for channel 4 (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG4R1_DATPACK =             // Data packing mode in DFSDM_CHDATINyR register (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG4R1_CKOUTDIV =            // Output serial clock divider (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static constexpr uint32_t CHCFG4R1_CKOUTSRC = 0x40000000;// Output serial clock source selection
    static constexpr uint32_t CHCFG4R1_DFSDMEN = 0x80000000; // Global enable for DFSDM interface
    static const uint32_t CHCFG4R1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHCFG4R2_DTRBS =               // Data right bit-shift for channel 4 (5 bits)
        bit_field_t<3, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG4R2_OFFSET =              // 24-bit calibration offset for channel 4 (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t CHCFG4R2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AWSCD4R_SCDT =                // short-circuit detector threshold for channel 4 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD4R_BKSCD =               // Break signal assignment for short-circuit detector on channel 4 (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD4R_AWFOSR =              // Analog watchdog filter oversampling ratio (decimation rate) on channel 4 (5 bits)
        bit_field_t<16, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD4R_AWFORD =              // Analog watchdog Sinc filter order on channel 4 (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    static const uint32_t AWSCD4R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHWDAT4R_WDATA =               // Input channel y watchdog data (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CHWDAT4R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHDATIN4R_INDAT0 =              // Input data for channel 4 (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHDATIN4R_INDAT1 =              // Input data for channel 5 (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t CHDATIN4R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHCFG5R1_SITP =                // Serial interface type for channel 5 (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG5R1_SPICKSEL =            // SPI clock select for channel 5 (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t CHCFG5R1_SCDEN = 0x20;         // Short-circuit detector enable on channel 5
    static constexpr uint32_t CHCFG5R1_CKABEN = 0x40;        // Clock absence detector enable on channel 5
    static constexpr uint32_t CHCFG5R1_CHEN = 0x80;          // Channel 5 enable
    static constexpr uint32_t CHCFG5R1_CHINSEL = 0x100;      // Channel inputs selection
    template<uint32_t X>
    static constexpr uint32_t CHCFG5R1_DATMPX =              // Input data multiplexer for channel 5 (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG5R1_DATPACK =             // Data packing mode in DFSDM_CHDATINyR register (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG5R1_CKOUTDIV =            // Output serial clock divider (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static constexpr uint32_t CHCFG5R1_CKOUTSRC = 0x40000000;// Output serial clock source selection
    static constexpr uint32_t CHCFG5R1_DFSDMEN = 0x80000000; // Global enable for DFSDM interface
    static const uint32_t CHCFG5R1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHCFG5R2_DTRBS =               // Data right bit-shift for channel 5 (5 bits)
        bit_field_t<3, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG5R2_OFFSET =              // 24-bit calibration offset for channel 5 (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t CHCFG5R2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AWSCD5R_SCDT =                // short-circuit detector threshold for channel 5 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD5R_BKSCD =               // Break signal assignment for short-circuit detector on channel 5 (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD5R_AWFOSR =              // Analog watchdog filter oversampling ratio (decimation rate) on channel 5 (5 bits)
        bit_field_t<16, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD5R_AWFORD =              // Analog watchdog Sinc filter order on channel 5 (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    static const uint32_t AWSCD5R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHWDAT5R_WDATA =               // Input channel y watchdog data (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CHWDAT5R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHDATIN5R_INDAT0 =              // Input data for channel 5 (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHDATIN5R_INDAT1 =              // Input data for channel 6 (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t CHDATIN5R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHCFG6R1_SITP =                // Serial interface type for channel 6 (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG6R1_SPICKSEL =            // SPI clock select for channel 6 (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t CHCFG6R1_SCDEN = 0x20;         // Short-circuit detector enable on channel 6
    static constexpr uint32_t CHCFG6R1_CKABEN = 0x40;        // Clock absence detector enable on channel 6
    static constexpr uint32_t CHCFG6R1_CHEN = 0x80;          // Channel 6 enable
    static constexpr uint32_t CHCFG6R1_CHINSEL = 0x100;      // Channel inputs selection
    template<uint32_t X>
    static constexpr uint32_t CHCFG6R1_DATMPX =              // Input data multiplexer for channel 6 (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG6R1_DATPACK =             // Data packing mode in DFSDM_CHDATINyR register (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG6R1_CKOUTDIV =            // Output serial clock divider (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static constexpr uint32_t CHCFG6R1_CKOUTSRC = 0x40000000;// Output serial clock source selection
    static constexpr uint32_t CHCFG6R1_DFSDMEN = 0x80000000; // Global enable for DFSDM interface
    static const uint32_t CHCFG6R1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHCFG6R2_DTRBS =               // Data right bit-shift for channel 6 (5 bits)
        bit_field_t<3, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG6R2_OFFSET =              // 24-bit calibration offset for channel 6 (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t CHCFG6R2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AWSCD6R_SCDT =                // short-circuit detector threshold for channel 6 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD6R_BKSCD =               // Break signal assignment for short-circuit detector on channel 6 (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD6R_AWFOSR =              // Analog watchdog filter oversampling ratio (decimation rate) on channel 6 (5 bits)
        bit_field_t<16, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD6R_AWFORD =              // Analog watchdog Sinc filter order on channel 6 (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    static const uint32_t AWSCD6R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHWDAT6R_WDATA =               // Input channel y watchdog data (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CHWDAT6R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHDATIN6R_INDAT0 =              // Input data for channel 6 (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHDATIN6R_INDAT1 =              // Input data for channel 7 (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t CHDATIN6R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHCFG7R1_SITP =                // Serial interface type for channel 7 (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG7R1_SPICKSEL =            // SPI clock select for channel 7 (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    static constexpr uint32_t CHCFG7R1_SCDEN = 0x20;         // Short-circuit detector enable on channel 7
    static constexpr uint32_t CHCFG7R1_CKABEN = 0x40;        // Clock absence detector enable on channel 7
    static constexpr uint32_t CHCFG7R1_CHEN = 0x80;          // Channel 7 enable
    static constexpr uint32_t CHCFG7R1_CHINSEL = 0x100;      // Channel inputs selection
    template<uint32_t X>
    static constexpr uint32_t CHCFG7R1_DATMPX =              // Input data multiplexer for channel 7 (2 bits)
        bit_field_t<12, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG7R1_DATPACK =             // Data packing mode in DFSDM_CHDATINyR register (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG7R1_CKOUTDIV =            // Output serial clock divider (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static constexpr uint32_t CHCFG7R1_CKOUTSRC = 0x40000000;// Output serial clock source selection
    static constexpr uint32_t CHCFG7R1_DFSDMEN = 0x80000000; // Global enable for DFSDM interface
    static const uint32_t CHCFG7R1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHCFG7R2_DTRBS =               // Data right bit-shift for channel 7 (5 bits)
        bit_field_t<3, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHCFG7R2_OFFSET =              // 24-bit calibration offset for channel 7 (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t CHCFG7R2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AWSCD7R_SCDT =                // short-circuit detector threshold for channel 7 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD7R_BKSCD =               // Break signal assignment for short-circuit detector on channel 7 (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD7R_AWFOSR =              // Analog watchdog filter oversampling ratio (decimation rate) on channel 7 (5 bits)
        bit_field_t<16, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AWSCD7R_AWFORD =              // Analog watchdog Sinc filter order on channel 7 (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    static const uint32_t AWSCD7R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHWDAT7R_WDATA =               // Input channel y watchdog data (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t CHWDAT7R_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CHDATIN7R_INDAT0 =              // Input data for channel 7 (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CHDATIN7R_INDAT1 =              // Input data for channel 8 (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t CHDATIN7R_RESET_VALUE = 0x0;

    static constexpr uint32_t DFSDM0_CR1_DFEN = 0x1;           // DFSDM enable
    static constexpr uint32_t DFSDM0_CR1_JSWSTART = 0x2;       // Start a conversion of the injected group of channels
    static constexpr uint32_t DFSDM0_CR1_JSYNC = 0x8;          // Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
    static constexpr uint32_t DFSDM0_CR1_JSCAN = 0x10;         // Scanning conversion mode for injected conversions
    static constexpr uint32_t DFSDM0_CR1_JDMAEN = 0x20;        // DMA channel enabled to read data for the injected channel group
    template<uint32_t X>
    static constexpr uint32_t DFSDM0_CR1_JEXTSEL =             // Trigger signal selection for launching injected conversions (5 bits)
        bit_field_t<8, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM0_CR1_JEXTEN =              // Trigger enable and trigger edge selection for injected conversions (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    static constexpr uint32_t DFSDM0_CR1_RSWSTART = 0x20000;   // Software start of a conversion on the regular channel
    static constexpr uint32_t DFSDM0_CR1_RCONT = 0x40000;      // Continuous mode selection for regular conversions
    static constexpr uint32_t DFSDM0_CR1_RSYNC = 0x80000;      // Launch regular conversion synchronously with DFSDM0
    static constexpr uint32_t DFSDM0_CR1_RDMAEN = 0x200000;    // DMA channel enabled to read data for the regular conversion
    template<uint32_t X>
    static constexpr uint32_t DFSDM0_CR1_RCH =                 // Regular channel selection (3 bits)
        bit_field_t<24, 0x7>::value<X>();
    static constexpr uint32_t DFSDM0_CR1_FAST = 0x20000000;    // Fast conversion mode selection for regular conversions
    static constexpr uint32_t DFSDM0_CR1_AWFSEL = 0x40000000;  // Analog watchdog fast mode select
    static const uint32_t DFSDM0_CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t DFSDM0_CR2_JEOCIE = 0x1;         // Injected end of conversion interrupt enable
    static constexpr uint32_t DFSDM0_CR2_REOCIE = 0x2;         // Regular end of conversion interrupt enable
    static constexpr uint32_t DFSDM0_CR2_JOVRIE = 0x4;         // Injected data overrun interrupt enable
    static constexpr uint32_t DFSDM0_CR2_ROVRIE = 0x8;         // Regular data overrun interrupt enable
    static constexpr uint32_t DFSDM0_CR2_AWDIE = 0x10;         // Analog watchdog interrupt enable
    static constexpr uint32_t DFSDM0_CR2_SCDIE = 0x20;         // Short-circuit detector interrupt enable
    static constexpr uint32_t DFSDM0_CR2_CKABIE = 0x40;        // Clock absence interrupt enable
    template<uint32_t X>
    static constexpr uint32_t DFSDM0_CR2_EXCH =                // Extremes detector channel selection (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM0_CR2_AWDCH =               // Analog watchdog channel selection (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static const uint32_t DFSDM0_CR2_RESET_VALUE = 0x0;

    static constexpr uint32_t DFSDM0_ISR_JEOCF = 0x1;          // End of injected conversion flag
    static constexpr uint32_t DFSDM0_ISR_REOCF = 0x2;          // End of regular conversion flag
    static constexpr uint32_t DFSDM0_ISR_JOVRF = 0x4;          // Injected conversion overrun flag
    static constexpr uint32_t DFSDM0_ISR_ROVRF = 0x8;          // Regular conversion overrun flag
    static constexpr uint32_t DFSDM0_ISR_AWDF = 0x10;          // Analog watchdog
    static constexpr uint32_t DFSDM0_ISR_JCIP = 0x2000;        // Injected conversion in progress status
    static constexpr uint32_t DFSDM0_ISR_RCIP = 0x4000;        // Regular conversion in progress status
    template<uint32_t X>
    static constexpr uint32_t DFSDM0_ISR_CKABF =               // Clock absence flag (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM0_ISR_SCDF =                // short-circuit detector flag (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t DFSDM0_ISR_RESET_VALUE = 0xff0000;

    static constexpr uint32_t DFSDM0_ICR_CLRJOVRF = 0x4;       // Clear the injected conversion overrun flag
    static constexpr uint32_t DFSDM0_ICR_CLRROVRF = 0x8;       // Clear the regular conversion overrun flag
    template<uint32_t X>
    static constexpr uint32_t DFSDM0_ICR_CLRCKABF =            // Clear the clock absence flag (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM0_ICR_CLRSCDF =             // Clear the short-circuit detector flag (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t DFSDM0_ICR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM0_JCHGR_JCHG =                // Injected channel group selection (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t DFSDM0_JCHGR_RESET_VALUE = 0x1;

    template<uint32_t X>
    static constexpr uint32_t DFSDM0_FCR_IOSR =                // Integrator oversampling ratio (averaging length) (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM0_FCR_FOSR =                // Sinc filter oversampling ratio (decimation rate) (10 bits)
        bit_field_t<16, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM0_FCR_FORD =                // Sinc filter order (3 bits)
        bit_field_t<29, 0x7>::value<X>();
    static const uint32_t DFSDM0_FCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM0_JDATAR_JDATACH =             // Injected channel most recently converted (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM0_JDATAR_JDATA =               // Injected group conversion data (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t DFSDM0_JDATAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM0_RDATAR_RDATACH =             // Regular channel most recently converted (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static constexpr uint32_t DFSDM0_RDATAR_RPEND = 0x10;         // Regular channel pending data
    template<uint32_t X>
    static constexpr uint32_t DFSDM0_RDATAR_RDATA =               // Regular channel conversion data (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t DFSDM0_RDATAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM0_AWHTR_BKAWH =               // Break signal assignment to analog watchdog high threshold event (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM0_AWHTR_AWHT =                // Analog watchdog high threshold (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t DFSDM0_AWHTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM0_AWLTR_BKAWL =               // Break signal assignment to analog watchdog low threshold event (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM0_AWLTR_AWLT =                // Analog watchdog low threshold (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t DFSDM0_AWLTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM0_AWSR_AWLTF =               // Analog watchdog low threshold flag (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM0_AWSR_AWHTF =               // Analog watchdog high threshold flag (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static const uint32_t DFSDM0_AWSR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM0_AWCFR_CLRAWLTF =            // Clear the analog watchdog low threshold flag (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM0_AWCFR_CLRAWHTF =            // Clear the analog watchdog high threshold flag (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static const uint32_t DFSDM0_AWCFR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM0_EXMAX_EXMAXCH =             // Extremes detector maximum data channel (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM0_EXMAX_EXMAX =               // Extremes detector maximum value (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t DFSDM0_EXMAX_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM0_EXMIN_EXMINCH =             // Extremes detector minimum data channel (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM0_EXMIN_EXMIN =               // Extremes detector minimum value (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t DFSDM0_EXMIN_RESET_VALUE = 0x7fffff00;

    template<uint32_t X>
    static constexpr uint32_t DFSDM0_CNVTIMR_CNVCNT =              // 28-bit timer counting conversion time (28 bits)
        bit_field_t<4, 0xfffffff>::value<X>();
    static const uint32_t DFSDM0_CNVTIMR_RESET_VALUE = 0x0;

    static constexpr uint32_t DFSDM1_CR1_DFEN = 0x1;           // DFSDM enable
    static constexpr uint32_t DFSDM1_CR1_JSWSTART = 0x2;       // Start a conversion of the injected group of channels
    static constexpr uint32_t DFSDM1_CR1_JSYNC = 0x8;          // Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
    static constexpr uint32_t DFSDM1_CR1_JSCAN = 0x10;         // Scanning conversion mode for injected conversions
    static constexpr uint32_t DFSDM1_CR1_JDMAEN = 0x20;        // DMA channel enabled to read data for the injected channel group
    template<uint32_t X>
    static constexpr uint32_t DFSDM1_CR1_JEXTSEL =             // Trigger signal selection for launching injected conversions (5 bits)
        bit_field_t<8, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM1_CR1_JEXTEN =              // Trigger enable and trigger edge selection for injected conversions (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    static constexpr uint32_t DFSDM1_CR1_RSWSTART = 0x20000;   // Software start of a conversion on the regular channel
    static constexpr uint32_t DFSDM1_CR1_RCONT = 0x40000;      // Continuous mode selection for regular conversions
    static constexpr uint32_t DFSDM1_CR1_RSYNC = 0x80000;      // Launch regular conversion synchronously with DFSDM0
    static constexpr uint32_t DFSDM1_CR1_RDMAEN = 0x200000;    // DMA channel enabled to read data for the regular conversion
    template<uint32_t X>
    static constexpr uint32_t DFSDM1_CR1_RCH =                 // Regular channel selection (3 bits)
        bit_field_t<24, 0x7>::value<X>();
    static constexpr uint32_t DFSDM1_CR1_FAST = 0x20000000;    // Fast conversion mode selection for regular conversions
    static constexpr uint32_t DFSDM1_CR1_AWFSEL = 0x40000000;  // Analog watchdog fast mode select
    static const uint32_t DFSDM1_CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t DFSDM1_CR2_JEOCIE = 0x1;         // Injected end of conversion interrupt enable
    static constexpr uint32_t DFSDM1_CR2_REOCIE = 0x2;         // Regular end of conversion interrupt enable
    static constexpr uint32_t DFSDM1_CR2_JOVRIE = 0x4;         // Injected data overrun interrupt enable
    static constexpr uint32_t DFSDM1_CR2_ROVRIE = 0x8;         // Regular data overrun interrupt enable
    static constexpr uint32_t DFSDM1_CR2_AWDIE = 0x10;         // Analog watchdog interrupt enable
    static constexpr uint32_t DFSDM1_CR2_SCDIE = 0x20;         // Short-circuit detector interrupt enable
    static constexpr uint32_t DFSDM1_CR2_CKABIE = 0x40;        // Clock absence interrupt enable
    template<uint32_t X>
    static constexpr uint32_t DFSDM1_CR2_EXCH =                // Extremes detector channel selection (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM1_CR2_AWDCH =               // Analog watchdog channel selection (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static const uint32_t DFSDM1_CR2_RESET_VALUE = 0x0;

    static constexpr uint32_t DFSDM1_ISR_JEOCF = 0x1;          // End of injected conversion flag
    static constexpr uint32_t DFSDM1_ISR_REOCF = 0x2;          // End of regular conversion flag
    static constexpr uint32_t DFSDM1_ISR_JOVRF = 0x4;          // Injected conversion overrun flag
    static constexpr uint32_t DFSDM1_ISR_ROVRF = 0x8;          // Regular conversion overrun flag
    static constexpr uint32_t DFSDM1_ISR_AWDF = 0x10;          // Analog watchdog
    static constexpr uint32_t DFSDM1_ISR_JCIP = 0x2000;        // Injected conversion in progress status
    static constexpr uint32_t DFSDM1_ISR_RCIP = 0x4000;        // Regular conversion in progress status
    template<uint32_t X>
    static constexpr uint32_t DFSDM1_ISR_CKABF =               // Clock absence flag (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM1_ISR_SCDF =                // short-circuit detector flag (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t DFSDM1_ISR_RESET_VALUE = 0xff0000;

    static constexpr uint32_t DFSDM1_ICR_CLRJOVRF = 0x4;       // Clear the injected conversion overrun flag
    static constexpr uint32_t DFSDM1_ICR_CLRROVRF = 0x8;       // Clear the regular conversion overrun flag
    template<uint32_t X>
    static constexpr uint32_t DFSDM1_ICR_CLRCKABF =            // Clear the clock absence flag (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM1_ICR_CLRSCDF =             // Clear the short-circuit detector flag (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t DFSDM1_ICR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM1_JCHGR_JCHG =                // Injected channel group selection (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t DFSDM1_JCHGR_RESET_VALUE = 0x1;

    template<uint32_t X>
    static constexpr uint32_t DFSDM1_FCR_IOSR =                // Integrator oversampling ratio (averaging length) (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM1_FCR_FOSR =                // Sinc filter oversampling ratio (decimation rate) (10 bits)
        bit_field_t<16, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM1_FCR_FORD =                // Sinc filter order (3 bits)
        bit_field_t<29, 0x7>::value<X>();
    static const uint32_t DFSDM1_FCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM1_JDATAR_JDATA =               // Injected group conversion data (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM1_JDATAR_JDATACH =             // Injected channel most recently converted (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM1_JDATAR_RDATA =               // Regular channel conversion data (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM1_JDATAR_RDATACH =             // Regular channel most recently converted (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static constexpr uint32_t DFSDM1_JDATAR_RPEND = 0x10;         // Regular channel pending data
    static const uint32_t DFSDM1_JDATAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM1_AWHTR_BKAWH =               // Break signal assignment to analog watchdog high threshold event (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM1_AWHTR_AWHT =                // Analog watchdog high threshold (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t DFSDM1_AWHTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM1_AWLTR_BKAWL =               // Break signal assignment to analog watchdog low threshold event (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM1_AWLTR_AWLT =                // Analog watchdog low threshold (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t DFSDM1_AWLTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM1_AWSR_AWLTF =               // Analog watchdog low threshold flag (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM1_AWSR_AWHTF =               // Analog watchdog high threshold flag (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static const uint32_t DFSDM1_AWSR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM1_AWCFR_CLRAWLTF =            // Clear the analog watchdog low threshold flag (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM1_AWCFR_CLRAWHTF =            // Clear the analog watchdog high threshold flag (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static const uint32_t DFSDM1_AWCFR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM1_EXMAX_EXMAXCH =             // Extremes detector maximum data channel (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM1_EXMAX_EXMAX =               // Extremes detector maximum value (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t DFSDM1_EXMAX_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM1_EXMIN_EXMINCH =             // Extremes detector minimum data channel (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM1_EXMIN_EXMIN =               // Extremes detector minimum value (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t DFSDM1_EXMIN_RESET_VALUE = 0x7fffff00;

    template<uint32_t X>
    static constexpr uint32_t DFSDM1_CNVTIMR_CNVCNT =              // 28-bit timer counting conversion time (28 bits)
        bit_field_t<4, 0xfffffff>::value<X>();
    static const uint32_t DFSDM1_CNVTIMR_RESET_VALUE = 0x0;

    static constexpr uint32_t DFSDM2_CR1_DFEN = 0x1;           // DFSDM enable
    static constexpr uint32_t DFSDM2_CR1_JSWSTART = 0x2;       // Start a conversion of the injected group of channels
    static constexpr uint32_t DFSDM2_CR1_JSYNC = 0x8;          // Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
    static constexpr uint32_t DFSDM2_CR1_JSCAN = 0x10;         // Scanning conversion mode for injected conversions
    static constexpr uint32_t DFSDM2_CR1_JDMAEN = 0x20;        // DMA channel enabled to read data for the injected channel group
    template<uint32_t X>
    static constexpr uint32_t DFSDM2_CR1_JEXTSEL =             // Trigger signal selection for launching injected conversions (5 bits)
        bit_field_t<8, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM2_CR1_JEXTEN =              // Trigger enable and trigger edge selection for injected conversions (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    static constexpr uint32_t DFSDM2_CR1_RSWSTART = 0x20000;   // Software start of a conversion on the regular channel
    static constexpr uint32_t DFSDM2_CR1_RCONT = 0x40000;      // Continuous mode selection for regular conversions
    static constexpr uint32_t DFSDM2_CR1_RSYNC = 0x80000;      // Launch regular conversion synchronously with DFSDM0
    static constexpr uint32_t DFSDM2_CR1_RDMAEN = 0x200000;    // DMA channel enabled to read data for the regular conversion
    template<uint32_t X>
    static constexpr uint32_t DFSDM2_CR1_RCH =                 // Regular channel selection (3 bits)
        bit_field_t<24, 0x7>::value<X>();
    static constexpr uint32_t DFSDM2_CR1_FAST = 0x20000000;    // Fast conversion mode selection for regular conversions
    static constexpr uint32_t DFSDM2_CR1_AWFSEL = 0x40000000;  // Analog watchdog fast mode select
    static const uint32_t DFSDM2_CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t DFSDM2_CR2_JEOCIE = 0x1;         // Injected end of conversion interrupt enable
    static constexpr uint32_t DFSDM2_CR2_REOCIE = 0x2;         // Regular end of conversion interrupt enable
    static constexpr uint32_t DFSDM2_CR2_JOVRIE = 0x4;         // Injected data overrun interrupt enable
    static constexpr uint32_t DFSDM2_CR2_ROVRIE = 0x8;         // Regular data overrun interrupt enable
    static constexpr uint32_t DFSDM2_CR2_AWDIE = 0x10;         // Analog watchdog interrupt enable
    static constexpr uint32_t DFSDM2_CR2_SCDIE = 0x20;         // Short-circuit detector interrupt enable
    static constexpr uint32_t DFSDM2_CR2_CKABIE = 0x40;        // Clock absence interrupt enable
    template<uint32_t X>
    static constexpr uint32_t DFSDM2_CR2_EXCH =                // Extremes detector channel selection (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM2_CR2_AWDCH =               // Analog watchdog channel selection (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static const uint32_t DFSDM2_CR2_RESET_VALUE = 0x0;

    static constexpr uint32_t DFSDM2_ISR_JEOCF = 0x1;          // End of injected conversion flag
    static constexpr uint32_t DFSDM2_ISR_REOCF = 0x2;          // End of regular conversion flag
    static constexpr uint32_t DFSDM2_ISR_JOVRF = 0x4;          // Injected conversion overrun flag
    static constexpr uint32_t DFSDM2_ISR_ROVRF = 0x8;          // Regular conversion overrun flag
    static constexpr uint32_t DFSDM2_ISR_AWDF = 0x10;          // Analog watchdog
    static constexpr uint32_t DFSDM2_ISR_JCIP = 0x2000;        // Injected conversion in progress status
    static constexpr uint32_t DFSDM2_ISR_RCIP = 0x4000;        // Regular conversion in progress status
    template<uint32_t X>
    static constexpr uint32_t DFSDM2_ISR_CKABF =               // Clock absence flag (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM2_ISR_SCDF =                // short-circuit detector flag (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t DFSDM2_ISR_RESET_VALUE = 0xff0000;

    static constexpr uint32_t DFSDM2_ICR_CLRJOVRF = 0x4;       // Clear the injected conversion overrun flag
    static constexpr uint32_t DFSDM2_ICR_CLRROVRF = 0x8;       // Clear the regular conversion overrun flag
    template<uint32_t X>
    static constexpr uint32_t DFSDM2_ICR_CLRCKABF =            // Clear the clock absence flag (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM2_ICR_CLRSCDF =             // Clear the short-circuit detector flag (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t DFSDM2_ICR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM2_JCHGR_JCHG =                // Injected channel group selection (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t DFSDM2_JCHGR_RESET_VALUE = 0x1;

    template<uint32_t X>
    static constexpr uint32_t DFSDM2_FCR_IOSR =                // Integrator oversampling ratio (averaging length) (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM2_FCR_FOSR =                // Sinc filter oversampling ratio (decimation rate) (10 bits)
        bit_field_t<16, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM2_FCR_FORD =                // Sinc filter order (3 bits)
        bit_field_t<29, 0x7>::value<X>();
    static const uint32_t DFSDM2_FCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM2_JDATAR_JDATA =               // Injected group conversion data (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM2_JDATAR_JDATACH =             // Injected channel most recently converted (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM2_JDATAR_RDATA =               // Regular channel conversion data (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM2_JDATAR_RDATACH =             // Regular channel most recently converted (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static constexpr uint32_t DFSDM2_JDATAR_RPEND = 0x10;         // Regular channel pending data
    static const uint32_t DFSDM2_JDATAR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM2_AWHTR_BKAWH =               // Break signal assignment to analog watchdog high threshold event (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM2_AWHTR_AWHT =                // Analog watchdog high threshold (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t DFSDM2_AWHTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM2_AWLTR_BKAWL =               // Break signal assignment to analog watchdog low threshold event (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM2_AWLTR_AWLT =                // Analog watchdog low threshold (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t DFSDM2_AWLTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM2_AWSR_AWLTF =               // Analog watchdog low threshold flag (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM2_AWSR_AWHTF =               // Analog watchdog high threshold flag (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static const uint32_t DFSDM2_AWSR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM2_AWCFR_CLRAWLTF =            // Clear the analog watchdog low threshold flag (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM2_AWCFR_CLRAWHTF =            // Clear the analog watchdog high threshold flag (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static const uint32_t DFSDM2_AWCFR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM2_EXMAX_EXMAXCH =             // Extremes detector maximum data channel (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM2_EXMAX_EXMAX =               // Extremes detector maximum value (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t DFSDM2_EXMAX_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM2_EXMIN_EXMINCH =             // Extremes detector minimum data channel (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM2_EXMIN_EXMIN =               // Extremes detector minimum value (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t DFSDM2_EXMIN_RESET_VALUE = 0x7fffff00;

    template<uint32_t X>
    static constexpr uint32_t DFSDM2_CNVTIMR_CNVCNT =              // 28-bit timer counting conversion time (28 bits)
        bit_field_t<4, 0xfffffff>::value<X>();
    static const uint32_t DFSDM2_CNVTIMR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM3_AWHTR_BKAWH =               // Break signal assignment to analog watchdog high threshold event (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM3_AWHTR_AWHT =                // Analog watchdog high threshold (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t DFSDM3_AWHTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM3_AWLTR_BKAWL =               // Break signal assignment to analog watchdog low threshold event (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM3_AWLTR_AWLT =                // Analog watchdog low threshold (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t DFSDM3_AWLTR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM3_AWSR_AWLTF =               // Analog watchdog low threshold flag (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM3_AWSR_AWHTF =               // Analog watchdog high threshold flag (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static const uint32_t DFSDM3_AWSR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM3_AWCFR_CLRAWLTF =            // Clear the analog watchdog low threshold flag (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM3_AWCFR_CLRAWHTF =            // Clear the analog watchdog high threshold flag (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static const uint32_t DFSDM3_AWCFR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM3_EXMAX_EXMAXCH =             // Extremes detector maximum data channel (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM3_EXMAX_EXMAX =               // Extremes detector maximum value (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t DFSDM3_EXMAX_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM3_EXMIN_EXMINCH =             // Extremes detector minimum data channel (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM3_EXMIN_EXMIN =               // Extremes detector minimum value (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    static const uint32_t DFSDM3_EXMIN_RESET_VALUE = 0x7fffff00;

    template<uint32_t X>
    static constexpr uint32_t DFSDM3_CNVTIMR_CNVCNT =              // 28-bit timer counting conversion time (28 bits)
        bit_field_t<4, 0xfffffff>::value<X>();
    static const uint32_t DFSDM3_CNVTIMR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM3_JCHGR_JCHG =                // Injected channel group selection (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t DFSDM3_JCHGR_RESET_VALUE = 0x1;

    template<uint32_t X>
    static constexpr uint32_t DFSDM3_FCR_IOSR =                // Integrator oversampling ratio (averaging length) (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM3_FCR_FOSR =                // Sinc filter oversampling ratio (decimation rate) (10 bits)
        bit_field_t<16, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM3_FCR_FORD =                // Sinc filter order (3 bits)
        bit_field_t<29, 0x7>::value<X>();
    static const uint32_t DFSDM3_FCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DFSDM3_JDATAR_JDATA =               // Injected group conversion data (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM3_JDATAR_JDATACH =             // Injected channel most recently converted (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM3_JDATAR_RDATA =               // Regular channel conversion data (24 bits)
        bit_field_t<8, 0xffffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM3_JDATAR_RDATACH =             // Regular channel most recently converted (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    static constexpr uint32_t DFSDM3_JDATAR_RPEND = 0x10;         // Regular channel pending data
    static const uint32_t DFSDM3_JDATAR_RESET_VALUE = 0x0;

    static constexpr uint32_t DFSDM3_CR1_DFEN = 0x1;           // DFSDM enable
    static constexpr uint32_t DFSDM3_CR1_JSWSTART = 0x2;       // Start a conversion of the injected group of channels
    static constexpr uint32_t DFSDM3_CR1_JSYNC = 0x8;          // Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
    static constexpr uint32_t DFSDM3_CR1_JSCAN = 0x10;         // Scanning conversion mode for injected conversions
    static constexpr uint32_t DFSDM3_CR1_JDMAEN = 0x20;        // DMA channel enabled to read data for the injected channel group
    template<uint32_t X>
    static constexpr uint32_t DFSDM3_CR1_JEXTSEL =             // Trigger signal selection for launching injected conversions (5 bits)
        bit_field_t<8, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM3_CR1_JEXTEN =              // Trigger enable and trigger edge selection for injected conversions (2 bits)
        bit_field_t<13, 0x3>::value<X>();
    static constexpr uint32_t DFSDM3_CR1_RSWSTART = 0x20000;   // Software start of a conversion on the regular channel
    static constexpr uint32_t DFSDM3_CR1_RCONT = 0x40000;      // Continuous mode selection for regular conversions
    static constexpr uint32_t DFSDM3_CR1_RSYNC = 0x80000;      // Launch regular conversion synchronously with DFSDM0
    static constexpr uint32_t DFSDM3_CR1_RDMAEN = 0x200000;    // DMA channel enabled to read data for the regular conversion
    template<uint32_t X>
    static constexpr uint32_t DFSDM3_CR1_RCH =                 // Regular channel selection (3 bits)
        bit_field_t<24, 0x7>::value<X>();
    static constexpr uint32_t DFSDM3_CR1_FAST = 0x20000000;    // Fast conversion mode selection for regular conversions
    static constexpr uint32_t DFSDM3_CR1_AWFSEL = 0x40000000;  // Analog watchdog fast mode select
    static const uint32_t DFSDM3_CR1_RESET_VALUE = 0x0;

    static constexpr uint32_t DFSDM3_CR2_JEOCIE = 0x1;         // Injected end of conversion interrupt enable
    static constexpr uint32_t DFSDM3_CR2_REOCIE = 0x2;         // Regular end of conversion interrupt enable
    static constexpr uint32_t DFSDM3_CR2_JOVRIE = 0x4;         // Injected data overrun interrupt enable
    static constexpr uint32_t DFSDM3_CR2_ROVRIE = 0x8;         // Regular data overrun interrupt enable
    static constexpr uint32_t DFSDM3_CR2_AWDIE = 0x10;         // Analog watchdog interrupt enable
    static constexpr uint32_t DFSDM3_CR2_SCDIE = 0x20;         // Short-circuit detector interrupt enable
    static constexpr uint32_t DFSDM3_CR2_CKABIE = 0x40;        // Clock absence interrupt enable
    template<uint32_t X>
    static constexpr uint32_t DFSDM3_CR2_EXCH =                // Extremes detector channel selection (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM3_CR2_AWDCH =               // Analog watchdog channel selection (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static const uint32_t DFSDM3_CR2_RESET_VALUE = 0x0;

    static constexpr uint32_t DFSDM3_ISR_JEOCF = 0x1;          // End of injected conversion flag
    static constexpr uint32_t DFSDM3_ISR_REOCF = 0x2;          // End of regular conversion flag
    static constexpr uint32_t DFSDM3_ISR_JOVRF = 0x4;          // Injected conversion overrun flag
    static constexpr uint32_t DFSDM3_ISR_ROVRF = 0x8;          // Regular conversion overrun flag
    static constexpr uint32_t DFSDM3_ISR_AWDF = 0x10;          // Analog watchdog
    static constexpr uint32_t DFSDM3_ISR_JCIP = 0x2000;        // Injected conversion in progress status
    static constexpr uint32_t DFSDM3_ISR_RCIP = 0x4000;        // Regular conversion in progress status
    template<uint32_t X>
    static constexpr uint32_t DFSDM3_ISR_CKABF =               // Clock absence flag (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM3_ISR_SCDF =                // short-circuit detector flag (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t DFSDM3_ISR_RESET_VALUE = 0xff0000;

    static constexpr uint32_t DFSDM3_ICR_CLRJOVRF = 0x4;       // Clear the injected conversion overrun flag
    static constexpr uint32_t DFSDM3_ICR_CLRROVRF = 0x8;       // Clear the regular conversion overrun flag
    template<uint32_t X>
    static constexpr uint32_t DFSDM3_ICR_CLRCKABF =            // Clear the clock absence flag (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DFSDM3_ICR_CLRSCDF =             // Clear the short-circuit detector flag (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t DFSDM3_ICR_RESET_VALUE = 0x0;

    static constexpr uint8_t DFSDM1_FLT0 = 99; // DFSDM1 Filter 0 global interrupt
    static constexpr uint8_t DFSDM1_FLT1 = 100; // DFSDM1 Filter 1 global interrupt
    static constexpr uint8_t DFSDM1_FLT2 = 101; // DFSDM1 Filter 2 global interrupt
    static constexpr uint8_t DFSDM1_FLT3 = 102; // DFSDM1 Filter 3 global interrupt
};

static dfsdm_t& DFSDM = *reinterpret_cast<dfsdm_t*>(0x40017400);

#define HAVE_PERIPHERAL_DFSDM


////
//
//    JPEG codec
//
////

struct jpeg_t
{
    volatile uint32_t    CONFR0;               // [Write-only] JPEG codec configuration register 0
    volatile uint32_t    CONFR1;               // [Read-write] JPEG codec configuration register 1
    volatile uint32_t    CONFR2;               // [Read-write] JPEG codec configuration register 2
    volatile uint32_t    CONFR3;               // [Read-write] JPEG codec configuration register 3
    volatile uint32_t    CONFR4;               // [Read-write] JPEG codec configuration register 4
    volatile uint32_t    CONFR5;               // [Read-write] JPEG codec configuration register 5
    volatile uint32_t    CONFR6;               // [Read-write] JPEG codec configuration register 6
    volatile uint32_t    CONFR7;               // [Read-write] JPEG codec configuration register 7
    reserved_t<4>        _0;
    volatile uint32_t    CR;                   // JPEG control register
    volatile uint32_t    SR;                   // [Read-only] JPEG status register
    volatile uint32_t    CFR;                  // [Write-only] JPEG clear flag register
    reserved_t<1>        _1;
    volatile uint32_t    DIR;                  // [Write-only] JPEG data input register
    volatile uint32_t    DOR;                  // [Read-only] JPEG data output register
    reserved_t<2>        _2;
    volatile uint32_t    QMEM0_0;              // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM0_1;              // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM0_2;              // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM0_3;              // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM0_4;              // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM0_5;              // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM0_6;              // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM0_7;              // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM0_8;              // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM0_9;              // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM0_10;             // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM0_11;             // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM0_12;             // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM0_13;             // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM0_14;             // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM0_15;             // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM1_0;              // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM1_1;              // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM1_2;              // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM1_3;              // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM1_4;              // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM1_5;              // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM1_6;              // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM1_7;              // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM1_8;              // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM1_9;              // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM1_10;             // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM1_11;             // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM1_12;             // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM1_13;             // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM1_14;             // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM1_15;             // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM2_0;              // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM2_1;              // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM2_2;              // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM2_3;              // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM2_4;              // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM2_5;              // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM2_6;              // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM2_7;              // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM2_8;              // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM2_9;              // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM2_10;             // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM2_11;             // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM2_12;             // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM2_13;             // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM2_14;             // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM2_15;             // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM3_0;              // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM3_1;              // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM3_2;              // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM3_3;              // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM3_4;              // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM3_5;              // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM3_6;              // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM3_7;              // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM3_8;              // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM3_9;              // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM3_10;             // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM3_11;             // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM3_12;             // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM3_13;             // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM3_14;             // [Read-write] JPEG quantization tables
    volatile uint32_t    QMEM3_15;             // [Read-write] JPEG quantization tables
    volatile uint32_t    HUFFMIN_0;            // [Read-write] JPEG HuffMin tables
    volatile uint32_t    HUFFMIN_1;            // [Read-write] JPEG HuffMin tables
    volatile uint32_t    HUFFMIN_2;            // [Read-write] JPEG HuffMin tables
    volatile uint32_t    HUFFMIN_3;            // [Read-write] JPEG HuffMin tables
    volatile uint32_t    HUFFMIN_4;            // [Read-write] JPEG HuffMin tables
    volatile uint32_t    HUFFMIN_5;            // [Read-write] JPEG HuffMin tables
    volatile uint32_t    HUFFMIN_6;            // [Read-write] JPEG HuffMin tables
    volatile uint32_t    HUFFMIN_7;            // [Read-write] JPEG HuffMin tables
    volatile uint32_t    HUFFMIN_8;            // [Read-write] JPEG HuffMin tables
    volatile uint32_t    HUFFMIN_9;            // [Read-write] JPEG HuffMin tables
    volatile uint32_t    HUFFMIN_10;           // [Read-write] JPEG HuffMin tables
    volatile uint32_t    HUFFMIN_11;           // [Read-write] JPEG HuffMin tables
    volatile uint32_t    HUFFMIN_12;           // [Read-write] JPEG HuffMin tables
    volatile uint32_t    HUFFMIN_13;           // [Read-write] JPEG HuffMin tables
    volatile uint32_t    HUFFMIN_14;           // [Read-write] JPEG HuffMin tables
    volatile uint32_t    HUFFMIN_15;           // [Read-write] JPEG HuffMin tables
    volatile uint32_t    HUFFBASE0;            // [Read-write] JPEG HuffSymb tables
    volatile uint32_t    HUFFBASE1;            // [Read-write] JPEG HuffSymb tables
    volatile uint32_t    HUFFBASE2;            // [Read-write] JPEG HuffSymb tables
    volatile uint32_t    HUFFBASE3;            // [Read-write] JPEG HuffSymb tables
    volatile uint32_t    HUFFBASE4;            // [Read-write] JPEG HuffSymb tables
    volatile uint32_t    HUFFBASE5;            // [Read-write] JPEG HuffSymb tables
    volatile uint32_t    HUFFBASE6;            // [Read-write] JPEG HuffSymb tables
    volatile uint32_t    HUFFBASE7;            // [Read-write] JPEG HuffSymb tables
    volatile uint32_t    HUFFBASE8;            // [Read-write] JPEG HuffSymb tables
    volatile uint32_t    HUFFBASE9;            // [Read-write] JPEG HuffSymb tables
    volatile uint32_t    HUFFBASE10;           // [Read-write] JPEG HuffSymb tables
    volatile uint32_t    HUFFBASE11;           // [Read-write] JPEG HuffSymb tables
    volatile uint32_t    HUFFBASE12;           // [Read-write] JPEG HuffSymb tables
    volatile uint32_t    HUFFBASE13;           // [Read-write] JPEG HuffSymb tables
    volatile uint32_t    HUFFBASE14;           // [Read-write] JPEG HuffSymb tables
    volatile uint32_t    HUFFBASE15;           // [Read-write] JPEG HuffSymb tables
    volatile uint32_t    HUFFBASE16;           // [Read-write] JPEG HuffSymb tables
    volatile uint32_t    HUFFBASE17;           // [Read-write] JPEG HuffSymb tables
    volatile uint32_t    HUFFBASE18;           // [Read-write] JPEG HuffSymb tables
    volatile uint32_t    HUFFBASE19;           // [Read-write] JPEG HuffSymb tables
    volatile uint32_t    HUFFBASE20;           // [Read-write] JPEG HuffSymb tables
    volatile uint32_t    HUFFBASE21;           // [Read-write] JPEG HuffSymb tables
    volatile uint32_t    HUFFBASE22;           // [Read-write] JPEG HuffSymb tables
    volatile uint32_t    HUFFBASE23;           // [Read-write] JPEG HuffSymb tables
    volatile uint32_t    HUFFBASE24;           // [Read-write] JPEG HuffSymb tables
    volatile uint32_t    HUFFBASE25;           // [Read-write] JPEG HuffSymb tables
    volatile uint32_t    HUFFBASE26;           // [Read-write] JPEG HuffSymb tables
    volatile uint32_t    HUFFBASE27;           // [Read-write] JPEG HuffSymb tables
    volatile uint32_t    HUFFBASE28;           // [Read-write] JPEG HuffSymb tables
    volatile uint32_t    HUFFBASE29;           // [Read-write] JPEG HuffSymb tables
    volatile uint32_t    HUFFBASE30;           // [Read-write] JPEG HuffSymb tables
    volatile uint32_t    HUFFBASE31;           // [Read-write] JPEG HuffSymb tables
    volatile uint32_t    HUFFSYMB0;            // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB1;            // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB2;            // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB3;            // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB4;            // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB5;            // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB6;            // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB7;            // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB8;            // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB9;            // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB10;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB11;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB12;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB13;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB14;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB15;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB16;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB17;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB18;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB19;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB20;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB21;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB22;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB23;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB24;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB25;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB26;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB27;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB28;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB29;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB30;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB31;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB32;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB33;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB34;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB35;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB36;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB37;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB38;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB39;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB40;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB41;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB42;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB43;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB44;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB45;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB46;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB47;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB48;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB49;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB50;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB51;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB52;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB53;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB54;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB55;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB56;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB57;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB58;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB59;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB60;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB61;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB62;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB63;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB64;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB65;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB66;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB67;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB68;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB69;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB70;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB71;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB72;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB73;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB74;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB75;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB76;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB77;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB78;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB79;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB80;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB81;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB82;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    HUFFSYMB83;           // [Read-write] JPEG HUFFSYMB tables
    volatile uint32_t    DHTMEM0;              // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM2;              // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM3;              // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM4;              // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM5;              // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM6;              // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM7;              // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM8;              // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM9;              // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM10;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM11;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM12;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM13;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM14;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM15;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM16;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM17;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM18;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM19;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM20;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM21;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM22;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM23;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM24;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM25;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM26;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM27;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM28;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM29;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM30;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM31;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM32;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM33;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM34;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM35;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM36;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM37;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM38;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM39;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM40;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM41;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM42;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM43;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM44;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM45;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM46;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM47;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM48;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM49;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM50;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM51;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM52;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM53;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM54;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM55;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM56;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM57;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM58;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM59;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM60;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM61;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM62;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM63;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM64;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM65;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM66;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM67;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM68;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM69;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM70;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM71;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM72;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM73;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM74;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM75;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM76;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM77;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM78;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM79;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM80;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM81;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM82;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM83;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM84;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM85;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM86;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM87;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM88;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM89;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM90;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM91;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM92;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM93;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM94;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM95;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM96;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM97;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM98;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM99;             // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM100;            // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM101;            // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM102;            // [Read-write] JPEG DHTMem tables
    volatile uint32_t    DHTMEM103;            // [Read-write] JPEG DHTMem tables
    reserved_t<1>        _3;
    volatile uint32_t    HUFFENC_AC0_0;        // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_1;        // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_2;        // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_3;        // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_4;        // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_5;        // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_6;        // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_7;        // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_8;        // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_9;        // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_10;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_11;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_12;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_13;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_14;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_15;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_16;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_17;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_18;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_19;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_20;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_21;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_22;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_23;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_24;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_25;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_26;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_27;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_28;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_29;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_30;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_31;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_32;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_33;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_34;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_35;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_36;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_37;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_38;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_39;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_40;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_41;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_42;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_43;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_44;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_45;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_46;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_47;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_48;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_49;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_50;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_51;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_52;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_53;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_54;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_55;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_56;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_57;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_58;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_59;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_60;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_61;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_62;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_63;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_64;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_65;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_66;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_67;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_68;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_69;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_70;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_71;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_72;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_73;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_74;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_75;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_76;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_77;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_78;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_79;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_80;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_81;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_82;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_83;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_84;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_85;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_86;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC0_87;       // [Read-write] JPEG encoder, AC Huffman table 0
    volatile uint32_t    HUFFENC_AC1_0;        // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_1;        // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_2;        // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_3;        // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_4;        // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_5;        // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_6;        // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_7;        // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_8;        // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_9;        // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_10;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_11;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_12;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_13;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_14;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_15;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_16;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_17;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_18;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_19;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_20;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_21;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_22;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_23;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_24;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_25;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_26;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_27;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_28;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_29;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_30;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_31;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_32;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_33;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_34;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_35;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_36;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_37;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_38;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_39;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_40;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_41;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_42;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_43;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_44;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_45;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_46;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_47;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_48;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_49;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_50;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_51;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_52;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_53;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_54;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_55;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_56;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_57;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_58;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_59;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_60;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_61;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_62;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_63;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_64;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_65;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_66;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_67;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_68;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_69;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_70;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_71;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_72;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_73;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_74;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_75;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_76;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_77;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_78;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_79;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_80;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_81;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_82;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_83;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_84;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_85;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_86;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_AC1_87;       // [Read-write] JPEG encoder, AC Huffman table 1
    volatile uint32_t    HUFFENC_DC0_0;        // [Read-write] JPEG encoder, DC Huffman table 0
    volatile uint32_t    HUFFENC_DC0_1;        // [Read-write] JPEG encoder, DC Huffman table 0
    volatile uint32_t    HUFFENC_DC0_2;        // [Read-write] JPEG encoder, DC Huffman table 0
    volatile uint32_t    HUFFENC_DC0_3;        // [Read-write] JPEG encoder, DC Huffman table 0
    volatile uint32_t    HUFFENC_DC0_4;        // [Read-write] JPEG encoder, DC Huffman table 0
    volatile uint32_t    HUFFENC_DC0_5;        // [Read-write] JPEG encoder, DC Huffman table 0
    volatile uint32_t    HUFFENC_DC0_6;        // [Read-write] JPEG encoder, DC Huffman table 0
    volatile uint32_t    HUFFENC_DC0_7;        // [Read-write] JPEG encoder, DC Huffman table 0
    volatile uint32_t    HUFFENC_DC1_0;        // [Read-write] JPEG encoder, DC Huffman table 1
    volatile uint32_t    HUFFENC_DC1_1;        // [Read-write] JPEG encoder, DC Huffman table 1
    volatile uint32_t    HUFFENC_DC1_2;        // [Read-write] JPEG encoder, DC Huffman table 1
    volatile uint32_t    HUFFENC_DC1_3;        // [Read-write] JPEG encoder, DC Huffman table 1
    volatile uint32_t    HUFFENC_DC1_4;        // [Read-write] JPEG encoder, DC Huffman table 1
    volatile uint32_t    HUFFENC_DC1_5;        // [Read-write] JPEG encoder, DC Huffman table 1
    volatile uint32_t    HUFFENC_DC1_6;        // [Read-write] JPEG encoder, DC Huffman table 1
    volatile uint32_t    HUFFENC_DC1_7;        // [Read-write] JPEG encoder, DC Huffman table 1

    static constexpr uint32_t CONFR0_START = 0x1;          // Start
    static const uint32_t CONFR0_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CONFR1_NF =                  // Number of color components (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static constexpr uint32_t CONFR1_DE = 0x8;             // Decoding Enable
    template<uint32_t X>
    static constexpr uint32_t CONFR1_COLORSPACE =          // Color Space (2 bits)
        bit_field_t<4, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CONFR1_NS =                  // Number of components for Scan (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t CONFR1_HDR = 0x100;          // Header Processing
    template<uint32_t X>
    static constexpr uint32_t CONFR1_YSIZE =               // Y Size (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t CONFR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CONFR2_NMCU =                // Number of MCU (26 bits)
        bit_field_t<0, 0x3ffffff>::value<X>();
    static const uint32_t CONFR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CONFR3_XSIZE =               // X size (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t CONFR3_RESET_VALUE = 0x0;

    static constexpr uint32_t CONFR4_HD = 0x1;             // Huffman DC
    static constexpr uint32_t CONFR4_HA = 0x2;             // Huffman AC
    template<uint32_t X>
    static constexpr uint32_t CONFR4_QT =                  // Quantization Table (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CONFR4_NB =                  // Number of Block (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CONFR4_VSF =                 // Vertical Sampling Factor (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CONFR4_HSF =                 // Horizontal Sampling Factor (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    static const uint32_t CONFR4_RESET_VALUE = 0x0;

    static constexpr uint32_t CONFR5_HD = 0x1;             // Huffman DC
    static constexpr uint32_t CONFR5_HA = 0x2;             // Huffman AC
    template<uint32_t X>
    static constexpr uint32_t CONFR5_QT =                  // Quantization Table (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CONFR5_NB =                  // Number of Block (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CONFR5_VSF =                 // Vertical Sampling Factor (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CONFR5_HSF =                 // Horizontal Sampling Factor (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    static const uint32_t CONFR5_RESET_VALUE = 0x0;

    static constexpr uint32_t CONFR6_HD = 0x1;             // Huffman DC
    static constexpr uint32_t CONFR6_HA = 0x2;             // Huffman AC
    template<uint32_t X>
    static constexpr uint32_t CONFR6_QT =                  // Quantization Table (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CONFR6_NB =                  // Number of Block (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CONFR6_VSF =                 // Vertical Sampling Factor (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CONFR6_HSF =                 // Horizontal Sampling Factor (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    static const uint32_t CONFR6_RESET_VALUE = 0x0;

    static constexpr uint32_t CONFR7_HD = 0x1;             // Huffman DC
    static constexpr uint32_t CONFR7_HA = 0x2;             // Huffman AC
    template<uint32_t X>
    static constexpr uint32_t CONFR7_QT =                  // Quantization Table (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CONFR7_NB =                  // Number of Block (4 bits)
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CONFR7_VSF =                 // Vertical Sampling Factor (4 bits)
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CONFR7_HSF =                 // Horizontal Sampling Factor (4 bits)
        bit_field_t<12, 0xf>::value<X>();
    static const uint32_t CONFR7_RESET_VALUE = 0x0;

    static constexpr uint32_t CR_JCEN = 0x1;           // JPEG Core Enable, Read-write
    static constexpr uint32_t CR_IFTIE = 0x2;          // Input FIFO Threshold Interrupt Enable, Read-write
    static constexpr uint32_t CR_IFNFIE = 0x4;         // Input FIFO Not Full Interrupt Enable, Read-write
    static constexpr uint32_t CR_OFTIE = 0x8;          // Output FIFO Threshold Interrupt Enable, Read-write
    static constexpr uint32_t CR_OFNEIE = 0x10;        // Output FIFO Not Empty Interrupt Enable, Read-write
    static constexpr uint32_t CR_EOCIE = 0x20;         // End of Conversion Interrupt Enable, Read-write
    static constexpr uint32_t CR_HPDIE = 0x40;         // Header Parsing Done Interrupt Enable, Read-write
    static constexpr uint32_t CR_IDMAEN = 0x800;       // Input DMA Enable, Read-write
    static constexpr uint32_t CR_ODMAEN = 0x1000;      // Output DMA Enable, Read-write
    static constexpr uint32_t CR_IFF = 0x2000;         // Input FIFO Flush, Read-only
    static constexpr uint32_t CR_OFF = 0x4000;         // Output FIFO Flush, Read-only
    static const uint32_t CR_RESET_VALUE = 0x0;

    static constexpr uint32_t SR_IFTF = 0x2;           // Input FIFO Threshold Flag
    static constexpr uint32_t SR_IFNFF = 0x4;          // Input FIFO Not Full Flag
    static constexpr uint32_t SR_OFTF = 0x8;           // Output FIFO Threshold Flag
    static constexpr uint32_t SR_OFNEF = 0x10;         // Output FIFO Not Empty Flag
    static constexpr uint32_t SR_EOCF = 0x20;          // End of Conversion Flag
    static constexpr uint32_t SR_HPDF = 0x40;          // Header Parsing Done Flag
    static constexpr uint32_t SR_COF = 0x80;           // Codec Operation Flag
    static const uint32_t SR_RESET_VALUE = 0x0;

    static constexpr uint32_t CFR_CEOCF = 0x20;         // Clear End of Conversion Flag
    static constexpr uint32_t CFR_CHPDF = 0x40;         // Clear Header Parsing Done Flag
    static const uint32_t CFR_RESET_VALUE = 0x0;


    static const uint32_t DIR_RESET_VALUE = 0x0;


    static const uint32_t DOR_RESET_VALUE = 0x0;


    static const uint32_t QMEM0_0_RESET_VALUE = 0x0;


    static const uint32_t QMEM0_1_RESET_VALUE = 0x0;


    static const uint32_t QMEM0_2_RESET_VALUE = 0x0;


    static const uint32_t QMEM0_3_RESET_VALUE = 0x0;


    static const uint32_t QMEM0_4_RESET_VALUE = 0x0;


    static const uint32_t QMEM0_5_RESET_VALUE = 0x0;


    static const uint32_t QMEM0_6_RESET_VALUE = 0x0;


    static const uint32_t QMEM0_7_RESET_VALUE = 0x0;


    static const uint32_t QMEM0_8_RESET_VALUE = 0x0;


    static const uint32_t QMEM0_9_RESET_VALUE = 0x0;


    static const uint32_t QMEM0_10_RESET_VALUE = 0x0;


    static const uint32_t QMEM0_11_RESET_VALUE = 0x0;


    static const uint32_t QMEM0_12_RESET_VALUE = 0x0;


    static const uint32_t QMEM0_13_RESET_VALUE = 0x0;


    static const uint32_t QMEM0_14_RESET_VALUE = 0x0;


    static const uint32_t QMEM0_15_RESET_VALUE = 0x0;


    static const uint32_t QMEM1_0_RESET_VALUE = 0x0;


    static const uint32_t QMEM1_1_RESET_VALUE = 0x0;


    static const uint32_t QMEM1_2_RESET_VALUE = 0x0;


    static const uint32_t QMEM1_3_RESET_VALUE = 0x0;


    static const uint32_t QMEM1_4_RESET_VALUE = 0x0;


    static const uint32_t QMEM1_5_RESET_VALUE = 0x0;


    static const uint32_t QMEM1_6_RESET_VALUE = 0x0;


    static const uint32_t QMEM1_7_RESET_VALUE = 0x0;


    static const uint32_t QMEM1_8_RESET_VALUE = 0x0;


    static const uint32_t QMEM1_9_RESET_VALUE = 0x0;


    static const uint32_t QMEM1_10_RESET_VALUE = 0x0;


    static const uint32_t QMEM1_11_RESET_VALUE = 0x0;


    static const uint32_t QMEM1_12_RESET_VALUE = 0x0;


    static const uint32_t QMEM1_13_RESET_VALUE = 0x0;


    static const uint32_t QMEM1_14_RESET_VALUE = 0x0;


    static const uint32_t QMEM1_15_RESET_VALUE = 0x0;


    static const uint32_t QMEM2_0_RESET_VALUE = 0x0;


    static const uint32_t QMEM2_1_RESET_VALUE = 0x0;


    static const uint32_t QMEM2_2_RESET_VALUE = 0x0;


    static const uint32_t QMEM2_3_RESET_VALUE = 0x0;


    static const uint32_t QMEM2_4_RESET_VALUE = 0x0;


    static const uint32_t QMEM2_5_RESET_VALUE = 0x0;


    static const uint32_t QMEM2_6_RESET_VALUE = 0x0;


    static const uint32_t QMEM2_7_RESET_VALUE = 0x0;


    static const uint32_t QMEM2_8_RESET_VALUE = 0x0;


    static const uint32_t QMEM2_9_RESET_VALUE = 0x0;


    static const uint32_t QMEM2_10_RESET_VALUE = 0x0;


    static const uint32_t QMEM2_11_RESET_VALUE = 0x0;


    static const uint32_t QMEM2_12_RESET_VALUE = 0x0;


    static const uint32_t QMEM2_13_RESET_VALUE = 0x0;


    static const uint32_t QMEM2_14_RESET_VALUE = 0x0;


    static const uint32_t QMEM2_15_RESET_VALUE = 0x0;


    static const uint32_t QMEM3_0_RESET_VALUE = 0x0;


    static const uint32_t QMEM3_1_RESET_VALUE = 0x0;


    static const uint32_t QMEM3_2_RESET_VALUE = 0x0;


    static const uint32_t QMEM3_3_RESET_VALUE = 0x0;


    static const uint32_t QMEM3_4_RESET_VALUE = 0x0;


    static const uint32_t QMEM3_5_RESET_VALUE = 0x0;


    static const uint32_t QMEM3_6_RESET_VALUE = 0x0;


    static const uint32_t QMEM3_7_RESET_VALUE = 0x0;


    static const uint32_t QMEM3_8_RESET_VALUE = 0x0;


    static const uint32_t QMEM3_9_RESET_VALUE = 0x0;


    static const uint32_t QMEM3_10_RESET_VALUE = 0x0;


    static const uint32_t QMEM3_11_RESET_VALUE = 0x0;


    static const uint32_t QMEM3_12_RESET_VALUE = 0x0;


    static const uint32_t QMEM3_13_RESET_VALUE = 0x0;


    static const uint32_t QMEM3_14_RESET_VALUE = 0x0;


    static const uint32_t QMEM3_15_RESET_VALUE = 0x0;


    static const uint32_t HUFFMIN_0_RESET_VALUE = 0x0;


    static const uint32_t HUFFMIN_1_RESET_VALUE = 0x0;


    static const uint32_t HUFFMIN_2_RESET_VALUE = 0x0;


    static const uint32_t HUFFMIN_3_RESET_VALUE = 0x0;


    static const uint32_t HUFFMIN_4_RESET_VALUE = 0x0;


    static const uint32_t HUFFMIN_5_RESET_VALUE = 0x0;


    static const uint32_t HUFFMIN_6_RESET_VALUE = 0x0;


    static const uint32_t HUFFMIN_7_RESET_VALUE = 0x0;


    static const uint32_t HUFFMIN_8_RESET_VALUE = 0x0;


    static const uint32_t HUFFMIN_9_RESET_VALUE = 0x0;


    static const uint32_t HUFFMIN_10_RESET_VALUE = 0x0;


    static const uint32_t HUFFMIN_11_RESET_VALUE = 0x0;


    static const uint32_t HUFFMIN_12_RESET_VALUE = 0x0;


    static const uint32_t HUFFMIN_13_RESET_VALUE = 0x0;


    static const uint32_t HUFFMIN_14_RESET_VALUE = 0x0;


    static const uint32_t HUFFMIN_15_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HUFFBASE0_HuffBase_RAM_0 =      // HuffBase RAM (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t HUFFBASE0_HuffBase_RAM_1 =      // HuffBase RAM (9 bits)
        bit_field_t<16, 0x1ff>::value<X>();
    static const uint32_t HUFFBASE0_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HUFFBASE1_HuffBase_RAM_0 =      // HuffBase RAM (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t HUFFBASE1_HuffBase_RAM_1 =      // HuffBase RAM (9 bits)
        bit_field_t<16, 0x1ff>::value<X>();
    static const uint32_t HUFFBASE1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HUFFBASE2_HuffBase_RAM_0 =      // HuffBase RAM (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t HUFFBASE2_HuffBase_RAM_1 =      // HuffBase RAM (9 bits)
        bit_field_t<16, 0x1ff>::value<X>();
    static const uint32_t HUFFBASE2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HUFFBASE3_HuffBase_RAM_0 =      // HuffBase RAM (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t HUFFBASE3_HuffBase_RAM_1 =      // HuffBase RAM (9 bits)
        bit_field_t<16, 0x1ff>::value<X>();
    static const uint32_t HUFFBASE3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HUFFBASE4_HuffBase_RAM_0 =      // HuffBase RAM (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t HUFFBASE4_HuffBase_RAM_1 =      // HuffBase RAM (9 bits)
        bit_field_t<16, 0x1ff>::value<X>();
    static const uint32_t HUFFBASE4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HUFFBASE5_HuffBase_RAM_0 =      // HuffBase RAM (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t HUFFBASE5_HuffBase_RAM_1 =      // HuffBase RAM (9 bits)
        bit_field_t<16, 0x1ff>::value<X>();
    static const uint32_t HUFFBASE5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HUFFBASE6_HuffBase_RAM_0 =      // HuffBase RAM (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t HUFFBASE6_HuffBase_RAM_1 =      // HuffBase RAM (9 bits)
        bit_field_t<16, 0x1ff>::value<X>();
    static const uint32_t HUFFBASE6_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HUFFBASE7_HuffBase_RAM_0 =      // HuffBase RAM (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t HUFFBASE7_HuffBase_RAM_1 =      // HuffBase RAM (9 bits)
        bit_field_t<16, 0x1ff>::value<X>();
    static const uint32_t HUFFBASE7_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HUFFBASE8_HuffBase_RAM_0 =      // HuffBase RAM (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t HUFFBASE8_HuffBase_RAM_1 =      // HuffBase RAM (9 bits)
        bit_field_t<16, 0x1ff>::value<X>();
    static const uint32_t HUFFBASE8_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HUFFBASE9_HuffBase_RAM_0 =      // HuffBase RAM (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t HUFFBASE9_HuffBase_RAM_1 =      // HuffBase RAM (9 bits)
        bit_field_t<16, 0x1ff>::value<X>();
    static const uint32_t HUFFBASE9_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HUFFBASE10_HuffBase_RAM_0 =      // HuffBase RAM (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t HUFFBASE10_HuffBase_RAM_1 =      // HuffBase RAM (9 bits)
        bit_field_t<16, 0x1ff>::value<X>();
    static const uint32_t HUFFBASE10_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HUFFBASE11_HuffBase_RAM_0 =      // HuffBase RAM (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t HUFFBASE11_HuffBase_RAM_1 =      // HuffBase RAM (9 bits)
        bit_field_t<16, 0x1ff>::value<X>();
    static const uint32_t HUFFBASE11_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HUFFBASE12_HuffBase_RAM_0 =      // HuffBase RAM (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t HUFFBASE12_HuffBase_RAM_1 =      // HuffBase RAM (9 bits)
        bit_field_t<16, 0x1ff>::value<X>();
    static const uint32_t HUFFBASE12_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HUFFBASE13_HuffBase_RAM_0 =      // HuffBase RAM (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t HUFFBASE13_HuffBase_RAM_1 =      // HuffBase RAM (9 bits)
        bit_field_t<16, 0x1ff>::value<X>();
    static const uint32_t HUFFBASE13_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HUFFBASE14_HuffBase_RAM_0 =      // HuffBase RAM (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t HUFFBASE14_HuffBase_RAM_1 =      // HuffBase RAM (9 bits)
        bit_field_t<16, 0x1ff>::value<X>();
    static const uint32_t HUFFBASE14_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HUFFBASE15_HuffBase_RAM_0 =      // HuffBase RAM (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t HUFFBASE15_HuffBase_RAM_1 =      // HuffBase RAM (9 bits)
        bit_field_t<16, 0x1ff>::value<X>();
    static const uint32_t HUFFBASE15_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HUFFBASE16_HuffBase_RAM_0 =      // HuffBase RAM (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t HUFFBASE16_HuffBase_RAM_1 =      // HuffBase RAM (9 bits)
        bit_field_t<16, 0x1ff>::value<X>();
    static const uint32_t HUFFBASE16_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HUFFBASE17_HuffBase_RAM_0 =      // HuffBase RAM (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t HUFFBASE17_HuffBase_RAM_1 =      // HuffBase RAM (9 bits)
        bit_field_t<16, 0x1ff>::value<X>();
    static const uint32_t HUFFBASE17_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HUFFBASE18_HuffBase_RAM_0 =      // HuffBase RAM (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t HUFFBASE18_HuffBase_RAM_1 =      // HuffBase RAM (9 bits)
        bit_field_t<16, 0x1ff>::value<X>();
    static const uint32_t HUFFBASE18_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HUFFBASE19_HuffBase_RAM_0 =      // HuffBase RAM (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t HUFFBASE19_HuffBase_RAM_1 =      // HuffBase RAM (9 bits)
        bit_field_t<16, 0x1ff>::value<X>();
    static const uint32_t HUFFBASE19_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HUFFBASE20_HuffBase_RAM_0 =      // HuffBase RAM (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t HUFFBASE20_HuffBase_RAM_1 =      // HuffBase RAM (9 bits)
        bit_field_t<16, 0x1ff>::value<X>();
    static const uint32_t HUFFBASE20_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HUFFBASE21_HuffBase_RAM_0 =      // HuffBase RAM (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t HUFFBASE21_HuffBase_RAM_1 =      // HuffBase RAM (9 bits)
        bit_field_t<16, 0x1ff>::value<X>();
    static const uint32_t HUFFBASE21_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HUFFBASE22_HuffBase_RAM_0 =      // HuffBase RAM (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t HUFFBASE22_HuffBase_RAM_1 =      // HuffBase RAM (9 bits)
        bit_field_t<16, 0x1ff>::value<X>();
    static const uint32_t HUFFBASE22_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HUFFBASE23_HuffBase_RAM_0 =      // HuffBase RAM (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t HUFFBASE23_HuffBase_RAM_1 =      // HuffBase RAM (9 bits)
        bit_field_t<16, 0x1ff>::value<X>();
    static const uint32_t HUFFBASE23_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HUFFBASE24_HuffBase_RAM_0 =      // HuffBase RAM (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t HUFFBASE24_HuffBase_RAM_1 =      // HuffBase RAM (9 bits)
        bit_field_t<16, 0x1ff>::value<X>();
    static const uint32_t HUFFBASE24_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HUFFBASE25_HuffBase_RAM_0 =      // HuffBase RAM (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t HUFFBASE25_HuffBase_RAM_1 =      // HuffBase RAM (9 bits)
        bit_field_t<16, 0x1ff>::value<X>();
    static const uint32_t HUFFBASE25_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HUFFBASE26_HuffBase_RAM_0 =      // HuffBase RAM (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t HUFFBASE26_HuffBase_RAM_1 =      // HuffBase RAM (9 bits)
        bit_field_t<16, 0x1ff>::value<X>();
    static const uint32_t HUFFBASE26_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HUFFBASE27_HuffBase_RAM_0 =      // HuffBase RAM (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t HUFFBASE27_HuffBase_RAM_1 =      // HuffBase RAM (9 bits)
        bit_field_t<16, 0x1ff>::value<X>();
    static const uint32_t HUFFBASE27_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HUFFBASE28_HuffBase_RAM_0 =      // HuffBase RAM (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t HUFFBASE28_HuffBase_RAM_1 =      // HuffBase RAM (9 bits)
        bit_field_t<16, 0x1ff>::value<X>();
    static const uint32_t HUFFBASE28_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HUFFBASE29_HuffBase_RAM_0 =      // HuffBase RAM (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t HUFFBASE29_HuffBase_RAM_1 =      // HuffBase RAM (9 bits)
        bit_field_t<16, 0x1ff>::value<X>();
    static const uint32_t HUFFBASE29_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HUFFBASE30_HuffBase_RAM_0 =      // HuffBase RAM (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t HUFFBASE30_HuffBase_RAM_1 =      // HuffBase RAM (9 bits)
        bit_field_t<16, 0x1ff>::value<X>();
    static const uint32_t HUFFBASE30_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t HUFFBASE31_HuffBase_RAM_0 =      // HuffBase RAM (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t HUFFBASE31_HuffBase_RAM_1 =      // HuffBase RAM (9 bits)
        bit_field_t<16, 0x1ff>::value<X>();
    static const uint32_t HUFFBASE31_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB0_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB1_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB2_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB3_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB4_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB5_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB6_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB7_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB8_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB9_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB10_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB11_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB12_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB13_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB14_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB15_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB16_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB17_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB18_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB19_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB20_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB21_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB22_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB23_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB24_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB25_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB26_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB27_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB28_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB29_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB30_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB31_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB32_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB33_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB34_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB35_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB36_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB37_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB38_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB39_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB40_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB41_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB42_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB43_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB44_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB45_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB46_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB47_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB48_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB49_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB50_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB51_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB52_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB53_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB54_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB55_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB56_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB57_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB58_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB59_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB60_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB61_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB62_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB63_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB64_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB65_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB66_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB67_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB68_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB69_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB70_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB71_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB72_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB73_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB74_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB75_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB76_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB77_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB78_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB79_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB80_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB81_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB82_RESET_VALUE = 0x0;


    static const uint32_t HUFFSYMB83_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM0_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM2_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM3_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM4_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM5_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM6_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM7_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM8_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM9_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM10_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM11_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM12_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM13_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM14_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM15_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM16_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM17_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM18_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM19_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM20_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM21_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM22_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM23_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM24_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM25_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM26_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM27_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM28_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM29_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM30_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM31_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM32_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM33_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM34_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM35_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM36_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM37_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM38_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM39_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM40_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM41_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM42_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM43_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM44_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM45_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM46_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM47_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM48_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM49_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM50_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM51_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM52_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM53_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM54_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM55_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM56_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM57_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM58_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM59_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM60_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM61_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM62_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM63_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM64_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM65_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM66_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM67_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM68_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM69_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM70_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM71_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM72_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM73_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM74_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM75_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM76_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM77_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM78_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM79_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM80_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM81_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM82_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM83_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM84_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM85_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM86_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM87_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM88_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM89_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM90_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM91_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM92_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM93_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM94_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM95_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM96_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM97_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM98_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM99_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM100_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM101_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM102_RESET_VALUE = 0x0;


    static const uint32_t DHTMEM103_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_0_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_1_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_2_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_3_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_4_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_5_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_6_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_7_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_8_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_9_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_10_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_11_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_12_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_13_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_14_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_15_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_16_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_17_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_18_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_19_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_20_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_21_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_22_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_23_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_24_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_25_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_26_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_27_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_28_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_29_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_30_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_31_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_32_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_33_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_34_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_35_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_36_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_37_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_38_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_39_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_40_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_41_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_42_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_43_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_44_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_45_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_46_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_47_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_48_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_49_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_50_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_51_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_52_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_53_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_54_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_55_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_56_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_57_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_58_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_59_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_60_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_61_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_62_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_63_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_64_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_65_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_66_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_67_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_68_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_69_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_70_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_71_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_72_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_73_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_74_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_75_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_76_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_77_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_78_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_79_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_80_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_81_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_82_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_83_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_84_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_85_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_86_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC0_87_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_0_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_1_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_2_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_3_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_4_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_5_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_6_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_7_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_8_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_9_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_10_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_11_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_12_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_13_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_14_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_15_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_16_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_17_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_18_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_19_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_20_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_21_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_22_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_23_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_24_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_25_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_26_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_27_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_28_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_29_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_30_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_31_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_32_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_33_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_34_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_35_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_36_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_37_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_38_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_39_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_40_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_41_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_42_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_43_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_44_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_45_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_46_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_47_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_48_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_49_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_50_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_51_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_52_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_53_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_54_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_55_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_56_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_57_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_58_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_59_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_60_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_61_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_62_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_63_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_64_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_65_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_66_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_67_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_68_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_69_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_70_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_71_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_72_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_73_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_74_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_75_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_76_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_77_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_78_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_79_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_80_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_81_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_82_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_83_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_84_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_85_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_86_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_AC1_87_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_DC0_0_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_DC0_1_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_DC0_2_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_DC0_3_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_DC0_4_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_DC0_5_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_DC0_6_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_DC0_7_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_DC1_0_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_DC1_1_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_DC1_2_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_DC1_3_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_DC1_4_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_DC1_5_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_DC1_6_RESET_VALUE = 0x0;


    static const uint32_t HUFFENC_DC1_7_RESET_VALUE = 0x0;

    static constexpr uint8_t JPEG = 108; // JPEG global interrupt
};

static jpeg_t& JPEG = *reinterpret_cast<jpeg_t*>(0x50051000);

#define HAVE_PERIPHERAL_JPEG


////
//
//    Ethernet: MAC management counters
//
////

struct ethernet_mmc_t
{
    volatile uint32_t    MMCCR;                // [Read-write] Ethernet MMC control register
    volatile uint32_t    MMCRIR;               // [Read-write] Ethernet MMC receive interrupt register
    volatile uint32_t    MMCTIR;               // [Read-only] Ethernet MMC transmit interrupt register
    volatile uint32_t    MMCRIMR;              // [Read-write] Ethernet MMC receive interrupt mask register
    volatile uint32_t    MMCTIMR;              // [Read-write] Ethernet MMC transmit interrupt mask register
    reserved_t<14>       _0;
    volatile uint32_t    MMCTGFSCCR;           // [Read-only] Ethernet MMC transmitted good frames after a single collision counter
    volatile uint32_t    MMCTGFMSCCR;          // [Read-only] Ethernet MMC transmitted good frames after more than a single collision
    reserved_t<5>        _1;
    volatile uint32_t    MMCTGFCR;             // [Read-only] Ethernet MMC transmitted good frames counter register
    reserved_t<10>       _2;
    volatile uint32_t    MMCRFCECR;            // [Read-only] Ethernet MMC received frames with CRC error counter register
    volatile uint32_t    MMCRFAECR;            // [Read-only] Ethernet MMC received frames with alignment error counter register
    reserved_t<10>       _3;
    volatile uint32_t    MMCRGUFCR;            // [Read-only] MMC received good unicast frames counter register

    static constexpr uint32_t MMCCR_CR = 0x1;             // CR
    static constexpr uint32_t MMCCR_CSR = 0x2;            // CSR
    static constexpr uint32_t MMCCR_ROR = 0x4;            // ROR
    static constexpr uint32_t MMCCR_MCF = 0x8;            // MCF
    static constexpr uint32_t MMCCR_MCP = 0x10;           // MCP
    static constexpr uint32_t MMCCR_MCFHP = 0x20;         // MCFHP
    static const uint32_t MMCCR_RESET_VALUE = 0x0;

    static constexpr uint32_t MMCRIR_RFCES = 0x20;         // RFCES
    static constexpr uint32_t MMCRIR_RFAES = 0x40;         // RFAES
    static constexpr uint32_t MMCRIR_RGUFS = 0x20000;      // RGUFS
    static const uint32_t MMCRIR_RESET_VALUE = 0x0;

    static constexpr uint32_t MMCTIR_TGFSCS = 0x4000;      // TGFSCS
    static constexpr uint32_t MMCTIR_TGFMSCS = 0x8000;     // TGFMSCS
    static constexpr uint32_t MMCTIR_TGFS = 0x200000;      // TGFS
    static const uint32_t MMCTIR_RESET_VALUE = 0x0;

    static constexpr uint32_t MMCRIMR_RFCEM = 0x20;         // RFCEM
    static constexpr uint32_t MMCRIMR_RFAEM = 0x40;         // RFAEM
    static constexpr uint32_t MMCRIMR_RGUFM = 0x20000;      // RGUFM
    static const uint32_t MMCRIMR_RESET_VALUE = 0x0;

    static constexpr uint32_t MMCTIMR_TGFSCM = 0x4000;      // TGFSCM
    static constexpr uint32_t MMCTIMR_TGFMSCM = 0x8000;     // TGFMSCM
    static constexpr uint32_t MMCTIMR_TGFM = 0x10000;       // TGFM
    static const uint32_t MMCTIMR_RESET_VALUE = 0x0;


    static const uint32_t MMCTGFSCCR_RESET_VALUE = 0x0;


    static const uint32_t MMCTGFMSCCR_RESET_VALUE = 0x0;


    static const uint32_t MMCTGFCR_RESET_VALUE = 0x0;


    static const uint32_t MMCRFCECR_RESET_VALUE = 0x0;


    static const uint32_t MMCRFAECR_RESET_VALUE = 0x0;


    static const uint32_t MMCRGUFCR_RESET_VALUE = 0x0;
};

static ethernet_mmc_t& ETHERNET_MMC = *reinterpret_cast<ethernet_mmc_t*>(0x40028100);

#define HAVE_PERIPHERAL_ETHERNET_MMC


////
//
//    Ethernet: Precision time protocol
//
////

struct ethernet_ptp_t
{
    volatile uint32_t    PTPTSCR;              // [Read-write] Ethernet PTP time stamp control register
    volatile uint32_t    PTPSSIR;              // [Read-write] Ethernet PTP subsecond increment register
    volatile uint32_t    PTPTSHR;              // [Read-only] Ethernet PTP time stamp high register
    volatile uint32_t    PTPTSLR;              // [Read-only] Ethernet PTP time stamp low register
    volatile uint32_t    PTPTSHUR;             // [Read-write] Ethernet PTP time stamp high update register
    volatile uint32_t    PTPTSLUR;             // [Read-write] Ethernet PTP time stamp low update register
    volatile uint32_t    PTPTSAR;              // [Read-write] Ethernet PTP time stamp addend register
    volatile uint32_t    PTPTTHR;              // [Read-write] Ethernet PTP target time high register
    volatile uint32_t    PTPTTLR;              // [Read-write] Ethernet PTP target time low register
    reserved_t<1>        _0;
    volatile uint32_t    PTPTSSR;              // [Read-only] Ethernet PTP time stamp status register
    volatile uint32_t    PTPPPSCR;             // [Read-only] Ethernet PTP PPS control register

    static constexpr uint32_t PTPTSCR_TSE = 0x1;            // TSE
    static constexpr uint32_t PTPTSCR_TSFCU = 0x2;          // TSFCU
    static constexpr uint32_t PTPTSCR_TSPTPPSV2E = 0x400;   // TSPTPPSV2E
    static constexpr uint32_t PTPTSCR_TSSPTPOEFE = 0x800;   // TSSPTPOEFE
    static constexpr uint32_t PTPTSCR_TSSIPV6FE = 0x1000;   // TSSIPV6FE
    static constexpr uint32_t PTPTSCR_TSSIPV4FE = 0x2000;   // TSSIPV4FE
    static constexpr uint32_t PTPTSCR_TSSEME = 0x4000;      // TSSEME
    static constexpr uint32_t PTPTSCR_TSSMRME = 0x8000;     // TSSMRME
    template<uint32_t X>
    static constexpr uint32_t PTPTSCR_TSCNT =               // TSCNT (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    static constexpr uint32_t PTPTSCR_TSPFFMAE = 0x40000;   // TSPFFMAE
    static constexpr uint32_t PTPTSCR_TSSTI = 0x4;          // TSSTI
    static constexpr uint32_t PTPTSCR_TSSTU = 0x8;          // TSSTU
    static constexpr uint32_t PTPTSCR_TSITE = 0x10;         // TSITE
    static constexpr uint32_t PTPTSCR_TTSARU = 0x20;        // TTSARU
    static constexpr uint32_t PTPTSCR_TSSARFE = 0x100;      // TSSARFE
    static constexpr uint32_t PTPTSCR_TSSSR = 0x200;        // TSSSR
    static const uint32_t PTPTSCR_RESET_VALUE = 0x2000;

    template<uint32_t X>
    static constexpr uint32_t PTPSSIR_STSSI =               // STSSI (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t PTPSSIR_RESET_VALUE = 0x0;


    static const uint32_t PTPTSHR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PTPTSLR_STSS =                // STSS (31 bits)
        bit_field_t<0, 0x7fffffff>::value<X>();
    static constexpr uint32_t PTPTSLR_STPNS = 0x80000000;   // STPNS
    static const uint32_t PTPTSLR_RESET_VALUE = 0x0;


    static const uint32_t PTPTSHUR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PTPTSLUR_TSUSS =               // TSUSS (31 bits)
        bit_field_t<0, 0x7fffffff>::value<X>();
    static constexpr uint32_t PTPTSLUR_TSUPNS = 0x80000000;  // TSUPNS
    static const uint32_t PTPTSLUR_RESET_VALUE = 0x0;


    static const uint32_t PTPTSAR_RESET_VALUE = 0x0;


    static const uint32_t PTPTTHR_RESET_VALUE = 0x0;


    static const uint32_t PTPTTLR_RESET_VALUE = 0x0;

    static constexpr uint32_t PTPTSSR_TSSO = 0x1;           // TSSO
    static constexpr uint32_t PTPTSSR_TSTTR = 0x2;          // TSTTR
    static const uint32_t PTPTSSR_RESET_VALUE = 0x0;

    static constexpr uint32_t PTPPPSCR_TSSO = 0x1;           // TSSO
    static constexpr uint32_t PTPPPSCR_TSTTR = 0x2;          // TSTTR
    static const uint32_t PTPPPSCR_RESET_VALUE = 0x0;
};

static ethernet_ptp_t& ETHERNET_PTP = *reinterpret_cast<ethernet_ptp_t*>(0x40028700);

#define HAVE_PERIPHERAL_ETHERNET_PTP


////
//
//    Ethernet: DMA controller operation
//
////

struct ethernet_dma_t
{
    volatile uint32_t    DMABMR;               // [Read-write] Ethernet DMA bus mode register
    volatile uint32_t    DMATPDR;              // [Read-write] Ethernet DMA transmit poll demand register
    volatile uint32_t    DMARPDR;              // [Read-write] EHERNET DMA receive poll demand register
    volatile uint32_t    DMARDLAR;             // [Read-write] Ethernet DMA receive descriptor list address register
    volatile uint32_t    DMATDLAR;             // [Read-write] Ethernet DMA transmit descriptor list address register
    volatile uint32_t    DMASR;                // Ethernet DMA status register
    volatile uint32_t    DMAOMR;               // [Read-write] Ethernet DMA operation mode register
    volatile uint32_t    DMAIER;               // [Read-write] Ethernet DMA interrupt enable register
    volatile uint32_t    DMAMFBOCR;            // [Read-write] Ethernet DMA missed frame and buffer overflow counter register
    volatile uint32_t    DMARSWTR;             // [Read-write] Ethernet DMA receive status watchdog timer register
    reserved_t<8>        _0;
    volatile uint32_t    DMACHTDR;             // [Read-only] Ethernet DMA current host transmit descriptor register
    volatile uint32_t    DMACHRDR;             // [Read-only] Ethernet DMA current host receive descriptor register
    volatile uint32_t    DMACHTBAR;            // [Read-only] Ethernet DMA current host transmit buffer address register
    volatile uint32_t    DMACHRBAR;            // [Read-only] Ethernet DMA current host receive buffer address register

    static constexpr uint32_t DMABMR_SR = 0x1;             // SR
    static constexpr uint32_t DMABMR_DA = 0x2;             // DA
    template<uint32_t X>
    static constexpr uint32_t DMABMR_DSL =                 // DSL (5 bits)
        bit_field_t<2, 0x1f>::value<X>();
    static constexpr uint32_t DMABMR_EDFE = 0x80;          // EDFE
    template<uint32_t X>
    static constexpr uint32_t DMABMR_PBL =                 // PBL (6 bits)
        bit_field_t<8, 0x3f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DMABMR_RTPR =                // RTPR (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t DMABMR_FB = 0x10000;         // FB
    template<uint32_t X>
    static constexpr uint32_t DMABMR_RDP =                 // RDP (6 bits)
        bit_field_t<17, 0x3f>::value<X>();
    static constexpr uint32_t DMABMR_USP = 0x800000;       // USP
    static constexpr uint32_t DMABMR_FPM = 0x1000000;      // FPM
    static constexpr uint32_t DMABMR_AAB = 0x2000000;      // AAB
    static constexpr uint32_t DMABMR_MB = 0x4000000;       // MB
    static const uint32_t DMABMR_RESET_VALUE = 0x2101;


    static const uint32_t DMATPDR_RESET_VALUE = 0x0;


    static const uint32_t DMARPDR_RESET_VALUE = 0x0;


    static const uint32_t DMARDLAR_RESET_VALUE = 0x0;


    static const uint32_t DMATDLAR_RESET_VALUE = 0x0;

    static constexpr uint32_t DMASR_TS = 0x1;             // TS, Read-write
    static constexpr uint32_t DMASR_TPSS = 0x2;           // TPSS, Read-write
    static constexpr uint32_t DMASR_TBUS = 0x4;           // TBUS, Read-write
    static constexpr uint32_t DMASR_TJTS = 0x8;           // TJTS, Read-write
    static constexpr uint32_t DMASR_ROS = 0x10;           // ROS, Read-write
    static constexpr uint32_t DMASR_TUS = 0x20;           // TUS, Read-write
    static constexpr uint32_t DMASR_RS = 0x40;            // RS, Read-write
    static constexpr uint32_t DMASR_RBUS = 0x80;          // RBUS, Read-write
    static constexpr uint32_t DMASR_RPSS = 0x100;         // RPSS, Read-write
    static constexpr uint32_t DMASR_PWTS = 0x200;         // PWTS, Read-write
    static constexpr uint32_t DMASR_ETS = 0x400;          // ETS, Read-write
    static constexpr uint32_t DMASR_FBES = 0x2000;        // FBES, Read-write
    static constexpr uint32_t DMASR_ERS = 0x4000;         // ERS, Read-write
    static constexpr uint32_t DMASR_AIS = 0x8000;         // AIS, Read-write
    static constexpr uint32_t DMASR_NIS = 0x10000;        // NIS, Read-write
    template<uint32_t X>
    static constexpr uint32_t DMASR_RPS =                 // RPS (3 bits), Read-only
        bit_field_t<17, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DMASR_TPS =                 // TPS (3 bits), Read-only
        bit_field_t<20, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DMASR_EBS =                 // EBS (3 bits), Read-only
        bit_field_t<23, 0x7>::value<X>();
    static constexpr uint32_t DMASR_MMCS = 0x8000000;     // MMCS, Read-only
    static constexpr uint32_t DMASR_PMTS = 0x10000000;    // PMTS, Read-only
    static constexpr uint32_t DMASR_TSTS = 0x20000000;    // TSTS, Read-only
    static const uint32_t DMASR_RESET_VALUE = 0x0;

    static constexpr uint32_t DMAOMR_SR = 0x2;             // SR
    static constexpr uint32_t DMAOMR_OSF = 0x4;            // OSF
    template<uint32_t X>
    static constexpr uint32_t DMAOMR_RTC =                 // RTC (2 bits)
        bit_field_t<3, 0x3>::value<X>();
    static constexpr uint32_t DMAOMR_FUGF = 0x40;          // FUGF
    static constexpr uint32_t DMAOMR_FEF = 0x80;           // FEF
    static constexpr uint32_t DMAOMR_ST = 0x2000;          // ST
    template<uint32_t X>
    static constexpr uint32_t DMAOMR_TTC =                 // TTC (3 bits)
        bit_field_t<14, 0x7>::value<X>();
    static constexpr uint32_t DMAOMR_FTF = 0x100000;       // FTF
    static constexpr uint32_t DMAOMR_TSF = 0x200000;       // TSF
    static constexpr uint32_t DMAOMR_DFRF = 0x1000000;     // DFRF
    static constexpr uint32_t DMAOMR_RSF = 0x2000000;      // RSF
    static constexpr uint32_t DMAOMR_DTCEFD = 0x4000000;   // DTCEFD
    static const uint32_t DMAOMR_RESET_VALUE = 0x0;

    static constexpr uint32_t DMAIER_TIE = 0x1;            // TIE
    static constexpr uint32_t DMAIER_TPSIE = 0x2;          // TPSIE
    static constexpr uint32_t DMAIER_TBUIE = 0x4;          // TBUIE
    static constexpr uint32_t DMAIER_TJTIE = 0x8;          // TJTIE
    static constexpr uint32_t DMAIER_ROIE = 0x10;          // ROIE
    static constexpr uint32_t DMAIER_TUIE = 0x20;          // TUIE
    static constexpr uint32_t DMAIER_RIE = 0x40;           // RIE
    static constexpr uint32_t DMAIER_RBUIE = 0x80;         // RBUIE
    static constexpr uint32_t DMAIER_RPSIE = 0x100;        // RPSIE
    static constexpr uint32_t DMAIER_RWTIE = 0x200;        // RWTIE
    static constexpr uint32_t DMAIER_ETIE = 0x400;         // ETIE
    static constexpr uint32_t DMAIER_FBEIE = 0x2000;       // FBEIE
    static constexpr uint32_t DMAIER_ERIE = 0x4000;        // ERIE
    static constexpr uint32_t DMAIER_AISE = 0x8000;        // AISE
    static constexpr uint32_t DMAIER_NISE = 0x10000;       // NISE
    static const uint32_t DMAIER_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DMAMFBOCR_MFC =                 // MFC (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static constexpr uint32_t DMAMFBOCR_OMFC = 0x10000;       // OMFC
    template<uint32_t X>
    static constexpr uint32_t DMAMFBOCR_MFA =                 // MFA (11 bits)
        bit_field_t<17, 0x7ff>::value<X>();
    static constexpr uint32_t DMAMFBOCR_OFOC = 0x10000000;    // OFOC
    static const uint32_t DMAMFBOCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DMARSWTR_RSWTC =               // RSWTC (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t DMARSWTR_RESET_VALUE = 0x0;


    static const uint32_t DMACHTDR_RESET_VALUE = 0x0;


    static const uint32_t DMACHRDR_RESET_VALUE = 0x0;


    static const uint32_t DMACHTBAR_RESET_VALUE = 0x0;


    static const uint32_t DMACHRBAR_RESET_VALUE = 0x0;
};

static ethernet_dma_t& ETHERNET_DMA = *reinterpret_cast<ethernet_dma_t*>(0x40029000);

#define HAVE_PERIPHERAL_ETHERNET_DMA


////
//
//    USB on the go full speed
//
////

struct otg_fs_host_t
{
    volatile uint32_t    OTG_FS_HCFG;          // OTG_FS host configuration register (OTG_FS_HCFG)
    volatile uint32_t    OTG_FS_HFIR;          // [Read-write] OTG_FS Host frame interval register
    volatile uint32_t    OTG_FS_HFNUM;         // [Read-only] OTG_FS host frame number/frame time remaining register (OTG_FS_HFNUM)
    reserved_t<1>        _0;
    volatile uint32_t    OTG_FS_HPTXSTS;       // OTG_FS_Host periodic transmit FIFO/queue status register (OTG_FS_HPTXSTS)
    volatile uint32_t    OTG_FS_HAINT;         // [Read-only] OTG_FS Host all channels interrupt register
    volatile uint32_t    OTG_FS_HAINTMSK;      // [Read-write] OTG_FS host all channels interrupt mask register
    reserved_t<9>        _1;
    volatile uint32_t    OTG_FS_HPRT;          // OTG_FS host port control and status register (OTG_FS_HPRT)
    reserved_t<47>       _2;
    volatile uint32_t    OTG_FS_HCCHAR0;       // [Read-write] OTG_FS host channel-0 characteristics register (OTG_FS_HCCHAR0)
    reserved_t<1>        _3;
    volatile uint32_t    OTG_FS_HCINT0;        // [Read-write] OTG_FS host channel-0 interrupt register (OTG_FS_HCINT0)
    volatile uint32_t    OTG_FS_HCINTMSK0;     // [Read-write] OTG_FS host channel-0 mask register (OTG_FS_HCINTMSK0)
    volatile uint32_t    OTG_FS_HCTSIZ0;       // [Read-write] OTG_FS host channel-0 transfer size register
    reserved_t<3>        _4;
    volatile uint32_t    OTG_FS_HCCHAR1;       // [Read-write] OTG_FS host channel-1 characteristics register (OTG_FS_HCCHAR1)
    reserved_t<1>        _5;
    volatile uint32_t    OTG_FS_HCINT1;        // [Read-write] OTG_FS host channel-1 interrupt register (OTG_FS_HCINT1)
    volatile uint32_t    OTG_FS_HCINTMSK1;     // [Read-write] OTG_FS host channel-1 mask register (OTG_FS_HCINTMSK1)
    volatile uint32_t    OTG_FS_HCTSIZ1;       // [Read-write] OTG_FS host channel-1 transfer size register
    reserved_t<3>        _6;
    volatile uint32_t    OTG_FS_HCCHAR2;       // [Read-write] OTG_FS host channel-2 characteristics register (OTG_FS_HCCHAR2)
    reserved_t<1>        _7;
    volatile uint32_t    OTG_FS_HCINT2;        // [Read-write] OTG_FS host channel-2 interrupt register (OTG_FS_HCINT2)
    volatile uint32_t    OTG_FS_HCINTMSK2;     // [Read-write] OTG_FS host channel-2 mask register (OTG_FS_HCINTMSK2)
    volatile uint32_t    OTG_FS_HCTSIZ2;       // [Read-write] OTG_FS host channel-2 transfer size register
    reserved_t<3>        _8;
    volatile uint32_t    OTG_FS_HCCHAR3;       // [Read-write] OTG_FS host channel-3 characteristics register (OTG_FS_HCCHAR3)
    reserved_t<1>        _9;
    volatile uint32_t    OTG_FS_HCINT3;        // [Read-write] OTG_FS host channel-3 interrupt register (OTG_FS_HCINT3)
    volatile uint32_t    OTG_FS_HCINTMSK3;     // [Read-write] OTG_FS host channel-3 mask register (OTG_FS_HCINTMSK3)
    volatile uint32_t    OTG_FS_HCTSIZ3;       // [Read-write] OTG_FS host channel-3 transfer size register
    reserved_t<3>        _10;
    volatile uint32_t    OTG_FS_HCCHAR4;       // [Read-write] OTG_FS host channel-4 characteristics register (OTG_FS_HCCHAR4)
    reserved_t<1>        _11;
    volatile uint32_t    OTG_FS_HCINT4;        // [Read-write] OTG_FS host channel-4 interrupt register (OTG_FS_HCINT4)
    volatile uint32_t    OTG_FS_HCINTMSK4;     // [Read-write] OTG_FS host channel-4 mask register (OTG_FS_HCINTMSK4)
    volatile uint32_t    OTG_FS_HCTSIZ4;       // [Read-write] OTG_FS host channel-x transfer size register
    reserved_t<3>        _12;
    volatile uint32_t    OTG_FS_HCCHAR5;       // [Read-write] OTG_FS host channel-5 characteristics register (OTG_FS_HCCHAR5)
    reserved_t<1>        _13;
    volatile uint32_t    OTG_FS_HCINT5;        // [Read-write] OTG_FS host channel-5 interrupt register (OTG_FS_HCINT5)
    volatile uint32_t    OTG_FS_HCINTMSK5;     // [Read-write] OTG_FS host channel-5 mask register (OTG_FS_HCINTMSK5)
    volatile uint32_t    OTG_FS_HCTSIZ5;       // [Read-write] OTG_FS host channel-5 transfer size register
    reserved_t<3>        _14;
    volatile uint32_t    OTG_FS_HCCHAR6;       // [Read-write] OTG_FS host channel-6 characteristics register (OTG_FS_HCCHAR6)
    reserved_t<1>        _15;
    volatile uint32_t    OTG_FS_HCINT6;        // [Read-write] OTG_FS host channel-6 interrupt register (OTG_FS_HCINT6)
    volatile uint32_t    OTG_FS_HCINTMSK6;     // [Read-write] OTG_FS host channel-6 mask register (OTG_FS_HCINTMSK6)
    volatile uint32_t    OTG_FS_HCTSIZ6;       // [Read-write] OTG_FS host channel-6 transfer size register
    reserved_t<3>        _16;
    volatile uint32_t    OTG_FS_HCCHAR7;       // [Read-write] OTG_FS host channel-7 characteristics register (OTG_FS_HCCHAR7)
    reserved_t<1>        _17;
    volatile uint32_t    OTG_FS_HCINT7;        // [Read-write] OTG_FS host channel-7 interrupt register (OTG_FS_HCINT7)
    volatile uint32_t    OTG_FS_HCINTMSK7;     // [Read-write] OTG_FS host channel-7 mask register (OTG_FS_HCINTMSK7)
    volatile uint32_t    OTG_FS_HCTSIZ7;       // [Read-write] OTG_FS host channel-7 transfer size register
    volatile uint32_t    OTG_FS_HCCHAR8;       // [Read-write] OTG_FS host channel-8 characteristics register
    volatile uint32_t    OTG_FS_HCINT8;        // [Read-write] OTG_FS host channel-8 interrupt register
    volatile uint32_t    OTG_FS_HCINTMSK8;     // [Read-write] OTG_FS host channel-8 mask register
    volatile uint32_t    OTG_FS_HCTSIZ8;       // [Read-write] OTG_FS host channel-8 transfer size register
    volatile uint32_t    OTG_FS_HCCHAR9;       // [Read-write] OTG_FS host channel-9 characteristics register
    volatile uint32_t    OTG_FS_HCINT9;        // [Read-write] OTG_FS host channel-9 interrupt register
    volatile uint32_t    OTG_FS_HCINTMSK9;     // [Read-write] OTG_FS host channel-9 mask register
    volatile uint32_t    OTG_FS_HCTSIZ9;       // [Read-write] OTG_FS host channel-9 transfer size register
    volatile uint32_t    OTG_FS_HCCHAR10;      // [Read-write] OTG_FS host channel-10 characteristics register
    volatile uint32_t    OTG_FS_HCINT10;       // [Read-write] OTG_FS host channel-10 interrupt register
    volatile uint32_t    OTG_FS_HCINTMSK10;    // [Read-write] OTG_FS host channel-10 mask register
    volatile uint32_t    OTG_FS_HCTSIZ10;      // [Read-write] OTG_FS host channel-10 transfer size register
    volatile uint32_t    OTG_FS_HCCHAR11;      // [Read-write] OTG_FS host channel-11 characteristics register
    volatile uint32_t    OTG_FS_HCINT11;       // [Read-write] OTG_FS host channel-11 interrupt register
    volatile uint32_t    OTG_FS_HCINTMSK11;    // [Read-write] OTG_FS host channel-11 mask register
    volatile uint32_t    OTG_FS_HCTSIZ11;      // [Read-write] OTG_FS host channel-11 transfer size register

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCFG_FSLSPCS =             // FS/LS PHY clock select (2 bits), Read-write
        bit_field_t<0, 0x3>::value<X>();
    static constexpr uint32_t OTG_FS_HCFG_FSLSS = 0x4;          // FS- and LS-only support, Read-only
    static const uint32_t OTG_FS_HCFG_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HFIR_FRIVL =               // Frame interval (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_FS_HFIR_RESET_VALUE = 0xea60;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HFNUM_FRNUM =               // Frame number (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HFNUM_FTREM =               // Frame time remaining (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OTG_FS_HFNUM_RESET_VALUE = 0x3fff;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HPTXSTS_PTXFSAVL =            // Periodic transmit data FIFO space available (16 bits), Read-write
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HPTXSTS_PTXQSAV =             // Periodic transmit request queue space available (8 bits), Read-only
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HPTXSTS_PTXQTOP =             // Top of the periodic transmit request queue (8 bits), Read-only
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t OTG_FS_HPTXSTS_RESET_VALUE = 0x80100;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HAINT_HAINT =               // Channel interrupts (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_FS_HAINT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HAINTMSK_HAINTM =              // Channel interrupt mask (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_FS_HAINTMSK_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_HPRT_PCSTS = 0x1;          // Port connect status, Read-only
    static constexpr uint32_t OTG_FS_HPRT_PCDET = 0x2;          // Port connect detected, Read-write
    static constexpr uint32_t OTG_FS_HPRT_PENA = 0x4;           // Port enable, Read-write
    static constexpr uint32_t OTG_FS_HPRT_PENCHNG = 0x8;        // Port enable/disable change, Read-write
    static constexpr uint32_t OTG_FS_HPRT_POCA = 0x10;          // Port overcurrent active, Read-only
    static constexpr uint32_t OTG_FS_HPRT_POCCHNG = 0x20;       // Port overcurrent change, Read-write
    static constexpr uint32_t OTG_FS_HPRT_PRES = 0x40;          // Port resume, Read-write
    static constexpr uint32_t OTG_FS_HPRT_PSUSP = 0x80;         // Port suspend, Read-write
    static constexpr uint32_t OTG_FS_HPRT_PRST = 0x100;         // Port reset, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HPRT_PLSTS =               // Port line status (2 bits), Read-only
        bit_field_t<10, 0x3>::value<X>();
    static constexpr uint32_t OTG_FS_HPRT_PPWR = 0x1000;        // Port power, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HPRT_PTCTL =               // Port test control (4 bits), Read-write
        bit_field_t<13, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HPRT_PSPD =                // Port speed (2 bits), Read-only
        bit_field_t<17, 0x3>::value<X>();
    static const uint32_t OTG_FS_HPRT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR0_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR0_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_FS_HCCHAR0_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_FS_HCCHAR0_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR0_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR0_MCNT =                // Multicount (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR0_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_FS_HCCHAR0_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_FS_HCCHAR0_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_FS_HCCHAR0_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_FS_HCCHAR0_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_HCINT0_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_FS_HCINT0_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_FS_HCINT0_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_FS_HCINT0_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_FS_HCINT0_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_FS_HCINT0_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_FS_HCINT0_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_FS_HCINT0_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_FS_HCINT0_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_FS_HCINT0_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_HCINTMSK0_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_FS_HCINTMSK0_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_FS_HCINTMSK0_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK0_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK0_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK0_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK0_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_FS_HCINTMSK0_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_FS_HCINTMSK0_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_FS_HCINTMSK0_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_FS_HCINTMSK0_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCTSIZ0_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCTSIZ0_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCTSIZ0_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_FS_HCTSIZ0_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR1_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR1_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_FS_HCCHAR1_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_FS_HCCHAR1_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR1_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR1_MCNT =                // Multicount (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR1_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_FS_HCCHAR1_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_FS_HCCHAR1_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_FS_HCCHAR1_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_FS_HCCHAR1_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_HCINT1_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_FS_HCINT1_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_FS_HCINT1_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_FS_HCINT1_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_FS_HCINT1_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_FS_HCINT1_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_FS_HCINT1_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_FS_HCINT1_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_FS_HCINT1_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_FS_HCINT1_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_HCINTMSK1_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_FS_HCINTMSK1_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_FS_HCINTMSK1_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK1_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK1_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK1_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK1_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_FS_HCINTMSK1_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_FS_HCINTMSK1_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_FS_HCINTMSK1_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_FS_HCINTMSK1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCTSIZ1_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCTSIZ1_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCTSIZ1_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_FS_HCTSIZ1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR2_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR2_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_FS_HCCHAR2_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_FS_HCCHAR2_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR2_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR2_MCNT =                // Multicount (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR2_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_FS_HCCHAR2_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_FS_HCCHAR2_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_FS_HCCHAR2_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_FS_HCCHAR2_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_HCINT2_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_FS_HCINT2_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_FS_HCINT2_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_FS_HCINT2_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_FS_HCINT2_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_FS_HCINT2_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_FS_HCINT2_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_FS_HCINT2_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_FS_HCINT2_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_FS_HCINT2_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_HCINTMSK2_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_FS_HCINTMSK2_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_FS_HCINTMSK2_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK2_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK2_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK2_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK2_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_FS_HCINTMSK2_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_FS_HCINTMSK2_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_FS_HCINTMSK2_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_FS_HCINTMSK2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCTSIZ2_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCTSIZ2_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCTSIZ2_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_FS_HCTSIZ2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR3_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR3_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_FS_HCCHAR3_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_FS_HCCHAR3_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR3_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR3_MCNT =                // Multicount (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR3_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_FS_HCCHAR3_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_FS_HCCHAR3_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_FS_HCCHAR3_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_FS_HCCHAR3_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_HCINT3_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_FS_HCINT3_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_FS_HCINT3_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_FS_HCINT3_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_FS_HCINT3_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_FS_HCINT3_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_FS_HCINT3_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_FS_HCINT3_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_FS_HCINT3_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_FS_HCINT3_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_HCINTMSK3_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_FS_HCINTMSK3_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_FS_HCINTMSK3_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK3_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK3_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK3_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK3_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_FS_HCINTMSK3_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_FS_HCINTMSK3_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_FS_HCINTMSK3_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_FS_HCINTMSK3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCTSIZ3_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCTSIZ3_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCTSIZ3_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_FS_HCTSIZ3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR4_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR4_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_FS_HCCHAR4_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_FS_HCCHAR4_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR4_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR4_MCNT =                // Multicount (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR4_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_FS_HCCHAR4_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_FS_HCCHAR4_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_FS_HCCHAR4_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_FS_HCCHAR4_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_HCINT4_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_FS_HCINT4_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_FS_HCINT4_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_FS_HCINT4_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_FS_HCINT4_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_FS_HCINT4_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_FS_HCINT4_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_FS_HCINT4_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_FS_HCINT4_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_FS_HCINT4_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_HCINTMSK4_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_FS_HCINTMSK4_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_FS_HCINTMSK4_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK4_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK4_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK4_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK4_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_FS_HCINTMSK4_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_FS_HCINTMSK4_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_FS_HCINTMSK4_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_FS_HCINTMSK4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCTSIZ4_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCTSIZ4_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCTSIZ4_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_FS_HCTSIZ4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR5_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR5_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_FS_HCCHAR5_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_FS_HCCHAR5_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR5_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR5_MCNT =                // Multicount (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR5_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_FS_HCCHAR5_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_FS_HCCHAR5_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_FS_HCCHAR5_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_FS_HCCHAR5_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_HCINT5_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_FS_HCINT5_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_FS_HCINT5_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_FS_HCINT5_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_FS_HCINT5_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_FS_HCINT5_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_FS_HCINT5_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_FS_HCINT5_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_FS_HCINT5_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_FS_HCINT5_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_HCINTMSK5_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_FS_HCINTMSK5_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_FS_HCINTMSK5_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK5_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK5_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK5_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK5_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_FS_HCINTMSK5_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_FS_HCINTMSK5_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_FS_HCINTMSK5_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_FS_HCINTMSK5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCTSIZ5_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCTSIZ5_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCTSIZ5_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_FS_HCTSIZ5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR6_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR6_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_FS_HCCHAR6_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_FS_HCCHAR6_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR6_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR6_MCNT =                // Multicount (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR6_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_FS_HCCHAR6_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_FS_HCCHAR6_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_FS_HCCHAR6_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_FS_HCCHAR6_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_HCINT6_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_FS_HCINT6_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_FS_HCINT6_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_FS_HCINT6_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_FS_HCINT6_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_FS_HCINT6_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_FS_HCINT6_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_FS_HCINT6_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_FS_HCINT6_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_FS_HCINT6_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_HCINTMSK6_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_FS_HCINTMSK6_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_FS_HCINTMSK6_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK6_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK6_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK6_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK6_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_FS_HCINTMSK6_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_FS_HCINTMSK6_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_FS_HCINTMSK6_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_FS_HCINTMSK6_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCTSIZ6_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCTSIZ6_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCTSIZ6_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_FS_HCTSIZ6_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR7_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR7_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_FS_HCCHAR7_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_FS_HCCHAR7_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR7_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR7_MCNT =                // Multicount (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR7_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_FS_HCCHAR7_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_FS_HCCHAR7_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_FS_HCCHAR7_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_FS_HCCHAR7_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_HCINT7_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_FS_HCINT7_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_FS_HCINT7_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_FS_HCINT7_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_FS_HCINT7_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_FS_HCINT7_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_FS_HCINT7_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_FS_HCINT7_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_FS_HCINT7_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_FS_HCINT7_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_HCINTMSK7_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_FS_HCINTMSK7_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_FS_HCINTMSK7_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK7_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK7_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK7_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK7_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_FS_HCINTMSK7_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_FS_HCINTMSK7_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_FS_HCINTMSK7_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_FS_HCINTMSK7_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCTSIZ7_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCTSIZ7_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCTSIZ7_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_FS_HCTSIZ7_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR8_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR8_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_FS_HCCHAR8_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_FS_HCCHAR8_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR8_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR8_MCNT =                // Multicount (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR8_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_FS_HCCHAR8_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_FS_HCCHAR8_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_FS_HCCHAR8_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_FS_HCCHAR8_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_HCINT8_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_FS_HCINT8_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_FS_HCINT8_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_FS_HCINT8_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_FS_HCINT8_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_FS_HCINT8_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_FS_HCINT8_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_FS_HCINT8_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_FS_HCINT8_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_FS_HCINT8_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_HCINTMSK8_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_FS_HCINTMSK8_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_FS_HCINTMSK8_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK8_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK8_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK8_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK8_TXERRM = 0x80;        // Transaction error
    static constexpr uint32_t OTG_FS_HCINTMSK8_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_FS_HCINTMSK8_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_FS_HCINTMSK8_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_FS_HCINTMSK8_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCTSIZ8_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCTSIZ8_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCTSIZ8_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_FS_HCTSIZ8_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR9_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR9_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_FS_HCCHAR9_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_FS_HCCHAR9_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR9_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR9_MCNT =                // Multicount (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR9_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_FS_HCCHAR9_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_FS_HCCHAR9_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_FS_HCCHAR9_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_FS_HCCHAR9_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_HCINT9_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_FS_HCINT9_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_FS_HCINT9_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_FS_HCINT9_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_FS_HCINT9_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_FS_HCINT9_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_FS_HCINT9_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_FS_HCINT9_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_FS_HCINT9_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_FS_HCINT9_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_HCINTMSK9_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_FS_HCINTMSK9_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_FS_HCINTMSK9_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK9_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK9_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK9_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK9_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_FS_HCINTMSK9_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_FS_HCINTMSK9_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_FS_HCINTMSK9_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_FS_HCINTMSK9_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCTSIZ9_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCTSIZ9_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCTSIZ9_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_FS_HCTSIZ9_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR10_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR10_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_FS_HCCHAR10_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_FS_HCCHAR10_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR10_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR10_MCNT =                // Multicount (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR10_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_FS_HCCHAR10_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_FS_HCCHAR10_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_FS_HCCHAR10_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_FS_HCCHAR10_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_HCINT10_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_FS_HCINT10_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_FS_HCINT10_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_FS_HCINT10_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_FS_HCINT10_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_FS_HCINT10_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_FS_HCINT10_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_FS_HCINT10_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_FS_HCINT10_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_FS_HCINT10_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_HCINTMSK10_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_FS_HCINTMSK10_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_FS_HCINTMSK10_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK10_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK10_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK10_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK10_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_FS_HCINTMSK10_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_FS_HCINTMSK10_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_FS_HCINTMSK10_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_FS_HCINTMSK10_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCTSIZ10_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCTSIZ10_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCTSIZ10_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_FS_HCTSIZ10_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR11_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR11_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_FS_HCCHAR11_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_FS_HCCHAR11_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR11_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR11_MCNT =                // Multicount (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCCHAR11_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_FS_HCCHAR11_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_FS_HCCHAR11_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_FS_HCCHAR11_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_FS_HCCHAR11_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_HCINT11_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_FS_HCINT11_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_FS_HCINT11_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_FS_HCINT11_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_FS_HCINT11_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_FS_HCINT11_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_FS_HCINT11_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_FS_HCINT11_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_FS_HCINT11_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_FS_HCINT11_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_HCINTMSK11_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_FS_HCINTMSK11_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_FS_HCINTMSK11_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK11_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK11_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK11_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_FS_HCINTMSK11_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_FS_HCINTMSK11_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_FS_HCINTMSK11_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_FS_HCINTMSK11_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_FS_HCINTMSK11_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCTSIZ11_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCTSIZ11_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_HCTSIZ11_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_FS_HCTSIZ11_RESET_VALUE = 0x0;
};

static otg_fs_host_t& OTG_FS_HOST = *reinterpret_cast<otg_fs_host_t*>(0x50000400);

#define HAVE_PERIPHERAL_OTG_FS_HOST


////
//
//    USB on the go full speed
//
////

struct otg_fs_device_t
{
    volatile uint32_t    OTG_FS_DCFG;          // [Read-write] OTG_FS device configuration register (OTG_FS_DCFG)
    volatile uint32_t    OTG_FS_DCTL;          // OTG_FS device control register (OTG_FS_DCTL)
    volatile uint32_t    OTG_FS_DSTS;          // [Read-only] OTG_FS device status register (OTG_FS_DSTS)
    reserved_t<1>        _0;
    volatile uint32_t    OTG_FS_DIEPMSK;       // [Read-write] OTG_FS device IN endpoint common interrupt mask register (OTG_FS_DIEPMSK)
    volatile uint32_t    OTG_FS_DOEPMSK;       // [Read-write] OTG_FS device OUT endpoint common interrupt mask register (OTG_FS_DOEPMSK)
    volatile uint32_t    OTG_FS_DAINT;         // [Read-only] OTG_FS device all endpoints interrupt register (OTG_FS_DAINT)
    volatile uint32_t    OTG_FS_DAINTMSK;      // [Read-write] OTG_FS all endpoints interrupt mask register (OTG_FS_DAINTMSK)
    reserved_t<2>        _1;
    volatile uint32_t    OTG_FS_DVBUSDIS;      // [Read-write] OTG_FS device VBUS discharge time register
    volatile uint32_t    OTG_FS_DVBUSPULSE;    // [Read-write] OTG_FS device VBUS pulsing time register
    reserved_t<1>        _2;
    volatile uint32_t    OTG_FS_DIEPEMPMSK;    // [Read-write] OTG_FS device IN endpoint FIFO empty interrupt mask register
    reserved_t<50>       _3;
    volatile uint32_t    OTG_FS_DIEPCTL0;      // OTG_FS device control IN endpoint 0 control register (OTG_FS_DIEPCTL0)
    reserved_t<1>        _4;
    volatile uint32_t    OTG_FS_DIEPINT0;      // device endpoint-x interrupt register
    reserved_t<1>        _5;
    volatile uint32_t    OTG_FS_DIEPTSIZ0;     // [Read-write] device endpoint-0 transfer size register
    reserved_t<1>        _6;
    volatile uint32_t    OTG_FS_DTXFSTS0;      // [Read-only] OTG_FS device IN endpoint transmit FIFO status register
    reserved_t<1>        _7;
    volatile uint32_t    OTG_FS_DIEPCTL1;      // OTG device endpoint-1 control register
    reserved_t<1>        _8;
    volatile uint32_t    OTG_FS_DIEPINT1;      // device endpoint-1 interrupt register
    reserved_t<1>        _9;
    volatile uint32_t    OTG_FS_DIEPTSIZ1;     // [Read-write] device endpoint-1 transfer size register
    reserved_t<1>        _10;
    volatile uint32_t    OTG_FS_DTXFSTS1;      // [Read-only] OTG_FS device IN endpoint transmit FIFO status register
    reserved_t<1>        _11;
    volatile uint32_t    OTG_FS_DIEPCTL2;      // OTG device endpoint-2 control register
    reserved_t<1>        _12;
    volatile uint32_t    OTG_FS_DIEPINT2;      // device endpoint-2 interrupt register
    reserved_t<1>        _13;
    volatile uint32_t    OTG_FS_DIEPTSIZ2;     // [Read-write] device endpoint-2 transfer size register
    reserved_t<1>        _14;
    volatile uint32_t    OTG_FS_DTXFSTS2;      // [Read-only] OTG_FS device IN endpoint transmit FIFO status register
    reserved_t<1>        _15;
    volatile uint32_t    OTG_FS_DIEPCTL3;      // OTG device endpoint-3 control register
    reserved_t<1>        _16;
    volatile uint32_t    OTG_FS_DIEPINT3;      // device endpoint-3 interrupt register
    reserved_t<1>        _17;
    volatile uint32_t    OTG_FS_DIEPTSIZ3;     // [Read-write] device endpoint-3 transfer size register
    reserved_t<1>        _18;
    volatile uint32_t    OTG_FS_DTXFSTS3;      // [Read-only] OTG_FS device IN endpoint transmit FIFO status register
    reserved_t<1>        _19;
    volatile uint32_t    OTG_FS_DIEPCTL4;      // OTG device endpoint-4 control register
    reserved_t<1>        _20;
    volatile uint32_t    OTG_FS_DIEPINT4;      // device endpoint-4 interrupt register
    reserved_t<2>        _21;
    volatile uint32_t    OTG_FS_DIEPTSIZ4;     // [Read-write] device endpoint-4 transfer size register
    reserved_t<1>        _22;
    volatile uint32_t    OTG_FS_DTXFSTS4;      // [Read-write] OTG_FS device IN endpoint transmit FIFO status register
    volatile uint32_t    OTG_FS_DIEPCTL5;      // OTG device endpoint-5 control register
    reserved_t<1>        _23;
    volatile uint32_t    OTG_FS_DIEPINT5;      // device endpoint-5 interrupt register
    reserved_t<1>        _24;
    volatile uint32_t    OTG_FS_DIEPTSIZ55;    // [Read-write] device endpoint-5 transfer size register
    reserved_t<1>        _25;
    volatile uint32_t    OTG_FS_DTXFSTS55;     // [Read-write] OTG_FS device IN endpoint transmit FIFO status register
    reserved_t<81>       _26;
    volatile uint32_t    OTG_FS_DOEPCTL0;      // device endpoint-0 control register
    reserved_t<1>        _27;
    volatile uint32_t    OTG_FS_DOEPINT0;      // [Read-write] device endpoint-0 interrupt register
    reserved_t<1>        _28;
    volatile uint32_t    OTG_FS_DOEPTSIZ0;     // [Read-write] device OUT endpoint-0 transfer size register
    reserved_t<3>        _29;
    volatile uint32_t    OTG_FS_DOEPCTL1;      // device endpoint-1 control register
    reserved_t<1>        _30;
    volatile uint32_t    OTG_FS_DOEPINT1;      // [Read-write] device endpoint-1 interrupt register
    reserved_t<1>        _31;
    volatile uint32_t    OTG_FS_DOEPTSIZ1;     // [Read-write] device OUT endpoint-1 transfer size register
    reserved_t<3>        _32;
    volatile uint32_t    OTG_FS_DOEPCTL2;      // device endpoint-2 control register
    reserved_t<1>        _33;
    volatile uint32_t    OTG_FS_DOEPINT2;      // [Read-write] device endpoint-2 interrupt register
    reserved_t<1>        _34;
    volatile uint32_t    OTG_FS_DOEPTSIZ2;     // [Read-write] device OUT endpoint-2 transfer size register
    reserved_t<3>        _35;
    volatile uint32_t    OTG_FS_DOEPCTL3;      // device endpoint-3 control register
    reserved_t<1>        _36;
    volatile uint32_t    OTG_FS_DOEPINT3;      // [Read-write] device endpoint-3 interrupt register
    reserved_t<1>        _37;
    volatile uint32_t    OTG_FS_DOEPTSIZ3;     // [Read-write] device OUT endpoint-3 transfer size register
    reserved_t<1>        _38;
    volatile uint32_t    OTG_FS_DOEPCTL4;      // device endpoint-4 control register
    reserved_t<1>        _39;
    volatile uint32_t    OTG_FS_DOEPINT4;      // [Read-write] device endpoint-4 interrupt register
    reserved_t<1>        _40;
    volatile uint32_t    OTG_FS_DOEPTSIZ4;     // [Read-write] device OUT endpoint-4 transfer size register
    reserved_t<1>        _41;
    volatile uint32_t    OTG_FS_DOEPCTL5;      // device endpoint-5 control register
    reserved_t<1>        _42;
    volatile uint32_t    OTG_FS_DOEPINT5;      // [Read-write] device endpoint-5 interrupt register
    reserved_t<1>        _43;
    volatile uint32_t    OTG_FS_DOEPTSIZ5;     // [Read-write] device OUT endpoint-5 transfer size register

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DCFG_DSPD =                // Device speed (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static constexpr uint32_t OTG_FS_DCFG_NZLSOHSK = 0x4;       // Non-zero-length status OUT handshake
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DCFG_DAD =                 // Device address (7 bits)
        bit_field_t<4, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DCFG_PFIVL =               // Periodic frame interval (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    static const uint32_t OTG_FS_DCFG_RESET_VALUE = 0x2200000;

    static constexpr uint32_t OTG_FS_DCTL_RWUSIG = 0x1;         // Remote wakeup signaling, Read-write
    static constexpr uint32_t OTG_FS_DCTL_SDIS = 0x2;           // Soft disconnect, Read-write
    static constexpr uint32_t OTG_FS_DCTL_GINSTS = 0x4;         // Global IN NAK status, Read-only
    static constexpr uint32_t OTG_FS_DCTL_GONSTS = 0x8;         // Global OUT NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DCTL_TCTL =                // Test control (3 bits), Read-write
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t OTG_FS_DCTL_SGINAK = 0x80;        // Set global IN NAK, Read-write
    static constexpr uint32_t OTG_FS_DCTL_CGINAK = 0x100;       // Clear global IN NAK, Read-write
    static constexpr uint32_t OTG_FS_DCTL_SGONAK = 0x200;       // Set global OUT NAK, Read-write
    static constexpr uint32_t OTG_FS_DCTL_CGONAK = 0x400;       // Clear global OUT NAK, Read-write
    static constexpr uint32_t OTG_FS_DCTL_POPRGDNE = 0x800;     // Power-on programming done, Read-write
    static const uint32_t OTG_FS_DCTL_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_DSTS_SUSPSTS = 0x1;        // Suspend status
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DSTS_ENUMSPD =             // Enumerated speed (2 bits)
        bit_field_t<1, 0x3>::value<X>();
    static constexpr uint32_t OTG_FS_DSTS_EERR = 0x8;           // Erratic error
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DSTS_FNSOF =               // Frame number of the received SOF (14 bits)
        bit_field_t<8, 0x3fff>::value<X>();
    static const uint32_t OTG_FS_DSTS_RESET_VALUE = 0x10;

    static constexpr uint32_t OTG_FS_DIEPMSK_XFRCM = 0x1;          // Transfer completed interrupt mask
    static constexpr uint32_t OTG_FS_DIEPMSK_EPDM = 0x2;           // Endpoint disabled interrupt mask
    static constexpr uint32_t OTG_FS_DIEPMSK_TOM = 0x8;            // Timeout condition mask (Non-isochronous endpoints)
    static constexpr uint32_t OTG_FS_DIEPMSK_ITTXFEMSK = 0x10;     // IN token received when TxFIFO empty mask
    static constexpr uint32_t OTG_FS_DIEPMSK_INEPNMM = 0x20;       // IN token received with EP mismatch mask
    static constexpr uint32_t OTG_FS_DIEPMSK_INEPNEM = 0x40;       // IN endpoint NAK effective mask
    static const uint32_t OTG_FS_DIEPMSK_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_DOEPMSK_XFRCM = 0x1;          // Transfer completed interrupt mask
    static constexpr uint32_t OTG_FS_DOEPMSK_EPDM = 0x2;           // Endpoint disabled interrupt mask
    static constexpr uint32_t OTG_FS_DOEPMSK_STUPM = 0x8;          // SETUP phase done mask
    static constexpr uint32_t OTG_FS_DOEPMSK_OTEPDM = 0x10;        // OUT token received when endpoint disabled mask
    static const uint32_t OTG_FS_DOEPMSK_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DAINT_IEPINT =              // IN endpoint interrupt bits (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DAINT_OEPINT =              // OUT endpoint interrupt bits (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OTG_FS_DAINT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DAINTMSK_IEPM =                // IN EP interrupt mask bits (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DAINTMSK_OEPINT =              // OUT endpoint interrupt bits (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OTG_FS_DAINTMSK_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DVBUSDIS_VBUSDT =              // Device VBUS discharge time (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_FS_DVBUSDIS_RESET_VALUE = 0x17d7;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DVBUSPULSE_DVBUSP =              // Device VBUS pulsing time (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t OTG_FS_DVBUSPULSE_RESET_VALUE = 0x5b8;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPEMPMSK_INEPTXFEM =           // IN EP Tx FIFO empty interrupt mask bits (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_FS_DIEPEMPMSK_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPCTL0_MPSIZ =               // Maximum packet size (2 bits), Read-write
        bit_field_t<0, 0x3>::value<X>();
    static constexpr uint32_t OTG_FS_DIEPCTL0_USBAEP = 0x8000;      // USB active endpoint, Read-only
    static constexpr uint32_t OTG_FS_DIEPCTL0_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPCTL0_EPTYP =               // Endpoint type (2 bits), Read-only
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_FS_DIEPCTL0_STALL = 0x200000;     // STALL handshake, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPCTL0_TXFNUM =              // TxFIFO number (4 bits), Read-write
        bit_field_t<22, 0xf>::value<X>();
    static constexpr uint32_t OTG_FS_DIEPCTL0_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_FS_DIEPCTL0_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_FS_DIEPCTL0_EPDIS = 0x40000000;   // Endpoint disable, Read-only
    static constexpr uint32_t OTG_FS_DIEPCTL0_EPENA = 0x80000000;   // Endpoint enable, Read-only
    static const uint32_t OTG_FS_DIEPCTL0_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_DIEPINT0_TXFE = 0x80;          // TXFE, Read-only
    static constexpr uint32_t OTG_FS_DIEPINT0_INEPNE = 0x40;        // INEPNE, Read-write
    static constexpr uint32_t OTG_FS_DIEPINT0_ITTXFE = 0x10;        // ITTXFE, Read-write
    static constexpr uint32_t OTG_FS_DIEPINT0_TOC = 0x8;            // TOC, Read-write
    static constexpr uint32_t OTG_FS_DIEPINT0_EPDISD = 0x2;         // EPDISD, Read-write
    static constexpr uint32_t OTG_FS_DIEPINT0_XFRC = 0x1;           // XFRC, Read-write
    static const uint32_t OTG_FS_DIEPINT0_RESET_VALUE = 0x80;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPTSIZ0_PKTCNT =              // Packet count (2 bits)
        bit_field_t<19, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPTSIZ0_XFRSIZ =              // Transfer size (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    static const uint32_t OTG_FS_DIEPTSIZ0_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DTXFSTS0_INEPTFSAV =           // IN endpoint TxFIFO space available (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_FS_DTXFSTS0_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_DIEPCTL1_EPENA = 0x80000000;   // EPENA, Read-write
    static constexpr uint32_t OTG_FS_DIEPCTL1_EPDIS = 0x40000000;   // EPDIS, Read-write
    static constexpr uint32_t OTG_FS_DIEPCTL1_SODDFRM_SD1PID = 0x20000000;// SODDFRM/SD1PID, Write-only
    static constexpr uint32_t OTG_FS_DIEPCTL1_SD0PID_SEVNFRM = 0x10000000;// SD0PID/SEVNFRM, Write-only
    static constexpr uint32_t OTG_FS_DIEPCTL1_SNAK = 0x8000000;     // SNAK, Write-only
    static constexpr uint32_t OTG_FS_DIEPCTL1_CNAK = 0x4000000;     // CNAK, Write-only
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPCTL1_TXFNUM =              // TXFNUM (4 bits), Read-write
        bit_field_t<22, 0xf>::value<X>();
    static constexpr uint32_t OTG_FS_DIEPCTL1_Stall = 0x200000;     // Stall, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPCTL1_EPTYP =               // EPTYP (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_FS_DIEPCTL1_NAKSTS = 0x20000;     // NAKSTS, Read-only
    static constexpr uint32_t OTG_FS_DIEPCTL1_EONUM_DPID = 0x10000; // EONUM/DPID, Read-only
    static constexpr uint32_t OTG_FS_DIEPCTL1_USBAEP = 0x8000;      // USBAEP, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPCTL1_MPSIZ =               // MPSIZ (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static const uint32_t OTG_FS_DIEPCTL1_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_DIEPINT1_TXFE = 0x80;          // TXFE, Read-only
    static constexpr uint32_t OTG_FS_DIEPINT1_INEPNE = 0x40;        // INEPNE, Read-write
    static constexpr uint32_t OTG_FS_DIEPINT1_ITTXFE = 0x10;        // ITTXFE, Read-write
    static constexpr uint32_t OTG_FS_DIEPINT1_TOC = 0x8;            // TOC, Read-write
    static constexpr uint32_t OTG_FS_DIEPINT1_EPDISD = 0x2;         // EPDISD, Read-write
    static constexpr uint32_t OTG_FS_DIEPINT1_XFRC = 0x1;           // XFRC, Read-write
    static const uint32_t OTG_FS_DIEPINT1_RESET_VALUE = 0x80;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPTSIZ1_MCNT =                // Multi count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPTSIZ1_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPTSIZ1_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    static const uint32_t OTG_FS_DIEPTSIZ1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DTXFSTS1_INEPTFSAV =           // IN endpoint TxFIFO space available (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_FS_DTXFSTS1_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_DIEPCTL2_EPENA = 0x80000000;   // EPENA, Read-write
    static constexpr uint32_t OTG_FS_DIEPCTL2_EPDIS = 0x40000000;   // EPDIS, Read-write
    static constexpr uint32_t OTG_FS_DIEPCTL2_SODDFRM = 0x20000000; // SODDFRM, Write-only
    static constexpr uint32_t OTG_FS_DIEPCTL2_SD0PID_SEVNFRM = 0x10000000;// SD0PID/SEVNFRM, Write-only
    static constexpr uint32_t OTG_FS_DIEPCTL2_SNAK = 0x8000000;     // SNAK, Write-only
    static constexpr uint32_t OTG_FS_DIEPCTL2_CNAK = 0x4000000;     // CNAK, Write-only
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPCTL2_TXFNUM =              // TXFNUM (4 bits), Read-write
        bit_field_t<22, 0xf>::value<X>();
    static constexpr uint32_t OTG_FS_DIEPCTL2_Stall = 0x200000;     // Stall, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPCTL2_EPTYP =               // EPTYP (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_FS_DIEPCTL2_NAKSTS = 0x20000;     // NAKSTS, Read-only
    static constexpr uint32_t OTG_FS_DIEPCTL2_EONUM_DPID = 0x10000; // EONUM/DPID, Read-only
    static constexpr uint32_t OTG_FS_DIEPCTL2_USBAEP = 0x8000;      // USBAEP, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPCTL2_MPSIZ =               // MPSIZ (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static const uint32_t OTG_FS_DIEPCTL2_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_DIEPINT2_TXFE = 0x80;          // TXFE, Read-only
    static constexpr uint32_t OTG_FS_DIEPINT2_INEPNE = 0x40;        // INEPNE, Read-write
    static constexpr uint32_t OTG_FS_DIEPINT2_ITTXFE = 0x10;        // ITTXFE, Read-write
    static constexpr uint32_t OTG_FS_DIEPINT2_TOC = 0x8;            // TOC, Read-write
    static constexpr uint32_t OTG_FS_DIEPINT2_EPDISD = 0x2;         // EPDISD, Read-write
    static constexpr uint32_t OTG_FS_DIEPINT2_XFRC = 0x1;           // XFRC, Read-write
    static const uint32_t OTG_FS_DIEPINT2_RESET_VALUE = 0x80;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPTSIZ2_MCNT =                // Multi count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPTSIZ2_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPTSIZ2_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    static const uint32_t OTG_FS_DIEPTSIZ2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DTXFSTS2_INEPTFSAV =           // IN endpoint TxFIFO space available (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_FS_DTXFSTS2_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_DIEPCTL3_EPENA = 0x80000000;   // EPENA, Read-write
    static constexpr uint32_t OTG_FS_DIEPCTL3_EPDIS = 0x40000000;   // EPDIS, Read-write
    static constexpr uint32_t OTG_FS_DIEPCTL3_SODDFRM = 0x20000000; // SODDFRM, Write-only
    static constexpr uint32_t OTG_FS_DIEPCTL3_SD0PID_SEVNFRM = 0x10000000;// SD0PID/SEVNFRM, Write-only
    static constexpr uint32_t OTG_FS_DIEPCTL3_SNAK = 0x8000000;     // SNAK, Write-only
    static constexpr uint32_t OTG_FS_DIEPCTL3_CNAK = 0x4000000;     // CNAK, Write-only
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPCTL3_TXFNUM =              // TXFNUM (4 bits), Read-write
        bit_field_t<22, 0xf>::value<X>();
    static constexpr uint32_t OTG_FS_DIEPCTL3_Stall = 0x200000;     // Stall, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPCTL3_EPTYP =               // EPTYP (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_FS_DIEPCTL3_NAKSTS = 0x20000;     // NAKSTS, Read-only
    static constexpr uint32_t OTG_FS_DIEPCTL3_EONUM_DPID = 0x10000; // EONUM/DPID, Read-only
    static constexpr uint32_t OTG_FS_DIEPCTL3_USBAEP = 0x8000;      // USBAEP, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPCTL3_MPSIZ =               // MPSIZ (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static const uint32_t OTG_FS_DIEPCTL3_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_DIEPINT3_TXFE = 0x80;          // TXFE, Read-only
    static constexpr uint32_t OTG_FS_DIEPINT3_INEPNE = 0x40;        // INEPNE, Read-write
    static constexpr uint32_t OTG_FS_DIEPINT3_ITTXFE = 0x10;        // ITTXFE, Read-write
    static constexpr uint32_t OTG_FS_DIEPINT3_TOC = 0x8;            // TOC, Read-write
    static constexpr uint32_t OTG_FS_DIEPINT3_EPDISD = 0x2;         // EPDISD, Read-write
    static constexpr uint32_t OTG_FS_DIEPINT3_XFRC = 0x1;           // XFRC, Read-write
    static const uint32_t OTG_FS_DIEPINT3_RESET_VALUE = 0x80;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPTSIZ3_MCNT =                // Multi count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPTSIZ3_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPTSIZ3_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    static const uint32_t OTG_FS_DIEPTSIZ3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DTXFSTS3_INEPTFSAV =           // IN endpoint TxFIFO space available (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_FS_DTXFSTS3_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_DIEPCTL4_EPENA = 0x80000000;   // EPENA, Read-write
    static constexpr uint32_t OTG_FS_DIEPCTL4_EPDIS = 0x40000000;   // EPDIS, Read-write
    static constexpr uint32_t OTG_FS_DIEPCTL4_SODDFRM = 0x20000000; // SODDFRM, Write-only
    static constexpr uint32_t OTG_FS_DIEPCTL4_SD0PID_SEVNFRM = 0x10000000;// SD0PID/SEVNFRM, Write-only
    static constexpr uint32_t OTG_FS_DIEPCTL4_SNAK = 0x8000000;     // SNAK, Write-only
    static constexpr uint32_t OTG_FS_DIEPCTL4_CNAK = 0x4000000;     // CNAK, Write-only
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPCTL4_TXFNUM =              // TXFNUM (4 bits), Read-write
        bit_field_t<22, 0xf>::value<X>();
    static constexpr uint32_t OTG_FS_DIEPCTL4_Stall = 0x200000;     // Stall, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPCTL4_EPTYP =               // EPTYP (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_FS_DIEPCTL4_NAKSTS = 0x20000;     // NAKSTS, Read-only
    static constexpr uint32_t OTG_FS_DIEPCTL4_EONUM_DPID = 0x10000; // EONUM/DPID, Read-only
    static constexpr uint32_t OTG_FS_DIEPCTL4_USBAEP = 0x8000;      // USBAEP, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPCTL4_MPSIZ =               // MPSIZ (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static const uint32_t OTG_FS_DIEPCTL4_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_DIEPINT4_TXFE = 0x80;          // TXFE, Read-only
    static constexpr uint32_t OTG_FS_DIEPINT4_INEPNE = 0x40;        // INEPNE, Read-write
    static constexpr uint32_t OTG_FS_DIEPINT4_ITTXFE = 0x10;        // ITTXFE, Read-write
    static constexpr uint32_t OTG_FS_DIEPINT4_TOC = 0x8;            // TOC, Read-write
    static constexpr uint32_t OTG_FS_DIEPINT4_EPDISD = 0x2;         // EPDISD, Read-write
    static constexpr uint32_t OTG_FS_DIEPINT4_XFRC = 0x1;           // XFRC, Read-write
    static const uint32_t OTG_FS_DIEPINT4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPTSIZ4_MCNT =                // Multi count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPTSIZ4_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPTSIZ4_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    static const uint32_t OTG_FS_DIEPTSIZ4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DTXFSTS4_INEPTFSAV =           // IN endpoint TxFIFO space available (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_FS_DTXFSTS4_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_DIEPCTL5_EPENA = 0x80000000;   // EPENA, Read-write
    static constexpr uint32_t OTG_FS_DIEPCTL5_EPDIS = 0x40000000;   // EPDIS, Read-write
    static constexpr uint32_t OTG_FS_DIEPCTL5_SODDFRM = 0x20000000; // SODDFRM, Write-only
    static constexpr uint32_t OTG_FS_DIEPCTL5_SD0PID_SEVNFRM = 0x10000000;// SD0PID/SEVNFRM, Write-only
    static constexpr uint32_t OTG_FS_DIEPCTL5_SNAK = 0x8000000;     // SNAK, Write-only
    static constexpr uint32_t OTG_FS_DIEPCTL5_CNAK = 0x4000000;     // CNAK, Write-only
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPCTL5_TXFNUM =              // TXFNUM (4 bits), Read-write
        bit_field_t<22, 0xf>::value<X>();
    static constexpr uint32_t OTG_FS_DIEPCTL5_Stall = 0x200000;     // Stall, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPCTL5_EPTYP =               // EPTYP (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_FS_DIEPCTL5_NAKSTS = 0x20000;     // NAKSTS, Read-only
    static constexpr uint32_t OTG_FS_DIEPCTL5_EONUM_DPID = 0x10000; // EONUM/DPID, Read-only
    static constexpr uint32_t OTG_FS_DIEPCTL5_USBAEP = 0x8000;      // USBAEP, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPCTL5_MPSIZ =               // MPSIZ (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static const uint32_t OTG_FS_DIEPCTL5_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_DIEPINT5_TXFE = 0x80;          // TXFE, Read-only
    static constexpr uint32_t OTG_FS_DIEPINT5_INEPNE = 0x40;        // INEPNE, Read-write
    static constexpr uint32_t OTG_FS_DIEPINT5_ITTXFE = 0x10;        // ITTXFE, Read-write
    static constexpr uint32_t OTG_FS_DIEPINT5_TOC = 0x8;            // TOC, Read-write
    static constexpr uint32_t OTG_FS_DIEPINT5_EPDISD = 0x2;         // EPDISD, Read-write
    static constexpr uint32_t OTG_FS_DIEPINT5_XFRC = 0x1;           // XFRC, Read-write
    static const uint32_t OTG_FS_DIEPINT5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPTSIZ55_MCNT =                // Multi count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPTSIZ55_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DIEPTSIZ55_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    static const uint32_t OTG_FS_DIEPTSIZ55_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DTXFSTS55_INEPTFSAV =           // IN endpoint TxFIFO space available (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_FS_DTXFSTS55_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_DOEPCTL0_EPENA = 0x80000000;   // EPENA, Write-only
    static constexpr uint32_t OTG_FS_DOEPCTL0_EPDIS = 0x40000000;   // EPDIS, Read-only
    static constexpr uint32_t OTG_FS_DOEPCTL0_SNAK = 0x8000000;     // SNAK, Write-only
    static constexpr uint32_t OTG_FS_DOEPCTL0_CNAK = 0x4000000;     // CNAK, Write-only
    static constexpr uint32_t OTG_FS_DOEPCTL0_Stall = 0x200000;     // Stall, Read-write
    static constexpr uint32_t OTG_FS_DOEPCTL0_SNPM = 0x100000;      // SNPM, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DOEPCTL0_EPTYP =               // EPTYP (2 bits), Read-only
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_FS_DOEPCTL0_NAKSTS = 0x20000;     // NAKSTS, Read-only
    static constexpr uint32_t OTG_FS_DOEPCTL0_USBAEP = 0x8000;      // USBAEP, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DOEPCTL0_MPSIZ =               // MPSIZ (2 bits), Read-only
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t OTG_FS_DOEPCTL0_RESET_VALUE = 0x8000;

    static constexpr uint32_t OTG_FS_DOEPINT0_B2BSTUP = 0x40;       // B2BSTUP
    static constexpr uint32_t OTG_FS_DOEPINT0_OTEPDIS = 0x10;       // OTEPDIS
    static constexpr uint32_t OTG_FS_DOEPINT0_STUP = 0x8;           // STUP
    static constexpr uint32_t OTG_FS_DOEPINT0_EPDISD = 0x2;         // EPDISD
    static constexpr uint32_t OTG_FS_DOEPINT0_XFRC = 0x1;           // XFRC
    static const uint32_t OTG_FS_DOEPINT0_RESET_VALUE = 0x80;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DOEPTSIZ0_STUPCNT =             // SETUP packet count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static constexpr uint32_t OTG_FS_DOEPTSIZ0_PKTCNT = 0x80000;     // Packet count
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DOEPTSIZ0_XFRSIZ =              // Transfer size (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    static const uint32_t OTG_FS_DOEPTSIZ0_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_DOEPCTL1_EPENA = 0x80000000;   // EPENA, Read-write
    static constexpr uint32_t OTG_FS_DOEPCTL1_EPDIS = 0x40000000;   // EPDIS, Read-write
    static constexpr uint32_t OTG_FS_DOEPCTL1_SODDFRM = 0x20000000; // SODDFRM, Write-only
    static constexpr uint32_t OTG_FS_DOEPCTL1_SD0PID_SEVNFRM = 0x10000000;// SD0PID/SEVNFRM, Write-only
    static constexpr uint32_t OTG_FS_DOEPCTL1_SNAK = 0x8000000;     // SNAK, Write-only
    static constexpr uint32_t OTG_FS_DOEPCTL1_CNAK = 0x4000000;     // CNAK, Write-only
    static constexpr uint32_t OTG_FS_DOEPCTL1_Stall = 0x200000;     // Stall, Read-write
    static constexpr uint32_t OTG_FS_DOEPCTL1_SNPM = 0x100000;      // SNPM, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DOEPCTL1_EPTYP =               // EPTYP (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_FS_DOEPCTL1_NAKSTS = 0x20000;     // NAKSTS, Read-only
    static constexpr uint32_t OTG_FS_DOEPCTL1_EONUM_DPID = 0x10000; // EONUM/DPID, Read-only
    static constexpr uint32_t OTG_FS_DOEPCTL1_USBAEP = 0x8000;      // USBAEP, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DOEPCTL1_MPSIZ =               // MPSIZ (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static const uint32_t OTG_FS_DOEPCTL1_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_DOEPINT1_B2BSTUP = 0x40;       // B2BSTUP
    static constexpr uint32_t OTG_FS_DOEPINT1_OTEPDIS = 0x10;       // OTEPDIS
    static constexpr uint32_t OTG_FS_DOEPINT1_STUP = 0x8;           // STUP
    static constexpr uint32_t OTG_FS_DOEPINT1_EPDISD = 0x2;         // EPDISD
    static constexpr uint32_t OTG_FS_DOEPINT1_XFRC = 0x1;           // XFRC
    static const uint32_t OTG_FS_DOEPINT1_RESET_VALUE = 0x80;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DOEPTSIZ1_RXDPID_STUPCNT =      // Received data PID/SETUP packet count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DOEPTSIZ1_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DOEPTSIZ1_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    static const uint32_t OTG_FS_DOEPTSIZ1_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_DOEPCTL2_EPENA = 0x80000000;   // EPENA, Read-write
    static constexpr uint32_t OTG_FS_DOEPCTL2_EPDIS = 0x40000000;   // EPDIS, Read-write
    static constexpr uint32_t OTG_FS_DOEPCTL2_SODDFRM = 0x20000000; // SODDFRM, Write-only
    static constexpr uint32_t OTG_FS_DOEPCTL2_SD0PID_SEVNFRM = 0x10000000;// SD0PID/SEVNFRM, Write-only
    static constexpr uint32_t OTG_FS_DOEPCTL2_SNAK = 0x8000000;     // SNAK, Write-only
    static constexpr uint32_t OTG_FS_DOEPCTL2_CNAK = 0x4000000;     // CNAK, Write-only
    static constexpr uint32_t OTG_FS_DOEPCTL2_Stall = 0x200000;     // Stall, Read-write
    static constexpr uint32_t OTG_FS_DOEPCTL2_SNPM = 0x100000;      // SNPM, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DOEPCTL2_EPTYP =               // EPTYP (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_FS_DOEPCTL2_NAKSTS = 0x20000;     // NAKSTS, Read-only
    static constexpr uint32_t OTG_FS_DOEPCTL2_EONUM_DPID = 0x10000; // EONUM/DPID, Read-only
    static constexpr uint32_t OTG_FS_DOEPCTL2_USBAEP = 0x8000;      // USBAEP, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DOEPCTL2_MPSIZ =               // MPSIZ (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static const uint32_t OTG_FS_DOEPCTL2_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_DOEPINT2_B2BSTUP = 0x40;       // B2BSTUP
    static constexpr uint32_t OTG_FS_DOEPINT2_OTEPDIS = 0x10;       // OTEPDIS
    static constexpr uint32_t OTG_FS_DOEPINT2_STUP = 0x8;           // STUP
    static constexpr uint32_t OTG_FS_DOEPINT2_EPDISD = 0x2;         // EPDISD
    static constexpr uint32_t OTG_FS_DOEPINT2_XFRC = 0x1;           // XFRC
    static const uint32_t OTG_FS_DOEPINT2_RESET_VALUE = 0x80;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DOEPTSIZ2_RXDPID_STUPCNT =      // Received data PID/SETUP packet count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DOEPTSIZ2_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DOEPTSIZ2_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    static const uint32_t OTG_FS_DOEPTSIZ2_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_DOEPCTL3_EPENA = 0x80000000;   // EPENA, Read-write
    static constexpr uint32_t OTG_FS_DOEPCTL3_EPDIS = 0x40000000;   // EPDIS, Read-write
    static constexpr uint32_t OTG_FS_DOEPCTL3_SODDFRM = 0x20000000; // SODDFRM, Write-only
    static constexpr uint32_t OTG_FS_DOEPCTL3_SD0PID_SEVNFRM = 0x10000000;// SD0PID/SEVNFRM, Write-only
    static constexpr uint32_t OTG_FS_DOEPCTL3_SNAK = 0x8000000;     // SNAK, Write-only
    static constexpr uint32_t OTG_FS_DOEPCTL3_CNAK = 0x4000000;     // CNAK, Write-only
    static constexpr uint32_t OTG_FS_DOEPCTL3_Stall = 0x200000;     // Stall, Read-write
    static constexpr uint32_t OTG_FS_DOEPCTL3_SNPM = 0x100000;      // SNPM, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DOEPCTL3_EPTYP =               // EPTYP (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_FS_DOEPCTL3_NAKSTS = 0x20000;     // NAKSTS, Read-only
    static constexpr uint32_t OTG_FS_DOEPCTL3_EONUM_DPID = 0x10000; // EONUM/DPID, Read-only
    static constexpr uint32_t OTG_FS_DOEPCTL3_USBAEP = 0x8000;      // USBAEP, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DOEPCTL3_MPSIZ =               // MPSIZ (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static const uint32_t OTG_FS_DOEPCTL3_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_DOEPINT3_B2BSTUP = 0x40;       // B2BSTUP
    static constexpr uint32_t OTG_FS_DOEPINT3_OTEPDIS = 0x10;       // OTEPDIS
    static constexpr uint32_t OTG_FS_DOEPINT3_STUP = 0x8;           // STUP
    static constexpr uint32_t OTG_FS_DOEPINT3_EPDISD = 0x2;         // EPDISD
    static constexpr uint32_t OTG_FS_DOEPINT3_XFRC = 0x1;           // XFRC
    static const uint32_t OTG_FS_DOEPINT3_RESET_VALUE = 0x80;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DOEPTSIZ3_RXDPID_STUPCNT =      // Received data PID/SETUP packet count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DOEPTSIZ3_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DOEPTSIZ3_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    static const uint32_t OTG_FS_DOEPTSIZ3_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_DOEPCTL4_EPENA = 0x80000000;   // EPENA, Read-write
    static constexpr uint32_t OTG_FS_DOEPCTL4_EPDIS = 0x40000000;   // EPDIS, Read-write
    static constexpr uint32_t OTG_FS_DOEPCTL4_SODDFRM = 0x20000000; // SODDFRM, Write-only
    static constexpr uint32_t OTG_FS_DOEPCTL4_SD0PID_SEVNFRM = 0x10000000;// SD0PID/SEVNFRM, Write-only
    static constexpr uint32_t OTG_FS_DOEPCTL4_SNAK = 0x8000000;     // SNAK, Write-only
    static constexpr uint32_t OTG_FS_DOEPCTL4_CNAK = 0x4000000;     // CNAK, Write-only
    static constexpr uint32_t OTG_FS_DOEPCTL4_Stall = 0x200000;     // Stall, Read-write
    static constexpr uint32_t OTG_FS_DOEPCTL4_SNPM = 0x100000;      // SNPM, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DOEPCTL4_EPTYP =               // EPTYP (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_FS_DOEPCTL4_NAKSTS = 0x20000;     // NAKSTS, Read-only
    static constexpr uint32_t OTG_FS_DOEPCTL4_EONUM_DPID = 0x10000; // EONUM/DPID, Read-only
    static constexpr uint32_t OTG_FS_DOEPCTL4_USBAEP = 0x8000;      // USBAEP, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DOEPCTL4_MPSIZ =               // MPSIZ (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static const uint32_t OTG_FS_DOEPCTL4_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_DOEPINT4_B2BSTUP = 0x40;       // B2BSTUP
    static constexpr uint32_t OTG_FS_DOEPINT4_OTEPDIS = 0x10;       // OTEPDIS
    static constexpr uint32_t OTG_FS_DOEPINT4_STUP = 0x8;           // STUP
    static constexpr uint32_t OTG_FS_DOEPINT4_EPDISD = 0x2;         // EPDISD
    static constexpr uint32_t OTG_FS_DOEPINT4_XFRC = 0x1;           // XFRC
    static const uint32_t OTG_FS_DOEPINT4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DOEPTSIZ4_RXDPID_STUPCNT =      // Received data PID/SETUP packet count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DOEPTSIZ4_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DOEPTSIZ4_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    static const uint32_t OTG_FS_DOEPTSIZ4_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_DOEPCTL5_EPENA = 0x80000000;   // EPENA, Read-write
    static constexpr uint32_t OTG_FS_DOEPCTL5_EPDIS = 0x40000000;   // EPDIS, Read-write
    static constexpr uint32_t OTG_FS_DOEPCTL5_SODDFRM = 0x20000000; // SODDFRM, Write-only
    static constexpr uint32_t OTG_FS_DOEPCTL5_SD0PID_SEVNFRM = 0x10000000;// SD0PID/SEVNFRM, Write-only
    static constexpr uint32_t OTG_FS_DOEPCTL5_SNAK = 0x8000000;     // SNAK, Write-only
    static constexpr uint32_t OTG_FS_DOEPCTL5_CNAK = 0x4000000;     // CNAK, Write-only
    static constexpr uint32_t OTG_FS_DOEPCTL5_Stall = 0x200000;     // Stall, Read-write
    static constexpr uint32_t OTG_FS_DOEPCTL5_SNPM = 0x100000;      // SNPM, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DOEPCTL5_EPTYP =               // EPTYP (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_FS_DOEPCTL5_NAKSTS = 0x20000;     // NAKSTS, Read-only
    static constexpr uint32_t OTG_FS_DOEPCTL5_EONUM_DPID = 0x10000; // EONUM/DPID, Read-only
    static constexpr uint32_t OTG_FS_DOEPCTL5_USBAEP = 0x8000;      // USBAEP, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DOEPCTL5_MPSIZ =               // MPSIZ (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static const uint32_t OTG_FS_DOEPCTL5_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_FS_DOEPINT5_B2BSTUP = 0x40;       // B2BSTUP
    static constexpr uint32_t OTG_FS_DOEPINT5_OTEPDIS = 0x10;       // OTEPDIS
    static constexpr uint32_t OTG_FS_DOEPINT5_STUP = 0x8;           // STUP
    static constexpr uint32_t OTG_FS_DOEPINT5_EPDISD = 0x2;         // EPDISD
    static constexpr uint32_t OTG_FS_DOEPINT5_XFRC = 0x1;           // XFRC
    static const uint32_t OTG_FS_DOEPINT5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DOEPTSIZ5_RXDPID_STUPCNT =      // Received data PID/SETUP packet count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DOEPTSIZ5_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_FS_DOEPTSIZ5_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    static const uint32_t OTG_FS_DOEPTSIZ5_RESET_VALUE = 0x0;
};

static otg_fs_device_t& OTG_FS_DEVICE = *reinterpret_cast<otg_fs_device_t*>(0x50000800);

#define HAVE_PERIPHERAL_OTG_FS_DEVICE


////
//
//    USB on the go full speed
//
////

struct otg_fs_pwrclk_t
{
    volatile uint32_t    OTG_FS_PCGCCTL;       // [Read-write] OTG_FS power and clock gating control register (OTG_FS_PCGCCTL)

    static constexpr uint32_t OTG_FS_PCGCCTL_STPPCLK = 0x1;        // Stop PHY clock
    static constexpr uint32_t OTG_FS_PCGCCTL_GATEHCLK = 0x2;       // Gate HCLK
    static constexpr uint32_t OTG_FS_PCGCCTL_PHYSUSP = 0x10;       // PHY Suspended
    static const uint32_t OTG_FS_PCGCCTL_RESET_VALUE = 0x0;
};

static otg_fs_pwrclk_t& OTG_FS_PWRCLK = *reinterpret_cast<otg_fs_pwrclk_t*>(0x50000e00);

#define HAVE_PERIPHERAL_OTG_FS_PWRCLK


////
//
//    USB on the go high speed
//
////

struct otg_hs_host_t
{
    volatile uint32_t    OTG_HS_HCFG;          // OTG_HS host configuration register
    volatile uint32_t    OTG_HS_HFIR;          // [Read-write] OTG_HS Host frame interval register
    volatile uint32_t    OTG_HS_HFNUM;         // [Read-only] OTG_HS host frame number/frame time remaining register
    reserved_t<1>        _0;
    volatile uint32_t    OTG_HS_HPTXSTS;       // OTG_HS_Host periodic transmit FIFO/queue status register
    volatile uint32_t    OTG_HS_HAINT;         // [Read-only] OTG_HS Host all channels interrupt register
    volatile uint32_t    OTG_HS_HAINTMSK;      // [Read-write] OTG_HS host all channels interrupt mask register
    reserved_t<9>        _1;
    volatile uint32_t    OTG_HS_HPRT;          // OTG_HS host port control and status register
    reserved_t<47>       _2;
    volatile uint32_t    OTG_HS_HCCHAR0;       // [Read-write] OTG_HS host channel-0 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT0;       // [Read-write] OTG_HS host channel-0 split control register
    volatile uint32_t    OTG_HS_HCINT0;        // [Read-write] OTG_HS host channel-11 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK0;     // [Read-write] OTG_HS host channel-11 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ0;       // [Read-write] OTG_HS host channel-11 transfer size register
    volatile uint32_t    OTG_HS_HCDMA0;        // [Read-write] OTG_HS host channel-0 DMA address register
    reserved_t<2>        _3;
    volatile uint32_t    OTG_HS_HCCHAR1;       // [Read-write] OTG_HS host channel-1 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT1;       // [Read-write] OTG_HS host channel-1 split control register
    volatile uint32_t    OTG_HS_HCINT1;        // [Read-write] OTG_HS host channel-1 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK1;     // [Read-write] OTG_HS host channel-1 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ1;       // [Read-write] OTG_HS host channel-1 transfer size register
    volatile uint32_t    OTG_HS_HCDMA1;        // [Read-write] OTG_HS host channel-1 DMA address register
    reserved_t<2>        _4;
    volatile uint32_t    OTG_HS_HCCHAR2;       // [Read-write] OTG_HS host channel-2 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT2;       // [Read-write] OTG_HS host channel-2 split control register
    volatile uint32_t    OTG_HS_HCINT2;        // [Read-write] OTG_HS host channel-2 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK2;     // [Read-write] OTG_HS host channel-2 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ2;       // [Read-write] OTG_HS host channel-2 transfer size register
    volatile uint32_t    OTG_HS_HCDMA2;        // [Read-write] OTG_HS host channel-2 DMA address register
    reserved_t<2>        _5;
    volatile uint32_t    OTG_HS_HCCHAR3;       // [Read-write] OTG_HS host channel-3 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT3;       // [Read-write] OTG_HS host channel-3 split control register
    volatile uint32_t    OTG_HS_HCINT3;        // [Read-write] OTG_HS host channel-3 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK3;     // [Read-write] OTG_HS host channel-3 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ3;       // [Read-write] OTG_HS host channel-3 transfer size register
    volatile uint32_t    OTG_HS_HCDMA3;        // [Read-write] OTG_HS host channel-3 DMA address register
    reserved_t<2>        _6;
    volatile uint32_t    OTG_HS_HCCHAR4;       // [Read-write] OTG_HS host channel-4 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT4;       // [Read-write] OTG_HS host channel-4 split control register
    volatile uint32_t    OTG_HS_HCINT4;        // [Read-write] OTG_HS host channel-4 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK4;     // [Read-write] OTG_HS host channel-4 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ4;       // [Read-write] OTG_HS host channel-4 transfer size register
    volatile uint32_t    OTG_HS_HCDMA4;        // [Read-write] OTG_HS host channel-4 DMA address register
    reserved_t<2>        _7;
    volatile uint32_t    OTG_HS_HCCHAR5;       // [Read-write] OTG_HS host channel-5 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT5;       // [Read-write] OTG_HS host channel-5 split control register
    volatile uint32_t    OTG_HS_HCINT5;        // [Read-write] OTG_HS host channel-5 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK5;     // [Read-write] OTG_HS host channel-5 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ5;       // [Read-write] OTG_HS host channel-5 transfer size register
    volatile uint32_t    OTG_HS_HCDMA5;        // [Read-write] OTG_HS host channel-5 DMA address register
    reserved_t<2>        _8;
    volatile uint32_t    OTG_HS_HCCHAR6;       // [Read-write] OTG_HS host channel-6 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT6;       // [Read-write] OTG_HS host channel-6 split control register
    volatile uint32_t    OTG_HS_HCINT6;        // [Read-write] OTG_HS host channel-6 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK6;     // [Read-write] OTG_HS host channel-6 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ6;       // [Read-write] OTG_HS host channel-6 transfer size register
    volatile uint32_t    OTG_HS_HCDMA6;        // [Read-write] OTG_HS host channel-6 DMA address register
    reserved_t<2>        _9;
    volatile uint32_t    OTG_HS_HCCHAR7;       // [Read-write] OTG_HS host channel-7 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT7;       // [Read-write] OTG_HS host channel-7 split control register
    volatile uint32_t    OTG_HS_HCINT7;        // [Read-write] OTG_HS host channel-7 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK7;     // [Read-write] OTG_HS host channel-7 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ7;       // [Read-write] OTG_HS host channel-7 transfer size register
    volatile uint32_t    OTG_HS_HCDMA7;        // [Read-write] OTG_HS host channel-7 DMA address register
    reserved_t<2>        _10;
    volatile uint32_t    OTG_HS_HCCHAR8;       // [Read-write] OTG_HS host channel-8 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT8;       // [Read-write] OTG_HS host channel-8 split control register
    volatile uint32_t    OTG_HS_HCINT8;        // [Read-write] OTG_HS host channel-8 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK8;     // [Read-write] OTG_HS host channel-8 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ8;       // [Read-write] OTG_HS host channel-8 transfer size register
    volatile uint32_t    OTG_HS_HCDMA8;        // [Read-write] OTG_HS host channel-8 DMA address register
    reserved_t<2>        _11;
    volatile uint32_t    OTG_HS_HCCHAR9;       // [Read-write] OTG_HS host channel-9 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT9;       // [Read-write] OTG_HS host channel-9 split control register
    volatile uint32_t    OTG_HS_HCINT9;        // [Read-write] OTG_HS host channel-9 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK9;     // [Read-write] OTG_HS host channel-9 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ9;       // [Read-write] OTG_HS host channel-9 transfer size register
    volatile uint32_t    OTG_HS_HCDMA9;        // [Read-write] OTG_HS host channel-9 DMA address register
    reserved_t<2>        _12;
    volatile uint32_t    OTG_HS_HCCHAR10;      // [Read-write] OTG_HS host channel-10 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT10;      // [Read-write] OTG_HS host channel-10 split control register
    volatile uint32_t    OTG_HS_HCINT10;       // [Read-write] OTG_HS host channel-10 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK10;    // [Read-write] OTG_HS host channel-10 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ10;      // [Read-write] OTG_HS host channel-10 transfer size register
    volatile uint32_t    OTG_HS_HCDMA10;       // [Read-write] OTG_HS host channel-10 DMA address register
    reserved_t<2>        _13;
    volatile uint32_t    OTG_HS_HCCHAR11;      // [Read-write] OTG_HS host channel-11 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT11;      // [Read-write] OTG_HS host channel-11 split control register
    volatile uint32_t    OTG_HS_HCINT11;       // [Read-write] OTG_HS host channel-11 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK11;    // [Read-write] OTG_HS host channel-11 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ11;      // [Read-write] OTG_HS host channel-11 transfer size register
    volatile uint32_t    OTG_HS_HCDMA11;       // [Read-write] OTG_HS host channel-11 DMA address register
    volatile uint32_t    OTG_HS_HCCHAR12;      // [Read-write] OTG_HS host channel-12 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT12;      // [Read-write] OTG_HS host channel-12 split control register
    volatile uint32_t    OTG_HS_HCINT12;       // [Read-write] OTG_HS host channel-12 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK12;    // [Read-write] OTG_HS host channel-12 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ12;      // [Read-write] OTG_HS host channel-12 transfer size register
    volatile uint32_t    OTG_HS_HCDMA12;       // [Read-write] OTG_HS host channel-12 DMA address register
    volatile uint32_t    OTG_HS_HCCHAR13;      // [Read-write] OTG_HS host channel-13 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT13;      // [Read-write] OTG_HS host channel-13 split control register
    volatile uint32_t    OTG_HS_HCINT13;       // [Read-write] OTG_HS host channel-13 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK13;    // [Read-write] OTG_HS host channel-13 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ13;      // [Read-write] OTG_HS host channel-13 transfer size register
    volatile uint32_t    OTG_HS_HCDMA13;       // [Read-write] OTG_HS host channel-13 DMA address register
    volatile uint32_t    OTG_HS_HCCHAR14;      // [Read-write] OTG_HS host channel-14 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT14;      // [Read-write] OTG_HS host channel-14 split control register
    volatile uint32_t    OTG_HS_HCINT14;       // [Read-write] OTG_HS host channel-14 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK14;    // [Read-write] OTG_HS host channel-14 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ14;      // [Read-write] OTG_HS host channel-14 transfer size register
    volatile uint32_t    OTG_HS_HCDMA14;       // [Read-write] OTG_HS host channel-14 DMA address register
    volatile uint32_t    OTG_HS_HCCHAR15;      // [Read-write] OTG_HS host channel-15 characteristics register
    volatile uint32_t    OTG_HS_HCSPLT15;      // [Read-write] OTG_HS host channel-15 split control register
    volatile uint32_t    OTG_HS_HCINT15;       // [Read-write] OTG_HS host channel-15 interrupt register
    volatile uint32_t    OTG_HS_HCINTMSK15;    // [Read-write] OTG_HS host channel-15 interrupt mask register
    volatile uint32_t    OTG_HS_HCTSIZ15;      // [Read-write] OTG_HS host channel-15 transfer size register
    volatile uint32_t    OTG_HS_HCDMA15;       // [Read-write] OTG_HS host channel-15 DMA address register

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCFG_FSLSPCS =             // FS/LS PHY clock select (2 bits), Read-write
        bit_field_t<0, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCFG_FSLSS = 0x4;          // FS- and LS-only support, Read-only
    static const uint32_t OTG_HS_HCFG_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HFIR_FRIVL =               // Frame interval (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_HFIR_RESET_VALUE = 0xea60;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HFNUM_FRNUM =               // Frame number (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HFNUM_FTREM =               // Frame time remaining (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OTG_HS_HFNUM_RESET_VALUE = 0x3fff;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HPTXSTS_PTXFSAVL =            // Periodic transmit data FIFO space available (16 bits), Read-write
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HPTXSTS_PTXQSAV =             // Periodic transmit request queue space available (8 bits), Read-only
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HPTXSTS_PTXQTOP =             // Top of the periodic transmit request queue (8 bits), Read-only
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t OTG_HS_HPTXSTS_RESET_VALUE = 0x80100;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HAINT_HAINT =               // Channel interrupts (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_HAINT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HAINTMSK_HAINTM =              // Channel interrupt mask (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_HAINTMSK_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HPRT_PCSTS = 0x1;          // Port connect status, Read-only
    static constexpr uint32_t OTG_HS_HPRT_PCDET = 0x2;          // Port connect detected, Read-write
    static constexpr uint32_t OTG_HS_HPRT_PENA = 0x4;           // Port enable, Read-write
    static constexpr uint32_t OTG_HS_HPRT_PENCHNG = 0x8;        // Port enable/disable change, Read-write
    static constexpr uint32_t OTG_HS_HPRT_POCA = 0x10;          // Port overcurrent active, Read-only
    static constexpr uint32_t OTG_HS_HPRT_POCCHNG = 0x20;       // Port overcurrent change, Read-write
    static constexpr uint32_t OTG_HS_HPRT_PRES = 0x40;          // Port resume, Read-write
    static constexpr uint32_t OTG_HS_HPRT_PSUSP = 0x80;         // Port suspend, Read-write
    static constexpr uint32_t OTG_HS_HPRT_PRST = 0x100;         // Port reset, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HPRT_PLSTS =               // Port line status (2 bits), Read-only
        bit_field_t<10, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HPRT_PPWR = 0x1000;        // Port power, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HPRT_PTCTL =               // Port test control (4 bits), Read-write
        bit_field_t<13, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HPRT_PSPD =                // Port speed (2 bits), Read-only
        bit_field_t<17, 0x3>::value<X>();
    static const uint32_t OTG_HS_HPRT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR0_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR0_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR0_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR0_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR0_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR0_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR0_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR0_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR0_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR0_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR0_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT0_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT0_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT0_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT0_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT0_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT0_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT0_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT0_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT0_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT0_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT0_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT0_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT0_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT0_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT0_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT0_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT0_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT0_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK0_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK0_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK0_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK0_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK0_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK0_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK0_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK0_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_HS_HCINTMSK0_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_HS_HCINTMSK0_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK0_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK0_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ0_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ0_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ0_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ0_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA0_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR1_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR1_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR1_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR1_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR1_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR1_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR1_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR1_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR1_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR1_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT1_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT1_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT1_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT1_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT1_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT1_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT1_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT1_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT1_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT1_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT1_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT1_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT1_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT1_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT1_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT1_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT1_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT1_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK1_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK1_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK1_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK1_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK1_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK1_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK1_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK1_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_HS_HCINTMSK1_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_HS_HCINTMSK1_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK1_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ1_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ1_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ1_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ1_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR2_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR2_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR2_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR2_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR2_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR2_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR2_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR2_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR2_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR2_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT2_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT2_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT2_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT2_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT2_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT2_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT2_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT2_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT2_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT2_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT2_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT2_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT2_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT2_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT2_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT2_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT2_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT2_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK2_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK2_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK2_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK2_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK2_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK2_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK2_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK2_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_HS_HCINTMSK2_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_HS_HCINTMSK2_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK2_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ2_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ2_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ2_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ2_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR3_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR3_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR3_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR3_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR3_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR3_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR3_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR3_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR3_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR3_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT3_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT3_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT3_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT3_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT3_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT3_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT3_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT3_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT3_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT3_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT3_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT3_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT3_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT3_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT3_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT3_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT3_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT3_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK3_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK3_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK3_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK3_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK3_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK3_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK3_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK3_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_HS_HCINTMSK3_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_HS_HCINTMSK3_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK3_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ3_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ3_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ3_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ3_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR4_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR4_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR4_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR4_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR4_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR4_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR4_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR4_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR4_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR4_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT4_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT4_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT4_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT4_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT4_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT4_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT4_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT4_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT4_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT4_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT4_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT4_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT4_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT4_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT4_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT4_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT4_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT4_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK4_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK4_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK4_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK4_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK4_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK4_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK4_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK4_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_HS_HCINTMSK4_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_HS_HCINTMSK4_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK4_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ4_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ4_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ4_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ4_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR5_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR5_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR5_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR5_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR5_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR5_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR5_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR5_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR5_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR5_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT5_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT5_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT5_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT5_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT5_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT5_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT5_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT5_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT5_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT5_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT5_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT5_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT5_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT5_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT5_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT5_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT5_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT5_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK5_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK5_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK5_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK5_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK5_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK5_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK5_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK5_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_HS_HCINTMSK5_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_HS_HCINTMSK5_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK5_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ5_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ5_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ5_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ5_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR6_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR6_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR6_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR6_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR6_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR6_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR6_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR6_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR6_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR6_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR6_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT6_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT6_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT6_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT6_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT6_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT6_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT6_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT6_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT6_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT6_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT6_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT6_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT6_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT6_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT6_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT6_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT6_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT6_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK6_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK6_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK6_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK6_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK6_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK6_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK6_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK6_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_HS_HCINTMSK6_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_HS_HCINTMSK6_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK6_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK6_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ6_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ6_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ6_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ6_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA6_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR7_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR7_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR7_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR7_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR7_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR7_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR7_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR7_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR7_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR7_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR7_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT7_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT7_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT7_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT7_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT7_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT7_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT7_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT7_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT7_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT7_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT7_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT7_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT7_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT7_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT7_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT7_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT7_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT7_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK7_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK7_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK7_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK7_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK7_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK7_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK7_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK7_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_HS_HCINTMSK7_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_HS_HCINTMSK7_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK7_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK7_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ7_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ7_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ7_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ7_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA7_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR8_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR8_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR8_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR8_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR8_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR8_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR8_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR8_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR8_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR8_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR8_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT8_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT8_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT8_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT8_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT8_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT8_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT8_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT8_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT8_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT8_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT8_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT8_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT8_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT8_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT8_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT8_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT8_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT8_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK8_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK8_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK8_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK8_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK8_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK8_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK8_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK8_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_HS_HCINTMSK8_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_HS_HCINTMSK8_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK8_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK8_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ8_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ8_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ8_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ8_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA8_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR9_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR9_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR9_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR9_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR9_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR9_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR9_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR9_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR9_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR9_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR9_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT9_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT9_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT9_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT9_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT9_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT9_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT9_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT9_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT9_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT9_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT9_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT9_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT9_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT9_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT9_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT9_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT9_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT9_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK9_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK9_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK9_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK9_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK9_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK9_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK9_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK9_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_HS_HCINTMSK9_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_HS_HCINTMSK9_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK9_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK9_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ9_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ9_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ9_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ9_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA9_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR10_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR10_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR10_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR10_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR10_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR10_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR10_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR10_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR10_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR10_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR10_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT10_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT10_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT10_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT10_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT10_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT10_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT10_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT10_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT10_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT10_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT10_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT10_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT10_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT10_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT10_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT10_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT10_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT10_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK10_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK10_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK10_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK10_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK10_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK10_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK10_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK10_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_HS_HCINTMSK10_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_HS_HCINTMSK10_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK10_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK10_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ10_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ10_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ10_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ10_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA10_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR11_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR11_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR11_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR11_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR11_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR11_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR11_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR11_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR11_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR11_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR11_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT11_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT11_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT11_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT11_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT11_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT11_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT11_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT11_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT11_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT11_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT11_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT11_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT11_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT11_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT11_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT11_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT11_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT11_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK11_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK11_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK11_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK11_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK11_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK11_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK11_NYET = 0x40;          // response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK11_TXERRM = 0x80;        // Transaction error mask
    static constexpr uint32_t OTG_HS_HCINTMSK11_BBERRM = 0x100;       // Babble error mask
    static constexpr uint32_t OTG_HS_HCINTMSK11_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK11_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK11_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ11_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ11_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ11_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ11_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA11_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR12_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR12_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR12_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR12_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR12_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR12_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR12_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR12_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR12_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR12_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR12_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT12_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT12_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT12_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT12_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT12_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT12_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT12_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT12_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT12_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT12_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT12_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT12_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT12_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT12_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT12_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT12_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT12_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT12_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK12_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK12_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK12_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK12_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK12_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK12_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK12_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINTMSK12_TXERRM = 0x80;        // Transaction error
    static constexpr uint32_t OTG_HS_HCINTMSK12_BBERRM = 0x100;       // Babble error
    static constexpr uint32_t OTG_HS_HCINTMSK12_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK12_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK12_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ12_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ12_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ12_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ12_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA12_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR13_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR13_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR13_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR13_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR13_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR13_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR13_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR13_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR13_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR13_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR13_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT13_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT13_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT13_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT13_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT13_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT13_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT13_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT13_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT13_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT13_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT13_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT13_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT13_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT13_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT13_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT13_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT13_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT13_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK13_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK13_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK13_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK13_STALLM = 0x8;         // STALLM response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK13_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK13_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK13_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINTMSK13_TXERRM = 0x80;        // Transaction error
    static constexpr uint32_t OTG_HS_HCINTMSK13_BBERRM = 0x100;       // Babble error
    static constexpr uint32_t OTG_HS_HCINTMSK13_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK13_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK13_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ13_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ13_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ13_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ13_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA13_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR14_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR14_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR14_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR14_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR14_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR14_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR14_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR14_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR14_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR14_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR14_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT14_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT14_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT14_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT14_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT14_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT14_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT14_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT14_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT14_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT14_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT14_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT14_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT14_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT14_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT14_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT14_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT14_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT14_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK14_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK14_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK14_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK14_STALLM = 0x8;         // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK14_NAKM = 0x10;          // NAKM response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK14_ACKM = 0x20;          // ACKM response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK14_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINTMSK14_TXERRM = 0x80;        // Transaction error
    static constexpr uint32_t OTG_HS_HCINTMSK14_BBERRM = 0x100;       // Babble error
    static constexpr uint32_t OTG_HS_HCINTMSK14_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK14_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK14_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ14_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ14_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ14_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ14_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA14_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR15_MPSIZ =               // Maximum packet size (11 bits)
        bit_field_t<0, 0x7ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR15_EPNUM =               // Endpoint number (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR15_EPDIR = 0x8000;       // Endpoint direction
    static constexpr uint32_t OTG_HS_HCCHAR15_LSDEV = 0x20000;      // Low-speed device
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR15_EPTYP =               // Endpoint type (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR15_MC =                  // Multi Count (MC) / Error Count (EC) (2 bits)
        bit_field_t<20, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCCHAR15_DAD =                 // Device address (7 bits)
        bit_field_t<22, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_HCCHAR15_ODDFRM = 0x20000000;  // Odd frame
    static constexpr uint32_t OTG_HS_HCCHAR15_CHDIS = 0x40000000;   // Channel disable
    static constexpr uint32_t OTG_HS_HCCHAR15_CHENA = 0x80000000;   // Channel enable
    static const uint32_t OTG_HS_HCCHAR15_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT15_PRTADDR =             // Port address (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT15_HUBADDR =             // Hub address (7 bits)
        bit_field_t<7, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCSPLT15_XACTPOS =             // XACTPOS (2 bits)
        bit_field_t<14, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_HCSPLT15_COMPLSPLT = 0x10000;  // Do complete split
    static constexpr uint32_t OTG_HS_HCSPLT15_SPLITEN = 0x80000000; // Split enable
    static const uint32_t OTG_HS_HCSPLT15_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINT15_XFRC = 0x1;           // Transfer completed
    static constexpr uint32_t OTG_HS_HCINT15_CHH = 0x2;            // Channel halted
    static constexpr uint32_t OTG_HS_HCINT15_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINT15_STALL = 0x8;          // STALL response received interrupt
    static constexpr uint32_t OTG_HS_HCINT15_NAK = 0x10;           // NAK response received interrupt
    static constexpr uint32_t OTG_HS_HCINT15_ACK = 0x20;           // ACK response received/transmitted interrupt
    static constexpr uint32_t OTG_HS_HCINT15_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINT15_TXERR = 0x80;         // Transaction error
    static constexpr uint32_t OTG_HS_HCINT15_BBERR = 0x100;        // Babble error
    static constexpr uint32_t OTG_HS_HCINT15_FRMOR = 0x200;        // Frame overrun
    static constexpr uint32_t OTG_HS_HCINT15_DTERR = 0x400;        // Data toggle error
    static const uint32_t OTG_HS_HCINT15_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_HCINTMSK15_XFRCM = 0x1;          // Transfer completed mask
    static constexpr uint32_t OTG_HS_HCINTMSK15_CHHM = 0x2;           // Channel halted mask
    static constexpr uint32_t OTG_HS_HCINTMSK15_AHBERR = 0x4;         // AHB error
    static constexpr uint32_t OTG_HS_HCINTMSK15_STALL = 0x8;          // STALL response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK15_NAKM = 0x10;          // NAK response received interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK15_ACKM = 0x20;          // ACK response received/transmitted interrupt mask
    static constexpr uint32_t OTG_HS_HCINTMSK15_NYET = 0x40;          // Response received interrupt
    static constexpr uint32_t OTG_HS_HCINTMSK15_TXERRM = 0x80;        // Transaction error
    static constexpr uint32_t OTG_HS_HCINTMSK15_BBERRM = 0x100;       // Babble error
    static constexpr uint32_t OTG_HS_HCINTMSK15_FRMORM = 0x200;       // Frame overrun mask
    static constexpr uint32_t OTG_HS_HCINTMSK15_DTERRM = 0x400;       // Data toggle error mask
    static const uint32_t OTG_HS_HCINTMSK15_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ15_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ15_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_HCTSIZ15_DPID =                // Data PID (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_HCTSIZ15_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_HCDMA15_RESET_VALUE = 0x0;
};

static otg_hs_host_t& OTG_HS_HOST = *reinterpret_cast<otg_hs_host_t*>(0x40040400);

#define HAVE_PERIPHERAL_OTG_HS_HOST


////
//
//    USB on the go high speed
//
////

struct otg_hs_device_t
{
    volatile uint32_t    OTG_HS_DCFG;          // [Read-write] OTG_HS device configuration register
    volatile uint32_t    OTG_HS_DCTL;          // OTG_HS device control register
    volatile uint32_t    OTG_HS_DSTS;          // [Read-only] OTG_HS device status register
    reserved_t<1>        _0;
    volatile uint32_t    OTG_HS_DIEPMSK;       // [Read-write] OTG_HS device IN endpoint common interrupt mask register
    volatile uint32_t    OTG_HS_DOEPMSK;       // [Read-write] OTG_HS device OUT endpoint common interrupt mask register
    volatile uint32_t    OTG_HS_DAINT;         // [Read-only] OTG_HS device all endpoints interrupt register
    volatile uint32_t    OTG_HS_DAINTMSK;      // [Read-write] OTG_HS all endpoints interrupt mask register
    reserved_t<2>        _1;
    volatile uint32_t    OTG_HS_DVBUSDIS;      // [Read-write] OTG_HS device VBUS discharge time register
    volatile uint32_t    OTG_HS_DVBUSPULSE;    // [Read-write] OTG_HS device VBUS pulsing time register
    volatile uint32_t    OTG_HS_DTHRCTL;       // [Read-write] OTG_HS Device threshold control register
    volatile uint32_t    OTG_HS_DIEPEMPMSK;    // [Read-write] OTG_HS device IN endpoint FIFO empty interrupt mask register
    volatile uint32_t    OTG_HS_DEACHINT;      // [Read-write] OTG_HS device each endpoint interrupt register
    volatile uint32_t    OTG_HS_DEACHINTMSK;   // [Read-write] OTG_HS device each endpoint interrupt register mask
    reserved_t<48>       _2;
    volatile uint32_t    OTG_HS_DIEPCTL0;      // OTG device endpoint-0 control register
    reserved_t<1>        _3;
    volatile uint32_t    OTG_HS_DIEPINT0;      // OTG device endpoint-0 interrupt register
    reserved_t<1>        _4;
    volatile uint32_t    OTG_HS_DIEPTSIZ0;     // [Read-write] OTG_HS device IN endpoint 0 transfer size register
    volatile uint32_t    OTG_HS_DIEPDMA1;      // [Read-write] OTG_HS device endpoint-1 DMA address register
    volatile uint32_t    OTG_HS_DTXFSTS0;      // [Read-only] OTG_HS device IN endpoint transmit FIFO status register
    reserved_t<1>        _5;
    volatile uint32_t    OTG_HS_DIEPCTL1;      // OTG device endpoint-1 control register
    reserved_t<1>        _6;
    volatile uint32_t    OTG_HS_DIEPINT1;      // OTG device endpoint-1 interrupt register
    reserved_t<1>        _7;
    volatile uint32_t    OTG_HS_DIEPTSIZ1;     // [Read-write] OTG_HS device endpoint transfer size register
    volatile uint32_t    OTG_HS_DIEPDMA2;      // [Read-write] OTG_HS device endpoint-2 DMA address register
    volatile uint32_t    OTG_HS_DTXFSTS1;      // [Read-only] OTG_HS device IN endpoint transmit FIFO status register
    reserved_t<1>        _8;
    volatile uint32_t    OTG_HS_DIEPCTL2;      // OTG device endpoint-2 control register
    reserved_t<1>        _9;
    volatile uint32_t    OTG_HS_DIEPINT2;      // OTG device endpoint-2 interrupt register
    reserved_t<1>        _10;
    volatile uint32_t    OTG_HS_DIEPTSIZ2;     // [Read-write] OTG_HS device endpoint transfer size register
    volatile uint32_t    OTG_HS_DIEPDMA3;      // [Read-write] OTG_HS device endpoint-3 DMA address register
    volatile uint32_t    OTG_HS_DTXFSTS2;      // [Read-only] OTG_HS device IN endpoint transmit FIFO status register
    reserved_t<1>        _11;
    volatile uint32_t    OTG_HS_DIEPCTL3;      // OTG device endpoint-3 control register
    reserved_t<1>        _12;
    volatile uint32_t    OTG_HS_DIEPINT3;      // OTG device endpoint-3 interrupt register
    reserved_t<1>        _13;
    volatile uint32_t    OTG_HS_DIEPTSIZ3;     // [Read-write] OTG_HS device endpoint transfer size register
    volatile uint32_t    OTG_HS_DIEPDMA4;      // [Read-write] OTG_HS device endpoint-4 DMA address register
    volatile uint32_t    OTG_HS_DTXFSTS3;      // [Read-only] OTG_HS device IN endpoint transmit FIFO status register
    reserved_t<1>        _14;
    volatile uint32_t    OTG_HS_DIEPCTL4;      // OTG device endpoint-4 control register
    reserved_t<1>        _15;
    volatile uint32_t    OTG_HS_DIEPINT4;      // OTG device endpoint-4 interrupt register
    reserved_t<1>        _16;
    volatile uint32_t    OTG_HS_DIEPTSIZ4;     // [Read-write] OTG_HS device endpoint transfer size register
    volatile uint32_t    OTG_HS_DIEPDMA5;      // [Read-write] OTG_HS device endpoint-5 DMA address register
    volatile uint32_t    OTG_HS_DTXFSTS4;      // [Read-only] OTG_HS device IN endpoint transmit FIFO status register
    reserved_t<1>        _17;
    volatile uint32_t    OTG_HS_DIEPCTL5;      // OTG device endpoint-5 control register
    volatile uint32_t    OTG_HS_DTXFSTS6;      // [Read-write] OTG_HS device IN endpoint transmit FIFO status register
    volatile uint32_t    OTG_HS_DIEPINT5;      // OTG device endpoint-5 interrupt register
    volatile uint32_t    OTG_HS_DTXFSTS7;      // [Read-write] OTG_HS device IN endpoint transmit FIFO status register
    volatile uint32_t    OTG_HS_DIEPTSIZ5;     // [Read-write] OTG_HS device endpoint transfer size register
    reserved_t<1>        _18;
    volatile uint32_t    OTG_HS_DTXFSTS5;      // [Read-only] OTG_HS device IN endpoint transmit FIFO status register
    reserved_t<1>        _19;
    volatile uint32_t    OTG_HS_DIEPCTL6;      // OTG device endpoint-6 control register
    reserved_t<1>        _20;
    volatile uint32_t    OTG_HS_DIEPINT6;      // OTG device endpoint-6 interrupt register
    reserved_t<5>        _21;
    volatile uint32_t    OTG_HS_DIEPCTL7;      // OTG device endpoint-7 control register
    reserved_t<1>        _22;
    volatile uint32_t    OTG_HS_DIEPINT7;      // OTG device endpoint-7 interrupt register
    reserved_t<69>       _23;
    volatile uint32_t    OTG_HS_DOEPCTL0;      // OTG_HS device control OUT endpoint 0 control register
    reserved_t<1>        _24;
    volatile uint32_t    OTG_HS_DOEPINT0;      // [Read-write] OTG_HS device endpoint-0 interrupt register
    reserved_t<1>        _25;
    volatile uint32_t    OTG_HS_DOEPTSIZ0;     // [Read-write] OTG_HS device endpoint-0 transfer size register
    reserved_t<3>        _26;
    volatile uint32_t    OTG_HS_DOEPCTL1;      // OTG device endpoint-1 control register
    reserved_t<1>        _27;
    volatile uint32_t    OTG_HS_DOEPINT1;      // [Read-write] OTG_HS device endpoint-1 interrupt register
    reserved_t<1>        _28;
    volatile uint32_t    OTG_HS_DOEPTSIZ1;     // [Read-write] OTG_HS device endpoint-1 transfer size register
    reserved_t<3>        _29;
    volatile uint32_t    OTG_HS_DOEPCTL2;      // OTG device endpoint-2 control register
    reserved_t<1>        _30;
    volatile uint32_t    OTG_HS_DOEPINT2;      // [Read-write] OTG_HS device endpoint-2 interrupt register
    reserved_t<1>        _31;
    volatile uint32_t    OTG_HS_DOEPTSIZ2;     // [Read-write] OTG_HS device endpoint-2 transfer size register
    reserved_t<3>        _32;
    volatile uint32_t    OTG_HS_DOEPCTL3;      // OTG device endpoint-3 control register
    reserved_t<1>        _33;
    volatile uint32_t    OTG_HS_DOEPINT3;      // [Read-write] OTG_HS device endpoint-3 interrupt register
    reserved_t<1>        _34;
    volatile uint32_t    OTG_HS_DOEPTSIZ3;     // [Read-write] OTG_HS device endpoint-3 transfer size register
    reserved_t<3>        _35;
    volatile uint32_t    OTG_HS_DOEPCTL4;      // OTG device endpoint-4 control register
    reserved_t<1>        _36;
    volatile uint32_t    OTG_HS_DOEPINT4;      // [Read-write] OTG_HS device endpoint-4 interrupt register
    reserved_t<1>        _37;
    volatile uint32_t    OTG_HS_DOEPTSIZ4;     // [Read-write] OTG_HS device endpoint-4 transfer size register
    reserved_t<3>        _38;
    volatile uint32_t    OTG_HS_DOEPCTL5;      // OTG device endpoint-5 control register
    reserved_t<1>        _39;
    volatile uint32_t    OTG_HS_DOEPINT5;      // [Read-write] OTG_HS device endpoint-5 interrupt register
    reserved_t<1>        _40;
    volatile uint32_t    OTG_HS_DOEPTSIZ5;     // [Read-write] OTG_HS device endpoint-5 transfer size register
    reserved_t<3>        _41;
    volatile uint32_t    OTG_HS_DOEPCTL6;      // OTG device endpoint-6 control register
    reserved_t<1>        _42;
    volatile uint32_t    OTG_HS_DOEPINT6;      // [Read-write] OTG_HS device endpoint-6 interrupt register
    reserved_t<1>        _43;
    volatile uint32_t    OTG_HS_DOEPTSIZ6;     // [Read-write] OTG_HS device endpoint-6 transfer size register
    reserved_t<3>        _44;
    volatile uint32_t    OTG_HS_DOEPCTL7;      // OTG device endpoint-7 control register
    reserved_t<1>        _45;
    volatile uint32_t    OTG_HS_DOEPINT7;      // [Read-write] OTG_HS device endpoint-7 interrupt register
    reserved_t<1>        _46;
    volatile uint32_t    OTG_HS_DOEPTSIZ7;     // [Read-write] OTG_HS device endpoint-7 transfer size register

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DCFG_DSPD =                // Device speed (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DCFG_NZLSOHSK = 0x4;       // Nonzero-length status OUT handshake
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DCFG_DAD =                 // Device address (7 bits)
        bit_field_t<4, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DCFG_PFIVL =               // Periodic (micro)frame interval (2 bits)
        bit_field_t<11, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DCFG_PERSCHIVL =           // Periodic scheduling interval (2 bits)
        bit_field_t<24, 0x3>::value<X>();
    static const uint32_t OTG_HS_DCFG_RESET_VALUE = 0x2200000;

    static constexpr uint32_t OTG_HS_DCTL_RWUSIG = 0x1;         // Remote wakeup signaling, Read-write
    static constexpr uint32_t OTG_HS_DCTL_SDIS = 0x2;           // Soft disconnect, Read-write
    static constexpr uint32_t OTG_HS_DCTL_GINSTS = 0x4;         // Global IN NAK status, Read-only
    static constexpr uint32_t OTG_HS_DCTL_GONSTS = 0x8;         // Global OUT NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DCTL_TCTL =                // Test control (3 bits), Read-write
        bit_field_t<4, 0x7>::value<X>();
    static constexpr uint32_t OTG_HS_DCTL_SGINAK = 0x80;        // Set global IN NAK, Write-only
    static constexpr uint32_t OTG_HS_DCTL_CGINAK = 0x100;       // Clear global IN NAK, Write-only
    static constexpr uint32_t OTG_HS_DCTL_SGONAK = 0x200;       // Set global OUT NAK, Write-only
    static constexpr uint32_t OTG_HS_DCTL_CGONAK = 0x400;       // Clear global OUT NAK, Write-only
    static constexpr uint32_t OTG_HS_DCTL_POPRGDNE = 0x800;     // Power-on programming done, Read-write
    static const uint32_t OTG_HS_DCTL_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DSTS_SUSPSTS = 0x1;        // Suspend status
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DSTS_ENUMSPD =             // Enumerated speed (2 bits)
        bit_field_t<1, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DSTS_EERR = 0x8;           // Erratic error
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DSTS_FNSOF =               // Frame number of the received SOF (14 bits)
        bit_field_t<8, 0x3fff>::value<X>();
    static const uint32_t OTG_HS_DSTS_RESET_VALUE = 0x10;

    static constexpr uint32_t OTG_HS_DIEPMSK_XFRCM = 0x1;          // Transfer completed interrupt mask
    static constexpr uint32_t OTG_HS_DIEPMSK_EPDM = 0x2;           // Endpoint disabled interrupt mask
    static constexpr uint32_t OTG_HS_DIEPMSK_TOM = 0x8;            // Timeout condition mask (nonisochronous endpoints)
    static constexpr uint32_t OTG_HS_DIEPMSK_ITTXFEMSK = 0x10;     // IN token received when TxFIFO empty mask
    static constexpr uint32_t OTG_HS_DIEPMSK_INEPNMM = 0x20;       // IN token received with EP mismatch mask
    static constexpr uint32_t OTG_HS_DIEPMSK_INEPNEM = 0x40;       // IN endpoint NAK effective mask
    static constexpr uint32_t OTG_HS_DIEPMSK_TXFURM = 0x100;       // FIFO underrun mask
    static constexpr uint32_t OTG_HS_DIEPMSK_BIM = 0x200;          // BNA interrupt mask
    static const uint32_t OTG_HS_DIEPMSK_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DOEPMSK_XFRCM = 0x1;          // Transfer completed interrupt mask
    static constexpr uint32_t OTG_HS_DOEPMSK_EPDM = 0x2;           // Endpoint disabled interrupt mask
    static constexpr uint32_t OTG_HS_DOEPMSK_STUPM = 0x8;          // SETUP phase done mask
    static constexpr uint32_t OTG_HS_DOEPMSK_OTEPDM = 0x10;        // OUT token received when endpoint disabled mask
    static constexpr uint32_t OTG_HS_DOEPMSK_B2BSTUP = 0x40;       // Back-to-back SETUP packets received mask
    static constexpr uint32_t OTG_HS_DOEPMSK_OPEM = 0x100;         // OUT packet error mask
    static constexpr uint32_t OTG_HS_DOEPMSK_BOIM = 0x200;         // BNA interrupt mask
    static const uint32_t OTG_HS_DOEPMSK_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DAINT_IEPINT =              // IN endpoint interrupt bits (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DAINT_OEPINT =              // OUT endpoint interrupt bits (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DAINT_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DAINTMSK_IEPM =                // IN EP interrupt mask bits (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DAINTMSK_OEPM =                // OUT EP interrupt mask bits (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DAINTMSK_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DVBUSDIS_VBUSDT =              // Device VBUS discharge time (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DVBUSDIS_RESET_VALUE = 0x17d7;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DVBUSPULSE_DVBUSP =              // Device VBUS pulsing time (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t OTG_HS_DVBUSPULSE_RESET_VALUE = 0x5b8;

    static constexpr uint32_t OTG_HS_DTHRCTL_NONISOTHREN = 0x1;    // Nonisochronous IN endpoints threshold enable
    static constexpr uint32_t OTG_HS_DTHRCTL_ISOTHREN = 0x2;       // ISO IN endpoint threshold enable
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DTHRCTL_TXTHRLEN =            // Transmit threshold length (9 bits)
        bit_field_t<2, 0x1ff>::value<X>();
    static constexpr uint32_t OTG_HS_DTHRCTL_RXTHREN = 0x10000;    // Receive threshold enable
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DTHRCTL_RXTHRLEN =            // Receive threshold length (9 bits)
        bit_field_t<17, 0x1ff>::value<X>();
    static constexpr uint32_t OTG_HS_DTHRCTL_ARPEN = 0x8000000;    // Arbiter parking enable
    static const uint32_t OTG_HS_DTHRCTL_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPEMPMSK_INEPTXFEM =           // IN EP Tx FIFO empty interrupt mask bits (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DIEPEMPMSK_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DEACHINT_IEP1INT = 0x2;        // IN endpoint 1interrupt bit
    static constexpr uint32_t OTG_HS_DEACHINT_OEP1INT = 0x20000;    // OUT endpoint 1 interrupt bit
    static const uint32_t OTG_HS_DEACHINT_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DEACHINTMSK_IEP1INTM = 0x2;       // IN Endpoint 1 interrupt mask bit
    static constexpr uint32_t OTG_HS_DEACHINTMSK_OEP1INTM = 0x20000;   // OUT Endpoint 1 interrupt mask bit
    static const uint32_t OTG_HS_DEACHINTMSK_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL0_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL0_USBAEP = 0x8000;      // USB active endpoint, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL0_EONUM_DPID = 0x10000; // Even/odd frame, Read-only
    static constexpr uint32_t OTG_HS_DIEPCTL0_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL0_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL0_Stall = 0x200000;     // STALL handshake, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL0_TXFNUM =              // TxFIFO number (4 bits), Read-write
        bit_field_t<22, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL0_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL0_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL0_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL0_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL0_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL0_EPENA = 0x80000000;   // Endpoint enable, Read-write
    static const uint32_t OTG_HS_DIEPCTL0_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DIEPINT0_XFRC = 0x1;           // Transfer completed interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT0_EPDISD = 0x2;         // Endpoint disabled interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT0_TOC = 0x8;            // Timeout condition, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT0_ITTXFE = 0x10;        // IN token received when TxFIFO is empty, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT0_INEPNE = 0x40;        // IN endpoint NAK effective, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT0_TXFE = 0x80;          // Transmit FIFO empty, Read-only
    static constexpr uint32_t OTG_HS_DIEPINT0_TXFIFOUDRN = 0x100;   // Transmit Fifo Underrun, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT0_BNA = 0x200;          // Buffer not available interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT0_PKTDRPSTS = 0x800;    // Packet dropped status, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT0_BERR = 0x1000;        // Babble error interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT0_NAK = 0x2000;         // NAK interrupt, Read-write
    static const uint32_t OTG_HS_DIEPINT0_RESET_VALUE = 0x80;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ0_XFRSIZ =              // Transfer size (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ0_PKTCNT =              // Packet count (2 bits)
        bit_field_t<19, 0x3>::value<X>();
    static const uint32_t OTG_HS_DIEPTSIZ0_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_DIEPDMA1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DTXFSTS0_INEPTFSAV =           // IN endpoint TxFIFO space avail (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DTXFSTS0_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL1_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL1_USBAEP = 0x8000;      // USB active endpoint, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL1_EONUM_DPID = 0x10000; // Even/odd frame, Read-only
    static constexpr uint32_t OTG_HS_DIEPCTL1_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL1_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL1_Stall = 0x200000;     // STALL handshake, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL1_TXFNUM =              // TxFIFO number (4 bits), Read-write
        bit_field_t<22, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL1_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL1_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL1_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL1_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL1_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL1_EPENA = 0x80000000;   // Endpoint enable, Read-write
    static const uint32_t OTG_HS_DIEPCTL1_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DIEPINT1_XFRC = 0x1;           // Transfer completed interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT1_EPDISD = 0x2;         // Endpoint disabled interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT1_TOC = 0x8;            // Timeout condition, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT1_ITTXFE = 0x10;        // IN token received when TxFIFO is empty, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT1_INEPNE = 0x40;        // IN endpoint NAK effective, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT1_TXFE = 0x80;          // Transmit FIFO empty, Read-only
    static constexpr uint32_t OTG_HS_DIEPINT1_TXFIFOUDRN = 0x100;   // Transmit Fifo Underrun, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT1_BNA = 0x200;          // Buffer not available interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT1_PKTDRPSTS = 0x800;    // Packet dropped status, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT1_BERR = 0x1000;        // Babble error interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT1_NAK = 0x2000;         // NAK interrupt, Read-write
    static const uint32_t OTG_HS_DIEPINT1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ1_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ1_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ1_MCNT =                // Multi count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_DIEPTSIZ1_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_DIEPDMA2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DTXFSTS1_INEPTFSAV =           // IN endpoint TxFIFO space avail (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DTXFSTS1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL2_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL2_USBAEP = 0x8000;      // USB active endpoint, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL2_EONUM_DPID = 0x10000; // Even/odd frame, Read-only
    static constexpr uint32_t OTG_HS_DIEPCTL2_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL2_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL2_Stall = 0x200000;     // STALL handshake, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL2_TXFNUM =              // TxFIFO number (4 bits), Read-write
        bit_field_t<22, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL2_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL2_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL2_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL2_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL2_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL2_EPENA = 0x80000000;   // Endpoint enable, Read-write
    static const uint32_t OTG_HS_DIEPCTL2_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DIEPINT2_XFRC = 0x1;           // Transfer completed interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT2_EPDISD = 0x2;         // Endpoint disabled interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT2_TOC = 0x8;            // Timeout condition, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT2_ITTXFE = 0x10;        // IN token received when TxFIFO is empty, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT2_INEPNE = 0x40;        // IN endpoint NAK effective, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT2_TXFE = 0x80;          // Transmit FIFO empty, Read-only
    static constexpr uint32_t OTG_HS_DIEPINT2_TXFIFOUDRN = 0x100;   // Transmit Fifo Underrun, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT2_BNA = 0x200;          // Buffer not available interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT2_PKTDRPSTS = 0x800;    // Packet dropped status, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT2_BERR = 0x1000;        // Babble error interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT2_NAK = 0x2000;         // NAK interrupt, Read-write
    static const uint32_t OTG_HS_DIEPINT2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ2_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ2_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ2_MCNT =                // Multi count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_DIEPTSIZ2_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_DIEPDMA3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DTXFSTS2_INEPTFSAV =           // IN endpoint TxFIFO space avail (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DTXFSTS2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL3_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL3_USBAEP = 0x8000;      // USB active endpoint, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL3_EONUM_DPID = 0x10000; // Even/odd frame, Read-only
    static constexpr uint32_t OTG_HS_DIEPCTL3_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL3_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL3_Stall = 0x200000;     // STALL handshake, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL3_TXFNUM =              // TxFIFO number (4 bits), Read-write
        bit_field_t<22, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL3_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL3_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL3_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL3_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL3_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL3_EPENA = 0x80000000;   // Endpoint enable, Read-write
    static const uint32_t OTG_HS_DIEPCTL3_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DIEPINT3_XFRC = 0x1;           // Transfer completed interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT3_EPDISD = 0x2;         // Endpoint disabled interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT3_TOC = 0x8;            // Timeout condition, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT3_ITTXFE = 0x10;        // IN token received when TxFIFO is empty, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT3_INEPNE = 0x40;        // IN endpoint NAK effective, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT3_TXFE = 0x80;          // Transmit FIFO empty, Read-only
    static constexpr uint32_t OTG_HS_DIEPINT3_TXFIFOUDRN = 0x100;   // Transmit Fifo Underrun, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT3_BNA = 0x200;          // Buffer not available interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT3_PKTDRPSTS = 0x800;    // Packet dropped status, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT3_BERR = 0x1000;        // Babble error interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT3_NAK = 0x2000;         // NAK interrupt, Read-write
    static const uint32_t OTG_HS_DIEPINT3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ3_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ3_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ3_MCNT =                // Multi count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_DIEPTSIZ3_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_DIEPDMA4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DTXFSTS3_INEPTFSAV =           // IN endpoint TxFIFO space avail (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DTXFSTS3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL4_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL4_USBAEP = 0x8000;      // USB active endpoint, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL4_EONUM_DPID = 0x10000; // Even/odd frame, Read-only
    static constexpr uint32_t OTG_HS_DIEPCTL4_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL4_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL4_Stall = 0x200000;     // STALL handshake, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL4_TXFNUM =              // TxFIFO number (4 bits), Read-write
        bit_field_t<22, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL4_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL4_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL4_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL4_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL4_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL4_EPENA = 0x80000000;   // Endpoint enable, Read-write
    static const uint32_t OTG_HS_DIEPCTL4_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DIEPINT4_XFRC = 0x1;           // Transfer completed interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT4_EPDISD = 0x2;         // Endpoint disabled interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT4_TOC = 0x8;            // Timeout condition, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT4_ITTXFE = 0x10;        // IN token received when TxFIFO is empty, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT4_INEPNE = 0x40;        // IN endpoint NAK effective, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT4_TXFE = 0x80;          // Transmit FIFO empty, Read-only
    static constexpr uint32_t OTG_HS_DIEPINT4_TXFIFOUDRN = 0x100;   // Transmit Fifo Underrun, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT4_BNA = 0x200;          // Buffer not available interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT4_PKTDRPSTS = 0x800;    // Packet dropped status, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT4_BERR = 0x1000;        // Babble error interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT4_NAK = 0x2000;         // NAK interrupt, Read-write
    static const uint32_t OTG_HS_DIEPINT4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ4_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ4_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ4_MCNT =                // Multi count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_DIEPTSIZ4_RESET_VALUE = 0x0;


    static const uint32_t OTG_HS_DIEPDMA5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DTXFSTS4_INEPTFSAV =           // IN endpoint TxFIFO space avail (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DTXFSTS4_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DIEPCTL5_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL5_EONUM_DPID = 0x10000; // Even/odd frame, Read-only
    static constexpr uint32_t OTG_HS_DIEPCTL5_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL5_EPENA = 0x80000000;   // Endpoint enable, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL5_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL5_MCNT =                // Multi count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL5_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL5_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL5_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL5_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL5_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL5_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL5_Stall = 0x200000;     // STALL handshake, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL5_TXFNUM =              // TxFIFO number (4 bits), Read-write
        bit_field_t<22, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL5_USBAEP = 0x8000;      // USB active endpoint, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL5_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    static const uint32_t OTG_HS_DIEPCTL5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DTXFSTS6_INEPTFSAV =           // IN endpoint TxFIFO space avail (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DTXFSTS6_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DIEPINT5_BERR = 0x1000;        // Babble error interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT5_BNA = 0x200;          // Buffer not available interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT5_EPDISD = 0x2;         // Endpoint disabled interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT5_INEPNE = 0x40;        // IN endpoint NAK effective, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT5_ITTXFE = 0x10;        // IN token received when TxFIFO is empty, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPINT5_MCNT =                // Multi count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPINT5_NAK = 0x2000;         // NAK interrupt, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPINT5_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPINT5_PKTDRPSTS = 0x800;    // Packet dropped status, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT5_TOC = 0x8;            // Timeout condition, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT5_TXFE = 0x80;          // Transmit FIFO empty, Read-only
    static constexpr uint32_t OTG_HS_DIEPINT5_TXFIFOUDRN = 0x100;   // Transmit Fifo Underrun, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT5_XFRC = 0x1;           // Transfer completed interrupt, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPINT5_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    static const uint32_t OTG_HS_DIEPINT5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DTXFSTS7_INEPTFSAV =           // IN endpoint TxFIFO space avail (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DTXFSTS7_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ5_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ5_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPTSIZ5_MCNT =                // Multi count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_DIEPTSIZ5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DTXFSTS5_INEPTFSAV =           // IN endpoint TxFIFO space avail (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t OTG_HS_DTXFSTS5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL6_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL6_USBAEP = 0x8000;      // USB active endpoint, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL6_EONUM_DPID = 0x10000; // Even/odd frame, Read-only
    static constexpr uint32_t OTG_HS_DIEPCTL6_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL6_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL6_Stall = 0x200000;     // STALL handshake, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL6_TXFNUM =              // TxFIFO number (4 bits), Read-write
        bit_field_t<22, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL6_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL6_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL6_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL6_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL6_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL6_EPENA = 0x80000000;   // Endpoint enable, Read-write
    static const uint32_t OTG_HS_DIEPCTL6_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DIEPINT6_XFRC = 0x1;           // Transfer completed interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT6_EPDISD = 0x2;         // Endpoint disabled interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT6_TOC = 0x8;            // Timeout condition, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT6_ITTXFE = 0x10;        // IN token received when TxFIFO is empty, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT6_INEPNE = 0x40;        // IN endpoint NAK effective, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT6_TXFE = 0x80;          // Transmit FIFO empty, Read-only
    static constexpr uint32_t OTG_HS_DIEPINT6_TXFIFOUDRN = 0x100;   // Transmit Fifo Underrun, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT6_BNA = 0x200;          // Buffer not available interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT6_PKTDRPSTS = 0x800;    // Packet dropped status, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT6_BERR = 0x1000;        // Babble error interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT6_NAK = 0x2000;         // NAK interrupt, Read-write
    static const uint32_t OTG_HS_DIEPINT6_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL7_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL7_USBAEP = 0x8000;      // USB active endpoint, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL7_EONUM_DPID = 0x10000; // Even/odd frame, Read-only
    static constexpr uint32_t OTG_HS_DIEPCTL7_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL7_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL7_Stall = 0x200000;     // STALL handshake, Read-write
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DIEPCTL7_TXFNUM =              // TxFIFO number (4 bits), Read-write
        bit_field_t<22, 0xf>::value<X>();
    static constexpr uint32_t OTG_HS_DIEPCTL7_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL7_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL7_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL7_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DIEPCTL7_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DIEPCTL7_EPENA = 0x80000000;   // Endpoint enable, Read-write
    static const uint32_t OTG_HS_DIEPCTL7_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DIEPINT7_XFRC = 0x1;           // Transfer completed interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT7_EPDISD = 0x2;         // Endpoint disabled interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT7_TOC = 0x8;            // Timeout condition, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT7_ITTXFE = 0x10;        // IN token received when TxFIFO is empty, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT7_INEPNE = 0x40;        // IN endpoint NAK effective, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT7_TXFE = 0x80;          // Transmit FIFO empty, Read-only
    static constexpr uint32_t OTG_HS_DIEPINT7_TXFIFOUDRN = 0x100;   // Transmit Fifo Underrun, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT7_BNA = 0x200;          // Buffer not available interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT7_PKTDRPSTS = 0x800;    // Packet dropped status, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT7_BERR = 0x1000;        // Babble error interrupt, Read-write
    static constexpr uint32_t OTG_HS_DIEPINT7_NAK = 0x2000;         // NAK interrupt, Read-write
    static const uint32_t OTG_HS_DIEPINT7_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL0_MPSIZ =               // Maximum packet size (2 bits), Read-only
        bit_field_t<0, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL0_USBAEP = 0x8000;      // USB active endpoint, Read-only
    static constexpr uint32_t OTG_HS_DOEPCTL0_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL0_EPTYP =               // Endpoint type (2 bits), Read-only
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL0_SNPM = 0x100000;      // Snoop mode, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL0_Stall = 0x200000;     // STALL handshake, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL0_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL0_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL0_EPDIS = 0x40000000;   // Endpoint disable, Read-only
    static constexpr uint32_t OTG_HS_DOEPCTL0_EPENA = 0x80000000;   // Endpoint enable, Write-only
    static const uint32_t OTG_HS_DOEPCTL0_RESET_VALUE = 0x8000;

    static constexpr uint32_t OTG_HS_DOEPINT0_XFRC = 0x1;           // Transfer completed interrupt
    static constexpr uint32_t OTG_HS_DOEPINT0_EPDISD = 0x2;         // Endpoint disabled interrupt
    static constexpr uint32_t OTG_HS_DOEPINT0_STUP = 0x8;           // SETUP phase done
    static constexpr uint32_t OTG_HS_DOEPINT0_OTEPDIS = 0x10;       // OUT token received when endpoint disabled
    static constexpr uint32_t OTG_HS_DOEPINT0_B2BSTUP = 0x40;       // Back-to-back SETUP packets received
    static constexpr uint32_t OTG_HS_DOEPINT0_NYET = 0x4000;        // NYET interrupt
    static const uint32_t OTG_HS_DOEPINT0_RESET_VALUE = 0x80;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ0_XFRSIZ =              // Transfer size (7 bits)
        bit_field_t<0, 0x7f>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPTSIZ0_PKTCNT = 0x80000;     // Packet count
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ0_STUPCNT =             // SETUP packet count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_DOEPTSIZ0_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL1_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL1_USBAEP = 0x8000;      // USB active endpoint, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL1_EONUM_DPID = 0x10000; // Even odd frame/Endpoint data PID, Read-only
    static constexpr uint32_t OTG_HS_DOEPCTL1_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL1_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL1_SNPM = 0x100000;      // Snoop mode, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL1_Stall = 0x200000;     // STALL handshake, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL1_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL1_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL1_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID/Set even frame, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL1_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL1_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL1_EPENA = 0x80000000;   // Endpoint enable, Read-write
    static const uint32_t OTG_HS_DOEPCTL1_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DOEPINT1_XFRC = 0x1;           // Transfer completed interrupt
    static constexpr uint32_t OTG_HS_DOEPINT1_EPDISD = 0x2;         // Endpoint disabled interrupt
    static constexpr uint32_t OTG_HS_DOEPINT1_STUP = 0x8;           // SETUP phase done
    static constexpr uint32_t OTG_HS_DOEPINT1_OTEPDIS = 0x10;       // OUT token received when endpoint disabled
    static constexpr uint32_t OTG_HS_DOEPINT1_B2BSTUP = 0x40;       // Back-to-back SETUP packets received
    static constexpr uint32_t OTG_HS_DOEPINT1_NYET = 0x4000;        // NYET interrupt
    static const uint32_t OTG_HS_DOEPINT1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ1_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ1_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ1_RXDPID_STUPCNT =      // Received data PID/SETUP packet count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_DOEPTSIZ1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL2_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL2_USBAEP = 0x8000;      // USB active endpoint, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL2_EONUM_DPID = 0x10000; // Even odd frame/Endpoint data PID, Read-only
    static constexpr uint32_t OTG_HS_DOEPCTL2_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL2_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL2_SNPM = 0x100000;      // Snoop mode, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL2_Stall = 0x200000;     // STALL handshake, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL2_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL2_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL2_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID/Set even frame, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL2_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL2_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL2_EPENA = 0x80000000;   // Endpoint enable, Read-write
    static const uint32_t OTG_HS_DOEPCTL2_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DOEPINT2_XFRC = 0x1;           // Transfer completed interrupt
    static constexpr uint32_t OTG_HS_DOEPINT2_EPDISD = 0x2;         // Endpoint disabled interrupt
    static constexpr uint32_t OTG_HS_DOEPINT2_STUP = 0x8;           // SETUP phase done
    static constexpr uint32_t OTG_HS_DOEPINT2_OTEPDIS = 0x10;       // OUT token received when endpoint disabled
    static constexpr uint32_t OTG_HS_DOEPINT2_B2BSTUP = 0x40;       // Back-to-back SETUP packets received
    static constexpr uint32_t OTG_HS_DOEPINT2_NYET = 0x4000;        // NYET interrupt
    static const uint32_t OTG_HS_DOEPINT2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ2_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ2_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ2_RXDPID_STUPCNT =      // Received data PID/SETUP packet count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_DOEPTSIZ2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL3_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL3_USBAEP = 0x8000;      // USB active endpoint, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL3_EONUM_DPID = 0x10000; // Even odd frame/Endpoint data PID, Read-only
    static constexpr uint32_t OTG_HS_DOEPCTL3_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL3_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL3_SNPM = 0x100000;      // Snoop mode, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL3_Stall = 0x200000;     // STALL handshake, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL3_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL3_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL3_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID/Set even frame, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL3_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL3_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL3_EPENA = 0x80000000;   // Endpoint enable, Read-write
    static const uint32_t OTG_HS_DOEPCTL3_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DOEPINT3_XFRC = 0x1;           // Transfer completed interrupt
    static constexpr uint32_t OTG_HS_DOEPINT3_EPDISD = 0x2;         // Endpoint disabled interrupt
    static constexpr uint32_t OTG_HS_DOEPINT3_STUP = 0x8;           // SETUP phase done
    static constexpr uint32_t OTG_HS_DOEPINT3_OTEPDIS = 0x10;       // OUT token received when endpoint disabled
    static constexpr uint32_t OTG_HS_DOEPINT3_B2BSTUP = 0x40;       // Back-to-back SETUP packets received
    static constexpr uint32_t OTG_HS_DOEPINT3_NYET = 0x4000;        // NYET interrupt
    static const uint32_t OTG_HS_DOEPINT3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ3_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ3_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ3_RXDPID_STUPCNT =      // Received data PID/SETUP packet count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_DOEPTSIZ3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL4_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL4_USBAEP = 0x8000;      // USB active endpoint, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL4_EONUM_DPID = 0x10000; // Even odd frame/Endpoint data PID, Read-only
    static constexpr uint32_t OTG_HS_DOEPCTL4_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL4_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL4_SNPM = 0x100000;      // Snoop mode, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL4_Stall = 0x200000;     // STALL handshake, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL4_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL4_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL4_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID/Set even frame, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL4_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL4_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL4_EPENA = 0x80000000;   // Endpoint enable, Read-write
    static const uint32_t OTG_HS_DOEPCTL4_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DOEPINT4_XFRC = 0x1;           // Transfer completed interrupt
    static constexpr uint32_t OTG_HS_DOEPINT4_EPDISD = 0x2;         // Endpoint disabled interrupt
    static constexpr uint32_t OTG_HS_DOEPINT4_STUP = 0x8;           // SETUP phase done
    static constexpr uint32_t OTG_HS_DOEPINT4_OTEPDIS = 0x10;       // OUT token received when endpoint disabled
    static constexpr uint32_t OTG_HS_DOEPINT4_B2BSTUP = 0x40;       // Back-to-back SETUP packets received
    static constexpr uint32_t OTG_HS_DOEPINT4_NYET = 0x4000;        // NYET interrupt
    static const uint32_t OTG_HS_DOEPINT4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ4_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ4_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ4_RXDPID_STUPCNT =      // Received data PID/SETUP packet count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_DOEPTSIZ4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL5_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL5_USBAEP = 0x8000;      // USB active endpoint, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL5_EONUM_DPID = 0x10000; // Even odd frame/Endpoint data PID, Read-only
    static constexpr uint32_t OTG_HS_DOEPCTL5_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL5_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL5_SNPM = 0x100000;      // Snoop mode, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL5_Stall = 0x200000;     // STALL handshake, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL5_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL5_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL5_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID/Set even frame, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL5_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL5_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL5_EPENA = 0x80000000;   // Endpoint enable, Read-write
    static const uint32_t OTG_HS_DOEPCTL5_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DOEPINT5_XFRC = 0x1;           // Transfer completed interrupt
    static constexpr uint32_t OTG_HS_DOEPINT5_EPDISD = 0x2;         // Endpoint disabled interrupt
    static constexpr uint32_t OTG_HS_DOEPINT5_STUP = 0x8;           // SETUP phase done
    static constexpr uint32_t OTG_HS_DOEPINT5_OTEPDIS = 0x10;       // OUT token received when endpoint disabled
    static constexpr uint32_t OTG_HS_DOEPINT5_B2BSTUP = 0x40;       // Back-to-back SETUP packets received
    static constexpr uint32_t OTG_HS_DOEPINT5_NYET = 0x4000;        // NYET interrupt
    static const uint32_t OTG_HS_DOEPINT5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ5_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ5_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ5_RXDPID_STUPCNT =      // Received data PID/SETUP packet count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_DOEPTSIZ5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL6_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL6_USBAEP = 0x8000;      // USB active endpoint, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL6_EONUM_DPID = 0x10000; // Even odd frame/Endpoint data PID, Read-only
    static constexpr uint32_t OTG_HS_DOEPCTL6_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL6_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL6_SNPM = 0x100000;      // Snoop mode, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL6_Stall = 0x200000;     // STALL handshake, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL6_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL6_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL6_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID/Set even frame, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL6_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL6_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL6_EPENA = 0x80000000;   // Endpoint enable, Read-write
    static const uint32_t OTG_HS_DOEPCTL6_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DOEPINT6_XFRC = 0x1;           // Transfer completed interrupt
    static constexpr uint32_t OTG_HS_DOEPINT6_EPDISD = 0x2;         // Endpoint disabled interrupt
    static constexpr uint32_t OTG_HS_DOEPINT6_STUP = 0x8;           // SETUP phase done
    static constexpr uint32_t OTG_HS_DOEPINT6_OTEPDIS = 0x10;       // OUT token received when endpoint disabled
    static constexpr uint32_t OTG_HS_DOEPINT6_B2BSTUP = 0x40;       // Back-to-back SETUP packets received
    static constexpr uint32_t OTG_HS_DOEPINT6_NYET = 0x4000;        // NYET interrupt
    static const uint32_t OTG_HS_DOEPINT6_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ6_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ6_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ6_RXDPID_STUPCNT =      // Received data PID/SETUP packet count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_DOEPTSIZ6_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL7_MPSIZ =               // Maximum packet size (11 bits), Read-write
        bit_field_t<0, 0x7ff>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL7_USBAEP = 0x8000;      // USB active endpoint, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL7_EONUM_DPID = 0x10000; // Even odd frame/Endpoint data PID, Read-only
    static constexpr uint32_t OTG_HS_DOEPCTL7_NAKSTS = 0x20000;     // NAK status, Read-only
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPCTL7_EPTYP =               // Endpoint type (2 bits), Read-write
        bit_field_t<18, 0x3>::value<X>();
    static constexpr uint32_t OTG_HS_DOEPCTL7_SNPM = 0x100000;      // Snoop mode, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL7_Stall = 0x200000;     // STALL handshake, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL7_CNAK = 0x4000000;     // Clear NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL7_SNAK = 0x8000000;     // Set NAK, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL7_SD0PID_SEVNFRM = 0x10000000;// Set DATA0 PID/Set even frame, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL7_SODDFRM = 0x20000000; // Set odd frame, Write-only
    static constexpr uint32_t OTG_HS_DOEPCTL7_EPDIS = 0x40000000;   // Endpoint disable, Read-write
    static constexpr uint32_t OTG_HS_DOEPCTL7_EPENA = 0x80000000;   // Endpoint enable, Read-write
    static const uint32_t OTG_HS_DOEPCTL7_RESET_VALUE = 0x0;

    static constexpr uint32_t OTG_HS_DOEPINT7_XFRC = 0x1;           // Transfer completed interrupt
    static constexpr uint32_t OTG_HS_DOEPINT7_EPDISD = 0x2;         // Endpoint disabled interrupt
    static constexpr uint32_t OTG_HS_DOEPINT7_STUP = 0x8;           // SETUP phase done
    static constexpr uint32_t OTG_HS_DOEPINT7_OTEPDIS = 0x10;       // OUT token received when endpoint disabled
    static constexpr uint32_t OTG_HS_DOEPINT7_B2BSTUP = 0x40;       // Back-to-back SETUP packets received
    static constexpr uint32_t OTG_HS_DOEPINT7_NYET = 0x4000;        // NYET interrupt
    static const uint32_t OTG_HS_DOEPINT7_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ7_XFRSIZ =              // Transfer size (19 bits)
        bit_field_t<0, 0x7ffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ7_PKTCNT =              // Packet count (10 bits)
        bit_field_t<19, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t OTG_HS_DOEPTSIZ7_RXDPID_STUPCNT =      // Received data PID/SETUP packet count (2 bits)
        bit_field_t<29, 0x3>::value<X>();
    static const uint32_t OTG_HS_DOEPTSIZ7_RESET_VALUE = 0x0;
};

static otg_hs_device_t& OTG_HS_DEVICE = *reinterpret_cast<otg_hs_device_t*>(0x40040800);

#define HAVE_PERIPHERAL_OTG_HS_DEVICE


////
//
//    USB on the go high speed
//
////

struct otg_hs_pwrclk_t
{
    volatile uint32_t    OTG_HS_PCGCR;         // [Read-write] Power and clock gating control register

    static constexpr uint32_t OTG_HS_PCGCR_STPPCLK = 0x1;        // Stop PHY clock
    static constexpr uint32_t OTG_HS_PCGCR_GATEHCLK = 0x2;       // Gate HCLK
    static constexpr uint32_t OTG_HS_PCGCR_PHYSUSP = 0x10;       // PHY suspended
    static const uint32_t OTG_HS_PCGCR_RESET_VALUE = 0x0;
};

static otg_hs_pwrclk_t& OTG_HS_PWRCLK = *reinterpret_cast<otg_hs_pwrclk_t*>(0x40040e00);

#define HAVE_PERIPHERAL_OTG_HS_PWRCLK


////
//
//    DSI Host
//
////

struct dsi_t
{
    volatile uint32_t    VR;                   // [Read-only] DSI Host Version Register
    volatile uint32_t    CR;                   // [Read-write] DSI Host Control Register
    volatile uint32_t    CCR;                  // [Read-write] DSI HOST Clock Control Register
    volatile uint32_t    LVCIDR;               // [Read-write] DSI Host LTDC VCID Register
    volatile uint32_t    LCOLCR;               // [Read-write] DSI Host LTDC Color Coding Register
    volatile uint32_t    LPCR;                 // [Read-write] DSI Host LTDC Polarity Configuration Register
    volatile uint32_t    LPMCR;                // [Read-write] DSI Host Low-Power mode Configuration Register
    reserved_t<4>        _0;
    volatile uint32_t    PCR;                  // [Read-write] DSI Host Protocol Configuration Register
    volatile uint32_t    GVCIDR;               // [Read-write] DSI Host Generic VCID Register
    volatile uint32_t    MCR;                  // [Read-write] DSI Host mode Configuration Register
    volatile uint32_t    VMCR;                 // [Read-write] DSI Host Video mode Configuration Register
    volatile uint32_t    VPCR;                 // [Read-write] DSI Host Video Packet Configuration Register
    volatile uint32_t    VCCR;                 // [Read-write] DSI Host Video Chunks Configuration Register
    volatile uint32_t    VNPCR;                // [Read-write] DSI Host Video Null Packet Configuration Register
    volatile uint32_t    VHSACR;               // [Read-write] DSI Host Video HSA Configuration Register
    volatile uint32_t    VHBPCR;               // [Read-write] DSI Host Video HBP Configuration Register
    volatile uint32_t    VLCR;                 // [Read-write] DSI Host Video Line Configuration Register
    volatile uint32_t    VVSACR;               // [Read-write] DSI Host Video VSA Configuration Register
    volatile uint32_t    VVBPCR;               // [Read-write] DSI Host Video VBP Configuration Register
    volatile uint32_t    VVFPCR;               // [Read-write] DSI Host Video VFP Configuration Register
    volatile uint32_t    VVACR;                // [Read-write] DSI Host Video VA Configuration Register
    volatile uint32_t    LCCR;                 // [Read-write] DSI Host LTDC Command Configuration Register
    volatile uint32_t    CMCR;                 // [Read-write] DSI Host Command mode Configuration Register
    volatile uint32_t    GHCR;                 // [Read-write] DSI Host Generic Header Configuration Register
    volatile uint32_t    GPDR;                 // [Read-write] DSI Host Generic Payload Data Register
    volatile uint32_t    GPSR;                 // [Read-only] DSI Host Generic Packet Status Register
    volatile uint32_t    TCCR0;                // [Read-write] DSI Host Timeout Counter Configuration Register 0
    volatile uint32_t    TCCR1;                // [Read-write] DSI Host Timeout Counter Configuration Register 1
    volatile uint32_t    TCCR2;                // [Read-write] DSI Host Timeout Counter Configuration Register 2
    volatile uint32_t    TCCR3;                // [Read-write] DSI Host Timeout Counter Configuration Register 3
    volatile uint32_t    TCCR4;                // [Read-write] DSI Host Timeout Counter Configuration Register 4
    volatile uint32_t    TCCR5;                // [Read-write] DSI Host Timeout Counter Configuration Register 5
    reserved_t<1>        _1;
    volatile uint32_t    CLCR;                 // [Read-write] DSI Host Clock Lane Configuration Register
    volatile uint32_t    CLTCR;                // [Read-write] DSI Host Clock Lane Timer Configuration Register
    volatile uint32_t    DLTCR;                // [Read-write] DSI Host Data Lane Timer Configuration Register
    volatile uint32_t    PCTLR;                // [Read-write] DSI Host PHY Control Register
    volatile uint32_t    PCONFR;               // [Read-write] DSI Host PHY Configuration Register
    volatile uint32_t    PUCR;                 // [Read-write] DSI Host PHY ULPS Control Register
    volatile uint32_t    PTTCR;                // [Read-write] DSI Host PHY TX Triggers Configuration Register
    volatile uint32_t    PSR;                  // [Read-only] DSI Host PHY Status Register
    reserved_t<2>        _2;
    volatile uint32_t    ISR0;                 // [Read-only] DSI Host Interrupt &amp; Status Register 0
    volatile uint32_t    ISR1;                 // [Read-only] DSI Host Interrupt &amp; Status Register 1
    volatile uint32_t    IER0;                 // [Read-write] DSI Host Interrupt Enable Register 0
    volatile uint32_t    IER1;                 // [Read-write] DSI Host Interrupt Enable Register 1
    reserved_t<3>        _3;
    volatile uint32_t    FIR0;                 // [Write-only] DSI Host Force Interrupt Register 0
    volatile uint32_t    FIR1;                 // [Write-only] DSI Host Force Interrupt Register 1
    reserved_t<8>        _4;
    volatile uint32_t    VSCR;                 // [Read-write] DSI Host Video Shadow Control Register
    reserved_t<2>        _5;
    volatile uint32_t    LCVCIDR;              // [Read-only] DSI Host LTDC Current VCID Register
    volatile uint32_t    LCCCR;                // [Read-only] DSI Host LTDC Current Color Coding Register
    reserved_t<1>        _6;
    volatile uint32_t    LPMCCR;               // [Read-only] DSI Host Low-Power mode Current Configuration Register
    reserved_t<7>        _7;
    volatile uint32_t    VMCCR;                // [Read-only] DSI Host Video mode Current Configuration Register
    volatile uint32_t    VPCCR;                // [Read-only] DSI Host Video Packet Current Configuration Register
    volatile uint32_t    VCCCR;                // [Read-only] DSI Host Video Chunks Current Configuration Register
    volatile uint32_t    VNPCCR;               // [Read-only] DSI Host Video Null Packet Current Configuration Register
    volatile uint32_t    VHSACCR;              // [Read-only] DSI Host Video HSA Current Configuration Register
    volatile uint32_t    VHBPCCR;              // [Read-only] DSI Host Video HBP Current Configuration Register
    volatile uint32_t    VLCCR;                // [Read-only] DSI Host Video Line Current Configuration Register
    volatile uint32_t    VVSACCR;              // [Read-only] DSI Host Video VSA Current Configuration Register
    volatile uint32_t    VVBPCCR;              // [Read-only] DSI Host Video VBP Current Configuration Register
    volatile uint32_t    VVFPCCR;              // [Read-only] DSI Host Video VFP Current Configuration Register
    volatile uint32_t    VVACCR;               // [Read-only] DSI Host Video VA Current Configuration Register
    reserved_t<167>      _8;
    volatile uint32_t    WCFGR;                // [Read-write] DSI Wrapper Configuration Register
    volatile uint32_t    WCR;                  // [Read-write] DSI Wrapper Control Register
    volatile uint32_t    WIER;                 // [Read-write] DSI Wrapper Interrupt Enable Register
    volatile uint32_t    WISR;                 // [Read-only] DSI Wrapper Interrupt &amp; Status Register
    volatile uint32_t    WIFCR;                // [Read-write] DSI Wrapper Interrupt Flag Clear Register
    reserved_t<1>        _9;
    volatile uint32_t    WPCR1;                // [Read-write] DSI Wrapper PHY Configuration Register 1
    volatile uint32_t    WPCR2;                // [Read-write] DSI Wrapper PHY Configuration Register 2
    volatile uint32_t    WPCR3;                // [Read-write] DSI Wrapper PHY Configuration Register 3
    volatile uint32_t    WPCR4;                // [Read-write] DSI_WPCR4
    volatile uint32_t    WPCR5;                // [Read-write] DSI Wrapper PHY Configuration Register 5
    reserved_t<1>        _10;
    volatile uint32_t    WRPCR;                // [Read-write] DSI Wrapper Regulator and PLL Control Register


    static const uint32_t VR_RESET_VALUE = 0x3133302a;

    static constexpr uint32_t CR_EN = 0x1;             // Enable
    static const uint32_t CR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CCR_TXECKDIV =            // TX Escape Clock Division (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCR_TOCKDIV =             // Timeout Clock Division (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static const uint32_t CCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t LVCIDR_VCID =                // Virtual Channel ID (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t LVCIDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t LCOLCR_COLC =                // Color Coding (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static constexpr uint32_t LCOLCR_LPE = 0x100;          // Loosely Packet Enable
    static const uint32_t LCOLCR_RESET_VALUE = 0x0;

    static constexpr uint32_t LPCR_DEP = 0x1;            // Data Enable Polarity
    static constexpr uint32_t LPCR_VSP = 0x2;            // VSYNC Polarity
    static constexpr uint32_t LPCR_HSP = 0x4;            // HSYNC Polarity
    static const uint32_t LPCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t LPMCR_VLPSIZE =             // VACT Largest Packet Size (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t LPMCR_LPSIZE =              // Largest Packet Size (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static const uint32_t LPMCR_RESET_VALUE = 0x0;

    static constexpr uint32_t PCR_ETTXE = 0x1;          // EoTp Transmission Enable
    static constexpr uint32_t PCR_ETRXE = 0x2;          // EoTp Reception Enable
    static constexpr uint32_t PCR_BTAE = 0x4;           // Bus Turn Around Enable
    static constexpr uint32_t PCR_ECCRXE = 0x8;         // ECC Reception Enable
    static constexpr uint32_t PCR_CRCRXE = 0x10;        // CRC Reception Enable
    static const uint32_t PCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t GVCIDR_VCID =                // Virtual Channel ID (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t GVCIDR_RESET_VALUE = 0x0;

    static constexpr uint32_t MCR_CMDM = 0x1;           // Command mode
    static const uint32_t MCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t VMCR_VMT =                 // Video mode Type (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static constexpr uint32_t VMCR_LPVSAE = 0x100;       // Low-Power Vertical Sync Active Enable
    static constexpr uint32_t VMCR_LPVBPE = 0x200;       // Low-power Vertical Back-Porch Enable
    static constexpr uint32_t VMCR_LPVFPE = 0x400;       // Low-power Vertical Front-porch Enable
    static constexpr uint32_t VMCR_LPVAE = 0x800;        // Low-Power Vertical Active Enable
    static constexpr uint32_t VMCR_LPHBPE = 0x1000;      // Low-Power Horizontal Back-Porch Enable
    static constexpr uint32_t VMCR_LPHFPE = 0x2000;      // Low-Power Horizontal Front-Porch Enable
    static constexpr uint32_t VMCR_FBTAAE = 0x4000;      // Frame Bus-Turn-Around Acknowledge Enable
    static constexpr uint32_t VMCR_LPCE = 0x8000;        // Low-Power Command Enable
    static constexpr uint32_t VMCR_PGE = 0x10000;        // Pattern Generator Enable
    static constexpr uint32_t VMCR_PGM = 0x100000;       // Pattern Generator mode
    static constexpr uint32_t VMCR_PGO = 0x1000000;      // Pattern Generator Orientation
    static const uint32_t VMCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t VPCR_VPSIZE =              // Video Packet Size (14 bits)
        bit_field_t<0, 0x3fff>::value<X>();
    static const uint32_t VPCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t VCCR_NUMC =                // Number of Chunks (13 bits)
        bit_field_t<0, 0x1fff>::value<X>();
    static const uint32_t VCCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t VNPCR_NPSIZE =              // Null Packet Size (13 bits)
        bit_field_t<0, 0x1fff>::value<X>();
    static const uint32_t VNPCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t VHSACR_HSA =                 // Horizontal Synchronism Active duration (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t VHSACR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t VHBPCR_HBP =                 // Horizontal Back-Porch duration (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t VHBPCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t VLCR_HLINE =               // Horizontal Line duration (15 bits)
        bit_field_t<0, 0x7fff>::value<X>();
    static const uint32_t VLCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t VVSACR_VSA =                 // Vertical Synchronism Active duration (10 bits)
        bit_field_t<0, 0x3ff>::value<X>();
    static const uint32_t VVSACR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t VVBPCR_VBP =                 // Vertical Back-Porch duration (10 bits)
        bit_field_t<0, 0x3ff>::value<X>();
    static const uint32_t VVBPCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t VVFPCR_VFP =                 // Vertical Front-Porch duration (10 bits)
        bit_field_t<0, 0x3ff>::value<X>();
    static const uint32_t VVFPCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t VVACR_VA =                  // Vertical Active duration (14 bits)
        bit_field_t<0, 0x3fff>::value<X>();
    static const uint32_t VVACR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t LCCR_CMDSIZE =             // Command Size (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t LCCR_RESET_VALUE = 0x0;

    static constexpr uint32_t CMCR_TEARE = 0x1;          // Tearing Effect Acknowledge Request Enable
    static constexpr uint32_t CMCR_ARE = 0x2;            // Acknowledge Request Enable
    static constexpr uint32_t CMCR_GSW0TX = 0x100;       // Generic Short Write Zero parameters Transmission
    static constexpr uint32_t CMCR_GSW1TX = 0x200;       // Generic Short Write One parameters Transmission
    static constexpr uint32_t CMCR_GSW2TX = 0x400;       // Generic Short Write Two parameters Transmission
    static constexpr uint32_t CMCR_GSR0TX = 0x800;       // Generic Short Read Zero parameters Transmission
    static constexpr uint32_t CMCR_GSR1TX = 0x1000;      // Generic Short Read One parameters Transmission
    static constexpr uint32_t CMCR_GSR2TX = 0x2000;      // Generic Short Read Two parameters Transmission
    static constexpr uint32_t CMCR_GLWTX = 0x4000;       // Generic Long Write Transmission
    static constexpr uint32_t CMCR_DSW0TX = 0x10000;     // DCS Short Write Zero parameter Transmission
    static constexpr uint32_t CMCR_DSW1TX = 0x20000;     // DCS Short Read One parameter Transmission
    static constexpr uint32_t CMCR_DSR0TX = 0x40000;     // DCS Short Read Zero parameter Transmission
    static constexpr uint32_t CMCR_DLWTX = 0x80000;      // DCS Long Write Transmission
    static constexpr uint32_t CMCR_MRDPS = 0x1000000;    // Maximum Read Packet Size
    static const uint32_t CMCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t GHCR_DT =                  // Type (6 bits)
        bit_field_t<0, 0x3f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GHCR_VCID =                // Channel (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GHCR_WCLSB =               // WordCount LSB (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GHCR_WCMSB =               // WordCount MSB (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static const uint32_t GHCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t GPDR_DATA1 =               // Payload Byte 1 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPDR_DATA2 =               // Payload Byte 2 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPDR_DATA3 =               // Payload Byte 3 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t GPDR_DATA4 =               // Payload Byte 4 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t GPDR_RESET_VALUE = 0x0;

    static constexpr uint32_t GPSR_CMDFE = 0x1;          // Command FIFO Empty
    static constexpr uint32_t GPSR_CMDFF = 0x2;          // Command FIFO Full
    static constexpr uint32_t GPSR_PWRFE = 0x4;          // Payload Write FIFO Empty
    static constexpr uint32_t GPSR_PWRFF = 0x8;          // Payload Write FIFO Full
    static constexpr uint32_t GPSR_PRDFE = 0x10;         // Payload Read FIFO Empty
    static constexpr uint32_t GPSR_PRDFF = 0x20;         // Payload Read FIFO Full
    static constexpr uint32_t GPSR_RCB = 0x40;           // Read Command Busy
    static const uint32_t GPSR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TCCR0_LPRX_TOCNT =          // Low-power Reception Timeout Counter (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TCCR0_HSTX_TOCNT =          // High-Speed Transmission Timeout Counter (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t TCCR0_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TCCR1_HSRD_TOCNT =          // High-Speed Read Timeout Counter (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t TCCR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TCCR2_LPRD_TOCNT =          // Low-Power Read Timeout Counter (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t TCCR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TCCR3_HSWR_TOCNT =          // High-Speed Write Timeout Counter (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static constexpr uint32_t TCCR3_PM = 0x1000000;       // Presp mode
    static const uint32_t TCCR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TCCR4_LSWR_TOCNT =          // Low-Power Write Timeout Counter (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t TCCR4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t TCCR5_BTA_TOCNT =           // Bus-Turn-Around Timeout Counter (16 bits)
        bit_field_t<0, 0xffff>::value<X>();
    static const uint32_t TCCR5_RESET_VALUE = 0x0;

    static constexpr uint32_t CLCR_DPCC = 0x1;           // D-PHY Clock Control
    static constexpr uint32_t CLCR_ACR = 0x2;            // Automatic Clock lane Control
    static const uint32_t CLCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CLTCR_LP2HS_TIME =          // Low-Power to High-Speed Time (10 bits)
        bit_field_t<0, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CLTCR_HS2LP_TIME =          // High-Speed to Low-Power Time (10 bits)
        bit_field_t<16, 0x3ff>::value<X>();
    static const uint32_t CLTCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t DLTCR_MRD_TIME =            // Maximum Read Time (15 bits)
        bit_field_t<0, 0x7fff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DLTCR_LP2HS_TIME =          // Low-Power To High-Speed Time (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t DLTCR_HS2LP_TIME =          // High-Speed To Low-Power Time (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t DLTCR_RESET_VALUE = 0x0;

    static constexpr uint32_t PCTLR_DEN = 0x2;            // Digital Enable
    static constexpr uint32_t PCTLR_CKE = 0x4;            // Clock Enable
    static const uint32_t PCTLR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PCONFR_NL =                  // Number of Lanes (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t PCONFR_SW_TIME =             // Stop Wait Time (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static const uint32_t PCONFR_RESET_VALUE = 0x0;

    static constexpr uint32_t PUCR_URCL = 0x1;           // ULPS Request on Clock Lane
    static constexpr uint32_t PUCR_UECL = 0x2;           // ULPS Exit on Clock Lane
    static constexpr uint32_t PUCR_URDL = 0x4;           // ULPS Request on Data Lane
    static constexpr uint32_t PUCR_UEDL = 0x8;           // ULPS Exit on Data Lane
    static const uint32_t PUCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t PTTCR_TX_TRIG =             // Transmission Trigger (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static const uint32_t PTTCR_RESET_VALUE = 0x0;

    static constexpr uint32_t PSR_PD = 0x2;             // PHY Direction
    static constexpr uint32_t PSR_PSSC = 0x4;           // PHY Stop State Clock lane
    static constexpr uint32_t PSR_UANC = 0x8;           // ULPS Active Not Clock lane
    static constexpr uint32_t PSR_PSS0 = 0x10;          // PHY Stop State lane 0
    static constexpr uint32_t PSR_UAN0 = 0x20;          // ULPS Active Not lane 1
    static constexpr uint32_t PSR_RUE0 = 0x40;          // RX ULPS Escape lane 0
    static constexpr uint32_t PSR_PSS1 = 0x80;          // PHY Stop State lane 1
    static constexpr uint32_t PSR_UAN1 = 0x100;         // ULPS Active Not lane 1
    static const uint32_t PSR_RESET_VALUE = 0x0;

    static constexpr uint32_t ISR0_AE0 = 0x1;            // Acknowledge Error 0
    static constexpr uint32_t ISR0_AE1 = 0x2;            // Acknowledge Error 1
    static constexpr uint32_t ISR0_AE2 = 0x4;            // Acknowledge Error 2
    static constexpr uint32_t ISR0_AE3 = 0x8;            // Acknowledge Error 3
    static constexpr uint32_t ISR0_AE4 = 0x10;           // Acknowledge Error 4
    static constexpr uint32_t ISR0_AE5 = 0x20;           // Acknowledge Error 5
    static constexpr uint32_t ISR0_AE6 = 0x40;           // Acknowledge Error 6
    static constexpr uint32_t ISR0_AE7 = 0x80;           // Acknowledge Error 7
    static constexpr uint32_t ISR0_AE8 = 0x100;          // Acknowledge Error 8
    static constexpr uint32_t ISR0_AE9 = 0x200;          // Acknowledge Error 9
    static constexpr uint32_t ISR0_AE10 = 0x400;         // Acknowledge Error 10
    static constexpr uint32_t ISR0_AE11 = 0x800;         // Acknowledge Error 11
    static constexpr uint32_t ISR0_AE12 = 0x1000;        // Acknowledge Error 12
    static constexpr uint32_t ISR0_AE13 = 0x2000;        // Acknowledge Error 13
    static constexpr uint32_t ISR0_AE14 = 0x4000;        // Acknowledge Error 14
    static constexpr uint32_t ISR0_AE15 = 0x8000;        // Acknowledge Error 15
    static constexpr uint32_t ISR0_PE0 = 0x10000;        // PHY Error 0
    static constexpr uint32_t ISR0_PE1 = 0x20000;        // PHY Error 1
    static constexpr uint32_t ISR0_PE2 = 0x40000;        // PHY Error 2
    static constexpr uint32_t ISR0_PE3 = 0x80000;        // PHY Error 3
    static constexpr uint32_t ISR0_PE4 = 0x100000;       // PHY Error 4
    static const uint32_t ISR0_RESET_VALUE = 0x0;

    static constexpr uint32_t ISR1_TOHSTX = 0x1;         // Timeout High-Speed Transmission
    static constexpr uint32_t ISR1_TOLPRX = 0x2;         // Timeout Low-Power Reception
    static constexpr uint32_t ISR1_ECCSE = 0x4;          // ECC Single-bit Error
    static constexpr uint32_t ISR1_ECCME = 0x8;          // ECC Multi-bit Error
    static constexpr uint32_t ISR1_CRCE = 0x10;          // CRC Error
    static constexpr uint32_t ISR1_PSE = 0x20;           // Packet Size Error
    static constexpr uint32_t ISR1_EOTPE = 0x40;         // EoTp Error
    static constexpr uint32_t ISR1_LPWRE = 0x80;         // LTDC Payload Write Error
    static constexpr uint32_t ISR1_GCWRE = 0x100;        // Generic Command Write Error
    static constexpr uint32_t ISR1_GPWRE = 0x200;        // Generic Payload Write Error
    static constexpr uint32_t ISR1_GPTXE = 0x400;        // Generic Payload Transmit Error
    static constexpr uint32_t ISR1_GPRDE = 0x800;        // Generic Payload Read Error
    static constexpr uint32_t ISR1_GPRXE = 0x1000;       // Generic Payload Receive Error
    static const uint32_t ISR1_RESET_VALUE = 0x0;

    static constexpr uint32_t IER0_AE0IE = 0x1;          // Acknowledge Error 0 Interrupt Enable
    static constexpr uint32_t IER0_AE1IE = 0x2;          // Acknowledge Error 1 Interrupt Enable
    static constexpr uint32_t IER0_AE2IE = 0x4;          // Acknowledge Error 2 Interrupt Enable
    static constexpr uint32_t IER0_AE3IE = 0x8;          // Acknowledge Error 3 Interrupt Enable
    static constexpr uint32_t IER0_AE4IE = 0x10;         // Acknowledge Error 4 Interrupt Enable
    static constexpr uint32_t IER0_AE5IE = 0x20;         // Acknowledge Error 5 Interrupt Enable
    static constexpr uint32_t IER0_AE6IE = 0x40;         // Acknowledge Error 6 Interrupt Enable
    static constexpr uint32_t IER0_AE7IE = 0x80;         // Acknowledge Error 7 Interrupt Enable
    static constexpr uint32_t IER0_AE8IE = 0x100;        // Acknowledge Error 8 Interrupt Enable
    static constexpr uint32_t IER0_AE9IE = 0x200;        // Acknowledge Error 9 Interrupt Enable
    static constexpr uint32_t IER0_AE10IE = 0x400;       // Acknowledge Error 10 Interrupt Enable
    static constexpr uint32_t IER0_AE11IE = 0x800;       // Acknowledge Error 11 Interrupt Enable
    static constexpr uint32_t IER0_AE12IE = 0x1000;      // Acknowledge Error 12 Interrupt Enable
    static constexpr uint32_t IER0_AE13IE = 0x2000;      // Acknowledge Error 13 Interrupt Enable
    static constexpr uint32_t IER0_AE14IE = 0x4000;      // Acknowledge Error 14 Interrupt Enable
    static constexpr uint32_t IER0_AE15IE = 0x8000;      // Acknowledge Error 15 Interrupt Enable
    static constexpr uint32_t IER0_PE0IE = 0x10000;      // PHY Error 0 Interrupt Enable
    static constexpr uint32_t IER0_PE1IE = 0x20000;      // PHY Error 1 Interrupt Enable
    static constexpr uint32_t IER0_PE2IE = 0x40000;      // PHY Error 2 Interrupt Enable
    static constexpr uint32_t IER0_PE3IE = 0x80000;      // PHY Error 3 Interrupt Enable
    static constexpr uint32_t IER0_PE4IE = 0x100000;     // PHY Error 4 Interrupt Enable
    static const uint32_t IER0_RESET_VALUE = 0x0;

    static constexpr uint32_t IER1_TOHSTXIE = 0x1;       // Timeout High-Speed Transmission Interrupt Enable
    static constexpr uint32_t IER1_TOLPRXIE = 0x2;       // Timeout Low-Power Reception Interrupt Enable
    static constexpr uint32_t IER1_ECCSEIE = 0x4;        // ECC Single-bit Error Interrupt Enable
    static constexpr uint32_t IER1_ECCMEIE = 0x8;        // ECC Multi-bit Error Interrupt Enable
    static constexpr uint32_t IER1_CRCEIE = 0x10;        // CRC Error Interrupt Enable
    static constexpr uint32_t IER1_PSEIE = 0x20;         // Packet Size Error Interrupt Enable
    static constexpr uint32_t IER1_EOTPEIE = 0x40;       // EoTp Error Interrupt Enable
    static constexpr uint32_t IER1_LPWREIE = 0x80;       // LTDC Payload Write Error Interrupt Enable
    static constexpr uint32_t IER1_GCWREIE = 0x100;      // Generic Command Write Error Interrupt Enable
    static constexpr uint32_t IER1_GPWREIE = 0x200;      // Generic Payload Write Error Interrupt Enable
    static constexpr uint32_t IER1_GPTXEIE = 0x400;      // Generic Payload Transmit Error Interrupt Enable
    static constexpr uint32_t IER1_GPRDEIE = 0x800;      // Generic Payload Read Error Interrupt Enable
    static constexpr uint32_t IER1_GPRXEIE = 0x1000;     // Generic Payload Receive Error Interrupt Enable
    static const uint32_t IER1_RESET_VALUE = 0x0;

    static constexpr uint32_t FIR0_FAE0 = 0x1;           // Force Acknowledge Error 0
    static constexpr uint32_t FIR0_FAE1 = 0x2;           // Force Acknowledge Error 1
    static constexpr uint32_t FIR0_FAE2 = 0x4;           // Force Acknowledge Error 2
    static constexpr uint32_t FIR0_FAE3 = 0x8;           // Force Acknowledge Error 3
    static constexpr uint32_t FIR0_FAE4 = 0x10;          // Force Acknowledge Error 4
    static constexpr uint32_t FIR0_FAE5 = 0x20;          // Force Acknowledge Error 5
    static constexpr uint32_t FIR0_FAE6 = 0x40;          // Force Acknowledge Error 6
    static constexpr uint32_t FIR0_FAE7 = 0x80;          // Force Acknowledge Error 7
    static constexpr uint32_t FIR0_FAE8 = 0x100;         // Force Acknowledge Error 8
    static constexpr uint32_t FIR0_FAE9 = 0x200;         // Force Acknowledge Error 9
    static constexpr uint32_t FIR0_FAE10 = 0x400;        // Force Acknowledge Error 10
    static constexpr uint32_t FIR0_FAE11 = 0x800;        // Force Acknowledge Error 11
    static constexpr uint32_t FIR0_FAE12 = 0x1000;       // Force Acknowledge Error 12
    static constexpr uint32_t FIR0_FAE13 = 0x2000;       // Force Acknowledge Error 13
    static constexpr uint32_t FIR0_FAE14 = 0x4000;       // Force Acknowledge Error 14
    static constexpr uint32_t FIR0_FAE15 = 0x8000;       // Force Acknowledge Error 15
    static constexpr uint32_t FIR0_FPE0 = 0x10000;       // Force PHY Error 0
    static constexpr uint32_t FIR0_FPE1 = 0x20000;       // Force PHY Error 1
    static constexpr uint32_t FIR0_FPE2 = 0x40000;       // Force PHY Error 2
    static constexpr uint32_t FIR0_FPE3 = 0x80000;       // Force PHY Error 3
    static constexpr uint32_t FIR0_FPE4 = 0x100000;      // Force PHY Error 4
    static const uint32_t FIR0_RESET_VALUE = 0x0;

    static constexpr uint32_t FIR1_FTOHSTX = 0x1;        // Force Timeout High-Speed Transmission
    static constexpr uint32_t FIR1_FTOLPRX = 0x2;        // Force Timeout Low-Power Reception
    static constexpr uint32_t FIR1_FECCSE = 0x4;         // Force ECC Single-bit Error
    static constexpr uint32_t FIR1_FECCME = 0x8;         // Force ECC Multi-bit Error
    static constexpr uint32_t FIR1_FCRCE = 0x10;         // Force CRC Error
    static constexpr uint32_t FIR1_FPSE = 0x20;          // Force Packet Size Error
    static constexpr uint32_t FIR1_FEOTPE = 0x40;        // Force EoTp Error
    static constexpr uint32_t FIR1_FLPWRE = 0x80;        // Force LTDC Payload Write Error
    static constexpr uint32_t FIR1_FGCWRE = 0x100;       // Force Generic Command Write Error
    static constexpr uint32_t FIR1_FGPWRE = 0x200;       // Force Generic Payload Write Error
    static constexpr uint32_t FIR1_FGPTXE = 0x400;       // Force Generic Payload Transmit Error
    static constexpr uint32_t FIR1_FGPRDE = 0x800;       // Force Generic Payload Read Error
    static constexpr uint32_t FIR1_FGPRXE = 0x1000;      // Force Generic Payload Receive Error
    static const uint32_t FIR1_RESET_VALUE = 0x0;

    static constexpr uint32_t VSCR_EN = 0x1;             // Enable
    static constexpr uint32_t VSCR_UR = 0x100;           // Update Register
    static const uint32_t VSCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t LCVCIDR_VCID =                // Virtual Channel ID (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t LCVCIDR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t LCCCR_COLC =                // Color Coding (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static constexpr uint32_t LCCCR_LPE = 0x100;          // Loosely Packed Enable
    static const uint32_t LCCCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t LPMCCR_VLPSIZE =             // VACT Largest Packet Size (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t LPMCCR_LPSIZE =              // Largest Packet Size (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static const uint32_t LPMCCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t VMCCR_VMT =                 // Video mode Type (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static constexpr uint32_t VMCCR_LPVSAE = 0x4;         // Low-Power Vertical Sync time Enable
    static constexpr uint32_t VMCCR_LPVBPE = 0x8;         // Low-power Vertical Back-Porch Enable
    static constexpr uint32_t VMCCR_LPVFPE = 0x10;        // Low-power Vertical Front-Porch Enable
    static constexpr uint32_t VMCCR_LPVAE = 0x20;         // Low-Power Vertical Active Enable
    static constexpr uint32_t VMCCR_LPHBPE = 0x40;        // Low-power Horizontal Back-Porch Enable
    static constexpr uint32_t VMCCR_LPHFE = 0x80;         // Low-Power Horizontal Front-Porch Enable
    static constexpr uint32_t VMCCR_FBTAAE = 0x100;       // Frame BTA Acknowledge Enable
    static constexpr uint32_t VMCCR_LPCE = 0x200;         // Low-Power Command Enable
    static const uint32_t VMCCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t VPCCR_VPSIZE =              // Video Packet Size (14 bits)
        bit_field_t<0, 0x3fff>::value<X>();
    static const uint32_t VPCCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t VCCCR_NUMC =                // Number of Chunks (13 bits)
        bit_field_t<0, 0x1fff>::value<X>();
    static const uint32_t VCCCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t VNPCCR_NPSIZE =              // Null Packet Size (13 bits)
        bit_field_t<0, 0x1fff>::value<X>();
    static const uint32_t VNPCCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t VHSACCR_HSA =                 // Horizontal Synchronism Active duration (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t VHSACCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t VHBPCCR_HBP =                 // Horizontal Back-Porch duration (12 bits)
        bit_field_t<0, 0xfff>::value<X>();
    static const uint32_t VHBPCCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t VLCCR_HLINE =               // Horizontal Line duration (15 bits)
        bit_field_t<0, 0x7fff>::value<X>();
    static const uint32_t VLCCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t VVSACCR_VSA =                 // Vertical Synchronism Active duration (10 bits)
        bit_field_t<0, 0x3ff>::value<X>();
    static const uint32_t VVSACCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t VVBPCCR_VBP =                 // Vertical Back-Porch duration (10 bits)
        bit_field_t<0, 0x3ff>::value<X>();
    static const uint32_t VVBPCCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t VVFPCCR_VFP =                 // Vertical Front-Porch duration (10 bits)
        bit_field_t<0, 0x3ff>::value<X>();
    static const uint32_t VVFPCCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t VVACCR_VA =                  // Vertical Active duration (14 bits)
        bit_field_t<0, 0x3fff>::value<X>();
    static const uint32_t VVACCR_RESET_VALUE = 0x0;

    static constexpr uint32_t WCFGR_VSPOL = 0x80;         // VSync Polarity
    static constexpr uint32_t WCFGR_AR = 0x40;            // Automatic Refresh
    static constexpr uint32_t WCFGR_TEPOL = 0x20;         // TE Polarity
    static constexpr uint32_t WCFGR_TESRC = 0x10;         // TE Source
    template<uint32_t X>
    static constexpr uint32_t WCFGR_COLMUX =              // Color Multiplexing (3 bits)
        bit_field_t<1, 0x7>::value<X>();
    static constexpr uint32_t WCFGR_DSIM = 0x1;           // DSI Mode
    static const uint32_t WCFGR_RESET_VALUE = 0x0;

    static constexpr uint32_t WCR_DSIEN = 0x8;          // DSI Enable
    static constexpr uint32_t WCR_LTDCEN = 0x4;         // LTDC Enable
    static constexpr uint32_t WCR_SHTDN = 0x2;          // Shutdown
    static constexpr uint32_t WCR_COLM = 0x1;           // Color Mode
    static const uint32_t WCR_RESET_VALUE = 0x0;

    static constexpr uint32_t WIER_RRIE = 0x2000;        // Regulator Ready Interrupt Enable
    static constexpr uint32_t WIER_PLLUIE = 0x400;       // PLL Unlock Interrupt Enable
    static constexpr uint32_t WIER_PLLLIE = 0x200;       // PLL Lock Interrupt Enable
    static constexpr uint32_t WIER_ERIE = 0x2;           // End of Refresh Interrupt Enable
    static constexpr uint32_t WIER_TEIE = 0x1;           // Tearing Effect Interrupt Enable
    static const uint32_t WIER_RESET_VALUE = 0x0;

    static constexpr uint32_t WISR_RRIF = 0x2000;        // Regulator Ready Interrupt Flag
    static constexpr uint32_t WISR_RRS = 0x1000;         // Regulator Ready Status
    static constexpr uint32_t WISR_PLLUIF = 0x400;       // PLL Unlock Interrupt Flag
    static constexpr uint32_t WISR_PLLLIF = 0x200;       // PLL Lock Interrupt Flag
    static constexpr uint32_t WISR_PLLLS = 0x100;        // PLL Lock Status
    static constexpr uint32_t WISR_BUSY = 0x4;           // Busy Flag
    static constexpr uint32_t WISR_ERIF = 0x2;           // End of Refresh Interrupt Flag
    static constexpr uint32_t WISR_TEIF = 0x1;           // Tearing Effect Interrupt Flag
    static const uint32_t WISR_RESET_VALUE = 0x0;

    static constexpr uint32_t WIFCR_CRRIF = 0x2000;       // Clear Regulator Ready Interrupt Flag
    static constexpr uint32_t WIFCR_CPLLUIF = 0x400;      // Clear PLL Unlock Interrupt Flag
    static constexpr uint32_t WIFCR_CPLLLIF = 0x200;      // Clear PLL Lock Interrupt Flag
    static constexpr uint32_t WIFCR_CERIF = 0x2;          // Clear End of Refresh Interrupt Flag
    static constexpr uint32_t WIFCR_CTEIF = 0x1;          // Clear Tearing Effect Interrupt Flag
    static const uint32_t WIFCR_RESET_VALUE = 0x0;

    static constexpr uint32_t WPCR1_TCLKPOSTEN = 0x8000000;// custom time for tCLK-POST Enable
    static constexpr uint32_t WPCR1_TLPXCEN = 0x4000000;  // custom time for tLPX for Clock lane Enable
    static constexpr uint32_t WPCR1_THSEXITEN = 0x2000000;// custom time for tHS-EXIT Enable
    static constexpr uint32_t WPCR1_TLPXDEN = 0x1000000;  // custom time for tLPX for Data lanes Enable
    static constexpr uint32_t WPCR1_THSZEROEN = 0x800000; // custom time for tHS-ZERO Enable
    static constexpr uint32_t WPCR1_THSTRAILEN = 0x400000;// custom time for tHS-TRAIL Enable
    static constexpr uint32_t WPCR1_THSPREPEN = 0x200000; // custom time for tHS-PREPARE Enable
    static constexpr uint32_t WPCR1_TCLKZEROEN = 0x100000;// custom time for tCLK-ZERO Enable
    static constexpr uint32_t WPCR1_TCLKPREPEN = 0x80000; // custom time for tCLK-PREPARE Enable
    static constexpr uint32_t WPCR1_PDEN = 0x40000;       // Pull-Down Enable
    static constexpr uint32_t WPCR1_TDDL = 0x10000;       // Turn Disable Data Lanes
    static constexpr uint32_t WPCR1_CDOFFDL = 0x4000;     // Contention Detection OFF on Data Lanes
    static constexpr uint32_t WPCR1_FTXSMDL = 0x2000;     // Force in TX Stop Mode the Data Lanes
    static constexpr uint32_t WPCR1_FTXSMCL = 0x1000;     // Force in TX Stop Mode the Clock Lane
    static constexpr uint32_t WPCR1_HSIDL1 = 0x800;       // Invert the High-Speed data signal on Data Lane 1
    static constexpr uint32_t WPCR1_HSIDL0 = 0x400;       // Invert the Hight-Speed data signal on Data Lane 0
    static constexpr uint32_t WPCR1_HSICL = 0x200;        // Invert Hight-Speed data signal on Clock Lane
    static constexpr uint32_t WPCR1_SWDL1 = 0x100;        // Swap Data Lane 1 pins
    static constexpr uint32_t WPCR1_SWDL0 = 0x80;         // Swap Data Lane 0 pins
    static constexpr uint32_t WPCR1_SWCL = 0x40;          // Swap Clock Lane pins
    template<uint32_t X>
    static constexpr uint32_t WPCR1_UIX4 =                // Unit Interval multiplied by 4 (6 bits)
        bit_field_t<0, 0x3f>::value<X>();
    static const uint32_t WPCR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t WPCR2_LPRXFT =              // Low-Power RX low-pass Filtering Tuning (2 bits)
        bit_field_t<25, 0x3>::value<X>();
    static constexpr uint32_t WPCR2_FLPRXLPM = 0x400000;  // Forces LP Receiver in Low-Power Mode
    template<uint32_t X>
    static constexpr uint32_t WPCR2_HSTXSRCDL =           // High-Speed Transmission Slew Rate Control on Data Lanes (2 bits)
        bit_field_t<18, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t WPCR2_HSTXSRCCL =           // High-Speed Transmission Slew Rate Control on Clock Lane (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    static constexpr uint32_t WPCR2_SDCC = 0x1000;        // SDD Control
    template<uint32_t X>
    static constexpr uint32_t WPCR2_LPSRDL =              // Low-Power transmission Slew Rate Compensation on Data Lanes (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t WPCR2_LPSRCL =              // Low-Power transmission Slew Rate Compensation on Clock Lane (2 bits)
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t WPCR2_HSTXDLL =             // High-Speed Transmission Delay on Data Lanes (2 bits)
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t WPCR2_HSTXDCL =             // High-Speed Transmission Delay on Clock Lane (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    static const uint32_t WPCR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t WPCR3_THSTRAIL =            // tHSTRAIL (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t WPCR3_THSPREP =             // tHS-PREPARE (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t WPCR3_TCLKZEO =             // tCLK-ZERO (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t WPCR3_TCLKPREP =            // tCLK-PREPARE (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t WPCR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t WPCR4_TLPXC =               // tLPXC for Clock lane (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t WPCR4_THSEXIT =             // tHSEXIT (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t WPCR4_TLPXD =               // tLPX for Data lanes (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t WPCR4_THSZERO =             // tHS-ZERO (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t WPCR4_RESET_VALUE = 0x3133302a;

    template<uint32_t X>
    static constexpr uint32_t WPCR5_THSZERO =             // tCLK-POST (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t WPCR5_RESET_VALUE = 0x0;

    static constexpr uint32_t WRPCR_REGEN = 0x1000000;    // Regulator Enable
    template<uint32_t X>
    static constexpr uint32_t WRPCR_ODF =                 // PLL Output Division Factor (2 bits)
        bit_field_t<16, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t WRPCR_IDF =                 // PLL Input Division Factor (4 bits)
        bit_field_t<11, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t WRPCR_NDIV =                // PLL Loop Division Factor (7 bits)
        bit_field_t<2, 0x7f>::value<X>();
    static constexpr uint32_t WRPCR_PLLEN = 0x1;          // PLL Enable
    static const uint32_t WRPCR_RESET_VALUE = 0x0;

    static constexpr uint8_t DSIHOST = 98; // DSI host global interrupt
};

static dsi_t& DSI = *reinterpret_cast<dsi_t*>(0x40016c00);

#define HAVE_PERIPHERAL_DSI


////
//
//    Nested Vectored Interrupt Controller
//
////

struct nvic_t
{
    volatile uint32_t    ISER0;                // [Read-write] Interrupt Set-Enable Register
    volatile uint32_t    ISER1;                // [Read-write] Interrupt Set-Enable Register
    volatile uint32_t    ISER2;                // [Read-write] Interrupt Set-Enable Register
    reserved_t<29>       _0;
    volatile uint32_t    ICER0;                // [Read-write] Interrupt Clear-Enable Register
    volatile uint32_t    ICER1;                // [Read-write] Interrupt Clear-Enable Register
    volatile uint32_t    ICER2;                // [Read-write] Interrupt Clear-Enable Register
    reserved_t<29>       _1;
    volatile uint32_t    ISPR0;                // [Read-write] Interrupt Set-Pending Register
    volatile uint32_t    ISPR1;                // [Read-write] Interrupt Set-Pending Register
    volatile uint32_t    ISPR2;                // [Read-write] Interrupt Set-Pending Register
    reserved_t<29>       _2;
    volatile uint32_t    ICPR0;                // [Read-write] Interrupt Clear-Pending Register
    volatile uint32_t    ICPR1;                // [Read-write] Interrupt Clear-Pending Register
    volatile uint32_t    ICPR2;                // [Read-write] Interrupt Clear-Pending Register
    reserved_t<29>       _3;
    volatile uint32_t    IABR0;                // [Read-only] Interrupt Active Bit Register
    volatile uint32_t    IABR1;                // [Read-only] Interrupt Active Bit Register
    volatile uint32_t    IABR2;                // [Read-only] Interrupt Active Bit Register
    reserved_t<61>       _4;
    volatile uint32_t    IPR0;                 // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR1;                 // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR2;                 // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR3;                 // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR4;                 // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR5;                 // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR6;                 // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR7;                 // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR8;                 // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR9;                 // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR10;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR11;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR12;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR13;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR14;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR15;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR16;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR17;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR18;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR19;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR20;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR21;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR22;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR23;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR24;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR25;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR26;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR27;                // [Read-write] Interrupt Priority Register
    volatile uint32_t    IPR28;                // [Read-write] Interrupt Priority Register


    static const uint32_t ISER0_RESET_VALUE = 0x0;


    static const uint32_t ISER1_RESET_VALUE = 0x0;


    static const uint32_t ISER2_RESET_VALUE = 0x0;


    static const uint32_t ICER0_RESET_VALUE = 0x0;


    static const uint32_t ICER1_RESET_VALUE = 0x0;


    static const uint32_t ICER2_RESET_VALUE = 0x0;


    static const uint32_t ISPR0_RESET_VALUE = 0x0;


    static const uint32_t ISPR1_RESET_VALUE = 0x0;


    static const uint32_t ISPR2_RESET_VALUE = 0x0;


    static const uint32_t ICPR0_RESET_VALUE = 0x0;


    static const uint32_t ICPR1_RESET_VALUE = 0x0;


    static const uint32_t ICPR2_RESET_VALUE = 0x0;


    static const uint32_t IABR0_RESET_VALUE = 0x0;


    static const uint32_t IABR1_RESET_VALUE = 0x0;


    static const uint32_t IABR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR0_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR0_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR0_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR0_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR0_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR1_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR1_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR1_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR1_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR2_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR2_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR2_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR2_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR3_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR3_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR3_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR3_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR3_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR4_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR4_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR4_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR4_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR4_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR5_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR5_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR5_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR5_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR5_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR6_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR6_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR6_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR6_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR6_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR7_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR7_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR7_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR7_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR7_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR8_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR8_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR8_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR8_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR8_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR9_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR9_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR9_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR9_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR9_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR10_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR10_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR10_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR10_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR10_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR11_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR11_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR11_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR11_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR11_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR12_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR12_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR12_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR12_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR12_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR13_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR13_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR13_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR13_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR13_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR14_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR14_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR14_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR14_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR14_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR15_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR15_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR15_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR15_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR15_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR16_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR16_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR16_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR16_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR16_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR17_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR17_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR17_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR17_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR17_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR18_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR18_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR18_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR18_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR18_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR19_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR19_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR19_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR19_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR19_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR20_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR20_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR20_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR20_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR20_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR21_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR21_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR21_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR21_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR21_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR22_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR22_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR22_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR22_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR22_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR23_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR23_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR23_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR23_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR23_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR24_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR24_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR24_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR24_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR24_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR25_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR25_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR25_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR25_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR25_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR26_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR26_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR26_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR26_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR26_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR27_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR27_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR27_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR27_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR27_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t IPR28_IPR_N0 =              // IPR_N0 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR28_IPR_N1 =              // IPR_N1 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR28_IPR_N2 =              // IPR_N2 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t IPR28_IPR_N3 =              // IPR_N3 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t IPR28_RESET_VALUE = 0x0;
};

static nvic_t& NVIC = *reinterpret_cast<nvic_t*>(0xe000e100);

#define HAVE_PERIPHERAL_NVIC


////
//
//    Memory protection unit
//
////

struct mpu_t
{
    volatile uint32_t    TYPER;                // [Read-only] MPU type register
    volatile uint32_t    CTRL;                 // [Read-only] MPU control register
    volatile uint32_t    RNR;                  // [Read-write] MPU region number register
    volatile uint32_t    RBAR;                 // [Read-write] MPU region base address register
    volatile uint32_t    RASR;                 // [Read-write] MPU region attribute and size register

    static constexpr uint32_t TYPER_SEPARATE = 0x1;       // Separate flag
    template<uint32_t X>
    static constexpr uint32_t TYPER_DREGION =             // Number of MPU data regions (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t TYPER_IREGION =             // Number of MPU instruction regions (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static const uint32_t TYPER_RESET_VALUE = 0x800;

    static constexpr uint32_t CTRL_ENABLE = 0x1;         // Enables the MPU
    static constexpr uint32_t CTRL_HFNMIENA = 0x2;       // Enables the operation of MPU during hard fault
    static constexpr uint32_t CTRL_PRIVDEFENA = 0x4;     // Enable priviliged software access to default memory map
    static const uint32_t CTRL_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RNR_REGION =              // MPU region (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    static const uint32_t RNR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RBAR_REGION =              // MPU region field (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    static constexpr uint32_t RBAR_VALID = 0x10;         // MPU region number valid
    template<uint32_t X>
    static constexpr uint32_t RBAR_ADDR =                // Region base address field (27 bits)
        bit_field_t<5, 0x7ffffff>::value<X>();
    static const uint32_t RBAR_RESET_VALUE = 0x0;

    static constexpr uint32_t RASR_ENABLE = 0x1;         // Region enable bit.
    template<uint32_t X>
    static constexpr uint32_t RASR_SIZE =                // Size of the MPU protection region (5 bits)
        bit_field_t<1, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RASR_SRD =                 // Subregion disable bits (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t RASR_B = 0x10000;          // memory attribute
    static constexpr uint32_t RASR_C = 0x20000;          // memory attribute
    static constexpr uint32_t RASR_S = 0x40000;          // Shareable memory attribute
    template<uint32_t X>
    static constexpr uint32_t RASR_TEX =                 // memory attribute (3 bits)
        bit_field_t<19, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t RASR_AP =                  // Access permission (3 bits)
        bit_field_t<24, 0x7>::value<X>();
    static constexpr uint32_t RASR_XN = 0x10000000;      // Instruction access disable bit
    static const uint32_t RASR_RESET_VALUE = 0x0;
};

static mpu_t& MPU = *reinterpret_cast<mpu_t*>(0xe000ed90);

#define HAVE_PERIPHERAL_MPU


////
//
//    SysTick timer
//
////

struct stk_t
{
    volatile uint32_t    CSR;                  // [Read-write] SysTick control and status register
    volatile uint32_t    RVR;                  // [Read-write] SysTick reload value register
    volatile uint32_t    CVR;                  // [Read-write] SysTick current value register
    volatile uint32_t    CALIB;                // [Read-write] SysTick calibration value register

    static constexpr uint32_t CSR_ENABLE = 0x1;         // Counter enable
    static constexpr uint32_t CSR_TICKINT = 0x2;        // SysTick exception request enable
    static constexpr uint32_t CSR_CLKSOURCE = 0x4;      // Clock source selection
    static constexpr uint32_t CSR_COUNTFLAG = 0x10000;  // COUNTFLAG
    static const uint32_t CSR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t RVR_RELOAD =              // RELOAD value (24 bits)
        bit_field_t<0, 0xffffff>::value<X>();
    static const uint32_t RVR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CVR_CURRENT =             // Current counter value (24 bits)
        bit_field_t<0, 0xffffff>::value<X>();
    static const uint32_t CVR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t CALIB_TENMS =               // Calibration value (24 bits)
        bit_field_t<0, 0xffffff>::value<X>();
    static constexpr uint32_t CALIB_SKEW = 0x40000000;    // SKEW flag: Indicates whether the TENMS value is exact
    static constexpr uint32_t CALIB_NOREF = 0x80000000;   // NOREF flag. Reads as zero
    static const uint32_t CALIB_RESET_VALUE = 0x0;
};

static stk_t& STK = *reinterpret_cast<stk_t*>(0xe000e010);

#define HAVE_PERIPHERAL_STK


////
//
//    Nested vectored interrupt controller
//
////

struct nvic_stir_t
{
    volatile uint32_t    STIR;                 // [Read-write] Software trigger interrupt register

    template<uint32_t X>
    static constexpr uint32_t STIR_INTID =               // Software generated interrupt ID (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static const uint32_t STIR_RESET_VALUE = 0x0;
};

static nvic_stir_t& NVIC_STIR = *reinterpret_cast<nvic_stir_t*>(0xe000ef00);

#define HAVE_PERIPHERAL_NVIC_STIR


////
//
//    Floating point unit CPACR
//
////

struct fpu_cpacr_t
{
    volatile uint32_t    CPACR;                // [Read-write] Coprocessor access control register

    template<uint32_t X>
    static constexpr uint32_t CPACR_CP =                  // CP (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    static const uint32_t CPACR_RESET_VALUE = 0x0;
};

static fpu_cpacr_t& FPU_CPACR = *reinterpret_cast<fpu_cpacr_t*>(0xe000ed88);

#define HAVE_PERIPHERAL_FPU_CPACR


////
//
//    System control block ACTLR
//
////

struct scb_actrl_t
{
    volatile uint32_t    ACTRL;                // [Read-write] Auxiliary control register

    static constexpr uint32_t ACTRL_DISFOLD = 0x4;        // DISFOLD
    static constexpr uint32_t ACTRL_FPEXCODIS = 0x400;    // FPEXCODIS
    static constexpr uint32_t ACTRL_DISRAMODE = 0x800;    // DISRAMODE
    static constexpr uint32_t ACTRL_DISITMATBFLUSH = 0x1000;// DISITMATBFLUSH
    static const uint32_t ACTRL_RESET_VALUE = 0x0;
};

static scb_actrl_t& SCB_ACTRL = *reinterpret_cast<scb_actrl_t*>(0xe000e008);

#define HAVE_PERIPHERAL_SCB_ACTRL


////
//
//    Floting point unit
//
////

struct fpu_t
{
    volatile uint32_t    FPCCR;                // [Read-write] Floating-point context control register
    volatile uint32_t    FPCAR;                // [Read-write] Floating-point context address register
    volatile uint32_t    FPSCR;                // [Read-write] Floating-point status control register

    static constexpr uint32_t FPCCR_LSPACT = 0x1;         // LSPACT
    static constexpr uint32_t FPCCR_USER = 0x2;           // USER
    static constexpr uint32_t FPCCR_THREAD = 0x8;         // THREAD
    static constexpr uint32_t FPCCR_HFRDY = 0x10;         // HFRDY
    static constexpr uint32_t FPCCR_MMRDY = 0x20;         // MMRDY
    static constexpr uint32_t FPCCR_BFRDY = 0x40;         // BFRDY
    static constexpr uint32_t FPCCR_MONRDY = 0x100;       // MONRDY
    static constexpr uint32_t FPCCR_LSPEN = 0x40000000;   // LSPEN
    static constexpr uint32_t FPCCR_ASPEN = 0x80000000;   // ASPEN
    static const uint32_t FPCCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t FPCAR_ADDRESS =             // Location of unpopulated floating-point (29 bits)
        bit_field_t<3, 0x1fffffff>::value<X>();
    static const uint32_t FPCAR_RESET_VALUE = 0x0;

    static constexpr uint32_t FPSCR_IOC = 0x1;            // Invalid operation cumulative exception bit
    static constexpr uint32_t FPSCR_DZC = 0x2;            // Division by zero cumulative exception bit.
    static constexpr uint32_t FPSCR_OFC = 0x4;            // Overflow cumulative exception bit
    static constexpr uint32_t FPSCR_UFC = 0x8;            // Underflow cumulative exception bit
    static constexpr uint32_t FPSCR_IXC = 0x10;           // Inexact cumulative exception bit
    static constexpr uint32_t FPSCR_IDC = 0x80;           // Input denormal cumulative exception bit.
    template<uint32_t X>
    static constexpr uint32_t FPSCR_RMode =               // Rounding Mode control field (2 bits)
        bit_field_t<22, 0x3>::value<X>();
    static constexpr uint32_t FPSCR_FZ = 0x1000000;       // Flush-to-zero mode control bit:
    static constexpr uint32_t FPSCR_DN = 0x2000000;       // Default NaN mode control bit
    static constexpr uint32_t FPSCR_AHP = 0x4000000;      // Alternative half-precision control bit
    static constexpr uint32_t FPSCR_V = 0x10000000;       // Overflow condition code flag
    static constexpr uint32_t FPSCR_C = 0x20000000;       // Carry condition code flag
    static constexpr uint32_t FPSCR_Z = 0x40000000;       // Zero condition code flag
    static constexpr uint32_t FPSCR_N = 0x80000000;       // Negative condition code flag
    static const uint32_t FPSCR_RESET_VALUE = 0x0;

    static constexpr uint8_t FPU = 81; // Floating point unit interrupt
};

static fpu_t& FPU = *reinterpret_cast<fpu_t*>(0xe000ef34);

#define HAVE_PERIPHERAL_FPU


////
//
//    System control block
//
////

struct scb_t
{
    volatile uint32_t    CPUID;                // [Read-only] CPUID base register
    volatile uint32_t    ICSR;                 // [Read-write] Interrupt control and state register
    volatile uint32_t    VTOR;                 // [Read-write] Vector table offset register
    volatile uint32_t    AIRCR;                // [Read-write] Application interrupt and reset control register
    volatile uint32_t    SCR;                  // [Read-write] System control register
    volatile uint32_t    CCR;                  // [Read-write] Configuration and control register
    volatile uint32_t    SHPR1;                // [Read-write] System handler priority registers
    volatile uint32_t    SHPR2;                // [Read-write] System handler priority registers
    volatile uint32_t    SHPR3;                // [Read-write] System handler priority registers
    volatile uint32_t    SHCRS;                // [Read-write] System handler control and state register
    volatile uint32_t    CFSR_UFSR_BFSR_MMFSR; // [Read-write] Configurable fault status register
    volatile uint32_t    HFSR;                 // [Read-write] Hard fault status register
    reserved_t<1>        _0;
    volatile uint32_t    MMFAR;                // [Read-write] Memory management fault address register
    volatile uint32_t    BFAR;                 // [Read-write] Bus fault address register

    template<uint32_t X>
    static constexpr uint32_t CPUID_Revision =            // Revision number (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CPUID_PartNo =              // Part number of the processor (12 bits)
        bit_field_t<4, 0xfff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CPUID_Constant =            // Reads as 0xF (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CPUID_Variant =             // Variant number (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CPUID_Implementer =         // Implementer code (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t CPUID_RESET_VALUE = 0x410fc241;

    template<uint32_t X>
    static constexpr uint32_t ICSR_VECTACTIVE =          // Active vector (9 bits)
        bit_field_t<0, 0x1ff>::value<X>();
    static constexpr uint32_t ICSR_RETTOBASE = 0x800;    // Return to base level
    template<uint32_t X>
    static constexpr uint32_t ICSR_VECTPENDING =         // Pending vector (7 bits)
        bit_field_t<12, 0x7f>::value<X>();
    static constexpr uint32_t ICSR_ISRPENDING = 0x400000;// Interrupt pending flag
    static constexpr uint32_t ICSR_PENDSTCLR = 0x2000000;// SysTick exception clear-pending bit
    static constexpr uint32_t ICSR_PENDSTSET = 0x4000000;// SysTick exception set-pending bit
    static constexpr uint32_t ICSR_PENDSVCLR = 0x8000000;// PendSV clear-pending bit
    static constexpr uint32_t ICSR_PENDSVSET = 0x10000000;// PendSV set-pending bit
    static constexpr uint32_t ICSR_NMIPENDSET = 0x80000000;// NMI set-pending bit.
    static const uint32_t ICSR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t VTOR_TBLOFF =              // Vector table base offset field (21 bits)
        bit_field_t<9, 0x1fffff>::value<X>();
    static const uint32_t VTOR_RESET_VALUE = 0x0;

    static constexpr uint32_t AIRCR_VECTRESET = 0x1;      // VECTRESET
    static constexpr uint32_t AIRCR_VECTCLRACTIVE = 0x2;  // VECTCLRACTIVE
    static constexpr uint32_t AIRCR_SYSRESETREQ = 0x4;    // SYSRESETREQ
    template<uint32_t X>
    static constexpr uint32_t AIRCR_PRIGROUP =            // PRIGROUP (3 bits)
        bit_field_t<8, 0x7>::value<X>();
    static constexpr uint32_t AIRCR_ENDIANESS = 0x8000;   // ENDIANESS
    template<uint32_t X>
    static constexpr uint32_t AIRCR_VECTKEYSTAT =         // Register key (16 bits)
        bit_field_t<16, 0xffff>::value<X>();
    static const uint32_t AIRCR_RESET_VALUE = 0x0;

    static constexpr uint32_t SCR_SLEEPONEXIT = 0x2;    // SLEEPONEXIT
    static constexpr uint32_t SCR_SLEEPDEEP = 0x4;      // SLEEPDEEP
    static constexpr uint32_t SCR_SEVEONPEND = 0x10;    // Send Event on Pending bit
    static const uint32_t SCR_RESET_VALUE = 0x0;

    static constexpr uint32_t CCR_NONBASETHRDENA = 0x1; // Configures how the processor enters Thread mode
    static constexpr uint32_t CCR_USERSETMPEND = 0x2;   // USERSETMPEND
    static constexpr uint32_t CCR_UNALIGN__TRP = 0x8;   // UNALIGN_ TRP
    static constexpr uint32_t CCR_DIV_0_TRP = 0x10;     // DIV_0_TRP
    static constexpr uint32_t CCR_BFHFNMIGN = 0x100;    // BFHFNMIGN
    static constexpr uint32_t CCR_STKALIGN = 0x200;     // STKALIGN
    static constexpr uint32_t CCR_DC = 0x10000;         // DC
    static constexpr uint32_t CCR_IC = 0x20000;         // IC
    static constexpr uint32_t CCR_BP = 0x40000;         // BP
    static const uint32_t CCR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SHPR1_PRI_4 =               // Priority of system handler 4 (8 bits)
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SHPR1_PRI_5 =               // Priority of system handler 5 (8 bits)
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SHPR1_PRI_6 =               // Priority of system handler 6 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    static const uint32_t SHPR1_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SHPR2_PRI_11 =              // Priority of system handler 11 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t SHPR2_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t SHPR3_PRI_14 =              // Priority of system handler 14 (8 bits)
        bit_field_t<16, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t SHPR3_PRI_15 =              // Priority of system handler 15 (8 bits)
        bit_field_t<24, 0xff>::value<X>();
    static const uint32_t SHPR3_RESET_VALUE = 0x0;

    static constexpr uint32_t SHCRS_MEMFAULTACT = 0x1;    // Memory management fault exception active bit
    static constexpr uint32_t SHCRS_BUSFAULTACT = 0x2;    // Bus fault exception active bit
    static constexpr uint32_t SHCRS_USGFAULTACT = 0x8;    // Usage fault exception active bit
    static constexpr uint32_t SHCRS_SVCALLACT = 0x80;     // SVC call active bit
    static constexpr uint32_t SHCRS_MONITORACT = 0x100;   // Debug monitor active bit
    static constexpr uint32_t SHCRS_PENDSVACT = 0x400;    // PendSV exception active bit
    static constexpr uint32_t SHCRS_SYSTICKACT = 0x800;   // SysTick exception active bit
    static constexpr uint32_t SHCRS_USGFAULTPENDED = 0x1000;// Usage fault exception pending bit
    static constexpr uint32_t SHCRS_MEMFAULTPENDED = 0x2000;// Memory management fault exception pending bit
    static constexpr uint32_t SHCRS_BUSFAULTPENDED = 0x4000;// Bus fault exception pending bit
    static constexpr uint32_t SHCRS_SVCALLPENDED = 0x8000;// SVC call pending bit
    static constexpr uint32_t SHCRS_MEMFAULTENA = 0x10000;// Memory management fault enable bit
    static constexpr uint32_t SHCRS_BUSFAULTENA = 0x20000;// Bus fault enable bit
    static constexpr uint32_t SHCRS_USGFAULTENA = 0x40000;// Usage fault enable bit
    static const uint32_t SHCRS_RESET_VALUE = 0x0;

    static constexpr uint32_t CFSR_UFSR_BFSR_MMFSR_IACCVIOL = 0x1;       // IACCVIOL
    static constexpr uint32_t CFSR_UFSR_BFSR_MMFSR_DACCVIOL = 0x2;       // DACCVIOL
    static constexpr uint32_t CFSR_UFSR_BFSR_MMFSR_MUNSTKERR = 0x8;      // MUNSTKERR
    static constexpr uint32_t CFSR_UFSR_BFSR_MMFSR_MSTKERR = 0x10;       // MSTKERR
    static constexpr uint32_t CFSR_UFSR_BFSR_MMFSR_MLSPERR = 0x20;       // MLSPERR
    static constexpr uint32_t CFSR_UFSR_BFSR_MMFSR_MMARVALID = 0x80;     // MMARVALID
    static constexpr uint32_t CFSR_UFSR_BFSR_MMFSR_IBUSERR = 0x100;      // Instruction bus error
    static constexpr uint32_t CFSR_UFSR_BFSR_MMFSR_PRECISERR = 0x200;    // Precise data bus error
    static constexpr uint32_t CFSR_UFSR_BFSR_MMFSR_IMPRECISERR = 0x400;  // Imprecise data bus error
    static constexpr uint32_t CFSR_UFSR_BFSR_MMFSR_UNSTKERR = 0x800;     // Bus fault on unstacking for a return from exception
    static constexpr uint32_t CFSR_UFSR_BFSR_MMFSR_STKERR = 0x1000;      // Bus fault on stacking for exception entry
    static constexpr uint32_t CFSR_UFSR_BFSR_MMFSR_LSPERR = 0x2000;      // Bus fault on floating-point lazy state preservation
    static constexpr uint32_t CFSR_UFSR_BFSR_MMFSR_BFARVALID = 0x8000;   // Bus Fault Address Register (BFAR) valid flag
    static constexpr uint32_t CFSR_UFSR_BFSR_MMFSR_UNDEFINSTR = 0x10000; // Undefined instruction usage fault
    static constexpr uint32_t CFSR_UFSR_BFSR_MMFSR_INVSTATE = 0x20000;   // Invalid state usage fault
    static constexpr uint32_t CFSR_UFSR_BFSR_MMFSR_INVPC = 0x40000;      // Invalid PC load usage fault
    static constexpr uint32_t CFSR_UFSR_BFSR_MMFSR_NOCP = 0x80000;       // No coprocessor usage fault.
    static constexpr uint32_t CFSR_UFSR_BFSR_MMFSR_UNALIGNED = 0x1000000;// Unaligned access usage fault
    static constexpr uint32_t CFSR_UFSR_BFSR_MMFSR_DIVBYZERO = 0x2000000;// Divide by zero usage fault
    static const uint32_t CFSR_UFSR_BFSR_MMFSR_RESET_VALUE = 0x0;

    static constexpr uint32_t HFSR_VECTTBL = 0x2;        // Vector table hard fault
    static constexpr uint32_t HFSR_FORCED = 0x40000000;  // Forced hard fault
    static constexpr uint32_t HFSR_DEBUG_VT = 0x80000000;// Reserved for Debug use
    static const uint32_t HFSR_RESET_VALUE = 0x0;


    static const uint32_t MMFAR_RESET_VALUE = 0x0;


    static const uint32_t BFAR_RESET_VALUE = 0x0;
};

static scb_t& SCB = *reinterpret_cast<scb_t*>(0xe000ed00);

#define HAVE_PERIPHERAL_SCB


////
//
//    Processor features
//
////

struct pf_t
{
    volatile uint32_t    CLIDR;                // [Read-only] Cache Level ID register
    volatile uint32_t    CTR;                  // [Read-only] Cache Type register
    volatile uint32_t    CCSIDR;               // [Read-only] Cache Size ID register

    template<uint32_t X>
    static constexpr uint32_t CLIDR_CL1 =                 // CL1 (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CLIDR_CL2 =                 // CL2 (3 bits)
        bit_field_t<3, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CLIDR_CL3 =                 // CL3 (3 bits)
        bit_field_t<6, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CLIDR_CL4 =                 // CL4 (3 bits)
        bit_field_t<9, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CLIDR_CL5 =                 // CL5 (3 bits)
        bit_field_t<12, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CLIDR_CL6 =                 // CL6 (3 bits)
        bit_field_t<15, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CLIDR_CL7 =                 // CL7 (3 bits)
        bit_field_t<18, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CLIDR_LoUIS =               // LoUIS (3 bits)
        bit_field_t<21, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CLIDR_LoC =                 // LoC (3 bits)
        bit_field_t<24, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CLIDR_LoU =                 // LoU (3 bits)
        bit_field_t<27, 0x7>::value<X>();
    static const uint32_t CLIDR_RESET_VALUE = 0x9000003;

    template<uint32_t X>
    static constexpr uint32_t CTR__IminLine =           // IminLine (4 bits)
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CTR_DMinLine =            // DMinLine (4 bits)
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CTR_ERG =                 // ERG (4 bits)
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CTR_CWG =                 // CWG (4 bits)
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CTR_Format =              // Format (3 bits)
        bit_field_t<29, 0x7>::value<X>();
    static const uint32_t CTR_RESET_VALUE = 0x8303c003;

    template<uint32_t X>
    static constexpr uint32_t CCSIDR_LineSize =            // LineSize (3 bits)
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCSIDR_Associativity =       // Associativity (10 bits)
        bit_field_t<3, 0x3ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t CCSIDR_NumSets =             // NumSets (15 bits)
        bit_field_t<13, 0x7fff>::value<X>();
    static constexpr uint32_t CCSIDR_WA = 0x10000000;      // WA
    static constexpr uint32_t CCSIDR_RA = 0x20000000;      // RA
    static constexpr uint32_t CCSIDR_WB = 0x40000000;      // WB
    static constexpr uint32_t CCSIDR_WT = 0x80000000;      // WT
    static const uint32_t CCSIDR_RESET_VALUE = 0x0;
};

static pf_t& PF = *reinterpret_cast<pf_t*>(0xe000ed78);

#define HAVE_PERIPHERAL_PF


////
//
//    Access control
//
////

struct ac_t
{
    volatile uint32_t    ITCMCR;               // [Read-write] Instruction and Data Tightly-Coupled Memory Control Registers
    volatile uint32_t    DTCMCR;               // [Read-write] Instruction and Data Tightly-Coupled Memory Control Registers
    volatile uint32_t    AHBPCR;               // [Read-write] AHBP Control register
    volatile uint32_t    CACR;                 // [Read-write] Auxiliary Cache Control register
    volatile uint32_t    AHBSCR;               // [Read-write] AHB Slave Control register
    reserved_t<1>        _0;
    volatile uint32_t    ABFSR;                // [Read-write] Auxiliary Bus Fault Status register

    static constexpr uint32_t ITCMCR_EN = 0x1;             // EN
    static constexpr uint32_t ITCMCR_RMW = 0x2;            // RMW
    static constexpr uint32_t ITCMCR_RETEN = 0x4;          // RETEN
    template<uint32_t X>
    static constexpr uint32_t ITCMCR_SZ =                  // SZ (4 bits)
        bit_field_t<3, 0xf>::value<X>();
    static const uint32_t ITCMCR_RESET_VALUE = 0x0;

    static constexpr uint32_t DTCMCR_EN = 0x1;             // EN
    static constexpr uint32_t DTCMCR_RMW = 0x2;            // RMW
    static constexpr uint32_t DTCMCR_RETEN = 0x4;          // RETEN
    template<uint32_t X>
    static constexpr uint32_t DTCMCR_SZ =                  // SZ (4 bits)
        bit_field_t<3, 0xf>::value<X>();
    static const uint32_t DTCMCR_RESET_VALUE = 0x0;

    static constexpr uint32_t AHBPCR_EN = 0x1;             // EN
    template<uint32_t X>
    static constexpr uint32_t AHBPCR_SZ =                  // SZ (3 bits)
        bit_field_t<1, 0x7>::value<X>();
    static const uint32_t AHBPCR_RESET_VALUE = 0x0;

    static constexpr uint32_t CACR_SIWT = 0x1;           // SIWT
    static constexpr uint32_t CACR_ECCEN = 0x2;          // ECCEN
    static constexpr uint32_t CACR_FORCEWT = 0x4;        // FORCEWT
    static const uint32_t CACR_RESET_VALUE = 0x0;

    template<uint32_t X>
    static constexpr uint32_t AHBSCR_CTL =                 // CTL (2 bits)
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AHBSCR_TPRI =                // TPRI (9 bits)
        bit_field_t<2, 0x1ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t AHBSCR_INITCOUNT =           // INITCOUNT (5 bits)
        bit_field_t<11, 0x1f>::value<X>();
    static const uint32_t AHBSCR_RESET_VALUE = 0x0;

    static constexpr uint32_t ABFSR_ITCM = 0x1;           // ITCM
    static constexpr uint32_t ABFSR_DTCM = 0x2;           // DTCM
    static constexpr uint32_t ABFSR_AHBP = 0x4;           // AHBP
    static constexpr uint32_t ABFSR_AXIM = 0x8;           // AXIM
    static constexpr uint32_t ABFSR_EPPB = 0x10;          // EPPB
    template<uint32_t X>
    static constexpr uint32_t ABFSR_AXIMTYPE =            // AXIMTYPE (2 bits)
        bit_field_t<8, 0x3>::value<X>();
    static const uint32_t ABFSR_RESET_VALUE = 0x0;
};

static ac_t& AC = *reinterpret_cast<ac_t*>(0xe000ef90);

#define HAVE_PERIPHERAL_AC


template<typename PERIPHERAL> struct peripheral_traits {};

template<> struct peripheral_traits<rng_t>
{
    static void enable() { RCC.AHB2ENR |= rcc_t::AHB2ENR_RNGEN; }
    static void disable() { RCC.AHB2ENR &= ~rcc_t::AHB2ENR_RNGEN; }
    static void reset() { RCC.AHB2RSTR |= rcc_t::AHB2RSTR_RNGRST; }
};

template<> struct peripheral_traits<hash_t>
{
    static void enable() { RCC.AHB2ENR |= rcc_t::AHB2ENR_HASHEN; }
    static void disable() { RCC.AHB2ENR &= ~rcc_t::AHB2ENR_HASHEN; }
};

template<> struct peripheral_traits<cryp_t>
{
    static void enable() { RCC.AHB2ENR |= rcc_t::AHB2ENR_CRYPEN; }
    static void disable() { RCC.AHB2ENR &= ~rcc_t::AHB2ENR_CRYPEN; }
    static void reset() { RCC.AHB2RSTR |= rcc_t::AHB2RSTR_CRYPRST; }
};

template<> struct peripheral_traits<dcmi_t>
{
    static void enable() { RCC.AHB2ENR |= rcc_t::AHB2ENR_DCMIEN; }
    static void disable() { RCC.AHB2ENR &= ~rcc_t::AHB2ENR_DCMIEN; }
    static void reset() { RCC.AHB2RSTR |= rcc_t::AHB2RSTR_DCMIRST; }
};

template<> struct peripheral_traits<fmc_t>
{
    static void enable() { RCC.AHB3ENR |= rcc_t::AHB3ENR_FMCEN; }
    static void disable() { RCC.AHB3ENR &= ~rcc_t::AHB3ENR_FMCEN; }
    static void reset() { RCC.AHB3RSTR |= rcc_t::AHB3RSTR_FMCRST; }
};

template<> struct peripheral_traits<dma2_t>
{
    static void enable() { RCC.AHB1ENR |= rcc_t::AHB1ENR_DMA2EN; }
    static void disable() { RCC.AHB1ENR &= ~rcc_t::AHB1ENR_DMA2EN; }
    static void reset() { RCC.AHB1RSTR |= rcc_t::AHB1RSTR_DMA2RST; }
};

template<> struct peripheral_traits<dma1_t>
{
    static void enable() { RCC.AHB1ENR |= rcc_t::AHB1ENR_DMA1EN; }
    static void disable() { RCC.AHB1ENR &= ~rcc_t::AHB1ENR_DMA1EN; }
    static void reset() { RCC.AHB1RSTR |= rcc_t::AHB1RSTR_DMA1RST; }
};

template<> struct peripheral_traits<gpiod_t>
{
    static void enable() { RCC.AHB1ENR |= rcc_t::AHB1ENR_GPIODEN; }
    static void disable() { RCC.AHB1ENR &= ~rcc_t::AHB1ENR_GPIODEN; }
    static void reset() { RCC.AHB1RSTR |= rcc_t::AHB1RSTR_GPIODRST; }
};

template<> struct peripheral_traits<gpioc_t>
{
    static void enable() { RCC.AHB1ENR |= rcc_t::AHB1ENR_GPIOCEN; }
    static void disable() { RCC.AHB1ENR &= ~rcc_t::AHB1ENR_GPIOCEN; }
    static void reset() { RCC.AHB1RSTR |= rcc_t::AHB1RSTR_GPIOCRST; }
};

template<> struct peripheral_traits<gpiok_t>
{
    static void enable() { RCC.AHB1ENR |= rcc_t::AHB1ENR_GPIOKEN; }
    static void disable() { RCC.AHB1ENR &= ~rcc_t::AHB1ENR_GPIOKEN; }
    static void reset() { RCC.AHB1RSTR |= rcc_t::AHB1RSTR_GPIOKRST; }
};

template<> struct peripheral_traits<gpioj_t>
{
    static void enable() { RCC.AHB1ENR |= rcc_t::AHB1ENR_GPIOJEN; }
    static void disable() { RCC.AHB1ENR &= ~rcc_t::AHB1ENR_GPIOJEN; }
    static void reset() { RCC.AHB1RSTR |= rcc_t::AHB1RSTR_GPIOJRST; }
};

template<> struct peripheral_traits<gpioi_t>
{
    static void enable() { RCC.AHB1ENR |= rcc_t::AHB1ENR_GPIOIEN; }
    static void disable() { RCC.AHB1ENR &= ~rcc_t::AHB1ENR_GPIOIEN; }
    static void reset() { RCC.AHB1RSTR |= rcc_t::AHB1RSTR_GPIOIRST; }
};

template<> struct peripheral_traits<gpioh_t>
{
    static void enable() { RCC.AHB1ENR |= rcc_t::AHB1ENR_GPIOHEN; }
    static void disable() { RCC.AHB1ENR &= ~rcc_t::AHB1ENR_GPIOHEN; }
    static void reset() { RCC.AHB1RSTR |= rcc_t::AHB1RSTR_GPIOHRST; }
};

template<> struct peripheral_traits<gpiog_t>
{
    static void enable() { RCC.AHB1ENR |= rcc_t::AHB1ENR_GPIOGEN; }
    static void disable() { RCC.AHB1ENR &= ~rcc_t::AHB1ENR_GPIOGEN; }
    static void reset() { RCC.AHB1RSTR |= rcc_t::AHB1RSTR_GPIOGRST; }
};

template<> struct peripheral_traits<gpiof_t>
{
    static void enable() { RCC.AHB1ENR |= rcc_t::AHB1ENR_GPIOFEN; }
    static void disable() { RCC.AHB1ENR &= ~rcc_t::AHB1ENR_GPIOFEN; }
    static void reset() { RCC.AHB1RSTR |= rcc_t::AHB1RSTR_GPIOFRST; }
};

template<> struct peripheral_traits<gpioe_t>
{
    static void enable() { RCC.AHB1ENR |= rcc_t::AHB1ENR_GPIOEEN; }
    static void disable() { RCC.AHB1ENR &= ~rcc_t::AHB1ENR_GPIOEEN; }
    static void reset() { RCC.AHB1RSTR |= rcc_t::AHB1RSTR_GPIOERST; }
};

template<> struct peripheral_traits<gpiob_t>
{
    static void enable() { RCC.AHB1ENR |= rcc_t::AHB1ENR_GPIOBEN; }
    static void disable() { RCC.AHB1ENR &= ~rcc_t::AHB1ENR_GPIOBEN; }
    static void reset() { RCC.AHB1RSTR |= rcc_t::AHB1RSTR_GPIOBRST; }
};

template<> struct peripheral_traits<gpioa_t>
{
    static void enable() { RCC.AHB1ENR |= rcc_t::AHB1ENR_GPIOAEN; }
    static void disable() { RCC.AHB1ENR &= ~rcc_t::AHB1ENR_GPIOAEN; }
    static void reset() { RCC.AHB1RSTR |= rcc_t::AHB1RSTR_GPIOARST; }
};

template<> struct peripheral_traits<syscfg_t>
{
    static void enable() { RCC.APB2ENR |= rcc_t::APB2ENR_SYSCFGEN; }
    static void disable() { RCC.APB2ENR &= ~rcc_t::APB2ENR_SYSCFGEN; }
    static void reset() { RCC.APB2RSTR |= rcc_t::APB2RSTR_SYSCFGRST; }
};

template<> struct peripheral_traits<spi1_t>
{
    static void enable() { RCC.APB2ENR |= rcc_t::APB2ENR_SPI1EN; }
    static void disable() { RCC.APB2ENR &= ~rcc_t::APB2ENR_SPI1EN; }
    static void reset() { RCC.APB2RSTR |= rcc_t::APB2RSTR_SPI1RST; }
};

template<> struct peripheral_traits<spi2_t>
{
    static void enable() { RCC.APB1ENR |= rcc_t::APB1ENR_SPI2EN; }
    static void disable() { RCC.APB1ENR &= ~rcc_t::APB1ENR_SPI2EN; }
    static void reset() { RCC.APB1RSTR |= rcc_t::APB1RSTR_SPI2RST; }
};

template<> struct peripheral_traits<spi4_t>
{
    static void reset() { RCC.APB2RSTR |= rcc_t::APB2RSTR_SPI4RST; }
};

template<> struct peripheral_traits<spi5_t>
{
    static void reset() { RCC.APB2RSTR |= rcc_t::APB2RSTR_SPI5RST; }
};

template<> struct peripheral_traits<spi3_t>
{
    static void enable() { RCC.APB1ENR |= rcc_t::APB1ENR_SPI3EN; }
    static void disable() { RCC.APB1ENR &= ~rcc_t::APB1ENR_SPI3EN; }
    static void reset() { RCC.APB1RSTR |= rcc_t::APB1RSTR_SPI3RST; }
};

template<> struct peripheral_traits<spi6_t>
{
    static void reset() { RCC.APB2RSTR |= rcc_t::APB2RSTR_SPI6RST; }
};

template<> struct peripheral_traits<adc1_t>
{
    static void enable() { RCC.APB2ENR |= rcc_t::APB2ENR_ADC1EN; }
    static void disable() { RCC.APB2ENR &= ~rcc_t::APB2ENR_ADC1EN; }
};

template<> struct peripheral_traits<adc2_t>
{
    static void enable() { RCC.APB2ENR |= rcc_t::APB2ENR_ADC2EN; }
    static void disable() { RCC.APB2ENR &= ~rcc_t::APB2ENR_ADC2EN; }
};

template<> struct peripheral_traits<adc3_t>
{
    static void enable() { RCC.APB2ENR |= rcc_t::APB2ENR_ADC3EN; }
    static void disable() { RCC.APB2ENR &= ~rcc_t::APB2ENR_ADC3EN; }
};

template<> struct peripheral_traits<dac_t>
{
    static void enable() { RCC.APB1ENR |= rcc_t::APB1ENR_DACEN; }
    static void disable() { RCC.APB1ENR &= ~rcc_t::APB1ENR_DACEN; }
    static void reset() { RCC.APB1RSTR |= rcc_t::APB1RSTR_DACRST; }
};

template<> struct peripheral_traits<pwr_t>
{
    static void enable() { RCC.APB1ENR |= rcc_t::APB1ENR_PWREN; }
    static void disable() { RCC.APB1ENR &= ~rcc_t::APB1ENR_PWREN; }
    static void reset() { RCC.APB1RSTR |= rcc_t::APB1RSTR_PWRRST; }
};

template<> struct peripheral_traits<wwdg_t>
{
    static void enable() { RCC.APB1ENR |= rcc_t::APB1ENR_WWDGEN; }
    static void disable() { RCC.APB1ENR &= ~rcc_t::APB1ENR_WWDGEN; }
    static void reset() { RCC.APB1RSTR |= rcc_t::APB1RSTR_WWDGRST; }
};

template<> struct peripheral_traits<tim1_t>
{
    static void enable() { RCC.APB2ENR |= rcc_t::APB2ENR_TIM1EN; }
    static void disable() { RCC.APB2ENR &= ~rcc_t::APB2ENR_TIM1EN; }
    static void reset() { RCC.APB2RSTR |= rcc_t::APB2RSTR_TIM1RST; }
};

template<> struct peripheral_traits<tim8_t>
{
    static void enable() { RCC.APB2ENR |= rcc_t::APB2ENR_TIM8EN; }
    static void disable() { RCC.APB2ENR &= ~rcc_t::APB2ENR_TIM8EN; }
    static void reset() { RCC.APB2RSTR |= rcc_t::APB2RSTR_TIM8RST; }
};

template<> struct peripheral_traits<tim2_t>
{
    static void enable() { RCC.APB1ENR |= rcc_t::APB1ENR_TIM2EN; }
    static void disable() { RCC.APB1ENR &= ~rcc_t::APB1ENR_TIM2EN; }
    static void reset() { RCC.APB1RSTR |= rcc_t::APB1RSTR_TIM2RST; }
};

template<> struct peripheral_traits<tim3_t>
{
    static void enable() { RCC.APB1ENR |= rcc_t::APB1ENR_TIM3EN; }
    static void disable() { RCC.APB1ENR &= ~rcc_t::APB1ENR_TIM3EN; }
    static void reset() { RCC.APB1RSTR |= rcc_t::APB1RSTR_TIM3RST; }
};

template<> struct peripheral_traits<tim4_t>
{
    static void enable() { RCC.APB1ENR |= rcc_t::APB1ENR_TIM4EN; }
    static void disable() { RCC.APB1ENR &= ~rcc_t::APB1ENR_TIM4EN; }
    static void reset() { RCC.APB1RSTR |= rcc_t::APB1RSTR_TIM4RST; }
};

template<> struct peripheral_traits<tim5_t>
{
    static void enable() { RCC.APB1ENR |= rcc_t::APB1ENR_TIM5EN; }
    static void disable() { RCC.APB1ENR &= ~rcc_t::APB1ENR_TIM5EN; }
    static void reset() { RCC.APB1RSTR |= rcc_t::APB1RSTR_TIM5RST; }
};

template<> struct peripheral_traits<tim9_t>
{
    static void enable() { RCC.APB2ENR |= rcc_t::APB2ENR_TIM9EN; }
    static void disable() { RCC.APB2ENR &= ~rcc_t::APB2ENR_TIM9EN; }
    static void reset() { RCC.APB2RSTR |= rcc_t::APB2RSTR_TIM9RST; }
};

template<> struct peripheral_traits<tim12_t>
{
    static void enable() { RCC.APB1ENR |= rcc_t::APB1ENR_TIM12EN; }
    static void disable() { RCC.APB1ENR &= ~rcc_t::APB1ENR_TIM12EN; }
    static void reset() { RCC.APB1RSTR |= rcc_t::APB1RSTR_TIM12RST; }
};

template<> struct peripheral_traits<tim10_t>
{
    static void enable() { RCC.APB2ENR |= rcc_t::APB2ENR_TIM10EN; }
    static void disable() { RCC.APB2ENR &= ~rcc_t::APB2ENR_TIM10EN; }
    static void reset() { RCC.APB2RSTR |= rcc_t::APB2RSTR_TIM10RST; }
};

template<> struct peripheral_traits<tim11_t>
{
    static void enable() { RCC.APB2ENR |= rcc_t::APB2ENR_TIM11EN; }
    static void disable() { RCC.APB2ENR &= ~rcc_t::APB2ENR_TIM11EN; }
    static void reset() { RCC.APB2RSTR |= rcc_t::APB2RSTR_TIM11RST; }
};

template<> struct peripheral_traits<tim13_t>
{
    static void enable() { RCC.APB1ENR |= rcc_t::APB1ENR_TIM13EN; }
    static void disable() { RCC.APB1ENR &= ~rcc_t::APB1ENR_TIM13EN; }
    static void reset() { RCC.APB1RSTR |= rcc_t::APB1RSTR_TIM13RST; }
};

template<> struct peripheral_traits<tim14_t>
{
    static void enable() { RCC.APB1ENR |= rcc_t::APB1ENR_TIM14EN; }
    static void disable() { RCC.APB1ENR &= ~rcc_t::APB1ENR_TIM14EN; }
    static void reset() { RCC.APB1RSTR |= rcc_t::APB1RSTR_TIM14RST; }
};

template<> struct peripheral_traits<tim6_t>
{
    static void enable() { RCC.APB1ENR |= rcc_t::APB1ENR_TIM6EN; }
    static void disable() { RCC.APB1ENR &= ~rcc_t::APB1ENR_TIM6EN; }
    static void reset() { RCC.APB1RSTR |= rcc_t::APB1RSTR_TIM6RST; }
};

template<> struct peripheral_traits<tim7_t>
{
    static void enable() { RCC.APB1ENR |= rcc_t::APB1ENR_TIM7EN; }
    static void disable() { RCC.APB1ENR &= ~rcc_t::APB1ENR_TIM7EN; }
    static void reset() { RCC.APB1RSTR |= rcc_t::APB1RSTR_TIM7RST; }
};

template<> struct peripheral_traits<crc_t>
{
    static void enable() { RCC.AHB1ENR |= rcc_t::AHB1ENR_CRCEN; }
    static void disable() { RCC.AHB1ENR &= ~rcc_t::AHB1ENR_CRCEN; }
    static void reset() { RCC.AHB1RSTR |= rcc_t::AHB1RSTR_CRCRST; }
};

template<> struct peripheral_traits<can1_t>
{
    static void enable() { RCC.APB1ENR |= rcc_t::APB1ENR_CAN1EN; }
    static void disable() { RCC.APB1ENR &= ~rcc_t::APB1ENR_CAN1EN; }
    static void reset() { RCC.APB1RSTR |= rcc_t::APB1RSTR_CAN1RST; }
};

template<> struct peripheral_traits<can2_t>
{
    static void enable() { RCC.APB1ENR |= rcc_t::APB1ENR_CAN2EN; }
    static void disable() { RCC.APB1ENR &= ~rcc_t::APB1ENR_CAN2EN; }
    static void reset() { RCC.APB1RSTR |= rcc_t::APB1RSTR_CAN2RST; }
};

template<> struct peripheral_traits<sai1_t>
{
    static void enable() { RCC.APB2ENR |= rcc_t::APB2ENR_SAI1EN; }
    static void disable() { RCC.APB2ENR &= ~rcc_t::APB2ENR_SAI1EN; }
    static void reset() { RCC.APB2RSTR |= rcc_t::APB2RSTR_SAI1RST; }
};

template<> struct peripheral_traits<sai2_t>
{
    static void enable() { RCC.APB2ENR |= rcc_t::APB2ENR_SAI2EN; }
    static void disable() { RCC.APB2ENR &= ~rcc_t::APB2ENR_SAI2EN; }
    static void reset() { RCC.APB2RSTR |= rcc_t::APB2RSTR_SAI2RST; }
};

template<> struct peripheral_traits<dma2d_t>
{
    static void enable() { RCC.AHB1ENR |= rcc_t::AHB1ENR_DMA2DEN; }
    static void disable() { RCC.AHB1ENR &= ~rcc_t::AHB1ENR_DMA2DEN; }
    static void reset() { RCC.AHB1RSTR |= rcc_t::AHB1RSTR_DMA2DRST; }
};

template<> struct peripheral_traits<cec_t>
{
    static void enable() { RCC.APB1ENR |= rcc_t::APB1ENR_CECEN; }
    static void disable() { RCC.APB1ENR &= ~rcc_t::APB1ENR_CECEN; }
    static void reset() { RCC.APB1RSTR |= rcc_t::APB1RSTR_CECRST; }
};

template<> struct peripheral_traits<spdifrx_t>
{
    static void enable() { RCC.APB1ENR |= rcc_t::APB1ENR_SPDIFRXEN; }
    static void disable() { RCC.APB1ENR &= ~rcc_t::APB1ENR_SPDIFRXEN; }
    static void reset() { RCC.APB1RSTR |= rcc_t::APB1RSTR_SPDIFRXRST; }
};

template<> struct peripheral_traits<sdmmc1_t>
{
    static void enable() { RCC.APB2ENR |= rcc_t::APB2ENR_SDMMC1EN; }
    static void disable() { RCC.APB2ENR &= ~rcc_t::APB2ENR_SDMMC1EN; }
    static void reset() { RCC.APB2RSTR |= rcc_t::APB2RSTR_SDMMC1RST; }
};

template<> struct peripheral_traits<lptim1_t>
{
    static void reset() { RCC.APB1RSTR |= rcc_t::APB1RSTR_LPTIM1RST; }
};

template<> struct peripheral_traits<i2c1_t>
{
    static void enable() { RCC.APB1ENR |= rcc_t::APB1ENR_I2C1EN; }
    static void disable() { RCC.APB1ENR &= ~rcc_t::APB1ENR_I2C1EN; }
    static void reset() { RCC.APB1RSTR |= rcc_t::APB1RSTR_I2C1RST; }
};

template<> struct peripheral_traits<i2c2_t>
{
    static void enable() { RCC.APB1ENR |= rcc_t::APB1ENR_I2C2EN; }
    static void disable() { RCC.APB1ENR &= ~rcc_t::APB1ENR_I2C2EN; }
    static void reset() { RCC.APB1RSTR |= rcc_t::APB1RSTR_I2C2RST; }
};

template<> struct peripheral_traits<i2c3_t>
{
    static void enable() { RCC.APB1ENR |= rcc_t::APB1ENR_I2C3EN; }
    static void disable() { RCC.APB1ENR &= ~rcc_t::APB1ENR_I2C3EN; }
    static void reset() { RCC.APB1RSTR |= rcc_t::APB1RSTR_I2C3RST; }
};

template<> struct peripheral_traits<i2c4_t>
{
    static void enable() { RCC.APB1ENR |= rcc_t::APB1ENR_I2C4EN; }
    static void disable() { RCC.APB1ENR &= ~rcc_t::APB1ENR_I2C4EN; }
    static void reset() { RCC.APB1RSTR |= rcc_t::APB1RSTR_I2C4RST; }
};

template<> struct peripheral_traits<usart6_t>
{
    static void enable() { RCC.APB2ENR |= rcc_t::APB2ENR_USART6EN; }
    static void disable() { RCC.APB2ENR &= ~rcc_t::APB2ENR_USART6EN; }
    static void reset() { RCC.APB2RSTR |= rcc_t::APB2RSTR_USART6RST; }
};

template<> struct peripheral_traits<usart1_t>
{
    static void enable() { RCC.APB2ENR |= rcc_t::APB2ENR_USART1EN; }
    static void disable() { RCC.APB2ENR &= ~rcc_t::APB2ENR_USART1EN; }
    static void reset() { RCC.APB2RSTR |= rcc_t::APB2RSTR_USART1RST; }
};

template<> struct peripheral_traits<usart3_t>
{
    static void enable() { RCC.APB1ENR |= rcc_t::APB1ENR_USART3EN; }
    static void disable() { RCC.APB1ENR &= ~rcc_t::APB1ENR_USART3EN; }
};

template<> struct peripheral_traits<usart2_t>
{
    static void enable() { RCC.APB1ENR |= rcc_t::APB1ENR_USART2EN; }
    static void disable() { RCC.APB1ENR &= ~rcc_t::APB1ENR_USART2EN; }
};

template<> struct peripheral_traits<uart5_t>
{
    static void enable() { RCC.APB1ENR |= rcc_t::APB1ENR_UART5EN; }
    static void disable() { RCC.APB1ENR &= ~rcc_t::APB1ENR_UART5EN; }
    static void reset() { RCC.APB1RSTR |= rcc_t::APB1RSTR_UART5RST; }
};

template<> struct peripheral_traits<uart4_t>
{
    static void enable() { RCC.APB1ENR |= rcc_t::APB1ENR_UART4EN; }
    static void disable() { RCC.APB1ENR &= ~rcc_t::APB1ENR_UART4EN; }
    static void reset() { RCC.APB1RSTR |= rcc_t::APB1RSTR_UART4RST; }
};

template<> struct peripheral_traits<uart8_t>
{
    static void reset() { RCC.APB1RSTR |= rcc_t::APB1RSTR_UART8RST; }
};

template<> struct peripheral_traits<uart7_t>
{
    static void reset() { RCC.APB1RSTR |= rcc_t::APB1RSTR_UART7RST; }
};

}

struct interrupt
{
    static inline void enable() { __asm volatile ("cpsie i"); }
    static inline void disable() { __asm volatile ("cpsid i"); }

    enum interrupt_t
    { RESET = -15
    , NMI = -14
    , HARDFAULT = -13
    , MEMMANAGE = -12
    , BUSFAULT = -11
    , USAGEFAULT = -10
    , SVCALL = -5
    , DEBUG = -4
    , PENDSV = -2
    , SYSTICK = -1
    , WWDG = 0
    , PVD = 1
    , TAMP_STAMP = 2
    , RTC_WKUP = 3
    , FLASH = 4
    , RCC = 5
    , EXTI0 = 6
    , EXTI1 = 7
    , EXTI2 = 8
    , EXTI3 = 9
    , EXTI4 = 10
    , DMA1_STREAM0 = 11
    , DMA1_STREAM1 = 12
    , DMA1_STREAM2 = 13
    , DMA1_STREAM3 = 14
    , DMA1_STREAM4 = 15
    , DMA1_STREAM5 = 16
    , DMA1_STREAM6 = 17
    , ADC = 18
    , CAN1_TX = 19
    , CAN1_RX0 = 20
    , CAN1_RX1 = 21
    , CAN1_SCE = 22
    , EXTI9_5 = 23
    , TIM1_BRK_TIM9 = 24
    , TIM1_UP_TIM10 = 25
    , TIM1_TRG_COM_TIM11 = 26
    , TIM1_CC = 27
    , TIM2 = 28
    , TIM3 = 29
    , TIM4 = 30
    , I2C1_EV = 31
    , I2C1_ER = 32
    , I2C2_EV = 33
    , I2C2_ER = 34
    , SPI1 = 35
    , SPI2 = 36
    , USART1 = 37
    , USART2 = 38
    , USART3 = 39
    , EXTI15_10 = 40
    , RTC_ALARM = 41
    , OTG_FS_WKUP = 42
    , TIM8_BRK_TIM12 = 43
    , TIM8_UP_TIM13 = 44
    , TIM8_TRG_COM_TIM14 = 45
    , TIM8_CC = 46
    , DMA1_STREAM7 = 47
    , FMC = 48
    , SDMMC1 = 49
    , TIM5 = 50
    , SPI3 = 51
    , UART4 = 52
    , UART5 = 53
    , TIM6_DAC = 54
    , TIM7 = 55
    , DMA2_STREAM0 = 56
    , DMA2_STREAM1 = 57
    , DMA2_STREAM2 = 58
    , DMA2_STREAM3 = 59
    , DMA2_STREAM4 = 60
    , ETH = 61
    , ETH_WKUP = 62
    , CAN2_TX = 63
    , CAN2_RX0 = 64
    , CAN2_RX1 = 65
    , CAN2_SCE = 66
    , OTG_FS = 67
    , DMA2_STREAM5 = 68
    , DMA2_STREAM6 = 69
    , DMA2_STREAM7 = 70
    , USART6 = 71
    , I2C3_EV = 72
    , I2C3_ER = 73
    , OTG_HS_EP1_OUT = 74
    , OTG_HS_EP1_IN = 75
    , OTG_HS_WKUP = 76
    , OTG_HS = 77
    , DCMI = 78
    , CRYP = 79
    , HASH_RNG = 80
    , FPU = 81
    , UART7 = 82
    , UART8 = 83
    , SPI4 = 84
    , SPI5 = 85
    , SPI6 = 86
    , SAI1 = 87
    , LCD_TFT = 88
    , LCD_TFT = 89
    , DMA2D = 90
    , SAI2 = 91
    , QUADSPI = 92
    , LP_TIMER1 = 93
    , I2C4_EV = 95
    , I2C4_ER = 96
    , SPDIFRX = 97
    , DSIHOST = 98
    , DFSDM1_FLT0 = 99
    , DFSDM1_FLT1 = 100
    , DFSDM1_FLT2 = 101
    , DFSDM1_FLT3 = 102
    , SDMMC2 = 103
    , CAN3_TX = 104
    , CAN3_RX0 = 105
    , CAN3_RX1 = 106
    , CAN3_SCE = 107
    , JPEG = 108
    , MDIOS = 109
    };
};
